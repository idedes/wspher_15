C
C
C To begin with Irene:
C
C    Detailed description of the meaning of the columns 
C    in all the log files
C
C    Put all the log-files in logfile directory and results in the 
C    result directory
C
C    Introduce exact comments about the r16 fragments in the code
C
C    Verify "check the nonsense" print from GENBAS
C
C    Verify all the warnings/questions marked with @@@
C
C    Parameter windows and increments
C
C    Meaning of parameters on the data files
C
C    Mass difference between the protons and the neutrons ?
C
C
C 
C=======================================================================
C
C     FORTRAN PROGRAM: wspher15.f, 05/02/2016;  =>>>  VERSION 15
C                                            Resumed in February 2016
C
C=======================================================================
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C=======================================================================
C
C     This program has been tested by compiling with automatic double
C     precision option -r8, and should be compiled as follows:
C
C              ifort -r8 wspher_{}.f -o wspher_{}
C
C     With the usual double precision compilation we obtain 14 digits
C     precision, in accordance with all the expectations on the level 
C     of the Gauss routines and the orthogonality of the eigenvectors
C     after diagonalisation.
C
C     Below we place our collection of general suggestions concerning 
C     possible tests of the precision obtained using this program and
C     suggested to repeat occasionally,  after changing/enlarging the
C     domain of the input data (new nuclei, larger basis etc.): 
C  
C     01.=> Use the test routine examining the precision of the Gauss
C           theorem applications; this should be checked particularly
C           when integrating  the matrix elements  of the short range
C           potential where, on the one-hand side, an increase of the
C           number of the integration points may seem necessary,  but
C           on the other hand, the big majority of the new points may 
C           lie outside effective potential range.
C @@@ IRENE: to be re-checked
C               The present applicability conditions are
C               NGAUSS(max)=60 and NSHELL(max)=20 giving
C               orthogonality condition verified down to
C               0.1e-30 or better i.e. equivalent to r16 
C                                              precision.
C
C=======================================================================
C=======================================================================
C=======================================================================
C FILE NAME = wspher01_main_p_15.f ! Keep this symbol:    $ident@string$
C=======================================================================
C=======================================================================
C=======================================================================
C     
      PROGRAM WSPHER15
C      
      EXTERNAL 
     *          FUNMIN
C
      INCLUDE  'MATDIM/MAXFEV.f'
      INCLUDE  'MATDIM/NDFUNC.f'
      INCLUDE  'MATDIM/NDIM_M.f'
      INCLUDE  'MATDIM/NDMESH.f'
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDPARS.f'
      INCLUDE  'MATDIM/NDIM_N.f'
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/NDLEXP.f'
      INCLUDE  'MATDIM/NDRADZ.f'
      INCLUDE  'MATDIM/NDRADN.f'
      INCLUDE  'MATDIM/NDMAIN.f'
      INCLUDE  'MATDIM/NDLAST.f'
      INCLUDE  'MATDIM/NDIM_P.f'
      INCLUDE  'MATDIM/ND_RHO.f'
      INCLUDE  'MATDIM/N_NOYX.f'
      INCLUDE  'MATDIM/NDTITL.f'
C
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1,NDMES2=NDMESH*NDMESH)
      PARAMETER 
     *         (IFMODE=1,NPRINT=5,NDWEIG=4000)
C
      REAL*16
     *          ANODES,AWEIGH,BAUXIL,CAUXIL,EPSLAG,QRNODE,
     *          QRWEIG,QNORNL,QDFLAG,QFLAGN,QPOLYN,QDPOLY,
     *          QPOLYN_DENSIT,QDPOLY_DENSIT
C
      CHARACTER
     *          PRONAM*10,WHATEX*06,LABSYM_PROTON*6,LABSYM_NEUTRS*6
      CHARACTER
     *          FILNAM*256,TITPAR*13,TITMSH*8,TITLES*12,
     *                                        TITLES_EXPORT*12
      CHARACTER
     *          INPSYM*6,TYPCHI*6,TAKCHI*3,NUCSYM*6
      CHARACTER
     *          DIRNAM*256,GENAME*256,STRING*126
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          TITAUX*7,AUXLAB*6,LABTEX*11
      CHARACTER
     *          FILNAM_ENDING*3,TAKPAR*3
      CHARACTER
     *          CALLED*6,VERSIO*3
      CHARACTER
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010,PARPOT_UNITSS*040
C
C=======================================================================
C
C               Basis related, Laguerre functions, Gauss integration
C
      DIMENSION
     *          QPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *          QDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
      DIMENSION
     *          QPOLYN(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *          QDPOLY(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          QFLAGN(0:NDIM_N,0:NDIM_L),
     *          QDFLAG(0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          QRNODE(1:NDGAUS,0:NDIM_L),
     *          QRWEIG(1:NDGAUS,0:NDIM_L)
C
      DIMENSION
     *          DENSIT_PROTON(1:NDGAUS,0:NDIM_L),
     *          DENSIT_NEUTRS(1:NDGAUS,0:NDIM_L)
C      
      DIMENSION 
     *          DIAGSC(1:NDPARS),QTRANF(1:NDPARS),
     *          WORKA1(1:NDPARS),WORKA2(1:NDPARS),
     *          WORKA3(1:NDPARS),WORKA4(1:NDFUNC)
      DIMENSION
     *          FJACOB(1:NDFUNC,1:NDPARS)
      DIMENSION 
     *          I_PERM(1:NDPARS)
      DIMENSION 
     *          FUNJAC(1:NDIM_M,1:NDPARS)
      DIMENSION 
     *          IPIVOT(1:NDPARS)
      DIMENSION
     *          INDEXI(1:NDIM_M),MCOUNT(1:NDIM_M),STPMSH(1:NDIM_M),
     *                                            MAXMSH(1:NDIM_P)
      DIMENSION
     *          PARMSH(1:NDIM_M,1:NDMESH),
     *          AXSMAP(1:NDMESH,1:NDMESH)
      DIMENSION
     *          TITPAR(1:NDPARS),TITMSH(1:NDIM_P),TAKCHI(1:NDNUCL),
     *                           TITAUX(1:NDIM_M),TAKPAR(1:NDIM_M)
      DIMENSION
     *          CHITOT_OFMESH(1:NDMESH,1:NDMESH),
     *          CHIPRO_OFMESH(1:NDMESH,1:NDMESH),
     *          CHINEU_OFMESH(1:NDMESH,1:NDMESH)
      DIMENSION
     *          PARPOT_OFMESH(1:NDMESH,1:NDMESH,1:NDPARS),
     *          PARPOT_PRINTI(1:NDPARS,1:NDMES2)
C
      DIMENSION
     *          RFUNUP_PROTON(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNDN_PROTON(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNUP_NEUTRS(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNDN_NEUTRS(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          LABORD_AUXILP(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *          LABORD_AUXILN(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION 
     *          POLYNX(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      DIMENSION 
     *          QNORNL(0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          RAD_UP(0:NDIM_L,0:NDIM_N),
     *          RAD_DN(0:NDIM_L,0:NDIM_N)
      DIMENSION
     *          HSORUP(1:NDBASE,1:NDBASE),HSORDN(1:NDBASE,1:NDBASE)
      DIMENSION
     *          SPENUP(1:NDBASE),SPENDN(1:NDBASE),AUXVEC(1:NDBASE)     
      DIMENSION
     *          ANODES(1:NDGAUS),AWEIGH(1:NDGAUS),BAUXIL(1:NDGAUS),
     *                                            CAUXIL(1:NDGAUS)
      DIMENSION
     *          ARGMNT(1:NDPARS)
      DIMENSION
     *          RMSPRO_WEIDEP(1:NDWEIG),
     *          RMSNEU_WEIDEP(1:NDWEIG),
     *          RMSPRO_WEINUC(1:NDWEIG,1:NDNUCL),
     *          RMSNEU_WEINUC(1:NDWEIG,1:NDNUCL),
     *          RMSVAL_RATPRO(1:NDWEIG,1:NDNUCL),
     *          RMSVAL_RATNEU(1:NDWEIG,1:NDNUCL),
     *          RMSGLO_RATPRO(1:NDWEIG),
     *          RMSGLO_RATNEU(1:NDWEIG),
     *          IND_V1(1:NDWEIG),
     *          IND_V2(1:NDWEIG),
     *          IND_V3(1:NDWEIG),
     *          IND_V4(1:NDWEIG),
     *          IND_V5(1:NDWEIG)
      DIMENSION
     *          WEIG1P(1:NDWEIG),
     *          WEIG2P(1:NDWEIG),
     *          WEIG3P(1:NDWEIG),
     *          WEIG6P(1:NDWEIG),
     *          WEIG8P(1:NDWEIG),
     *          WEIG1N(1:NDWEIG),
     *          WEIG2N(1:NDWEIG),
     *          WEIG3N(1:NDWEIG),
     *          WEIG6N(1:NDWEIG),
     *          WEIG8N(1:NDWEIG)
      DIMENSION
     *          IASTER(1:NDWEIG),JASTER(1:NDWEIG)
C
      COMMON
     *       /TITEXP/ TITLES_EXPORT(1:NDTITL)
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /ARGINI/ XINITS(1:NDIM_P)
C @@@ IRENE WRONG ALIGNMENT =>> PLEASE SPLIT INTO TWO COMMONS
      COMMON
     *       /MESHIN/ I_MESH(1:NDIM_P),
     *                XMIN_I(1:NDIM_P),
     *                XMAX_I(1:NDIM_P),
     *                MAXPAR(1:NDIM_P)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
C     
      COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /LEVSYM/ LABSYM_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABSYM_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                              LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                              LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /EKINET/ ENEKIN_PROTON(1:NDNUCL,1:NDBASE,
     *                                       1:NDBASE,0:NDIM_L),
     *                ENEKIN_NEUTRS(1:NDNUCL,1:NDBASE,
     *                                       1:NDBASE,0:NDIM_L)
      COMMON
     *       /CFACTO/ CMATUP_PROTON(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_PROTON(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_NEUTRS(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_NEUTRS(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /POLPOL/ XPOLYN(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *                XDPOLY(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      COMMON
     *       /POLDEN/ XPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,
     *                                                0:NDIM_L), 
     *                XDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,
     *                                                0:NDIM_L)
      COMMON
     *       /ENUPDN/ ENERUP_PROTON(0:NDIM_L,1:NDBASE),
     *                ENERDN_PROTON(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_NEUTRS(0:NDIM_L,1:NDBASE),
     *                ENERDN_NEUTRS(0:NDIM_L,1:NDBASE)
      COMMON
     *       /NMLCNT/ XNORNL(0:NDIM_N,0:NDIM_L)
      COMMON 
     *       /LAGLAG/ XFLAGN(0:NDIM_N,0:NDIM_L),
     *                XDFLAG(0:NDIM_N,0:NDIM_L)
      COMMON
     *       /NODWEI/ XRNODE(1:NDGAUS,0:NDIM_L),
     *                XRWEIG(1:NDGAUS,0:NDIM_L)
      COMMON
     *       /VLIMIT/ VMISTR(1:NDPARS),
     *                VMIMIN(1:NDPARS),
     *                VMIMAX(1:NDPARS),
     *                VMISTP(1:NDPARS)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
C 
      COMMON
     *       /V2COEF/ VCOEUP_PROTON(0:NDIM_L,1:NDBASE),
     *                VCOEDN_PROTON(0:NDIM_L,1:NDBASE),
     *
     *                VCOEUP_NEUTRS(0:NDIM_L,1:NDBASE),
     *                VCOEDN_NEUTRS(0:NDIM_L,1:NDBASE)
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /ER_RMS/ RMSERR_PROTON(1:NDNUCL),
     *                RMSERR_NEUTRS(1:NDNUCL)
      COMMON
     *       /FERGPS/ FERMEX_PROTON(1:NDNUCL),GAPEXP_PROTON(1:NDNUCL),
     *                DENSUP_PROTON(1:NDNUCL),DENSDW_PROTON(1:NDNUCL),
     *
     *                FERMEX_NEUTRS(1:NDNUCL),GAPEXP_NEUTRS(1:NDNUCL),
     *                DENSUP_NEUTRS(1:NDNUCL),DENSDW_NEUTRS(1:NDNUCL)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)    
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI    
      COMMON
     *       /CHIEXT/ CHIMI1,CHIMI2_PROTON,CHIMI3_PROTON,
     *                       CHIMI2_NEUTRS,CHIMI3_NEUTRS
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /CHI_PN/ CHISQU_PROTON,CHISQU_NEUTRS
      COMMON
     *       /CHICHO/ VALCHI
     *       /DENSTR/ IFDENS
     *       /TENSOR/ IFTENS
      COMMON
     *       /ENEPRI/ ENEMAX
     *       /INPSEL/ WHATEX
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /FEVALS/ IFUNCT_EVALUS
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /CNTCNT/ ICOUNT_DENGRD,ICOUNT_FUNMIN,ICOUNT_HAMMAT,
     *                ICOUNT_EXPTHE,ICOUNT_CHOICE,ICOUNT_DIAMAT
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON  
     *       /VERSIN/ VERSIO
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /PARUNI/ PARPOT_UNITSS(1:NDTITL)
      COMMON
     *       /NUCWEI/ WEINUC_PROTON(1:NDNUCL),
     *                WEINUC_NEUTRS(1:NDNUCL),
     *                WEIRAD_PROTON(1:NDNUCL),
     *                WEIRAD_NEUTRS(1:NDNUCL)
      COMMON
     *       /RMSGLO_NUCLEU/ RMSGLO_TAKPRO,
     *                       RMSGLO_TAKNEU,
     *                       RMSVAL_TAKPRO(1:NDNUCL),
     *                       RMSVAL_TAKNEU(1:NDNUCL)
      COMMON
     *       /RMSREF/ RMSVAL_REFPRO(1:NDNUCL),
     *                RMSVAL_REFNEU(1:NDNUCL),
     *                RMSGLO_REFPRO,
     *                RMSGLO_REFNEU
      COMMON
     *       /RMSIND/ RMSIND_PROTON(1:NDNUCL),
     *                RMSIND_NEUTRS(1:NDNUCL)
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
      DATA
     *       EPSLAG / 1.0Q-32 /
C
C=======================================================================
C=======================================================================
C=======================================================================
C
      CALL CPUTIM('WSPH15',1)
C
C=======================================================================
C=======================================================================
C=======================================================================
C
                       PRONAM='wspher_15W'
C
C=======================================================================
C
      VERSIO='15W'
C
C=======================================================================
C     
C     Creating the necessary titles
C
      CALL CREATG_TITLES(NDTITL,NDNUCL,TITLES,TITLES_LATEXS,
     *                          PARPOT_UNITSS,NUCNAM_LATEXS)
C
      DO I=1,NDTITL
         TITLES_EXPORT(I)=TITLES(I)
      END DO
C
C=======================================================================
C
C     Creating the necessary folders to store the results.
C @@@ Irene?
C     The indication -p means that if the directory is already 
C     created the machine will not complain, i.e. the folders
C     will not be over-written (but yes the files if inside the
C     code are created again with the same name).
C
C      THE OLD FILES WILL BE OVERWRITTEN? YES, THEY WILL
C
      CALL SYSTEM('mkdir -pv Results')
C
      CALL SYSTEM('mkdir -pv LogFiles/IFDENS-0')
      CALL SYSTEM('mkdir -pv LogFiles/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv LogFiles/IFDENS-1_IFTENS-1')
C
      CALL SYSTEM('mkdir -pv Fitting-Results')
      CALL SYSTEM('mkdir -pv Fitting-Results/Global-Fit')
      CALL SYSTEM('mkdir -pv Fitting-Results/Fortran-Readable')
      CALL SYSTEM('mkdir -pv Fitting-Results/Latex-Readable')
C
      CALL SYSTEM('mkdir -pv EnergyLevels/IFDENS-0/Fitted')
      CALL SYSTEM('mkdir -pv EnergyLevels/IFDENS-0/Predic')
      CALL SYSTEM('mkdir -pv EnergyLevels/IFDENS-0/OneRun')
      CALL SYSTEM('mkdir -pv EnergyLevels/IFDENS-0/WSUniv')
C
      CALL SYSTEM('mkdir -pv EnergyLevels/IFDENS-1_IFTENS-0/Fitted')
      CALL SYSTEM('mkdir -pv EnergyLevels/IFDENS-1_IFTENS-0/Predic')
      CALL SYSTEM('mkdir -pv EnergyLevels/IFDENS-1_IFTENS-0/OneRun')
C
      CALL SYSTEM('mkdir -pv EnergyLevels/IFDENS-1_IFTENS-1/Fitted')
      CALL SYSTEM('mkdir -pv EnergyLevels/IFDENS-1_IFTENS-1/Predic')
      CALL SYSTEM('mkdir -pv EnergyLevels/IFDENS-1_IFTENS-1/OneRun')
C
      CALL SYSTEM('mkdir -pv DensitCurves/IFDENS-0/Fitted')
      CALL SYSTEM('mkdir -pv DensitCurves/IFDENS-0/Predic')
      CALL SYSTEM('mkdir -pv DensitCurves/IFDENS-0/OneRun')
C
      CALL SYSTEM('mkdir -pv DensitCurves/IFDENS-1_IFTENS-0/Fitted')
      CALL SYSTEM('mkdir -pv DensitCurves/IFDENS-1_IFTENS-0/Predic')
      CALL SYSTEM('mkdir -pv DensitCurves/IFDENS-1_IFTENS-0/OneRun')
C
      CALL SYSTEM('mkdir -pv DensitCurves/IFDENS-1_IFTENS-1/Fitted')
      CALL SYSTEM('mkdir -pv DensitCurves/IFDENS-1_IFTENS-1/Predic')
      CALL SYSTEM('mkdir -pv DensitCurves/IFDENS-1_IFTENS-1/OneRun')
C
      CALL SYSTEM('mkdir -pv LogFMesh/IFDENS-0')
      CALL SYSTEM('mkdir -pv LogFMesh/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv LogFMesh/IFDENS-1_IFTENS-1')
C
      CALL SYSTEM('mkdir -pv MeshTables/IFDENS-0')
      CALL SYSTEM('mkdir -pv MeshTables/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv MeshTables/IFDENS-1_IFTENS-1')
C
      CALL SYSTEM('mkdir -pv Chi2Maps/IFDENS-0')
      CALL SYSTEM('mkdir -pv Chi2Maps/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv Chi2Maps/IFDENS-1_IFTENS-1')
C
      CALL SYSTEM('mkdir -pv SPECurves/IFDENS-0')
      CALL SYSTEM('mkdir -pv SPECurves/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv SPECurves/IFDENS-1_IFTENS-1')
C
      CALL SYSTEM('mkdir -pv LogFMont/IFDENS-0')
      CALL SYSTEM('mkdir -pv LogFMont/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv LogFMont/IFDENS-1_IFTENS-1')
C
      CALL SYSTEM('mkdir -pv LogMonte/IFDENS-0')
      CALL SYSTEM('mkdir -pv LogMonte/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv LogMonte/IFDENS-1_IFTENS-1')
C
      CALL SYSTEM('mkdir -pv SPEMontC/IFDENS-0')
      CALL SYSTEM('mkdir -pv SPEMontC/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv SPEMontC/IFDENS-1_IFTENS-1')
C
C=======================================================================
C
C     Defining the output unit numbers for the log-files
C
      LOGCHP=22 ! Log file to store chi^2 for protons
      LOGCHN=23 ! Log file to store chi^2 for neutrons
C
      LOGPRO=82
      LOGNEU=83
C
      IRESUL=10
      ICONVE=20

      NOUTPT=6
      N_OUTP=6
      LSCREN=0
C
      IORTHO=1
C
C=======================================================================
C
      LOGBIS=41
C
      LOGAUX=50
      LOGENE=550
      LOGRAD=551
C
C=======================================================================
C
C                 Opening the central logfile called "total" =>> _t
      LOGFIL=21
      LOGWRI=01 ! This will be overwritten in SUBROUTINE NAMELI
C
      IALPHA=00 ! Integration weight proportional to z^{\ell-1/2}
C               ! This is the physicist's choice for controlled reasons
C
      IF (LOGWRI.GT.0) THEN
C
          STRING(1:16)=PRONAM//'_t.log'
C
          OPEN(LOGFIL,FILE=STRING(1:16),STATUS='UNKNOWN',
     *                                  FORM='FORMATTED')
C
          WRITE(LOGFIL,'(/,''Entering the MAIN program '',A10)')
     *                                                   PRONAM
C
          WRITE(LOGFIL,'(/,''ATTENTION: VERSION IALPHA='',I1,'' IS ''
     *                     ''USED =>>'')')      IALPHA
          WRITE(LOGFIL,'(11X,''Weight = z^{\ell-1/2}'')')
C
      END IF
C
C=======================================================================
C=======================================================================
C     Opening the log-files for the output-control information
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(/,''Finished the do-loop over nuclei '',
     *                        ''<<= experimental input'')')
C
          WRITE(LOGFIL,'(/,''In MAIN, LOG-TYPE files:'',/)')
C_______________________________________________________________________
C
          STRING(1:16)=PRONAM//'_p.log'
C
          OPEN(UNIT=LOGPRO,FILE=STRING(1:16),STATUS='UNKNOWN',
     *                                       FORM='FORMATTED')
C
          WRITE(LOGFIL,'(9X,''Opening the file: '',A,
     *                   1X,''UNIT='',I2)') STRING(1:16),LOGPRO
C_______________________________________________________________________
C
          STRING(1:16)=PRONAM//'_n.log'
C
          OPEN(UNIT=LOGNEU,FILE=STRING(1:16),STATUS='UNKNOWN',
     *                                       FORM='FORMATTED')
C
          WRITE(LOGFIL,'(9X,''Opening the file: '',A,
     *                   1X,''UNIT='',I2)') STRING(1:16),LOGNEU
C_______________________________________________________________________
C
          STRING(1:21)=PRONAM//'_iresul.log'
          OPEN(UNIT=IRESUL,FILE=STRING(1:21),STATUS='UNKNOWN',
     *                                       FORM='FORMATTED')
          WRITE(LOGFIL,'(9X,''Opening the file: '',A,
     *                   1X,''UNIT='',I2)') STRING(1:21),IRESUL
C_______________________________________________________________________
C
          IF (LOGWRI.GE.5) THEN
C
              STRING(1:21)=PRONAM//'_bisect.log'
              OPEN(UNIT=LOGBIS,FILE=STRING(1:21),STATUS='UNKNOWN',
     *                                           FORM='FORMATTED')
              WRITE(LOGFIL,'(/,''Opening BISECT  logfile from '',A,/)')
     *                                           PRONAM
          END IF
C
C=======================================================================
C
          OPEN(LOGCHN,FILE='Results/Log_file_CHIN.d',STATUS='UNKNOWN',
     *                                               FORM='FORMATTED')
          WRITE(LOGFIL,'(9X,''Opening the file:'',
     *                   1X,''Results/Log_file_CHIN.d'',
     *                   1X,''UNIT='',I2)') LOGHIN
C_______________________________________________________________________
C
          OPEN(LOGCHP,FILE='Results/Log_file_CHIP.d',STATUS='UNKNOWN',
     *                                               FORM='FORMATTED')
          WRITE(LOGFIL,'(  9X,''Opening the file:'',
     *                     1X,''Results/Log_file_CHIP.d'',
     *                     1X,''UNIT='',I2)') LOGHIP
C_______________________________________________________________________
C
          WRITE(LOGFIL,'()')
C
          WRITE(LOGFIL,'(/,''Entering NAMELI from MAIN'')')
C
          WRITE(N_OUTP,'(///,''ATTENTION: VERSION IALPHA='',I1,'' IS ''
     *                       ''USED !!!'',/)')    IALPHA
C
      END IF
C
C=======================================================================
C=======================================================================
C=======================================================================
C=======================================================================
C  @@@ IRENE, check this: IS IT A RIGHT PLACE for "this" to be HERE?
      CHIMI1       =9999. ! used only in printing routine
      CHIMI2_PROTON=9999. ! used only in printing routine      
      CHIMI3_PROTON=9999. ! used only in printing routine      
      CHIMI2_NEUTRS=9999. ! used only in printing routine      
      CHIMI3_NEUTRS=9999. ! used only in printing routine      
C
C=======================================================================
C     Routine reading the input data for this particular run
C=======================================================================
C
C     NGAUSS     !  The number of nodes in the Gauss formula
C     NSHELL     !  Maximum value  of the possible L-indices
C
      CALL NAMELI(NUCACT,ITAKNU,INPUTZ,INPUTN,INPSYM,NSHELL_PROTON,
     *                                               NSHELL_NEUTRS,
     *                   LDRAND,NGAUSS,ENEMAX,I_SEED,ISIMPL,NEWSED,
     *                          AOSCIL_PROTON,AOSCIL_NEUTRS,HOMEGA)
C
C=======================================================================
C     Reading and preparing the experimental charge-densities 
C     for a l l the nuclei which are experimentally available
C=======================================================================
C     
      IF (LOGWRI.GT.4) THEN
C
          WRITE(LOGFIL,'()')
C
          DO I=1,3
             WRITE(LOGFIL,'(22(''=''))')
          END DO
C
          WRITE(LOGFIL,'(/,''Entering PREPAR_DENEXP from MAIN'')')
C
      END IF
C
      CALL PREPAR_DENEXP
C
C=======================================================================
C     Reading the experimental information  for EACH nucleus 
C     spherical energy levels, radii, Fermi and gap energies 
C=======================================================================
C
      DO INUCLI=1,LDNUCL
         DO ILEVEL=1,NDLEXP
C
            LABEXP_PROTON(INUCLI,ILEVEL)='XXXXXX'
            LABEXP_NEUTRS(INUCLI,ILEVEL)='XXXXXX'
C
            EXPEXP_PROTON(INUCLI,ILEVEL)=999.999
            EXPEXP_NEUTRS(INUCLI,ILEVEL)=999.999
C
            IDEGEX_PROTON(INUCLI,ILEVEL)=999
            IDEGEX_NEUTRS(INUCLI,ILEVEL)=999
C
         END DO
      END DO
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(/,''Entering the do-loop over nuclei from '',
     *                     ''MAIN, <<= experimental input'')')
      END IF
C
      LDNUCL_AUXILI=8
C
      DO INUCLI=1,LDNUCL_AUXILI
C      
         IZ_FIX=NUMB_Z(INUCLI)
         IN_FIX=NUMB_N(INUCLI)
C 
         IDEFCN=1
C
C=======================================================================
C        Optionally reading the experimental radii: protons...
C=======================================================================
C
         IF (LOGWRI.GT.4) THEN
C
             WRITE(LOGFIL,'()')
C
             DO I=1,3
                WRITE(LOGFIL,'(9X,22(''=''))')
             END DO
C
             WRITE(LOGFIL,'(/,9X,''Entering RDPROT_RMSRAD from MAIN,'',
     *                        1X,''INUCLI='',I1,'' LDNUCL='',I1,
     *                        1X,''IZ_FIX='',I2,'' IN_FIX='',I3)')
     *                             INUCLI,         LDNUCL,
     *                             IZ_FIX,         IN_FIX
         END IF
                                                               IFEXPE=1
         CALL RDPROT_RMSRAD(NDRADZ,RADPRO,CHGRMS,RERROR,IZ_FIX,IN_FIX,
     *                                                  IFEXPE,IPRIEX)
C
C=======================================================================
C        ... and then neutrons
C=======================================================================
C
         IF (LOGWRI.GT.4 .AND. IDEFCN.EQ.1) THEN
             WRITE(LOGFIL,'(/,9X,''Entering PROVID_RMS_NR from MAIN,'',
     *                        1X,''INUCLI='',I1,'' LDNUCL='',I1,
     *                        1X,''IZ_FIX='',I2,'' IN_FIX='',I3)')
     *                             INUCLI,         LDNUCL,
     *                             IZ_FIX,         IN_FIX
         END IF
C
         CALL PROVID_RMS_NR(NDRADN,RADNEU,ERRNEU,IZ_FIX,IN_FIX,IDEFCN,
     *                                                  IFEXPE,IPRIEX)
         RMSEXP_PROTON(INUCLI)=RADPRO
         RMSERR_PROTON(INUCLI)=RERROR
C      
         RMSEXP_NEUTRS(INUCLI)=RADNEU 
         RMSERR_NEUTRS(INUCLI)=ERRNEU   
C
C=======================================================================
C        Optionally reading experimental  single particle
C        levels; option for doubly magic spherical nuclei
C=======================================================================
C
         IF (LOGWRI.GT.4) THEN
             WRITE(LOGFIL,'(/,9X,''Entering READEX_LEVELS from MAIN, '',
     *                           ''INUCLI='',I1,'' LDNUCL='',I1,
     *                        1X,''IZ_FIX='',I2,'' IN_FIX='',I3)')
     *                             INUCLI,         LDNUCL,
     *                             IZ_FIX,         IN_FIX
         END IF
C     
         CALL READEX_LEVELS(IFEXPE,IDEFCN)
C
C=======================================================================     
C        Reading the experimental single particle energies p/n
C=======================================================================     
C
         ISOSPI=1
C
         IF (LOGWRI.GT.4) THEN
             WRITE(LOGFIL,'(/,9X,''Entering PREPAR_EXPLEV from MAIN,'',
     *                        1X,''ISOSPI='',I1,
     *                        1X,''IZ_FIX='',I2,'' IN_FIX='',I3)') 
     *                             ISOSPI,
     *                             IZ_FIX,         IN_FIX
         END IF
C
         CALL PREPAR_EXPLEV(IZ_FIX,IN_FIX,FERMEX,GAPEXP,DENSUP,DENSDW,
     *                             IDEFCN,WHATEX,ISOSPI,IFEXPE,INUCLI)
          
         FERMEX_PROTON(INUCLI)=FERMEX
         GAPEXP_PROTON(INUCLI)=GAPEXP
         DENSUP_PROTON(INUCLI)=DENSUP
         DENSDW_PROTON(INUCLI)=DENSDW
C
         ISOSPI=0      
C
         IF (LOGWRI.GT.4) THEN
             WRITE(LOGFIL,'(/,9X,''Entering PREPAR_EXPLEV from MAIN,'',
     *                        1X,''ISOSPI='',I1, 
     *                        1X,''IZ_FIX='',I2,'' IN_FIX='',I3)') 
     *                             ISOSPI,
     *                             IZ_FIX,         IN_FIX
         END IF
C
         CALL PREPAR_EXPLEV(IZ_FIX,IN_FIX,FERMEX,GAPEXP,DENSUP,DENSDW,
     *                             IDEFCN,WHATEX,ISOSPI,IFEXPE,INUCLI)
     
         FERMEX_NEUTRS(INUCLI)=FERMEX
         GAPEXP_NEUTRS(INUCLI)=GAPEXP
         DENSUP_NEUTRS(INUCLI)=DENSUP
         DENSDW_NEUTRS(INUCLI)=DENSDW 
C
C=======================================================================
C          
      END DO  ! Over INUCLI
C
C=======================================================================
C=======================================================================
C     Defining  the Gauss integration parameters  as well as
C     generalised Laguerre basis polynomials and derivatives
C=======================================================================
C=======================================================================
C   
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,9X,''Entering GENBAS from MAIN'',/)')
      END IF
C
      CALL GENBAS(NDIM_N,NDIM_L,NDGAUS,NGAUSS,ANODES,AWEIGH,
     *            NSHELL_NEUTRS,BAUXIL,CAUXIL,EPSLAG,QRNODE,
     *            QRWEIG,QNORNL,QDFLAG,QFLAGN,QPOLYN,QDPOLY,
     *                   IALPHA,QPOLYN_DENSIT,QDPOLY_DENSIT)
C
C=======================================================================
C     Changing Nodes, Weights and Polynomials from REAL*16 to REAL*8
C=======================================================================
C
      MAXIML=NSHELL_NEUTRS
      NORDER=NSHELL_NEUTRS/2
      LORDER=NSHELL_NEUTRS
C
C=======================================================================
C  
C     Testing the precision of nodes and weights / printout neutralised
C     
C     WRITE(90,'(80(''#''),/,''#'',78X,''#'')')
C     WRITE(90,'(''#'',9X,A,9X,''#'',/,''#'',78X,''#'')')
C    *    'Comparing Real*16 with Real*8 obtained by applying R=REAL(Q)'
C     WRITE(90,'(80(''#''),/)')
C
C     WRITE(90,'(4X,''L'',4X,''IG'',15X,''NODE-Q/R'',28X,''WEIGHT-Q/R''
C    *                                                              )')
C       
      DO LQNUMB=0,MAXIML
C
C        WRITE(90,'(18X,''123456789 123456789 123456'',
C    *              10X,''123456789 123456789 123456'')') 
C      
         DO IPOINT=1,NGAUSS
C            
            XRNODE(IPOINT,LQNUMB)=REAL(QRNODE(IPOINT,LQNUMB))
            XRWEIG(IPOINT,LQNUMB)=REAL(QRWEIG(IPOINT,LQNUMB))
C           
C           WRITE(90,'(2I6.3,2E36.26,/,12x,2e36.26)') 
C    *                                  LQNUMB,IPOINT,
C    *                                  QRNODE(IPOINT,LQNUMB),
C    *                                  QRWEIG(IPOINT,LQNUMB),
C    *                                  XRNODE(IPOINT,LQNUMB),
C    *                                  XRWEIG(IPOINT,LQNUMB)
C           
         END DO
      END DO
C
C=======================================================================
C     Conclusion: There remain up to 16 coinciding decimals from this
C                 test. To be compared with 32 digits precision, when
C                 testing the orthogonality in quadruple precision =>
C     Conclusion: Double precision retains 16 decimal places??????
C=======================================================================
C=======================================================================
C
C     Similar as above but: for precision of normalisation constants,
C     Laguerre functions and their derivatives / printout neutralised
C
C       
C     WRITE(91,'(80(''#''),/,''#'',78X,''#'')')
C     WRITE(91,'(''#'',20X,A,29X,''#'',/,''#'',78X,''#'')')
C    *               'Comparing Real*16 with Real*8'
C     WRITE(91,'(80(''#''),/)')
C      
C     WRITE(91,'(4X,''N'',5X,''L'',20X,''NORM-Q/R'',
C    *           32X,''Lag^N_L'',32X,''D Lag^N_L'')')
C       
      DO NQNUMB=0,NORDER
C
C        WRITE(91,'(20X,''123456789 123456789 12345678'',
C    *              12X,''123456789 123456789 12345678'', 
C    *              12X,''123456789 123456789 12345678'')') 
C
         DO LQNUMB=0,LORDER
C            
            XNORNL(NQNUMB,LQNUMB)=REAL(QNORNL(NQNUMB,LQNUMB))
C            
            XFLAGN(NQNUMB,LQNUMB)=REAL(QFLAGN(NQNUMB,LQNUMB))
            XDFLAG(NQNUMB,LQNUMB)=REAL(QDFLAG(NQNUMB,LQNUMB))
C            
C           WRITE(91,'(2I6.3,3E40.28,/,12x,3E40.28)')
C    *                                 NQNUMB,LQNUMB,
C    *                                 QNORNL(NQNUMB,LQNUMB),
C    *                                 QFLAGN(NQNUMB,LQNUMB),
C    *                                 QDFLAG(NQNUMB,LQNUMB),
C    *                                 XNORNL(NQNUMB,LQNUMB),
C    *                                 XFLAGN(NQNUMB,LQNUMB),
C    *                                 XDFLAG(NQNUMB,LQNUMB)
C            
         END DO
      END DO
C
C=======================================================================
C
C                 N I H I L   N O V I   S U B   S O L E
C
C     Conclusion: There remain up to 16 coinciding decimals from this
C                 test. To be compared with 32 digits precision, when
C                 testing the orthogonality in quadruple precision =>
C=======================================================================
C=======================================================================
C
C     Similar to the above, but for the normalised Laguerre functions
C                                           with prints commented out
C
C     This is because the Great Artist expected to discover differ...
C       
C     WRITE(92,'(80(''#''),/,''#'',78X,''#'')')
C     WRITE(92,'(''#'',20X,A,29X,''#'',/,''#'',78X,''#'')')
C    *               'Comparing Real*16 with Real*8'
C     WRITE(92,'(80(''#''),/)')
C       
C     WRITE(92,'(4X,''L'',5X,''N'',4X,''IG'',18X,''Norm-L:Q/R'',
C    *                                       30X,''Norm-DL:Q/R'')')
C       
      DO N_MAIN=NSHELL_NEUTRS,0,-1
C         
         DO LQNUMB=N_MAIN,0,-2
            NQNUMB=(N_MAIN-LQNUMB)/2
C
C           WRITE(92,'(26X,''123456789 123456789 12345678'',
C    *                 12X,''123456789 123456789 12345678'')') 
C            
            DO IPOINT=1,NGAUSS
C                
               XPOLYN(IPOINT,NQNUMB,LQNUMB)=
     *         REAL(QPOLYN(IPOINT,NQNUMB,LQNUMB))
C     
               XDPOLY(IPOINT,NQNUMB,LQNUMB)=
     *         REAL(QDPOLY(IPOINT,NQNUMB,LQNUMB))
C     
C              WRITE(92,'(3I6.3,2E40.28,/,18x,2E40.28)')
C    *                                    LQNUMB,NQNUMB,IPOINT,
C    *                                    QPOLYN(IPOINT,NQNUMB,LQNUMB),
C    *                                    QDPOLY(IPOINT,NQNUMB,LQNUMB),
C    *                                    XPOLYN(IPOINT,NQNUMB,LQNUMB),
C    *                                    XDPOLY(IPOINT,NQNUMB,LQNUMB)
C             
               DO NAUXIL=0,NORDER
                  DO LAUXIL=0,LORDER
C                   
                     XPOLYN_DENSIT(IPOINT,NAUXIL,LAUXIL,LQNUMB)=
     *               REAL(QPOLYN_DENSIT(IPOINT,NAUXIL,LAUXIL,LQNUMB))
C                   
                     XDPOLY_DENSIT(IPOINT,NAUXIL,LAUXIL,LQNUMB)=
     *               REAL(QDPOLY_DENSIT(IPOINT,NAUXIL,LAUXIL,LQNUMB))
C                   
                  END DO
               END DO
C            
            END DO ! IPOINT of Gauss integration
         END DO ! LQNUMB   
      END DO ! N_MAIN
C
C=======================================================================
C     Here we wish to calm down the passionate reader who at this point
C     is dying of curiosity about results of these profound efforts ...
C     And the conclusion is â€¦ surprise / surprise =>> the same as above
C=======================================================================
C=======================================================================
C
      DO INUCLI=1,LDNUCL
C          
         IZ_FIX=NUMB_Z(INUCLI)
         IN_FIX=NUMB_N(INUCLI)      
C
C=======================================================================
C=======================================================================
C        Preparing the kinetic energy term; this part is needed
C        once per run of the code;  we avoid repeating the same
C        operations millions of times ...
C=======================================================================
C=======================================================================
C
         IF (LOGWRI.GT.5) THEN
             WRITE(LOGFIL,'(/,''Entering KINMAT from MAIN,  protons, '',
     *                        ''INUCLI='',I2,'' LDNUCL='',I2)')
     *                          INUCLI,         LDNUCL
         END IF
C
         CALL KINMAT(XPOLYN,XDPOLY,POLYNX,XRNODE,XRWEIG,ENEKIN_PROTON,
     *               HOMEGA,NDBASE,NDIM_N,NDIM_L,NSHELL_PROTON,NDGAUS,
     *                                           NGAUSS,NDNUCL,INUCLI)
C
         IF (LOGWRI.GT.5) THEN
             WRITE(LOGFIL,'(/,''Entering KINMAT from MAIN, neutrons, '',
     *                        ''INUCLI='',I2,'' LDNUCL='',I2)')
     *                          INUCLI,         LDNUCL
         END IF
C
         CALL KINMAT(XPOLYN,XDPOLY,POLYNX,XRNODE,XRWEIG,ENEKIN_NEUTRS,
     *               HOMEGA,NDBASE,NDIM_N,NDIM_L,NSHELL_NEUTRS,NDGAUS,
     *                                           NGAUSS,NDNUCL,INUCLI)
C
C=======================================================================     
C=======================================================================     
C
C        This an intrinsic-test routine, checking the fact that the 
C        total HO hamiltonian (the sum of the kinetic and potential
C        energies) is diagonal in the  {|n l s j m_j>}  basis,  the
C        diagonal terms being the eigen-energies 
C
C                         E_nl=(2n+l+3/2)*homega
C
C        Since the call below is testing the HO properties using HO 
C        wave functions,  rather than the actual physical potential,
C        it is of no interest [we verified the machine precision of
C        the numerical algorithm calculating the Laguerre-type wave
C        functions already]. 
C
C        IF (LOGWRI.GT.0) THEN
C            WRITE(LOGFIL,'(/,''Entering CHEKHO from MAIN,  '',
C    *                        ''NSHELL_PROTON only, IALPHA='',I2,1X,
C    *                                            ''INUCLI='',I2)')
C    *                                              IALPHA,INUCLI
C        END IF
C
C        CALL CHEKHO(XPOLYN,XDPOLY,POLYNX,XRNODE,XRWEIG,HOMEGA,
C    *               NDBASE,NDIM_N,NDIM_L,NSHELL_PROTON,NDGAUS,
C    *                             NGAUSS,IALPHA,NDNUCL,INUCLI)
C
C        The conclusions of these equally profound efforts is that...
C        harmonic oscillator wave functions,  in quadrupole precision
C        when multiplied by r^2 and integrated preserve the precision
C        So do the first order derivatives...
C
C=======================================================================     
C        Reading the order of the theoretical single-particle levels 
C=======================================================================     
C
         IF (LOGWRI.GT.5) THEN
             WRITE(LOGFIL,'(/,''Entering ORDLAB from MAIN, '',
     *                        ''NSHELL_PROTON only, IALPHA='',I1)')
     *                                              IALPHA
         END IF
C
         IF (IZ_FIX.LE.82 .AND. IN_FIX.LE.126) THEN
             CALL ORDLAB(NDIM_N,NDIM_L,LABORD_PROTON,LABORD_NEUTRS,
     *                                 LABSYM_PROTON,LABSYM_NEUTRS,
     *                                               NDNUCL,INUCLI)
         END IF
C
      END DO ! INUCLI
C
C=======================================================================     
C=======================================================================     
C=======================================================================     
C     The following is a single run for the standard 
C     WS Hamiltonian with universal parameters (WSSTAN)  
C=======================================================================
C=======================================================================     
C=======================================================================     
C
      IF (ISIMPL.EQ.1) THEN
C
          WRITE(LSCREN,'(''Simple run with the spherical WS '',
     *                          ''Hamiltonian'')')
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,''Entering WSUNIV, SINGLE RUN'')')
          END IF 
C
          CALL ONERUN_WSUNIV
          
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,''Exiting WSUNIV - SINGLE RUN'')')
          END IF
C
C=======================================================================
C       
          STOP 'Single-run with the standard WS Hamiltonian successful'
C      
      END IF
C
C=======================================================================     
C=======================================================================     
C=======================================================================     
C     The following is a single run for a user-choice of 
C     parameters and options.
C=======================================================================
C=======================================================================     
C=======================================================================     
C
      IF (IFTEST.EQ.1) THEN 
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,''Entering ONERUN, IFTEST='',I1,1X,
     *                            ''from MAIN'')')   IFTEST
          END IF
C
C=======================================================================     
C
          CALL ONERUN
C
C=======================================================================     
C      
       STOP 'Stop! Single-run version successful'
C
      END IF
C
C=======================================================================     
C=======================================================================     
C=======================================================================     
C     B e l o w   t h e   p a r a m e t e r - f i t t i n g 
C=======================================================================     
C=======================================================================     
C=======================================================================     
C
      IF (IFFITS.EQ.1) THEN
C
          IDEFCN=1
C
C=======================================================================
C
          IFUNCT_EVALUS=0
C
          ICOUNT=0
          DO I=1,NDPARS
             IF (IFTAKE(I).EQ.1) THEN
                  ICOUNT=ICOUNT+1
                  ARGMNT(ICOUNT)=VMISTR(I)
                  TITPAR(ICOUNT)=TITLES(I)(2:8)//'PROTON'
             END IF
          END DO
C
C=======================================================================
C
          IF (LOGWRI.NE.0) THEN
              WRITE(LOGFIL,'()')
              DO I=1,5
                 WRITE(LOGFIL,'(''Entering LMMINI '',
     *                          ''from MAIN, IFFITS=1'')')
              END DO
          END IF
C          
          CALL LMMINI(ARGMNT,I_SEED,LDRAND,NEWSED,NDLAST)
C
          IF (LOGWRI.NE.0) THEN
              WRITE(LOGFIL,'()')
              DO I=1,5
                 WRITE(LOGFIL,'(''END OF RUN - '',
     *                          ''from MAIN, IFFITS=1'')')
              END DO
          END IF
C           
C=======================================================================
C          
          CALL CPUTIM('WSPH15',0)
          CALL TIMPRI
C           
C=======================================================================
C      
          STOP 'Stop! Parameter-fitting version successful'
C           
C=======================================================================
C
      END IF    
C
C=======================================================================     
C=======================================================================     
C=======================================================================
C
C                         M E S H - O P T I O N    
C 
C     Below we run an option of minimising over N variables (N chosen 
C     by the user in the input file), whereas all other variables are
C     fixed by the user. The results are stored on a disc for plotting 
C     analysis purposes ( M A P   P L O T S ) .
C     
C     For making easier the code, the user can only choose TWO varia-
C     bles in the input file with I_MESH(I) = 1
C
C=======================================================================     
C=======================================================================     
C=======================================================================     
C   
      IF (IFMESH.EQ.1) THEN
          
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,''Running the option of a'',
     *                         '' Minimisation on a Rectangular'',
     *                         '' Mesh of points'')')
C
              WRITE(LOGFIL,'(/,9X,''Entering MESHIN_MAPING '',
     *                            ''from MAIN'')')
          END IF
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LSCREN,'(''Setting LOGWRI=0 to avoid a '',
     *                       ''HUGE output file'')')
              LOGWRI=0
          END IF
C
          CALL MESHIN_MAPING(LDRAND)
C
          CALL CPUTIM('WSPH15',0)
          CALL TIMPRI
C           
C=======================================================================
C      
          STOP 'From MAIN: Mesh-option version successful'
C           
C=======================================================================
C      
      END IF ! IFMESH = 1
C
C=======================================================================     
C=======================================================================     
C=======================================================================
C
C      SINGLE PARTICLE ENERGIES AS A FUNCTION OF ONE PARAMETER 
C
C=======================================================================     
C=======================================================================     
C=======================================================================
C
      IF (ISPE_P.EQ.1) THEN
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,''Running the option of '',
     *                         '' SPE as a function of '',
     *                         '' one parameter'')')
C
              WRITE(LOGFIL,'(/,9X,''Entering SPENER_OFPARA '',
     *                            ''from MAIN'')')
          END IF
C
C          IF (LOGWRI.GT.0) THEN
C              WRITE(LSCREN,'(''Setting LOGWRI=0 to avoid a '',
C     *                       ''HUGE output file'')')
C              LOGWRI=0
C          END IF
C
          CALL SPENER_OFPARA(LDRAND)
C
          CALL CPUTIM('WSPH15',0)
          CALL TIMPRI
C           
C=======================================================================
C      
          STOP 'From MAIN: SPE of parameter version successful'
C           
C=======================================================================
C
      END IF ! ISPE_P=1
C
C=======================================================================     
C=======================================================================     
C=======================================================================
C
C      MONTE-CARLO RUN: S.P.E. LEVELS IN HISTOGRAM FORMS
C
C=======================================================================     
C=======================================================================     
C=======================================================================
C
      IF (IFMOCA.EQ.1) THEN
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,''Running the option of Monte-Carlo'')')
          END IF
C
          IF (IFPARA.EQ.1) THEN
              IF (LOGWRI.GT.0) WRITE(LOGFIL,'(/,9X,''Entering '',
     *                             ''SPENER_MONTEC from MAIN'')')
              CALL SPENER_MONTEC
          END IF
C
          IF (IFPSEU.EQ.1) THEN
              IF (LOGWRI.GT.0) WRITE(LOGFIL,'(/,9X,''Entering '',
     *                             ''FITTIN_MONTEC from MAIN'')')
              CALL FITTIN_MONTEC(I_SEED,NEWSED)
          END IF
C
          STOP 'From MAIN: Monte-Carlo SPE Histogram version successful'
C
      END IF
C           
C=======================================================================
C
      STOP 'ALLRIGHT'      
      END 
C
C=======================================================================
C=======================================================================
C=======================================================================
C FILE NAME = wspher02_nameli_15.f ! Keep this symbol:    $ident@string$
C=======================================================================
C=======================================================================
C=======================================================================
C      
C=======================================================================
C=======================================================================
C                     INPUT SUBROUTINE NAMELIST STYLE
C=======================================================================
C=======================================================================
C      
      SUBROUTINE NAMELI(NUCACT,ITAKNU,INPUTZ,INPUTN,INPSYM,
     *                                NSHELL_PROTON,NSHELL_NEUTRS,
     *                  LDRAND,NGAUSS,ENEMAX,I_SEED,ISIMPL,NEWSED,
     *                         AOSCIL_PROTON,AOSCIL_NEUTRS,HOMEGA)
C      
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDRAND.f'
      INCLUDE   'MATDIM/NDRAUS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDLAST.f'
      INCLUDE   'MATDIM/NDCOLO.f'
      INCLUDE   'MATDIM/NDMONT.f'
      INCLUDE   'MATDIM/NDBINS.f'
C      
      PARAMETER
     *         (N_READ=5)
C
      CHARACTER 
     *          KEYWOR*10,SPACIN*10,CHIDEF*6,WHATEX*6,STRING*256
      CHARACTER 
     *          EXTENT_PROTON*40,EXTENT_NEUTRS*40
      CHARACTER 
     *          LABPRO_REMOVE*6,LABNEU_REMOVE*6,
     *          REMOVE_PROTON*3,REMOVE_NEUTRS*3
      CHARACTER
     *          INPSYM*6,TYPCHI*6,NUCSYM*6
      DIMENSION
     *          ITAKNU(1:NDNUCL),
     *          INPUTZ(1:NDNUCL),
     *          INPUTN(1:NDNUCL),
     *          INPSYM(1:NDNUCL)
      DIMENSION
     *          AOSCIL_PROTON(1:NDNUCL),
     *          AOSCIL_NEUTRS(1:NDNUCL),
     *          HOMEGA(1:NDNUCL)
C
      COMMON
     *       /NUCWEI/ WEINUC_PROTON(1:NDNUCL),
     *                WEINUC_NEUTRS(1:NDNUCL),
     *                WEIRAD_PROTON(1:NDNUCL),
     *                WEIRAD_NEUTRS(1:NDNUCL)
      COMMON
     *       /WEIGHT/ WEIGHT_CORREL,WEIGHT_RADIUS,WEIGHT_INVERT,
     *                WEIGHT_EFERMI,WEIGHT_ENEGAP,WEIWEI,
     *                WEIGHT_ERRABS,WEIGHT_EABSAV,WEIGHT_ERRMAX,
     *                WEIGHT_DENSUP,WEIGHT_DENSDW,WEIGHT_RHODEN
      COMMON
     *       /EXTREM/ V0CMAX,V0CMIN,XL_MAX,XL_MIN,XEFMAX,XEFMIN,
     *                R0CMAX,R0CMIN,R0SMAX,R0SMIN,REFMAX,REFMIN,
     *                A0CMAX,A0CMIN,A0SMAX,A0SMIN,AEFMAX,AEFMIN,
     *                                            CouMAX,CouMIN,
     *                              XPPMAX,XPPMIN,XPNMAX,XPNMIN,
     *                              XNPMAX,XNPMIN,XNNMAX,XNNMIN,
     *                              YPPMAX,YPPMIN,YPNMAX,YPNMIN,
     *                              YNPMAX,YNPMIN,YNNMAX,YNNMIN,
     *                              CPPMAX,CPPMIN,CPNMAX,CPNMIN,
     *                              CNPMAX,CNPMIN,CNNMAX,CNNMIN,
     *
     *                                            UPFACT,DWFACT
      COMMON
     *       /KAPPAS/ XKCMIN,XKCMAX,XACMIN,XACMAX,XRCMIN,XRCMAX,
     *                XKSMIN,XKSMAX,XASMIN,XASMAX,XRSMIN,XRSMAX,
     *                XKEMIN,XKEMAX,XAEMIN,XAEMAX,XREMIN,XREMAX,
     *                                            XCoMIN,XCoMAX
      COMMON
     *       /EXTKAP/ V0CMIN_KAPPAR,V0CMAX_KAPPAR,XKCMIN_KAPPAR,
     *                XKCMAX_KAPPAR,A0CMIN_KAPPAR,A0CMAX_KAPPAR,
     *                XACMIN_KAPPAR,XACMAX_KAPPAR,R0CMIN_KAPPAR,
     *                R0CMAX_KAPPAR,XRCMIN_KAPPAR,XRCMAX_KAPPAR,
     *                XL_MIN_KAPPAR,XL_MAX_KAPPAR,XKSMIN_KAPPAR,
     *                XKSMAX_KAPPAR,A0SMIN_KAPPAR,A0SMAX_KAPPAR,
     *                XASMIN_KAPPAR,XASMAX_KAPPAR,R0SMIN_KAPPAR,
     *                R0SMAX_KAPPAR,XRSMIN_KAPPAR,XRSMAX_KAPPAR
      COMMON
     *       /HBAR_V/ HBAR_C    
C 
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /FILEXT/ EXTENT_PROTON,EXTENT_NEUTRS
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /REMLAB/ REMOVE_PROTON,REMOVE_NEUTRS
      COMMON
     *       /OUTLAB/ LABPRO_REMOVE(1:NDRAUS),
     *                LABNEU_REMOVE(1:NDRAUS)
      COMMON
     *       /OUTIND/ INDPRO_LETOUT(1:NDRAUS),
     *                INDNEU_LETOUT(1:NDRAUS)
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /VLIMIT/ VMISTR(1:NDPARS),
     *                VMIMIN(1:NDPARS),
     *                VMIMAX(1:NDPARS),
     *                VMISTP(1:NDPARS)
      COMMON
     *       /CNTROL/ PARAMT(1:NDPARS),
     *                DPARAM(1:NDPARS)     
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /MESHIN/ I_MESH(1:NDPARS),
     *                XMIN_I(1:NDPARS),
     *                XMAX_I(1:NDPARS),
     *                MAXPAR(1:NDPARS)
      COMMON
     *       /DELTAF/ DFACTO(1:NDNUCL,1:2),
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /WHERBE/ IRUNMI,NEWOLD 
      COMMON
     *       /PRINAL/ IMTALK
     *       /INPSEL/ WHATEX
     *       /WHICHI/ CHIDEF
     *       /DENSTR/ IFDENS
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /SVDSVC/ SVDCUT
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /XLENGT/ XMIN_T,XMAX_T,XMIN_E,XMAX_E
      COMMON
     *       /ATTRIB/ ISTYLE,I_TYPE,ICOLOR(1:NDCOLO),ITHICK(1:NDCOLO)
      COMMON
     *       /TOLERS/ TOLERF,TOLERX,TOLERG,FACTOR
      COMMON
     *       /STOPAR/ EPSLAS,LDLAST
      COMMON
     *       /LAMUNI/ UNITLA
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /PARCOR/ IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS
      COMMON
     *       /STEPBI/ BISTEP
      COMMON
     *       /FACCOU/ COUFAC
      COMMON
     *       /CTSHIF/ V0SHIF_PROTON(1:NDNUCL),
     *                V0SHIF_NEUTRS(1:NDNUCL)
      COMMON
     *       /RMSREF/ RMSVAL_REFPRO(1:NDNUCL),
     *                RMSVAL_REFNEU(1:NDNUCL),
     *                RMSGLO_REFPRO,
     *                RMSGLO_REFNEU
      COMMON
     *       /RMSIND/ RMSIND_PROTON(1:NDNUCL),
     *                RMSIND_NEUTRS(1:NDNUCL)
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /GAUSSI/ PARPOT_XMEANS(1:NDPARS),
     *                PARPOT_SIGMAS(1:NDPARS)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS                                                 
C_______________________________________________________________________
C
      DATA
     *     HBAR_C /197.327053/,! Units: MeV*fm;   ERROR: (+/-)0.000059
     *     XMASSP /938.27231 /,! Units: MeV/c**2; ERROR: (+/-)0.00028
     *     XMASSN /939.56563 / ! Units: MeV/c**2; ERROR: (+/-)0.00028
C @@@ DISCUSS THAT FINALLY...
      DATA
     *     NGSMAX /80/  ! Maximum order in the Gauss integrations
     *     NSHMAX /20/  ! Effective maximum of shells guaranteeing @@@
C                         that  the quadruple precision integrals
C                         will be possible to calculate
C     
C=======================================================================
C     In this subroutine we read input data in the NAMELIST style
C=======================================================================
C
C=======================================================================
C
   1  CONTINUE     
C     
C=======================================================================
C     
      READ (N_READ,'(A10)',END=2)  KEYWOR
C
C=======================================================================
C=======================================================================
C     Here the proton and neutron numbers of the nucleus in question...
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'IFHOWTORUN') THEN
C
          READ (N_READ,*) ISIMPL,IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA,
     *                           IF_DIR,IFDENS,IFTENS,ISCREN,LOGWRI
C
C         In the case of a single-nucleus run IZ_FIX and IN_FIX will
C         define the nucleus in question, see however the option for
C         fitting the parameters for several nuclei at the same time
C
C         ISIMPL=1 =>> A single WS run with the standard Hamiltonian
C         IFTEST=1 =>> Testing: The WS_RUN routine with the standard
C                                                         parameters
C         IFFITS=1 =>> Fitting the WS-Hamiltonian parameters various
C                                           variants described below
C         IF_DIR=1 =>> Option with the Dirac form of the Hamiltonian
C         IFDENS=1 =>> Option with the density-dependent  spin-orbit
C         IFTENS=1 =>> Mean-field  tensor-interaction term  included
C
C         ISCREN=1 =>> Partial output on the screen for online cntrl
C         LOGWRI>0 =>> Controlling the format of the log-file output,
C                      If 0, no logfile, If > 0, various variants of
C                      the details of the information.
C_______________________________________________________________________
C
          WRITE(LSCREN,'(/,9X,''From NAMELI, LOGWRI='',i1)') LOGWRI
C
          WRITE(LOGFIL,'(/,9X,''From NAMELI, LOGWRI='',i1)') LOGWRI
C
          WRITE(LOGFIL,'(/,A)') KEYWOR
C_______________________________________________________________________
C
          IF (ISIMPL.EQ.1) THEN
C
              IF (ISCREN.GT.0) THEN
                  WRITE(LSCREN,'(''Single-run with Universal'',1X, 
     *                           ''Parameters Variant Selected'')')
              END IF
C
              WRITE(LOGFIL,'( 9X,''Single-run with Universal'',1X, 
     *                           ''Parameters Variant Selected'')')
          END IF
C_______________________________________________________________________
C
          IF (IFTEST.EQ.1) THEN
C
              IF (ISCREN.GT.0) THEN
                  WRITE(LSCREN,'(''Single-run with User'',1X, 
     *                           ''Parameters Variant Selected'')')
              END IF
C
              WRITE(LOGFIL,'( 9X,''Single-run with User'',1X, 
     *                           ''Parameters Variant Selected'')')
          END IF
C_______________________________________________________________________
C
          IF (IFFITS.EQ.1) THEN
C
              IF (ISCREN.GT.0) THEN
                  WRITE(LSCREN,'(''Parameter Fitting Variant '',
     *                           ''Selected'')')
              END IF
C
              WRITE(LOGFIL,'( 9X,''Parameter Fitting Variant '',
     *                           ''Selected'')')
          END IF
C_______________________________________________________________________
C
          IF (IFMESH.EQ.1) THEN
C
              IF (ISCREN.GT.0) THEN
                  WRITE(LSCREN,'(''Parameter Mesh Variant '',
     *                           ''Selected'')')
              END IF
C
              WRITE(LOGFIL,'( 9X,''Parameter Mesh Variant '',
     *                           ''Selected'')')
          END IF
C_______________________________________________________________________      
C
          IF (IF_DIR.EQ.1) THEN
C
              IF (ISCREN.NE.0) THEN
                  WRITE(LSCREN,'(''Dirac Equation Variant '',
     *                           ''Selected'')')
              END IF
C
              WRITE(LOGFIL,'( 9X,''Dirac Equation Variant '',
     *                           ''Selected'')')
C
              STOP 'DIRAC option not implemented yet'
C
          END IF
C_______________________________________________________________________
C
          IF (IFDENS.EQ.0) THEN
C
              IF (ISCREN.GT.0) THEN
                  WRITE(LSCREN,'(''Calculation WITHOUT density-'',
     *                           ''dependent spin-orbit'')')
              END IF
C
              WRITE(LOGFIL,'( 9X,''Calculation WITHOUT density-'',
     *                           ''dependent spin-orbit'')')
          ELSE
C
              IF (ISCREN.GT.0) THEN
                  WRITE(LSCREN,'(''Calculating WITH density-'',
     *                           ''dependent spin-orbit'')')
              END IF
C
              WRITE(LOGFIL,'( 9X,''Calculating WITH density-'',
     *                           ''dependent spin-orbit'')')
          END IF
C_______________________________________________________________________
C
          IF (IFTENS.EQ.0) THEN
C
              IF (ISCREN.GT.0) THEN
                  WRITE(LSCREN,'(''Calculation WITHOUT tensor '',
     *                           ''contribution'')')
              END IF
C
              WRITE(LOGFIL,'( 9X,''Calculation WITHOUT tensor '',
     *                           ''contribution'')')
          ELSE
C
              IF (ISCREN.GT.0) THEN
                  WRITE(LSCREN,'(''Calculating WITH tensor '',
     *                           ''contribution'')')
              END IF
C
              WRITE(LOGFIL,'( 9X,''Calculating WITH tensor '',
     *                           ''contribution'')')
          END IF
C
      END IF
C
C=======================================================================
C=======================================================================
C=======================================================================
C     Reading what contributions to chi^2 which we take into account
C=======================================================================
C=======================================================================
C=======================================================================
C  
      IF (KEYWOR.EQ.'IFTAKECHI2') THEN
C
          READ(N_READ,*) IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,
     *                                                      IF_INV
C
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(9X,''Fitting requests:'')')
C
          IF (IF_SPE.EQ.1) THEN
              WRITE(LOGFIL,'(27X,''Single Particle levels - YES'')')
              ITKCHI(1)=1
          ELSE
              WRITE(LOGFIL,'(27X,''Single Particle levels - NO'')')
              ITKCHI(1)=0
          END IF
C 
          IF (IF_RAD.EQ.1) THEN
              WRITE(LOGFIL,'(27X,''R.M.S. radii ......... - YES'')')
              ITKCHI(2)=1
          ELSE
              WRITE(LOGFIL,'(27X,''R.M.S. radii ......... - NO'')')
              ITKCHI(2)=0
          END IF
C
          IF (IF_GAP.EQ.1) THEN
              WRITE(LOGFIL,'(27X,''Main gap sizes ....... - YES'')')
              ITKCHI(3)=1
          ELSE
              WRITE(LOGFIL,'(27X,''Main gap sizes ....... - NO'')')
              ITKCHI(3)=0
          END IF
C
          IF (IF_FER.EQ.1) THEN
              WRITE(LOGFIL,'(27X,''Average Fermi levels   - YES'')')
              ITKCHI(4)=1
          ELSE
              WRITE(LOGFIL,'(27X,''Average Fermi levels   - NO'')')
              ITKCHI(4)=0
          END IF
C
          IF (IF_DEN.EQ.1) THEN
              WRITE(LOGFIL,'(27X,''Densities =/- shells   - YES'')')
              ITKCHI(5)=1
          ELSE
              WRITE(LOGFIL,'(27X,''Densities =/- shells   - NO'')')
              ITKCHI(5)=0
          END IF
C
          IF (IF_RHO.EQ.1) THEN
              WRITE(LOGFIL,'(27X,''Densities rho(r) ..... - YES'')')
              ITKCHI(6)=1
          ELSE
              WRITE(LOGFIL,'(27X,''Densities rho(r) ..... - NO'')')
              ITKCHI(6)=0
          END IF
C
          IF (IF_INV.EQ.1) THEN
              WRITE(LOGFIL,'(27X,''Level inversions ..... - YES'')')
              ITKCHI(7)=1
          ELSE
              WRITE(LOGFIL,'(27X,''Level inversions ..... - NO'')')
              ITKCHI(7)=0
          END IF
C
          TYPCHI(1)='IF_SPE'
          TYPCHI(2)='IF_RAD'
          TYPCHI(3)='IF_GAP'
          TYPCHI(4)='IF_FER'
          TYPCHI(5)='IF_DEN'
          TYPCHI(6)='IF_RHO'
          TYPCHI(7)='IF_INV'
C
          LDCHI2=7
C
      END IF
C
C=======================================================================
C=======================================================================
C     Nuclei chosen for the minimisation
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'EXPER_FILE') THEN
C
          READ (N_READ,*) IFDEEP,IFPRON
C
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(9X,''Experimental file:'')')
C
          IF (IFDEEP.EQ.1) THEN
              WRITE(LOGFIL,'(27X,''Deeply-bound states... - YES'')')
          ELSE
              WRITE(LOGFIL,'(27X,''Deeply-bound states... - NO'')')
          END IF
C
          IF (IFPRON.EQ.1) THEN
              WRITE(LOGFIL,'(27X,''P-N pairing N=Z nuclei - YES'')')
          ELSE
              WRITE(LOGFIL,'(27X,''P-N pairing N=Z nuclei - NO'')')
          END IF
C
      END IF
C
C=======================================================================
C=======================================================================
C     How many nuclei to chose from for the minimisation
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'HOWMANYNUC') THEN
C
          READ(N_READ,*) LDNUCL
C
          IF (LDNUCL.GT.NDNUCL) THEN
              WRITE(0,'(/,''Alarm in NAMELI: LDNUCL= '',I3,
     *                    ''is .GT. NDNUCL= '',I3,/)') LDNUCL,NDNUCL
              STOP 'STOP in NAMELI: LDNUCL.GT.NDNUCL'
          END IF
C 
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(9X,''Scanning data base for LDNUCL='',I2,
     *                      '' nuclei'')') LDNUCL
C
      END IF
C
C=======================================================================
C=======================================================================
C     Which nuclei really chosen?
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'ITAKENUCLS') THEN
C        
          READ(N_READ,*) (ITAKNU(I),I=1,LDNUCL)
C        
          NUCACT=0
C        
          DO I=1,LDNUCL
C          
             IF (ITAKNU(I).EQ.1) THEN
                 NUCACT=NUCACT+1
             END IF
C        
          END DO
C_______________________________________________________________________
C
          WRITE(LOGFIL,'(A)') KEYWOR
C_______________________________________________________________________
C        
          IF (NUCACT.EQ.0) THEN
              WRITE(LSCREN,'(/,''There is NO active nucleus '',
     *                         ''for the calculation!'',/)')
C
              STOP 'STOP in NAMELI: No active nucleus in the input file'
C
          END IF
C
          IF (NUCACT.GT.LDNUCL) THEN
              WRITE(0,'(/,''Alarm in NAMELI: NUCACT= '',I3,''is .GT. ''
     *                    ''LDNUCL= '',i3,/)') NUCACT,LDNUCL
              STOP 'STOP: NUCACT.GT.LDNUCL'
          END IF
C_______________________________________________________________________
C        
          LDACTV=0
C_______________________________________________________________________
C        
          IF (ITAKNU(1).EQ.1) THEN
C            
              LDACTV=LDACTV+1
C            
              INPUTZ(LDACTV)=8
              INPUTN(LDACTV)=8
              INPSYM(LDACTV)='   16O'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
          END IF
C_______________________________________________________________________
C        
          IF (ITAKNU(2).EQ.1) THEN
C            
              LDACTV=LDACTV+1
C            
              INPUTZ(LDACTV)=20
              INPUTN(LDACTV)=20
              INPSYM(LDACTV)='  40Ca'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
          END IF
C_______________________________________________________________________
C        
          IF (ITAKNU(3).EQ.1) THEN
C            
              LDACTV=LDACTV+1
C            
              INPUTZ(LDACTV)=20
              INPUTN(LDACTV)=28
              INPSYM(LDACTV)='  48Ca'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
          END IF
C_______________________________________________________________________
C        
          IF (ITAKNU(4).EQ.1) THEN
C            
              LDACTV=LDACTV+1
C            
              INPUTZ(LDACTV)=28
              INPUTN(LDACTV)=28
              INPSYM(LDACTV)='  56Ni'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
          END IF
C_______________________________________________________________________
C        
          IF (ITAKNU(5).EQ.1) THEN
C            
              LDACTV=LDACTV+1
C            
              INPUTZ(LDACTV)=40
              INPUTN(LDACTV)=50
              INPSYM(LDACTV)='  90Zr'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
          END IF
C_______________________________________________________________________
C        
          IF (ITAKNU(6).EQ.1) THEN
C            
              LDACTV=LDACTV+1
C            
              INPUTZ(LDACTV)=50
              INPUTN(LDACTV)=82
              INPSYM(LDACTV)=' 132Sn'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
          END IF
C_______________________________________________________________________
C        
          IF (ITAKNU(7).EQ.1) THEN
C            
              LDACTV=LDACTV+1
C            
              INPUTZ(LDACTV)=64
              INPUTN(LDACTV)=82
              INPSYM(LDACTV)=' 146Gd'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
          END IF
C_______________________________________________________________________
C        
          IF (ITAKNU(8).EQ.1) THEN
C            
              LDACTV=LDACTV+1
C            
              INPUTZ(LDACTV)=82
              INPUTN(LDACTV)=126
              INPSYM(LDACTV)=' 208Pb'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
          END IF
C_______________________________________________________________________
C
          IF (ITAKNU(9).EQ.1) THEN
C
              LDACTV=LDACTV+1
C
              INPUTZ(LDACTV)=114
              INPUTN(LDACTV)=164
              INPSYM(LDACTV)=' 278Fl'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
C
          END IF
C_______________________________________________________________________
C
          IF (ITAKNU(10).EQ.1) THEN
C
              LDACTV=LDACTV+1
C
              INPUTZ(LDACTV)=114
              INPUTN(LDACTV)=186
              INPSYM(LDACTV)=' 300Fl'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
C
          END IF
C_______________________________________________________________________
C
          IF (ITAKNU(11).EQ.1) THEN
C
              LDACTV=LDACTV+1
C
              INPUTZ(LDACTV)=114
              INPUTN(LDACTV)=220
              INPSYM(LDACTV)=' 334Fl'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
C
          END IF
C_______________________________________________________________________
C
          IF (ITAKNU(12).EQ.1) THEN
C
              LDACTV=LDACTV+1
C
              INPUTZ(LDACTV)=126
              INPUTN(LDACTV)=164
              INPSYM(LDACTV)='290Ubh'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
C
          END IF
C_______________________________________________________________________
C
          IF (ITAKNU(13).EQ.1) THEN
C
              LDACTV=LDACTV+1
C
              INPUTZ(LDACTV)=126
              INPUTN(LDACTV)=186
              INPSYM(LDACTV)='312Ubh'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
C
          END IF
C_______________________________________________________________________
C
          IF (ITAKNU(14).EQ.1) THEN
C
              LDACTV=LDACTV+1
C
              INPUTZ(LDACTV)=126
              INPUTN(LDACTV)=220
              INPSYM(LDACTV)='346Ubh'
C
              WRITE(LOGFIL,'(9X,''Actually taken: '',A6)')
     *                                      INPSYM(LDACTV)
C
          END IF
C_______________________________________________________________________
C
          IF (LDACTV.NE.NUCACT) THEN
C
              WRITE(LSCREN,'(''WARNING!: LDACTV='',I3,
     *                       '' is NOT equal to NUCACT='',/)')
     *                                   LDACTV,NUCACT
C
              STOP 'Problem in KEYWOR=ITAKENUCLS in NAMELI'
C
          END IF
C_______________________________________________________________________
C      
          IF (NUCACT.EQ.1) THEN
C
              WRITE(LSCREN,'(''Calculations with '',I3,
     *                       '' nucleus: '',(A6))')
     *                          NUCACT,INPSYM(1)
          ELSE
C
              WRITE(LSCREN,'(/,9X,''Calculations with '',I3,
     *                         '' nuclei: '',<NUCACT>(A6))')
     *                         NUCACT,(INPSYM(I),I=1,NUCACT)
          END IF
C
          IF (NUCACT.EQ.1) THEN
      
              WRITE(LOGFIL,'(9X,''Calculations with'',I3,1X,
     *                          ''nucleus: '',(A6),'' --> Z='',
     *                                        I3,''; N='',I3)')
     *                     NUCACT,INPSYM(1),INPUTZ(1),INPUTN(1)
          ELSE
C
              WRITE(LOGFIL,'(9X,''Calculations with'',I3,1X,
     *                          ''nuclei:  '',(A6),'' --> Z='',
     *                                        I3,''; N='',I3)')
     *                     NUCACT,INPSYM(1),INPUTZ(1),INPUTN(1)
              DO I=2,NUCACT
C
                 WRITE(LOGFIL,'(39X,A6,'' --> Z='',I3,''; N='',I3)')
     *                                 INPSYM(I),INPUTZ(I),INPUTN(I)
              END DO
C
          END IF
C
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'NUCLEIDATA') THEN
C          
          READ(N_READ,'(12X,<LDNUCL>(A6,1X))') (NUCSYM(I),I=1,LDNUCL)
C                                        Symbols of nuclei; 16O, etc.
          READ(N_READ,*) (NUMB_Z(I),I=1,LDNUCL)
          READ(N_READ,*) (NUMB_N(I),I=1,LDNUCL)
C_______________________________________________________________________
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''READING:'',<LDNUCL>(1X,A6))')
     *                  (NUCSYM(I),I=1,LDNUCL)
          WRITE(LOGFIL,'(17X,<LDNUCL>(1X,I6))')(NUMB_Z(I),I=1,LDNUCL)
          WRITE(LOGFIL,'(17X,<LDNUCL>(1X,I6))')(NUMB_N(I),I=1,LDNUCL)
C_______________________________________________________________________
C
          IF (LOGWRI.GE.5) THEN
C          
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(/,9X,''Our data base contains '',
     *                            ''the following'',/,9X,
     *                            ''doubly-magic spherical nuclei:'',
     *                                                            /)')
              DO I=1,LDNUCL
                 WRITE(LOGFIL,'(12X,A6,3X,I4,I4)') NUCSYM(I),NUMB_Z(I),
     *                                                       NUMB_N(I)
              END DO
C
          END IF
C          
      END IF
C
C=======================================================================
C=======================================================================
C     Pairing options and yes/no for the including of the density
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'IF-PAIRING') THEN
C
          READ (N_READ,*) IFGPAI,IFDPAI
C

          IF (IFGPAI.NE.0 .AND. IFDPAI.NE.0) THEN
C
              WRITE(LSCREN,'(''Conflicting option IFGPAI='',i1,1x,
     *                  ''and IFDPAI='',i1,'' forcing Delta-option'')')
     *                    IFGPAI,IFDPAI
              IFGPAI=0 
          END IF
C
          IF (IFGPAI.NE.0 .OR. IFDPAI.NE.0) THEN
              IF_PAI=1
          END IF          
C_______________________________________________________________________
C
          WRITE(LOGFIL,'(A)') KEYWOR
C_______________________________________________________________________
C
          IF (IFGPAI.NE.0) THEN
C
              WRITE(LSCREN,
     *            '(''Pairing from empirical G-parametrisation'')')
C
              WRITE(LOGFIL,
     *            '(9X,''Pairing from empirical G-parametrisation'')')
          END IF          
C_______________________________________________________________________
C
          IF (IFDPAI.NE.0) THEN
C
              WRITE(LSCREN,
     *       '(''Pairing from empirical-delta [mass-differences]'')')
C
              WRITE(LOGFIL,
     *       '(9X,''Pairing from empirical-delta [mass-differences]''
     *                                                            )')
          END IF


C  @@@ IRENE: WHAT DOES THIS "IF" HAVE TO LOOK FOR UNDER PAIRING? MISLEADING
C  @@@ IRENE: WHAT DOES THIS "IF" HAVE TO LOOK FOR UNDER PAIRING? MISLEADING
C  @@@ IRENE: WHAT DOES THIS "IF" HAVE TO LOOK FOR UNDER PAIRING? MISLEADING
C  @@@ IRENE: WHAT DOES THIS "IF" HAVE TO LOOK FOR UNDER PAIRING? MISLEADING
C  @@@ IRENE: WHAT DOES THIS "IF" HAVE TO LOOK FOR UNDER PAIRING? MISLEADING
C  @@@ IRENE: WHAT DOES THIS "IF" HAVE TO LOOK FOR UNDER PAIRING? MISLEADING
C  @@@ IRENE: WHAT DOES THIS "IF" HAVE TO LOOK FOR UNDER PAIRING? MISLEADING
C  @@@ IRENE: WHAT DOES THIS "IF" HAVE TO LOOK FOR UNDER PAIRING? MISLEADING
C  @@@ IRENE: WHAT DOES THIS "IF" HAVE TO LOOK FOR UNDER PAIRING? MISLEADING
C  @@@ IRENE: WHAT DOES THIS "IF" HAVE TO LOOK FOR UNDER PAIRING? MISLEADING


C_______________________________________________________________________
C
          IF (IFDENS.EQ.0) THEN
C
              WRITE(LSCREN,'(''Calculating WITHOUT density-dependent '',
     *                       ''Spin-Orbit'')')
C
              WRITE(LOGFIL,'(9X,''Calculating WITHOUT '',
     *                          ''density-dependent Spin-Orbit'')')
          ELSE
C
              WRITE(LSCREN,'(''Calculating WITH density-dependent '',
     *                       ''Spin-Orbit'')')
C
              WRITE(LOGFIL,'(9X,''Calculating WITH '',
     *                          ''density dependent Spin-Orbit'')')
C
          END IF
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Pairing BISECTION options
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'BISECTSTEP') THEN
C
          READ(N_READ,*) BISTEP
C
          IF (IFDPAI.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''1 BCS equation, BISTEP= '',F6.3)') 
     *                                            BISTEP
          ELSE
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''IFDPAI=0: '',
     *                          ''NO Delta-parameterised pairing '',
     *                          ''was activated'')')
          END IF
C
      END IF
C
C=======================================================================
C          
      IF (KEYWOR.EQ.'DELTAFACTO') THEN
C
          READ(N_READ,*) (DFACTO(I,1),I=1,LDNUCL) ! Protons
          READ(N_READ,*) (DFACTO(I,2),I=1,LDNUCL) ! Neutrons              
C
          IF (IFDPAI.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''INUCLI | PROTON:  DFACTO  '',
     *                          ''DELEXP  PRODUC'',
     *                          '' | NEUTRS:  DFACTO  DELEXP'',
     *                                            ''  PRODUC'')')
              DO INUCLI=1,LDNUCL
C                
                 IZ_FIX=NUMB_Z(INUCLI)
                 IN_FIX=NUMB_N(INUCLI)
C                 
                 DELTAP=DELEXP(IZ_FIX,IN_FIX,1)
                 DELTAN=DELEXP(IZ_FIX,IN_FIX,0)
C
                 DELT_2(INUCLI,1)=(DFACTO(INUCLI,1)*DELTAP)**2
                 DELT_2(INUCLI,2)=(DFACTO(INUCLI,2)*DELTAN)**2
C
                 WRITE(LOGFIL,'(9X,I4,14X,F6.2,2X,F6.2,2X,F6.2,11X,
     *                                       F6.2,2X,F6.2,2X,F6.2)') 
     *                              INUCLI,DFACTO(INUCLI,1),DELTAP,
     *                                     DFACTO(INUCLI,1)*DELTAP,
     *                                     DFACTO(INUCLI,2),DELTAN,
     *                                     DFACTO(INUCLI,2)*DELTAN
              END DO
C
          ELSE
C
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''IFDPAI=0: NO Delta-parameterised '',
     *                          ''pairing was activated'')')
          END IF
C
      END IF ! DELTAFACTO
C
C=======================================================================
C=======================================================================
C     Introducing (or not) the tensor interaction to the central, 
C     spin-orbit and tensor interaction as such to the hamiltonian
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'TENSOPTION') THEN
C
          READ (N_READ,*) ICENTT,ISORBT,ITENSR
CID:
C         ICENTT - add tensor to the central potential
C         ISORBT - add tensor to the spin-orbit potential
C         ITENSR - add tensor as such (to be clarified...)
CID. @@@ IRENE, LET US CLARIFY @@@
          WRITE(LOGFIL,'(A)') KEYWOR
C_______________________________________________________________________
C
          IF (ICENTT.EQ.0) THEN
C
              WRITE(LSCREN,'(''Calculation WITHOUT tensor '',
     *                       ''contribution in the central '',
     *                                        ''potential'')')
C
              WRITE(LOGFIL,'(9X,''Calculating WITHOUT tensor '',
     *                          ''contribution in the central '',
     *                                           ''potential'')')
          ELSE
C
              WRITE(LSCREN,'(''Calculating WITH tensor contribution '',
     *                       ''in the central potential'')')
C
              WRITE(LOGFIL,'(9X,''Calculating WITH tensor '',
     *                     ''contribution in the central potential'')')
C
          END IF 
C_______________________________________________________________________
C          
          IF (ISORBT.EQ.0) THEN
C
              WRITE(LSCREN,'(''Calculating WITHOUT tensor '',
     *                       ''contribution '',
     *                       ''in the spin-orbit potential'')')
C
              WRITE(LOGFIL,'(9X,''Calculating WITHOUT tensor '',
     *                 ''contribution in the spin-orbit potential'')')
C
          ELSE
C
              WRITE(LSCREN,'(''Calculating WITH tensor contribution '',
     *                       ''in the spin-orbit potential'')')
C
              WRITE(LOGFIL,'(9X,''Calculating WITH tensor '',
     *                  ''contribution in the spin-orbit potential'')')
C
          END IF
C_______________________________________________________________________
C 
          IF (ITENSR.EQ.0) THEN
C
              WRITE(LSCREN,'(''Calculating WITHOUT tensor term'')')
C
              WRITE(LOGFIL,'(9X,''Calculating WITHOUT tensor '',
     *                                                      ''term'')')
C
          ELSE
C
              WRITE(LSCREN,'(''Calculating WITH tensor term'')')
C
              WRITE(LOGFIL,'(9X,''Calculating WITH tensor term'')')
C
          END IF
C
      END IF
C
C=======================================================================
C=======================================================================
C     Parameters of the basis and the Gauss integration control
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'PARAMSBASE') THEN
C
          READ (N_READ,*) NSHELL_PROTON,NSHELL_NEUTRS,NGAUSS,HOMEG0
C
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(9X,''NSHELL_PROTON,NSHELL_NEUTRS,NGAUSS,'',
     *                                                   ''HOMEG0'')')
          WRITE(LOGFIL,'(9X,I7,7X,I7,8X,I3,3X,F6.3)')
     *                       NSHELL_PROTON,NSHELL_NEUTRS,NGAUSS,HOMEG0
C
          WRITE(LOGFIL,'(9X,''The following quantities are '',
     *                             ''calculated here ONCE FOREVER '',
     *                              ''including the reduced masses'')')
C
          WRITE(LOGFIL,'(9X,''INUCLI  IZ_FIX  IN_FIX  A_MASS  '',
     *                      ''X_MASS_PROTON  X_MASS_NEUTRS  '',
     *                      ''HOMEGA_VALUES  AOSCIL_PROTON  '',
     *                                     ''AOSCIL_NEUTRS'')')
C_______________________________________________________________________
C          
          DO I=1,LDNUCL
C           
             IZ_FIX=NUMB_Z(I)
             IN_FIX=NUMB_N(I)
C           
             A_MASS=IZ_FIX+IN_FIX
C          
             X_MASS_PROTON=XMASSP*((IZ_FIX-1)*XMASSP+IN_FIX*XMASSN)
     *                               /(IZ_FIX*XMASSP+IN_FIX*XMASSN)
C
             X_MASS_NEUTRS=XMASSN*(IZ_FIX*XMASSP+(IN_FIX-1)*XMASSN)
     *                               /(IZ_FIX*XMASSP+IN_FIX*XMASSN)
C
             HOMEGA(I)=HOMEG0/A_MASS**(1./3.)
             HOMEGA(I)=1.2000*HOMEGA(I)         
C
             AOSCIL_PROTON(I)=HBAR_C**2/HOMEGA(I)/X_MASS_PROTON
             AOSCIL_PROTON(I)=SQRT(AOSCIL_PROTON(I))
C
             AOSCIL_NEUTRS(I)=HBAR_C**2/HOMEGA(I)/X_MASS_NEUTRS
             AOSCIL_NEUTRS(I)=SQRT(AOSCIL_NEUTRS(I))
C
             XPCENT=100.0*X_MASS_PROTON/XMASSP
             XNCENT=100.0*X_MASS_NEUTRS/XMASSN  
C         
             WRITE(LOGFIL,'(9X,3(I6,2X),F6.0,2X,F7.3,F5.1,''%'',2X,
     *                                          F7.3,F5.1,''%'',
     *                                               3(F13.4,2X))')
     *                                     I,IZ_FIX,IN_FIX,A_MASS,
     *                                       X_MASS_PROTON,XPCENT,
     *                                       X_MASS_NEUTRS,XNCENT,
     *                                 HOMEGA(I),AOSCIL_PROTON(I),
     *                                           AOSCIL_NEUTRS(I)
C  
          END DO
C_______________________________________________________________________
C
          IF (NGAUSS.GT.NGSMAX) THEN
C
              WRITE(LSCREN,'(/,''NGAUSS='',I3,'' in Gauss-Laguerre '',
     *                         ''exceeds NGMAXX='',I2,/)') NGAUSS,NGSMAX
              STOP 'Stop! NGAUSS > NGSMAX in NAMELI'
C
          END IF
C_______________________________________________________________________
C
          IF (NSHELL_NEUTRS.GT.2*NGAUSS) THEN
C
              WRITE(LSCREN,'(/,''NSHELL_NEUTRS='',I2,'' exceeds '',
     *                         ''2*NGAUSS='',I3,/)')
     *                           NSHELL_NEUTRS,2*NGAUSS
              STOP 'Stop! NSHELL_NEUTRS > 2*NGAUSS in NAMELI'
C
          END IF
C
          IF (NSHELL_PROTON.GT.2*NGAUSS) THEN
C
              WRITE(LSCREN,'(/,''NSHELL_PROTON='',I2,'' exceeds '',
     *                         ''2*NGAUSS='',I3,/)')
     *                           NSHELL_PROTON,2*NGAUSS
              STOP 'Stop! NSHELL_PROTON > 2*NGAUSS in NAMELI'
C
          END IF
C_______________________________________________________________________
C
          IF (NSHELL_NEUTRS.GT.NSHMAX) THEN
C
              WRITE(LOGFIL,'(''NSHELL_NEUTRS='',I2,'' exceeds '',
     *                       ''NSHMAX='',I2)') NSHELL_NEUTRS,NSHMAX
          END IF
C
          IF (NSHELL_PROTON.GT.NSHMAX) THEN
C
              WRITE(LOGFIL,'(''NSHELL_PROTON='',I2,'' exceeds '',
     *                       ''NSHMAX='',I2)') NSHELL_PROTON,NSHMAX
          END IF
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     One of the options for the experimental input
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'EXPOPTIONS') THEN
C
          READ (N_READ,*) WHATEX
C
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(  9X,''Options for the experimental '',
     *            ''input:'',/,9X,''Among: EXTRUE, EXOROS, SHELLM, '',
     *                         ''EXPNEW you selected: '',a6)') WHATEX
C
          WRITE(LSCREN,'(/,''Options for the experimental input:'',/,
     *                     ''Among: EXTRUE, EXOROS, SHELLM, EXPNEW '',
     *                     ''you selected: '',a6)') WHATEX
C
      END IF
C
C=======================================================================
C=======================================================================
C     Options related to the print control
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'WHATPRINTS') THEN
C
          READ (N_READ,*) ENEMAX
C
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(9X,''ENEMAX'',/,9X,F6.2)') ENEMAX
C
      END IF
C
C=======================================================================
C=======================================================================
C     Options related to the SVD routine (singular values cutoff)
C=======================================================================
C=======================================================================
C
C @@@ VERIFY THE FUNCTIONING
      IF (KEYWOR.EQ.'SVDWHATCUT') THEN
C
          READ (N_READ,*) SVDCUT
C
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(9X,''Singular Value Decomposition cut '',
     *                      ''SVDCUT='',e12.5)')
     *                        SVDCUT
C
          WRITE(LSCREN,'(/,''Singular Value Decomposition cut '',
     *                     ''SVDCUT='',e12.5)')
     *                       SVDCUT
      END IF
C
C=======================================================================
C=======================================================================
C     Which conditions we want for the Spin-Orbit with density
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'IFLAMBVSOD') THEN
C
C         With these parameters we decide how we want to set the 
C         SO-density \lambda's. 
C
C         IFPAR1 - \lambda_pp
C         IFPAR2 - \lambda_pn
C         IFPAR3 - \lambda_np
C         IFPAR4 - \lambda_nn
C
C         Example: if IFPAR1=+1 and IFPAR2=IFPAR3=IFPAR4=-1, then:
C
C         \lambda_pp=\lambda_pn=\lambda_np=\lambda_nn
C
C         If IFPAR1=+1 and IFPAR4=-1 and IFPAR2=+2 and IFPAR3=-2
C
C         \lambda_pp=\lambda_nn
C         \lambda_np=\lambda_pn
C
C         If IFPAR1=IFPAR2=IFPAR3=IFPAR4=+1 the 4 \lambda parameters
C                                                    are independent
C
          READ (N_READ,*) IFPAR1,IFPAR2,IFPAR3,IFPAR4
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(  9X,''Spin-Orbit density dependent '',
     *                        ''conditions: '',
     *                        ''IFPAR1= '',I2,'' IFPAR2= '',I2,1X,
     *                        ''IFPAR3= '',I2,'' IFPAR4= '',I2)')
     *                          IFPAR1,          IFPAR2,
     *                          IFPAR3,          IFPAR4
C
      END IF
C
C=======================================================================
C=======================================================================
C     Which conditions we want for the TENSOR Spin-Orbit with density
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'IFLAMBVSOT') THEN
C  @@@ IRENE, DO WE HAVE HERE A LIBERTY OF HAVING INDEPENDENT LAMBDA ???
C         With these parameters we decide how we want to set the 
C         SO-density TENSOR \lambda's. 
C
C         IFPAR5 - \lambda_pp^{t,so}
C         IFPAR6 - \lambda_pn^{t,so}
C         IFPAR7 - \lambda_np^{t,so}
C         IFPAR8 - \lambda_nn^{t,so}
C
C         The functioning is the same as IFLAMBVSOD
C
          READ (N_READ,*) IFPAR5,IFPAR6,IFPAR7,IFPAR8
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(  9X,''Spin-Orbit tensor  dependent '',
     *                        ''conditions: '',
     *                        ''IFPAR5= '',I2,'' IFPAR6= '',I2,1X,
     *                        ''IFPAR7= '',I2,'' IFPAR8= '',I2,''??'')')
     *                          IFPAR5,          IFPAR6,
     *                          IFPAR7,          IFPAR8
C
      END IF
C
C=======================================================================
C=======================================================================
C     Which conditions we want for the TENSOR contribution to central V 
C=======================================================================
C=======================================================================
C  @@@ IRENE, DO WE HAVE HERE A LIBERTY OF HAVING INDEPENDENT LAMBDA ???
      IF (KEYWOR.EQ.'IFLAMBVCNT') THEN
C
C         With these parameters we decide how we want to set the 
C         Central TENSOR \lambda's. 
C
C         IFPA09 - \lambda_pp^{t,cnt}
C         IFPA10 - \lambda_pn^{t,cnt}
C         IFPA11 - \lambda_np^{t,cnt}
C         IFPA12 - \lambda_nn^{t,cnt}
C
C         The functioning is the same as IFLAMBVSOD
C
          READ (N_READ,*) IFPA09,IFPA10,IFPA11,IFPA12
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(  9X,''Central-V  Density dependent '',
     *                        ''conditions: '',
     *                        ''IFPA09= '',I2,'' IFPA10= '',I2,1X,
     *                        ''IFPA11= '',I2,'' IFPA12= '',I2)')
     *                          IFPA09,          IFPA10,
     *                          IFPA11,          IFPA12
C
      END IF   
C
C=======================================================================
C=======================================================================
C     Reading the unit over which we divide the \lambda's for
C     printing/plotting reasons.
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'UNITLAMBDA') THEN
C
          READ(*,*) UNITLA
C
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(9X,''Unit over which we divide the '',
     *                      ''\lambdas writing purposes only: UNITLA'',
     *                       /,71X,F6.2)') UNITLA
          DO I=1,5
             WRITE(LOGFIL,'(9X,''IS IT STILL ACTUAL?????'')')
          END DO
      END IF    
C
C=======================================================================
C=======================================================================
C     Reading if we want to use the 'kappa-parametrization' for 
C     depth, radii and diffusness
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFKAPPAPAR') THEN
          READ(*,*) IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(A)')KEYWOR
              WRITE(LOGFIL,'(9X,''IFK_VC IFK_VS IFK_RC IFK_RS '',
     *                                        ''IFK_AC IFK_AS'')')
              WRITE(LOGFIL,'(9X,6(I6,1X))')IFK_VC,IFK_VS,IFK_RC,
     *                                     IFK_RS,IFK_AC,IFK_AS
          END IF
      END IF
C 
C=======================================================================
C=======================================================================
C     Reading if we want to introduce parametric correlations
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'IFPARAMCOR') THEN
          READ(N_READ,*) IFCORR
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(A)')KEYWOR
              WRITE(LOGFIL,'(9X,''IFCORR'')')
              WRITE(LOGFIL,'(9X,I6)')IFCORR
          END IF
      END IF
C 
C=======================================================================
C=======================================================================
C     Reading the indices that activate the parametric correlations
C     that we want to eliminate
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'PARAMCORRE') THEN
          READ(N_READ,*) IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(A)')KEYWOR
              WRITE(LOGFIL,'(9X,''IFRCVC IFRCAC IFVCAC IFRSVS '',
     *                                        ''IFRSAS IFVSAS'')')
              WRITE(LOGFIL,'(9X,6(I6,1X))')IFRCVC,IFRCAC,IFVCAC,
     *                                     IFRSVS,IFRSAS,IFVSAS
          END IF
      END IF
C 
C=======================================================================
C=======================================================================
C     Central potential parameters - either values to be used in
C     the single run option or starting values, if the parameter
C     has been selected by choosing <IFFITS=1>. If random number
C     option used  ->> the initial parameter values are modified
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'CENTRALPOT') THEN
C
C         User's Central Potential Parameter Values
C
          READ (N_READ,*) V0CENT_PROTON,R0CENT_PROTON,A0CENT_PROTON,
     *                    XK_V0C_PROTON,XK_R0C_PROTON,XK_A0C_PROTON,
     *                                         R0COUL,XK_COU,COUFAC,
     *                    V0CENT_NEUTRS,R0CENT_NEUTRS,A0CENT_NEUTRS,
     *                    XK_V0C_NEUTRS,XK_R0C_NEUTRS,XK_A0C_NEUTRS
C 
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''User Defined Central Potential '',
     *                      ''Parameter Values:'',/)')
C
          WRITE(LOGFIL,'(9X,''V0CENT  R0CENT  A0CENT  XK_V0C  '',
     *                      ''XK_R0C  XK_A0C  R0COUL  XK_COU'')')
C
          WRITE(LOGFIL,'(8X,F8.4,1X,7(F6.4,2X),2X,''protons'')')
     *                                           V0CENT_PROTON,
     *                             R0CENT_PROTON,A0CENT_PROTON,
     *                             XK_V0C_PROTON,XK_R0C_PROTON,
     *                             XK_A0C_PROTON,R0COUL,XK_COU
C
          WRITE(LOGFIL,'(8X,F8.4,1X,5(F6.4,2X),18X,''neutrons'')')
     *                             V0CENT_NEUTRS,R0CENT_NEUTRS,
     *                             A0CENT_NEUTRS,XK_V0C_NEUTRS,
     *                             XK_R0C_NEUTRS,XK_A0C_NEUTRS          
      END IF          
C 
C=======================================================================
C=======================================================================
C     Spin-Orbit potential parameters
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'SPIN-ORBIT') THEN
C
C         User's Traditional WS Spin-Orbit Parameter Values
C
          READ (N_READ,*) V0SORB_PROTON,R0SORB_PROTON,A0SORB_PROTON,
     *                    XK_LAM_PROTON,XK_RSO_PROTON,XK_ASO_PROTON,
     *
     *                    V0SORB_NEUTRS,R0SORB_NEUTRS,A0SORB_NEUTRS,
     *                    XK_LAM_NEUTRS,XK_RSO_NEUTRS,XK_ASO_NEUTRS
C
          IF (IFDENS.EQ.0) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''User Defined Traditional WS '',
     *                      ''Spin-Orbit Parameter Values:'',/)')
C
              WRITE(LOGFIL,'(9X,''V0SORB  R0SORB  A0SORB  XK_LAM  '',
     *                                       ''XK_RSO  XK_ASO'')')
C
              WRITE(LOGFIL,'(8X,F8.4,1X,5(F6.4,2X),18X,''protons'')')
     *                    V0SORB_PROTON,R0SORB_PROTON,A0SORB_PROTON,
     *                    XK_LAM_PROTON,XK_RSO_PROTON,XK_ASO_PROTON
C
              WRITE(LOGFIL,'(8X,F8.4,1X,5(F6.4,2X),18X,''neutrons'')')
     *                    V0SORB_NEUTRS,R0SORB_NEUTRS,A0SORB_NEUTRS,
     *                    XK_LAM_NEUTRS,XK_RSO_NEUTRS,XK_ASO_NEUTRS
          END IF
C
      END IF
C 
C=======================================================================
C=======================================================================
C     Kappa parametrization values for Central Potential Parameters
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'KAPPA-CENT') THEN
C
          READ(N_READ,*) V0CENT_KAPPAR,XK_V0C_KAPPAR,
     *                   R0CENT_KAPPAR,XK_R0C_KAPPAR,
     *                   A0CENT_KAPPAR,XK_A0C_KAPPAR
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          IF (IFK_VC.EQ.1) WRITE(LOGFIL,'(9X,''V0CENT  XK_V0C  '',$)')
          IF (IFK_RC.EQ.1) WRITE(LOGFIL,'(''R0CENT  XK_R0C  '',$)')
          IF (IFK_AC.EQ.1) WRITE(LOGFIL,'(''A0CENT  XK_A0C  '')')
C
          IF (IFK_VC.EQ.1) WRITE(LOGFIL,'(9X,2(F6.2,2X),$)')
     *                                                   V0CENT_KAPPAR,
     *                                                   XK_V0C_KAPPAR
C
          IF (IFK_RC.EQ.1) WRITE(LOGFIL,'(2(F6.2,2X),$)')R0CENT_KAPPAR,
     *                                                   XK_R0C_KAPPAR
C
          IF (IFK_AC.EQ.1) WRITE(LOGFIL,'(2(F6.2,2X))')A0CENT_KAPPAR,
     *                                                 XK_A0C_KAPPAR
C
      END IF
C 
C=======================================================================
C=======================================================================
C     Kappa parametrization values for Pure WS Potential Parameters
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'KAPPA-SORB') THEN
C
          READ(N_READ,*) V0SORB_KAPPAR,XK_V0S_KAPPAR,
     *                   R0SORB_KAPPAR,XK_R0S_KAPPAR,
     *                   A0SORB_KAPPAR,XK_A0S_KAPPAR
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          IF (IFK_VS.EQ.1) WRITE(LOGFIL,'(9X,''V0SORB  XK_V0S  '',$)')
          IF (IFK_RS.EQ.1) WRITE(LOGFIL,'(''R0SORB  XK_R0S  '',$)')
          IF (IFK_AS.EQ.1) WRITE(LOGFIL,'(''A0SORB  XK_A0S  '')')
C
          IF (IFK_VS.EQ.1) WRITE(LOGFIL,'(9X,2(F6.2,2X),$)')
     *                                                   V0SORB_KAPPAR,
     *                                                   XK_V0S_KAPPAR
C
          IF (IFK_RS.EQ.1) WRITE(LOGFIL,'(2(F6.2,2X),$)')R0SORB_KAPPAR,
     *                                                   XK_R0S_KAPPAR
C
          IF (IFK_AS.EQ.1) WRITE(LOGFIL,'(2(F6.2,2X))')A0SORB_KAPPAR,
     *                                                 XK_A0S_KAPPAR
C
      END IF
C 
C=======================================================================
C=======================================================================
C     Optional: effective-mass term for the Dirac equation
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'EFFECTMASS') THEN
C
C         Effective Mass Parameters
C
          READ (N_READ,*) V0EFFM_PROTON,R0EFFM_PROTON,A0EFFM_PROTON,
     *                    XK_LEF_PROTON,XK_REF_PROTON,XK_AEF_PROTON,
     *                    V0EFFM_NEUTRS,R0EFFM_NEUTRS,A0EFFM_NEUTRS,
     *                    XK_LEF_NEUTRS,XK_REF_NEUTRS,XK_AEF_NEUTRS
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''User Defined Effective Mass '',
     *                      ''Parameter Values:'',/)')
C
          WRITE(LOGFIL,'(9X,''V0EFFM  R0EFFM  A0EFFM  XK_LEF  '',
     *                                       ''XK_REF  XK_AEF'')')
C
          WRITE(LOGFIL,'(8X,F8.4,1X,5(F6.4,2X),18X,''protons'')')
     *                    V0EFFM_PROTON,R0EFFM_PROTON,A0EFFM_PROTON,
     *                    XK_LEF_PROTON,XK_REF_PROTON,XK_AEF_PROTON
C
          WRITE(LOGFIL,'(8X,F8.4,1X,5(F6.4,2X),18X,''neutrons'')')
     *                    V0EFFM_NEUTRS,R0EFFM_NEUTRS,A0EFFM_NEUTRS,
     *                    XK_LEF_NEUTRS,XK_REF_NEUTRS,XK_AEF_NEUTRS
C
      END IF        
C 
C=======================================================================
C=======================================================================
C     Optional: spin-orbit with density
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'DENSTSORBI') THEN
C
C         Density Spin-Orbit Potential Parameters
C
          READ (N_READ,*) ALAMPP,ALAMPN,ALAMNP,ALAMNN   
C
          IF (IFDENS.EQ.1) THEN
              WRITE(LOGFIL,'(A)')KEYWOR
              WRITE(LOGFIL,'(9X,''User Defined Density Spin-Orbit '',
     *                      ''Potential Parameter Values:'',/)')
              WRITE(LOGFIL,'(9X,''ALAMPP  ALAMPN  ALAMNP  ALAMNN'')')
              WRITE(LOGFIL,'(9X,4(F6.2,2X))')
     *                    ALAMPP,ALAMPN,ALAMNP,ALAMNN
          END IF
C
      END IF    
C 
C=======================================================================
C=======================================================================
C     Optional: spin-orbit with TENSOR density
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'TENSOSORBI') THEN
C
C         Density Spin-Orbit TENSOR Potential Parameters
C
          READ (N_READ,*) TLAMPP,TLAMPN,TLAMNP,TLAMNN 
C
          IF (ISORBT.EQ.1) THEN
              WRITE(LOGFIL,'(A)')KEYWOR
              WRITE(LOGFIL,'(9X,''User Defined Density Spin-Orbit '',
     *                      ''TENSOR Potential Parameter Values:'',/)')
              WRITE(LOGFIL,'(9X,''TLAMPP  TLAMPN  TLAMNP  TLAMNN'')')
              WRITE(LOGFIL,'(9X,4(F6.2,2X))')
     *                    TLAMPP,TLAMPN,TLAMNP,TLAMNN
          END IF
C
      END IF 
C 
C=======================================================================
C=======================================================================
C     Optional: spin-orbit with TENSOR density
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'TENSOCENTR') THEN
C
C         Central TENSOR Potential Parameters
C
          READ (N_READ,*) CLAMPP,CLAMPN,CLAMNP,CLAMNN
C
          IF (ICENTT.EQ.1) THEN
              WRITE(LOGFIL,'(A)')KEYWOR
              WRITE(LOGFIL,'(9X,''User Defined Central TENSOR '',
     *                      ''Potential Parameter Values:'',/)')
              WRITE(LOGFIL,'(9X,''CLAMPP  CLAMPN  CLAMNP  CLAMNN'')')
              WRITE(LOGFIL,'(9X,4(F6.2,2X))')
     *                    CLAMPP,CLAMPN,CLAMNP,CLAMNN
          END IF
      END IF 
C 
C=======================================================================
C=======================================================================
C     Reading the shift applied to V_0_central (only applied for ONERUN)
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'SHIFTCENTR') THEN
C
          READ(N_READ,*) (V0SHIF_PROTON(I),I=1,LDNUCL)
          READ(N_READ,*) (V0SHIF_NEUTRS(I),I=1,LDNUCL)
C
          IF (IFTEST.EQ.1 .AND. LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(A)')KEYWOR
              WRITE(LOGFIL,'(9X,''SHIFOx  SHIFC0  SHIFC8  SHIFNi  '',
     *                          ''SHIFZr  SHIFSn  SHIFGd  SHIFPb'')')
              WRITE(LOGFIL,'(9X,<LDNUCL>(F6.2,2X),/,
     *                       9X,<LDNUCL>(F6.2,2X))')
     *                      (V0SHIF_PROTON(I),I=1,LDNUCL),
     *                      (V0SHIF_NEUTRS(I),I=1,LDNUCL)
          END IF
C
      END IF
C      
C=======================================================================
C      < Reading the control parameters for the minimisation >
C=======================================================================
C
C      Defining the Dirac parameters valid for the whole run:
C
C      IRMFST (I - Relativistic Mean Field - Strict)  controls 
C              the equality  between spin-orbit parameters and 
C              effective mass parameters. According to the RMF, 
C              both sets should be equal.  This relation is to 
C              forced when IRMFST=1. In such a case, we cannot
C              vary the effective mass parameters  (see NAMELI, 
C              where  independent  minimisation variables  are 
C                                                      defined
C
C      I_RAND - It should be equal to 1 if minimisation should
C               start from randomly chosen initial values
C
C      LDRAND - The number  of restarts  of the  random-number
C               generating routine and thus also the number of
C               independent minimisation - check LDRAND
C
C      I_SEED - First we initialise the "seed" by calling 
C
C                        RANDIN(I_SEED), 
C             
C               where I_SEED can be set to any value.
C 
C      Next generate your random numbers (uniformly distributed 
C      within 0 and 1) by calling ZUFALL(N,A);  N is the actual 
C      number of the random numbers needed  and A is the vector 
C      that contains them
C
C=======================================================================
C 
      IF (KEYWOR.EQ.'WHICHMINIM') THEN
C
          READ (*,*) IRMFST,I_RAND,LDRAND,I_SEED,NEWSED,IMTALK,IRUNMI
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''IRMFST  I_RAND  LDRAND  '',
     *                      ''I_SEED  NEWSED  IMTALK  IRUNMI'')')
C
          WRITE(LOGFIL,'(9X,7(I6,2X))') IRMFST,I_RAND,LDRAND,I_SEED,
     *                                         NEWSED,IMTALK,IRUNMI
          IF (LDRAND.GT.NDRAND) THEN
              WRITE(NOUTPT,'(''LDRAND='',I6,'' exceeds NDRAND='',I6)')
     *                         LDRAND,                 NDRAND
              STOP 'LDRAND > NDRAND in NAMELI'
          END IF
      END IF
C
C=======================================================================
C=======================================================================
C     Reading ITECHI - the maximum no. of chi^2 evaluations 
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'MINIMEVALS') THEN
C
          READ (N_READ,*) ITECHI ! Maximum number of chi^2 evaluations
C
          IF (IFFITS.EQ.1 .OR. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''Maximum number of chi^2 evaluations'',
     *                          '' ITECHI= '',I5)') ITECHI
          END IF
C
      END IF
C
C=======================================================================
C     ... and also the tolerance factors
C
      IF (KEYWOR.EQ.'TOLERANCES') THEN
C
          READ (*,*) DWFACT,UPFACT,PUSHIN
C
          IF (IFFITS.EQ.1 .OR. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''chi^2 Tolerances: '',
     *                  ''DWFACT  UPFACT  PUSHIN'',/,28X,3(f6.4,2x))') 
     *                    DWFACT, UPFACT, PUSHIN
          END IF
      END IF
C
C=======================================================================
C     ... and the conditions for stoping the minimisation (for LEVMAR)
C
      IF (KEYWOR.EQ.'STOPTOLERS') THEN
C  @@@ IRENE: WHAT IS FACTOR ???
          READ(*,*) TOLERF,TOLERX,TOLERG,FACTOR
C
          IF (IFFITS.EQ.1 .OR. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''TOLERF  TOLERX  TOLERG  FACTOR'')')
C
              WRITE(LOGFIL,'(9X,3(ES6.0,2X),F6.2)') TOLERF,TOLERX,
     *                                              TOLERG,FACTOR
          END IF
C
      END IF
C
C=======================================================================
C     ... and the conditions for stoping the minimisation (for LEVMAR)
C 
      IF (KEYWOR.EQ.'STOPINCOND') THEN
C
C         If the gradient condition does not impo
C         LDLAST - We continue iterating at most LDSAT times verifying
C                  whether 
C
          READ(*,*) LDLAST,EPSLAS
C
          IF (IFFITS.EQ.1 .OR. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''Stopping conditions for LEVMAR: '',
     *                      ''LDLAST  EPSLAS'',/,41X,I6,2X,ES6.0)')
     *                        LDLAST, EPSLAS
          END IF
C
          IF (LDLAST.GT.NDLAST) THEN
C
              WRITE(LOGFIL,'(/,''Alarm in NAMELI: LDLAST= '',I3,
     *                  '' is .GT. NDLAST= '',I3,/)') LDLAST,NDLAST

              WRITE(0,'(/,''Alarm in NAMELI: LDLAST= '',I3,
     *                  '' is .GT. NDLAST= '',I3,/)') LDLAST,NDLAST
C
              STOP 'STOP in NAMELI: LDLAST.GT.NDLAST'
C
          END IF
C
      END IF
C
C=======================================================================
C=======================================================================
C     Reading the weight-factors to define the minimised function
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'MINWEIGHTS') THEN
C  @@@ IRENE; EVEN IF ONE CAN GUESS THE MEANING OF MOST OF THE WEIGHTS,
C      PLEASE INTRODUCE THE DEFINITIONS (IN A FEW WORDS) OF ALL OF THEM 
          READ (*,*) WEICOR,WEIRAD,WEIINV,WEIFER,WEIGAP,WEIWEI,
     *               WEIDIF,WEIABS,WEIMAX,WEIDUP,WEIDDW,WEIRHO
C
C ###     Renaming the WEIGHTS
C       
          WEIGHT_CORREL=WEICOR
          WEIGHT_RADIUS=WEIRAD
          WEIGHT_INVERT=WEIINV
          WEIGHT_EFERMI=WEIFER
          WEIGHT_ENEGAP=WEIGAP
C
C ###     WEIWEI rests with the same name
C
          WEIGHT_ERRABS=WEIDIF
          WEIGHT_EABSAV=WEIABS
          WEIGHT_ERRMAX=WEIMAX
          WEIGHT_DENSUP=WEIDUP
          WEIGHT_DENSDW=WEIDDW   
          WEIGHT_RHODEN=WEIRHO   
C
          WRITE(LOGFIL,'(A)')KEYWOR
C
          WRITE(LOGFIL,'(9X,''WEICOR  WEIRAD  WEIINV  WEIFER  '',
     *                      ''WEIGAP  WEIWEI  WEIDIF  WEIABS  '',
     *                      ''WEIMAX  WEIDUP  WEIDDW  WEIRHO'')')
C
          WRITE(LOGFIL,'(9X,12(F6.2,2X))') WEICOR,WEIRAD,WEIINV,
     *                                     WEIFER,WEIGAP,WEIWEI,
     *                WEIDIF,WEIABS,WEIMAX,WEIDUP,WEIDDW,WEIRHO
     
      END IF
C
C=======================================================================
C=======================================================================
C     Reading the choice parameter that will define 'chi^2'
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'CHOICEOFHI') THEN
C  @@@ IRENE: PLEAS PUT THE COMMENTS ABOUT ALL POSSIBLE CHOICES
C      AND TEHIR MEANING
          READ (*,*) CHIDEF
C
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(9X,''CHIDEF= '',A)') CHIDEF
C
      END IF
C
C=======================================================================
C=======================================================================
C     Reading the weight factors for energies and radii for each nucleus
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'CHIWEI_PRO') THEN
                                           LDNUCL_AUXILI=8
          READ (*,*) (WEINUC_PROTON(I),I=1,LDNUCL_AUXILI)
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''WEI_Ox  WEI_Ca  WEI_Ca  WEI_Ni  '',
     *                      ''WEI_Zr  WEI_Sn  WEI_Gd  WEI_Pb'')')
C
          WRITE(LOGFIL,'(9X,<LDNUCL_AUXILI>(F6.2,2X))')
     *                              (WEINUC_PROTON(I),I=1,LDNUCL_AUXILI)
C          
      END IF
C
C=======================================================================
C    
      IF (KEYWOR.EQ.'CHIWEI_NEU') THEN
                                           LDNUCL_AUXILI=8
          READ (*,*) (WEINUC_NEUTRS(I),I=1,LDNUCL_AUXILI)
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''WEI_Ox  WEI_Ca  WEI_Ca  WEI_Ni  '',
     *                      ''WEI_Zr  WEI_Sn  WEI_Gd  WEI_Pb'')')
C
          WRITE(LOGFIL,'(9X,<LDNUCL_AUXILI>(F6.2,2X))')
     *                              (WEINUC_NEUTRS(I),I=1,LDNUCL_AUXILI)
C          
      END IF
C
C=======================================================================
C      
      IF (KEYWOR.EQ.'RADWEI_PRO') THEN
                                           LDNUCL_AUXILI=8
          READ (*,*) (WEIRAD_PROTON(I),I=1,LDNUCL_AUXILI)
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''WEI_Ox  WEI_Ca  WEI_Ca  WEI_Ni  '',
     *                      ''WEI_Zr  WEI_Sn  WEI_Gd  WEI_Pb'')')
C
          WRITE(LOGFIL,'(9X,<LDNUCL_AUXILI>(F6.2,2X))')
     *                              (WEIRAD_PROTON(I),I=1,LDNUCL_AUXILI)
C          
      END IF
C
C=======================================================================
C   
      IF (KEYWOR.EQ.'RADWEI_NEU') THEN
                                           LDNUCL_AUXILI=8
          READ (*,*) (WEIRAD_NEUTRS(I),I=1,LDNUCL_AUXILI)
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''WEI_Ox  WEI_Ca  WEI_Ca  WEI_Ni  '',
     *                      ''WEI_Zr  WEI_Sn  WEI_Gd  WEI_Pb'')')

          WRITE(LOGFIL,'(9X,<LDNUCL_AUXILI>(F6.2,2X))')
     *                              (WEIRAD_NEUTRS(I),I=1,LDNUCL_AUXILI)
C          
      END IF
C 
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'RMSVAL_PRO') THEN
                                          LDNUCL_AUXILI=8
          READ(*,*) (RMSVAL_REFPRO(I),I=1,LDNUCL_AUXILI)
C 
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''Pro_Ox  Pro_Ca  Pro_Ca  Pro_Ni  '',
     *                      ''Pro_Zr  Pro_Sn  Pro_Gd  Pro_Pb'')')

          WRITE(LOGFIL,'(9X,<LDNUCL_AUXILI>(F6.2,2X))')
     *                              (RMSVAL_REFPRO(I),I=1,LDNUCL_AUXILI)
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'RMSVAL_NEU') THEN
                                          LDNUCL_AUXILI=8
          READ(*,*) (RMSVAL_REFNEU(I),I=1,LDNUCL_AUXILI)
C 
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''Neu_Ox  Neu_Ca  Neu_Ca  Neu_Ni  '',
     *                      ''Neu_Zr  Neu_Sn  Neu_Gd  Neu_Pb'')')

          WRITE(LOGFIL,'(9X,<LDNUCL_AUXILI>(F6.2,2X))')
     *                              (RMSVAL_REFNEU(I),I=1,LDNUCL_AUXILI)
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'RMSGLO_REF') THEN
C
          READ(*,*) RMSGLO_REFPRO,RMSGLO_REFNEU
C 
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''RMSPRO  RMSNEU'')')

          WRITE(LOGFIL,'(9X,<LDNUCL>(F6.2,2X))')RMSGLO_REFPRO, 
     *                                          RMSGLO_REFNEU
      END IF
C 
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'RMSIND_PRO') THEN
                                          LDNUCL_AUXILI=8
          READ(*,*) (RMSIND_PROTON(I),I=1,LDNUCL_AUXILI)
C 
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''Pro_Ox  Pro_Ca  Pro_Ca  Pro_Ni  '',
     *                      ''Pro_Zr  Pro_Sn  Pro_Gd  Pro_Pb'')')

          WRITE(LOGFIL,'(9X,<LDNUCL_AUXILI>(F6.2,2X))')
     *                              (RMSIND_PROTON(I),I=1,LDNUCL_AUXILI)
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'RMSIND_NEU') THEN
                                          LDNUCL_AUXILI=8
          READ(*,*) (RMSIND_NEUTRS(I),I=1,LDNUCL_AUXILI)
C 
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''Neu_Ox  Neu_Ca  Neu_Ca  Neu_Ni  '',
     *                      ''Neu_Zr  Neu_Sn  Neu_Gd  Neu_Pb'')')

          WRITE(LOGFIL,'(9X,<LDNUCL_AUXILI>(F6.2,2X))')
     *                              (RMSIND_PROTON(I),I=1,LDNUCL_AUXILI)
      END IF
C 
C=======================================================================
C=======================================================================
C     Central  potential  parameters - ranges  for minimisation
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'CENTLIMITS') THEN
C
          READ (N_READ,*) V0CMIN,V0CMAX,A0CMIN,A0CMAX,R0CMIN,R0CMAX,
     *                                                CouMIN,CouMAX
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''V0CMIN  V0CMAX  '',
     *                      ''A0CMIN  A0CMAX  '',
     *                      ''R0CMIN  R0CMAX'',/,
     *                   9X,  F6.2,2X,F6.2,2X,
     *                        F6.4,2X,F6.4,2X,
     *                        F6.4,2X,F6.4,2X)')
     *
     *                        V0CMIN,V0CMAX,A0CMIN,A0CMAX,R0CMIN,R0CMAX
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     Spin-orbit potential parameters - ranges for minimisation
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'SORBLIMITS') THEN
C
          READ (N_READ,*) XL_MIN,XL_MAX,A0SMIN,A0SMAX,R0SMIN,R0SMAX
C
          IF (IFDENS.EQ.0) THEN
C
             WRITE(LOGFIL,'(A)') KEYWOR
C
             WRITE(LOGFIL,'(9X,''XL_MIN  XL_MAX  '',
     *                         ''A0SMIN  A0SMAX  '',
     *                         ''R0SMIN  R0SMAX'',/,9X,
     *                           F6.2,2X,F6.2,2X,
     *                           F6.4,2X,F6.4,2X,
     *                           F6.4,2X,F6.4,2X)')
     *
     *                    XL_MIN,XL_MAX,A0SMIN,A0SMAX,R0SMIN,R0SMAX
          END IF
C
      END IF         
C 
C=======================================================================
C=======================================================================
C     Effective-mass   term  parameters - ranges for minimisation
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'EFFMLIMITS') THEN
C
          READ (N_READ,*) XEFMIN,XEFMAX,AEFMIN,AEFMAX,REFMIN,REFMAX
C
          WRITE(LOGFIL,'(A)')KEYWOR
C               
          WRITE(LOGFIL,'(9X,''XEFMIN  XEFMAX  '',
     *                      ''AEFMIN  AEFMAX  '',
     *                      ''REFMIN  REFMAX'',/,9X,
     *                        F6.2,2X,F6.2,2X,
     *                        F6.4,2X,F6.4,2X,
     *                        F6.4,2X,F6.4,2X)')
     *
     *                        XEFMIN,XEFMAX,AEFMIN,AEFMAX,REFMIN,REFMAX
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     Density dependent S-O pot. parameters - ranges for minimisation
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'DENSLIMITS') THEN
C
          READ (N_READ,*) XPPMIN,XPPMAX,XPNMIN,XPNMAX,
     *                    XNPMIN,XNPMAX,XNNMIN,XNNMAX
C
          IF (IFDENS.EQ.1) THEN
C
             WRITE(LOGFIL,'(A)') KEYWOR
C               
             WRITE(LOGFIL,'(9X,''XPPMIN  XPPMAX  '',
     *                         ''XPNMIN  XPNMAX'',/,9X,
     *                           F6.1,2X,F6.1,2X,
     *                           F6.1,2X,F6.1,2X,//,9X,
     *                         ''XNPMIN  XNPMAX  '',
     *                         ''XNNMIN  XNNMAX'',/,9X,
     *                           F6.1,2X,F6.1,2X,
     *                           F6.1,2X,F6.1,2X)')
     *
     *                           XPPMIN,XPPMAX,XPNMIN,XPNMAX,
     *                           XNPMIN,XNPMAX,XNNMIN,XNNMAX
          END IF
C
      END IF
C 
C=======================================================================
C=======================================================================
C     Tensor parameters - ranges for minimisation
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'TENSLIMITS') THEN
C
          READ (N_READ,*) YPPMIN,YPPMAX,YPNMIN,YPNMAX,
     *                    YNPMIN,YNPMAX,YNNMIN,YNNMAX
C
          IF (ISORBT.EQ.1 .AND. IFTENS.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)')KEYWOR
C               
              WRITE(LOGFIL,'(9X,''YPPMIN  YPPMAX  '',
     *                          ''YPNMIN  YPNMAX'',/,9X,
     *                            F6.1,2X,F6.1,2X,
     *                            F6.1,2X,F6.1,2X,//,9X,
     *                          ''YNPMIN  YNPMAX  '',
     *                          ''YNNMIN  YNNMAX'',/,9X,
     *                            F6.1,2X,F6.1,2X,
     *                            F6.1,2X,F6.1,2X)')
     *
     *                            YPPMIN,YPPMAX,YPNMIN,YPNMAX,
     *                            YNPMIN,YNPMAX,YNNMIN,YNNMAX  
          END IF    
      END IF          
C 
C=======================================================================
C=======================================================================
C     Tensor parameters - ranges for minimisation
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'TNCNLIMITS') THEN
C
          READ (N_READ,*) CPPMIN,CPPMAX,CPNMIN,CPNMAX,
     *                    CNPMIN,CNPMAX,CNNMIN,CNNMAX
C
          IF (ICENTT.EQ.1 .AND. IFTENS.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''CPPMIN  CPPMAX  '',
     *                          ''CPNMIN  CPNMAX'',/,9X,
     *                            F6.1,2X,F6.1,2X,
     *                            F6.1,2X,F6.1,2X,//,9X,
     *                          ''CNPMIN  CNPMAX  '',
     *                          ''CNNMIN  CNNMAX'',/,9X,
     *                            F6.1,2X,F6.1,2X,
     *                            F6.1,2X,F6.1,2X)')
     *
     *                            CPPMIN,CPPMAX,CPNMIN,CPNMAX,
     *                            CNPMIN,CNPMAX,CNNMIN,CNNMAX
          END IF    
C
      END IF  
C 
C=======================================================================
C=======================================================================
C     Choice of the argument increments for the derivatives
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'DERPARSTPS') THEN
C
          READ (N_READ,*) DL_V0C,DL_A0C,DL_R0C,DL_XLA,DL_A0S,DL_R0S,
     *                                         DL_XRM,DL_ARM,DL_RRM,
     *                                                       DL_COU,
     *                                  DL_XPP,DL_XPN,DL_XNP,DL_XNN,
     *                                  DL_YPP,DL_YPN,DL_YNP,DL_YNN,
     *                                  DL_CPP,DL_CPN,DL_CNP,DL_CNN
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''DL_V0C  DL_A0C  DL_R0C'')')
          WRITE(LOGFIL,'(9X,3(F6.4,2X),/)')DL_V0C,DL_A0C,DL_R0C
C
          IF (IFDENS.EQ.0) THEN
              WRITE(LOGFIL,'(9X,''DL_XLA  DL_A0S  DL_R0S'')')
              WRITE(LOGFIL,'(9X,3(F6.4,2X),/)')DL_XLA,DL_A0S,DL_R0S
          END IF
C
          WRITE(LOGFIL,'(9X,''DL_XRM  DL_ARM  DL_RRM  DL_COU'')')
          WRITE(LOGFIL,'(9X,4(F6.4,2X),/)')DL_XRM,DL_ARM,DL_RRM,DL_COU
C
          IF (IFDENS.EQ.1) THEN
C
              WRITE(LOGFIL,'(9X,''DL_XPP  DL_XPN  DL_XNP  DL_XNN'')')
              WRITE(LOGFIL,'(9X,4(F6.4,2X))')
     *                                    DL_XPP,DL_XPN,DL_XNP,DL_XNN
C
              IF (ISORBT.EQ.1 .AND. IFTENS.EQ.1) THEN
C
                  WRITE(LOGFIL,'(9X,''DL_YPP  DL_YPN  DL_YNP  '',
     *                                              ''DL_YNN'')')
                  WRITE(LOGFIL,'(9X,4(F6.4,2X))')
     *                                   DL_YPP,DL_YPN,DL_YNP,DL_YNN
              END IF
C
              IF (ICENTT.EQ.1 .AND. IFTENS.EQ.1) THEN
C
                  WRITE(LOGFIL,'(9X,''DL_CPP  DL_CPN  DL_CNP  '',
     *                                              ''DL_CNN'')')
                  WRITE(LOGFIL,'(9X,4(F6.4,2X))')
     *                                  DL_CPP,DL_CPN,DL_CNP,DL_CNN
              END IF
C
          END IF   
C_______________________________________________________________________
C
          WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *                ''#  V0CMIN  V0CMAX  DL_V0C    '',
     *                ''A0CMIN  A0CMAX  DL_A0C    '',
     *                ''R0CMIN  R0CMAX  DL_R0C  #'',/,
     *                ''#  '',F6.2,2X,F6.2,2X,F6.4,1X,
     *                ''   '',F6.4,2X,F6.4,2X,F6.4,1X,
     *                ''   '',F6.4,2X,F6.4,2X,F6.4,''  #'')')
     *
     *                V0CMIN,V0CMAX,DL_V0C,A0CMIN,A0CMAX,DL_A0C,
     *                                     R0CMIN,R0CMAX,DL_R0C
C_______________________________________________________________________
C
          WRITE(NOUTPT,'(  ''#'',T80,''#'',/,
     *                ''#  XL_MIN  XL_MAX  DL_XLA    '',
     *                ''A0SMIN  A0SMAX  DL_A0S    '',
     *                ''R0SMIN  R0SMAX  DL_R0S  #'',/,
     *                ''#  '',F6.2,2X,F6.2,2X,F6.4,1X,
     *                ''   '',F6.4,2X,F6.4,2X,F6.4,1X,
     *                ''   '',F6.4,2X,F6.4,2X,F6.4,''  #'')')
     *
     *                XL_MIN,XL_MAX,DL_XLA,A0SMIN,A0SMAX,DL_A0S,
     *                R0SMIN,R0SMAX,DL_R0S
C_______________________________________________________________________
C
          WRITE(NOUTPT,'(  ''#'',T80,''#'',/,
     *                ''#  XEFMIN  XEFMAX  DL_XRM    '',
     *                ''AEFMIN  AEFMAX  DL_ARM    '',
     *                ''REFMIN  REFMAX  DL_RRM  #'',/,
     *                ''#  '',F6.2,2X,F6.2,2X,F6.4,1X,
     *                ''   '',F6.4,2X,F6.4,2X,F6.4,1X,
     *                ''   '',F6.4,2X,F6.4,2X,F6.4,''  #'',/,
     *                ''#'',T80,''#'')')
     *
     *                XEFMIN,XEFMAX,DL_XRM,AEFMIN,AEFMAX,DL_ARM,
     *                REFMIN,REFMAX,DL_RRM
C_______________________________________________________________________
C
          IF (IFDENS.EQ.1) THEN
C
              WRITE(NOUTPT,'(  ''#'',T80,''#'',/,
     *                ''#  XPPMIN  XPPMAX  DL_XPP    '',
     *                ''XPNMIN  XPNMAX  DL_XPN'',T80,''#'',/,
     *                ''#  '',F6.1,2X,F6.2,2X,F6.4,1X,
     *                ''   '',F6.1,2X,F6.2,2X,F6.4,1X,
     *                T80,''#'',/,''#'',T80,''#'',/,
     *                ''#  XNPMIN  XNPMAX  DL_XNP    '',
     *                ''XNNMIN  XNNMAX  DL_XNN'',T80,''#'',
     *                /,
     *                ''#  '',F6.1,2X,F6.2,2X,F6.4,1X,
     *                ''   '',F6.1,2X,F6.2,2X,F6.4,1X,
     *                T80,''#'',/,
     *                ''#'',T80,''#'',/,80(''#''))')
     *
     *                XPPMIN,XPPMAX,DL_XPP,XPNMIN,XPNMAX,DL_XPN,
     *                XNPMIN,XNPMAX,DL_XNP,XNNMIN,XNNMAX,DL_XNN  
C_______________________________________________________________________
C
              WRITE(NOUTPT,'(  ''#'',T80,''#'',/,
     *                ''#  YPPMIN  YPPMAX  DL_YPP    '',
     *                ''YPNMIN  YPNMAX  DL_YPN'',T80,''#'',/,
     *                ''#  '',F6.1,2X,F6.2,2X,F6.4,1X,
     *                ''   '',F6.1,2X,F6.2,2X,F6.4,1X,
     *                T80,''#'',/,''#'',T80,''#'',/,
     *                ''#  YNPMIN  YNPMAX  DL_YNP    '',
     *                ''YNNMIN  YNNMAX  DL_YNN'',T80,''#'',
     *                /,
     *                ''#  '',F6.1,2X,F6.2,2X,F6.4,1X,
     *                ''   '',F6.1,2X,F6.2,2X,F6.4,1X,
     *                T80,''#'',/,
     *                ''#'',T80,''#'',/,80(''#''))')
     *
     *                YPPMIN,YPPMAX,DL_YPP,YPNMIN,YPNMAX,DL_YPN,
     *                YNPMIN,YNPMAX,DL_YNP,YNNMIN,YNNMAX,DL_YNN 
C_______________________________________________________________________
C
              WRITE(NOUTPT,'(  ''#'',T80,''#'',/,
     *                ''#  CPPMIN  CPPMAX  DL_CPP    '',
     *                ''CPNMIN  CPNMAX  DL_CPN'',T80,''#'',/,
     *                ''#  '',F6.1,2X,F6.1,2X,F6.4,1X,
     *                ''   '',F6.1,2X,F6.1,2X,F6.4,1X,
     *                T80,''#'',/,''#'',T80,''#'',/,
     *                ''#  CNPMIN  CNPMAX  DL_CNP    '',
     *                ''CNNMIN  CNNMAX  DL_CNN'',T80,''#'',
     *                /,
     *                ''#  '',F6.1,2X,F6.1,2X,F6.4,1X,
     *                ''   '',F6.1,2X,F6.1,2X,F6.4,1X,
     *                T80,''#'',/,
     *                ''#'',T80,''#'',/,80(''#''))')
     *
     *                CPPMIN,CPPMAX,DL_CPP,CPNMIN,CPNMAX,DL_CPN,
     *                CNPMIN,CNPMAX,DL_CNP,CNNMIN,CNNMAX,DL_CNN  
C
          END IF
C  
      END IF        
C 
C=======================================================================
C=======================================================================
C     Central potential KAPPA parameters - ranges for minimisation
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'CENTKAPPAS') THEN
C
          READ (N_READ,*) XKCMIN,XKCMAX,XACMIN,XACMAX,XRCMIN,XRCMAX,
     *                                                XCoMIN,XCoMAX
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''XKCMIN  XKCMAX  '',
     *                      ''XACMIN  XACMAX  '',
     *                      ''XRCMIN  XRCMAX  '',
     *                      ''XCoMIN  XCoMAX'',/,
     *                        9X,F6.2,2X,F6.2,2X,
     *                           F6.3,2X,F6.4,2X,
     *                           F6.3,2X,F6.4,2X,
     *                           F6.3,2X,F6.4)')
     *
     *                        XKCMIN,XKCMAX,XACMIN,XACMAX,XRCMIN,XRCMAX,
     *                                                    XCoMIN,XCoMAX
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     Spin-orbit potential KAPPA parameters - ranges for minimisation
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'SORBKAPPAS') THEN
C
          READ (N_READ,*) XKSMIN,XKSMAX,XASMIN,XASMAX,XRSMIN,XRSMAX
C
          IF (IFDENS.EQ.0) THEN

              WRITE(LOGFIL,'(A)') KEYWOR

              WRITE(LOGFIL,'(9X,''XKSMIN  XKSMAX  '',
     *                          ''XASMIN  XASMAX  '',
     *                          ''XRSMIN  XRSMAX  '',/,
     *                            9X,F6.2,2X,F6.2,2X,
     *                               F6.3,2X,F6.4,2X,
     *                               F6.3,2X,F6.4,2X)')
     *
     *                      XKSMIN,XKSMAX,XASMIN,XASMAX,XRSMIN,XRSMAX
          END IF    
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     Reduced-mass term KAPPA parameters - ranges for minimisation
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'EFFMKAPPAS') THEN
C
          READ (N_READ,*) XKEMIN,XKEMAX,XAEMIN,XAEMAX,XREMIN,XREMAX
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''XKEMIN  XKEMAX  '',
     *                      ''XAEMIN  XAEMAX  '',
     *                      ''XREMIN  XREMAX  '',/,
     *                        9X,F6.2,2X,F6.2,2X,
     *                           F6.3,2X,F6.4,2X,
     *                           F6.3,2X,F6.4,2X)')
     *
     *                        XKEMIN,XKEMAX,XAEMIN,XAEMAX,XREMIN,XREMAX
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     Choice of the argument increments (KAPPA-old) for the derivatives
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'DERKAPSTPS') THEN
C
          READ (N_READ,*) DLKV0C,DLKA0C,DLKR0C,DLKXLA,DLKA0S,DLKR0S,
     *                                         DLKXRM,DLKARM,DLKRRM,
     *                                                       DLKCOU
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''DLKV0C  DLKA0C  DLKR0C  DLKXLA  '',
     *                      ''DLKA0S  DLKR0S  DLKXRM  DLKARM  '',
     *                      ''DLKRRM  DLKCOU'')')
C
          WRITE(LOGFIL,'(9X,10(F6.4,2X))') DLKV0C,DLKA0C,DLKR0C,DLKXLA,
     *                                     DLKA0S,DLKR0S,DLKXRM,DLKARM,
     *                                                   DLKRRM,DLKCOU
C_______________________________________________________________________
C
          WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *                   ''#  XKCMIN  XKCMAX  DLKV0C    '',
     *                   ''XACMIN  XACMAX  DLKA0C    '',
     *                   ''XRCMIN  XRCMAX  DLKR0C  #'',/,
     *                   ''#  '',F6.2,2X,F6.2,2X,F6.4,1X,
     *                   ''   '',F6.3,2X,F6.4,2X,F6.4,1X,
     *                   ''   '',F6.3,2X,F6.4,2X,F6.4,''  #'')')
     *
     *                   XKCMIN,XKCMAX,DLKV0C,XACMIN,XACMAX,DLKA0C,
     *                                        XRCMIN,XRCMAX,DLKR0C
C_______________________________________________________________________
C
          WRITE(NOUTPT,'(''#'',T80,''#'',/,
     *                ''#  XKSMIN  XKSMAX  DLKXLA    '',
     *                ''XASMIN  XASMAX  DLKA0S    '',
     *                ''XRSMIN  XRSMAX  DLKR0S  #'',/,
     *                ''#  '',F6.2,2X,F6.2,2X,F6.4,1X,
     *                ''   '',F6.3,2X,F6.4,2X,F6.4,1X,
     *                ''   '',F6.3,2X,F6.4,2X,F6.4,''  #'')')
     *
     *                XKSMIN,XKSMAX,DLKXLA,XASMIN,XASMAX,DLKA0S,
     *                                     XRSMIN,XRSMAX,DLKR0S
C_______________________________________________________________________
C 
          WRITE(NOUTPT,'(  ''#'',T80,''#'',/,
     *                ''#  XKEMIN  XKEMAX  DLKXRM    '',
     *                ''XAEMIN  XAEMAX  DLKARM    '',
     *                ''XREMIN  XREMAX  DLKRRM  #'',/,
     *                ''#  '',F6.2,2X,F6.2,2X,F6.4,1X,
     *                ''   '',F6.3,2X,F6.4,2X,F6.4,1X,
     *                ''   '',F6.3,2X,F6.4,2X,F6.4,''  #'',/,
     *                ''#'',T80,''#'',/,
     *                ''#'',T56,''XCoMIN  XCoMAX  DLKCOU  #'',/,
     *                ''#'',T56,F6.3,2X,F6.4,2X,F6.4,''  #'',/,
     *                ''#'',T80,''#'',/,80(''#''),/)')
     *
     *                XKEMIN,XKEMAX,DLKXRM,XAEMIN,XAEMAX,DLKARM,
     *                                     XREMIN,XREMAX,DLKRRM,
     *                                     XCoMIN,XCoMAX,DLKCOU
C
      END IF           
C 
C=======================================================================
C=======================================================================
C     Choice of the argument limits and increments (KAPPA-new) 
C     random starts and for the derivatives, respectively
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'KAPA-C-LIM') THEN
          READ(*,*) V0CMIN_KAPPAR,V0CMAX_KAPPAR,XKCMIN_KAPPAR,
     *              XKCMAX_KAPPAR,A0CMIN_KAPPAR,A0CMAX_KAPPAR,
     *              XACMIN_KAPPAR,XACMAX_KAPPAR,R0CMIN_KAPPAR,
     *              R0CMAX_KAPPAR,XRCMIN_KAPPAR,XRCMAX_KAPPAR
          WRITE(LOGFIL,'(A)')KEYWOR
          WRITE(LOGFIL,'(9X,''V0CMIN  V0CMAX  XKCMIN  XKCMAX  '',
     *                      ''A0CMIN  A0CMAX  XACMIN  XACMAX  '',
     *                      ''R0CMIN  R0CMAX  XRCMIN  XRCMAX'')')
          WRITE(LOGFIL,'(9X,12(F6.2,2X))')
     *              V0CMIN_KAPPAR,V0CMAX_KAPPAR,XKCMIN_KAPPAR,
     *              XKCMAX_KAPPAR,A0CMIN_KAPPAR,A0CMAX_KAPPAR,
     *              XACMIN_KAPPAR,XACMAX_KAPPAR,R0CMIN_KAPPAR,
     *              R0CMAX_KAPPAR,XRCMIN_KAPPAR,XRCMAX_KAPPAR
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'KAPASO-LIM') THEN
          READ(*,*) XL_MIN_KAPPAR,XL_MAX_KAPPAR,XKSMIN_KAPPAR,
     *              XKSMAX_KAPPAR,A0SMIN_KAPPAR,A0SMAX_KAPPAR,
     *              XASMIN_KAPPAR,XASMAX_KAPPAR,R0SMIN_KAPPAR,
     *              R0SMAX_KAPPAR,XRSMIN_KAPPAR,XRSMAX_KAPPAR

          WRITE(LOGFIL,'(A)')KEYWOR
          WRITE(LOGFIL,'(9X,''XL_MIN  XL_MAX  XKSMIN  XKSMAX  '',
     *                      ''A0SMIN  A0SMAX  XASMIN  XASMAX  '',
     *                      ''R0SMIN  R0SMAX  XRSMIN  XRSMAX'')')
          WRITE(LOGFIL,'(9X,12(F6.2,2X))')
     *              XL_MIN_KAPPAR,XL_MAX_KAPPAR,XKSMIN_KAPPAR,
     *              XKSMAX_KAPPAR,A0SMIN_KAPPAR,A0SMAX_KAPPAR,
     *              XASMIN_KAPPAR,XASMAX_KAPPAR,R0SMIN_KAPPAR,
     *              R0SMAX_KAPPAR,XRSMIN_KAPPAR,XRSMAX_KAPPAR
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'STEPSKAPPA') THEN
          READ(*,*) DL_V0C_KAPPAR,DLKV0C_KAPPAR,DL_A0C_KAPPAR,
     *              DLKA0C_KAPPAR,DL_R0C_KAPPAR,DLKR0C_KAPPAR,
     *              DL_VSO_KAPPAR,DLKXLA_KAPPAR,DL_A0S_KAPPAR,
     *              DLKA0S_KAPPAR,DL_R0S_KAPPAR,DLKR0S_KAPPAR

          WRITE(LOGFIL,'(A)')KEYWOR
          WRITE(LOGFIL,'(9X,''DL_V0C  DLKV0C  DL_A0C  DLKA0C  '',
     *                      ''DL_R0C  DLKR0C  DL_VSO  DLKXLA  '',
     *                      ''DL_A0S  DLKA0S  DL_R0S  DLKR0S'')')
          WRITE(LOGFIL,'(9X,14(F6.4,2X))')
     *              DL_V0C_KAPPAR,DLKV0C_KAPPAR,DL_A0C_KAPPAR,
     *              DLKA0C_KAPPAR,DL_R0C_KAPPAR,DLKR0C_KAPPAR,
     *              DL_VSO_KAPPAR,DLKXLA_KAPPAR,DL_A0S_KAPPAR,
     *              DLKA0S_KAPPAR,DL_R0S_KAPPAR,DLKR0S_KAPPAR
      END IF
C
C=======================================================================
C     Defining the starting parameter values for the chi^2
C     minimisation as well as parameter selection
C=======================================================================
C=======================================================================
C     Protons
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFTAKEPARP') THEN
C
          READ (*,*) IF_V0C_PROTON,IF_A0C_PROTON,IF_R0C_PROTON,
     *               IF_XLA_PROTON,IF_A0S_PROTON,IF_R0S_PROTON,
     *               IF_XRM_PROTON,IF_ARM_PROTON,IF_RRM_PROTON,
     *                                                  IF_COU
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''IF_V0C  IF_A0C  IF_R0C  IF_XLA  '',
     *                      ''IF_A0S  IF_R0S  IF_XRM  IF_ARM  '',
     *                      ''IF_RRM  IF_COU'')')
C
          WRITE(LOGFIL,'(9X,10(I6,2X))')
     *                   IF_V0C_PROTON,IF_A0C_PROTON,IF_R0C_PROTON,
     *                   IF_XLA_PROTON,IF_A0S_PROTON,IF_R0S_PROTON,
     *                   IF_XRM_PROTON,IF_ARM_PROTON,IF_RRM_PROTON,
     *                                                      IF_COU
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         1 -> central potential depth (p)
C         2 -> central potential radius (p)
C         3 -> central potential diffuseness (p)
C
C         4 -> spin-orbit strength (p)
C         5 -> spin-orbit potential radius (p)
C         6 -> spin-orbit potential diffuseness (p)
C
C         7 -> effective mass strength (p)
C         8 -> effective mass radius (p) 
C         9 -> effective mass diffuseness (p) 
C
C         10-> Coulomb radius parameter 
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C 
C         Default starting values of parameters 
C 
          VMISTR(1)=V0CENT_PROTON
          VMISTR(2)=R0CENT_PROTON
          VMISTR(3)=A0CENT_PROTON
C
          VMISTR(4)=V0SORB_PROTON
          VMISTR(5)=R0SORB_PROTON
          VMISTR(6)=A0SORB_PROTON
C
          VMISTR(7)=V0EFFM_PROTON
          VMISTR(8)=R0EFFM_PROTON
          VMISTR(9)=A0EFFM_PROTON
C
          VMISTR(10)=R0COUL
C
          V0COLD=V0CENT_PROTON
          R0COLD=R0CENT_PROTON
          A0COLD=A0CENT_PROTON
C
          V0SOLD=V0SORB_PROTON
          R0SOLD=R0SORB_PROTON
          A0SOLD=A0SORB_PROTON
C      
          V0EOLD=V0EFFM_PROTON
          R0EOLD=R0EFFM_PROTON
          A0EOLD=A0EFFM_PROTON
C      
          C0COLD=R0COUL
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          VMIMIN(1)=V0CMIN
          VMIMIN(2)=R0CMIN
          VMIMIN(3)=A0CMIN
C          
          VMIMIN(4)=XL_MIN
          VMIMIN(5)=R0SMIN
          VMIMIN(6)=A0SMIN
C
          VMIMIN(7)=XEFMIN
          VMIMIN(8)=REFMIN
          VMIMIN(9)=AEFMIN
C_______________________________________________________________________
C
          VMIMIN(10)=CouMIN
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          VMIMAX(1)=V0CMAX
          VMIMAX(2)=R0CMAX
          VMIMAX(3)=A0CMAX
C
          VMIMAX(4)=XL_MAX
          VMIMAX(5)=R0SMAX
          VMIMAX(6)=A0SMAX
C
          VMIMAX(7)=XEFMAX
          VMIMAX(8)=REFMAX
          VMIMAX(9)=AEFMAX
C_______________________________________________________________________
C
          VMIMAX(10)=CouMAX
C_______________________________________________________________________
C
C         Step values (for calculating the derivatives)
C
          VMISTP(1)=DL_V0C
          VMISTP(2)=DL_R0C
          VMISTP(3)=DL_A0C
C
          VMISTP(4)=DL_XLA
          VMISTP(5)=DL_R0S
          VMISTP(6)=DL_A0S
C
          VMISTP(7)=DL_XRM
          VMISTP(8)=DL_RRM
          VMISTP(9)=DL_ARM
C_______________________________________________________________________
C
          VMISTP(10)=DL_COU
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          IFTAKE(1)=IF_V0C_PROTON
          IFTAKE(2)=IF_R0C_PROTON
          IFTAKE(3)=IF_A0C_PROTON
C          
          IFTAKE(4)=IF_XLA_PROTON
          IFTAKE(5)=IF_R0S_PROTON
          IFTAKE(6)=IF_A0S_PROTON
C          
          IFTAKE(7)=IF_XRM_PROTON
          IFTAKE(8)=IF_RRM_PROTON
          IFTAKE(9)=IF_ARM_PROTON
C_______________________________________________________________________
C          
          IFTAKE(10)=IF_COU
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFTAKEKAPP') THEN
C
          READ (*,*) IFKV0C_PROTON,IFKA0C_PROTON,IFKR0C_PROTON,
     *	             IFKXLA_PROTON,IFKA0S_PROTON,IFKR0S_PROTON,
     *               IFKXRM_PROTON,IFKARM_PROTON,IFKRRM_PROTON,
     *                                                  IFKCOU
C
          WRITE(LOGFIL,'(A)') KEYWOR

          WRITE(LOGFIL,'(9X,''IFKV0C  IFKA0C  IFKR0C  IFKXLA  '',
     *                      ''IFKA0S  IFKR0S  IFKXRM  IFKARM  '',
     *                      ''IFKRRM  IFKCOU'')')
C
          WRITE(LOGFIL,'(9X,10(I6,2X))')
     *                   IFKV0C_PROTON,IFKA0C_PROTON,IFKR0C_PROTON,
     *	                 IFKXLA_PROTON,IFKA0S_PROTON,IFKR0S_PROTON,
     *                   IFKXRM_PROTON,IFKARM_PROTON,IFKRRM_PROTON,
     *                                                      IFKCOU
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         11-> central potential depth (p)
C         12-> central potential radius (p)
C         13-> central potential diffuseness (p)
C
C         14-> spin-orbit strength (p)
C         15-> spin-orbit potential radius (p)
C         16-> spin-orbit potential diffuseness (p)
C
C         17-> effective mass strength (p)
C         18-> effective mass radius (p) 
C         19-> effective mass diffuseness (p) 
C
C         20-> Coulomb radius parameter 
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C 
C         Default starting values of parameters 
C 
          VMISTR(11)=XK_V0C_PROTON
          VMISTR(12)=XK_R0C_PROTON
          VMISTR(13)=XK_A0C_PROTON
C
          VMISTR(14)=XK_LAM_PROTON
          VMISTR(15)=XK_RSO_PROTON
          VMISTR(16)=XK_ASO_PROTON
C
          VMISTR(17)=XK_LEF_PROTON
          VMISTR(18)=XK_REF_PROTON
          VMISTR(19)=XK_AEF_PROTON
C
          VMISTR(20)=XK_COU
C      
          OK_V0C=XK_V0C_PROTON
          OK_R0C=XK_R0C_PROTON
          OK_A0C=XK_A0C_PROTON
C      
          OK_LAM=XK_LAM_PROTON
          OK_RSO=XK_RSO_PROTON
          OK_ASO=XK_ASO_PROTON
C      
          OK_LEF=XK_LEF_PROTON
          OK_REF=XK_REF_PROTON
          OK_AEF=XK_AEF_PROTON
C      
          OK_COU=XK_COU
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          VMIMIN(11)=XKCMIN
          VMIMIN(12)=XRCMIN
          VMIMIN(13)=XACMIN
C          
          VMIMIN(14)=XKSMIN
          VMIMIN(15)=XRSMIN
          VMIMIN(16)=XASMIN
C
          VMIMIN(17)=XKEMIN
          VMIMIN(18)=XREMIN
          VMIMIN(19)=XAEMIN
C_______________________________________________________________________
C
          VMIMIN(20)=XCoMIN
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          VMIMAX(11)=XKCMAX
          VMIMAX(12)=XRCMAX
          VMIMAX(13)=XACMAX
C
          VMIMAX(14)=XKSMAX
          VMIMAX(15)=XRSMAX
          VMIMAX(16)=XASMAX
C
          VMIMAX(17)=XKEMAX
          VMIMAX(18)=XREMAX
          VMIMAX(19)=XAEMAX
C_______________________________________________________________________
C
          VMIMAX(20)=XCoMAX
C_______________________________________________________________________
C
C         Step values (for calculating the derivatives - KAPPA)
C
          VMISTP(11)=DLKV0C
          VMISTP(12)=DLKR0C
          VMISTP(13)=DLKA0C
C
          VMISTP(14)=DLKXLA
          VMISTP(15)=DLKR0S
          VMISTP(16)=DLKA0S
C
          VMISTP(17)=DLKXRM
          VMISTP(18)=DLKRRM
          VMISTP(19)=DLKARM
C_______________________________________________________________________
C
          VMISTP(20)=DLKCOU
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this KAPPA 
C 
          IFTAKE(11)=IFKV0C_PROTON
          IFTAKE(12)=IFKR0C_PROTON
          IFTAKE(13)=IFKA0C_PROTON
C          
          IFTAKE(14)=IFKXLA_PROTON
          IFTAKE(15)=IFKR0S_PROTON
          IFTAKE(16)=IFKA0S_PROTON
C          
          IFTAKE(17)=IFKXRM_PROTON
          IFTAKE(18)=IFKRRM_PROTON
          IFTAKE(19)=IFKARM_PROTON
C_______________________________________________________________________
C          
          IFTAKE(20)=IFKCOU
C_______________________________________________________________________
C
          DO I=1,NDPARS
             DPARAM(I)=VMISTP(I)
          END DO
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Neutrons
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'IFTAKEPARN') THEN
C
          READ (*,*) IF_V0C_NEUTRS,IF_A0C_NEUTRS,IF_R0C_NEUTRS,
     *               IF_XLA_NEUTRS,IF_A0S_NEUTRS,IF_R0S_NEUTRS,
     *               IF_XRM_NEUTRS,IF_ARM_NEUTRS,IF_RRM_NEUTRS
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''IF_V0C  IF_A0C  IF_R0C  IF_XLA  '',
     *                      ''IF_A0S  IF_R0S  IF_XRM  IF_ARM  '',
     *                      ''IF_RRM '')')
C
          WRITE(LOGFIL,'(9X,9(I6,2X))')
     *                   IF_V0C_NEUTRS,IF_A0C_NEUTRS,IF_R0C_NEUTRS,
     *                   IF_XLA_NEUTRS,IF_A0S_NEUTRS,IF_R0S_NEUTRS,
     *                   IF_XRM_NEUTRS,IF_ARM_NEUTRS,IF_RRM_NEUTRS
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         21 -> central potential depth (n)
C         22 -> central potential radius (n)
C         23 -> central potential diffuseness (n)
C
C         24 -> spin-orbit strength (n)
C         25 -> spin-orbit potential radius (n)
C         26 -> spin-orbit potential diffuseness (n)
C
C         27 -> effective mass strength (n)
C         28 -> effective mass radius (n) 
C         29 -> effective mass diffuseness (n) 
C_______________________________________________________________________
C 
C         Below, the we use  the followng coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C 
C         Default starting values of parameters 
C 
          VMISTR(21)=V0CENT_NEUTRS
          VMISTR(22)=R0CENT_NEUTRS
          VMISTR(23)=A0CENT_NEUTRS
C
          VMISTR(24)=V0SORB_NEUTRS
          VMISTR(25)=R0SORB_NEUTRS
          VMISTR(26)=A0SORB_NEUTRS
C
          VMISTR(27)=V0EFFM_NEUTRS
          VMISTR(28)=R0EFFM_NEUTRS
          VMISTR(29)=A0EFFM_NEUTRS
C
          V0COLD=V0CENT_PROTON
          R0COLD=R0CENT_PROTON
          A0COLD=A0CENT_PROTON
C
          V0SOLD=V0SORB_PROTON
          R0SOLD=R0SORB_PROTON
          A0SOLD=A0SORB_PROTON
C      
          V0EOLD=V0EFFM_PROTON
          R0EOLD=R0EFFM_PROTON
          A0EOLD=A0EFFM_PROTON
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          VMIMIN(21)=V0CMIN
          VMIMIN(22)=R0CMIN
          VMIMIN(23)=A0CMIN
C          
          VMIMIN(24)=XL_MIN
          VMIMIN(25)=R0SMIN
          VMIMIN(26)=A0SMIN
C
          VMIMIN(27)=XEFMIN
          VMIMIN(28)=REFMIN
          VMIMIN(29)=AEFMIN
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          VMIMAX(21)=V0CMAX
          VMIMAX(22)=R0CMAX
          VMIMAX(23)=A0CMAX
C
          VMIMAX(24)=XL_MAX
          VMIMAX(25)=R0SMAX
          VMIMAX(26)=A0SMAX
C
          VMIMAX(27)=XEFMAX
          VMIMAX(28)=REFMAX
          VMIMAX(29)=AEFMAX
C_______________________________________________________________________
C
C         Step values (for calculating the derivatives)
C
          VMISTP(21)=DL_V0C
          VMISTP(22)=DL_R0C
          VMISTP(23)=DL_A0C
C
          VMISTP(24)=DL_XLA
          VMISTP(25)=DL_R0S
          VMISTP(26)=DL_A0S
C
          VMISTP(27)=DL_XRM
          VMISTP(28)=DL_RRM
          VMISTP(29)=DL_ARM
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          IFTAKE(21)=IF_V0C_NEUTRS
          IFTAKE(22)=IF_R0C_NEUTRS
          IFTAKE(23)=IF_A0C_NEUTRS
C          
          IFTAKE(24)=IF_XLA_NEUTRS
          IFTAKE(25)=IF_R0S_NEUTRS
          IFTAKE(26)=IF_A0S_NEUTRS
C          
          IFTAKE(27)=IF_XRM_NEUTRS
          IFTAKE(28)=IF_RRM_NEUTRS
          IFTAKE(29)=IF_ARM_NEUTRS
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFTAKEKAPN') THEN
C
          READ (*,*) IFKV0C_NEUTRS,IFKA0C_NEUTRS,IFKR0C_NEUTRS,
     *	             IFKXLA_NEUTRS,IFKA0S_NEUTRS,IFKR0S_NEUTRS,
     *               IFKXRM_NEUTRS,IFKARM_NEUTRS,IFKRRM_NEUTRS
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''IFKV0C  IFKA0C  IFKR0C  IFKXLA  '',
     *                      ''IFKA0S  IFKR0S  IFKXRM  IFKARM  '',
     *                      ''IFKRRM  '')')
C
          WRITE(LOGFIL,'(9X,9(I6,2X))')
     *                   IFKV0C_NEUTRS,IFKA0C_NEUTRS,IFKR0C_NEUTRS,
     *	                 IFKXLA_NEUTRS,IFKA0S_NEUTRS,IFKR0S_NEUTRS,
     *                   IFKXRM_NEUTRS,IFKARM_NEUTRS,IFKRRM_NEUTRS
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         30-> central potential depth (p)
C         31-> central potential radius (p)
C         32-> central potential diffuseness (p)
C
C         33-> spin-orbit strength (p)
C         34-> spin-orbit potential radius (p)
C         35-> spin-orbit potential diffuseness (p)
C
C         36-> effective mass strength (p)
C         37-> effective mass radius (p) 
C         38-> effective mass diffuseness (p) 
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C 
C         Default starting values of parameters 
C 
          VMISTR(30)=XK_V0C_PROTON
          VMISTR(31)=XK_R0C_PROTON
          VMISTR(32)=XK_A0C_PROTON
C
          VMISTR(33)=XK_LAM_PROTON
          VMISTR(34)=XK_RSO_PROTON
          VMISTR(35)=XK_ASO_PROTON
C
          VMISTR(36)=XK_LEF_PROTON
          VMISTR(37)=XK_REF_PROTON
          VMISTR(37)=XK_AEF_PROTON
C      
          OK_V0C=XK_V0C_PROTON
          OK_R0C=XK_R0C_PROTON
          OK_A0C=XK_A0C_PROTON
C      
          OK_LAM=XK_LAM_PROTON
          OK_RSO=XK_RSO_PROTON
          OK_ASO=XK_ASO_PROTON
C      
          OK_LEF=XK_LEF_PROTON
          OK_REF=XK_REF_PROTON
          OK_AEF=XK_AEF_PROTON
C      
          OK_COU=XK_COU
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          VMIMIN(30)=XKCMIN
          VMIMIN(31)=XRCMIN
          VMIMIN(32)=XACMIN
C          
          VMIMIN(33)=XKSMIN
          VMIMIN(34)=XRSMIN
          VMIMIN(35)=XASMIN
C
          VMIMIN(36)=XKEMIN
          VMIMIN(37)=XREMIN
          VMIMIN(38)=XAEMIN
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          VMIMAX(30)=XKCMAX
          VMIMAX(31)=XRCMAX
          VMIMAX(32)=XACMAX
C
          VMIMAX(33)=XKSMAX
          VMIMAX(34)=XRSMAX
          VMIMAX(35)=XASMAX
C
          VMIMAX(36)=XKEMAX
          VMIMAX(37)=XREMAX
          VMIMAX(38)=XAEMAX
C_______________________________________________________________________
C
C         Step values (for calculating the derivatives - KAPPA)
C
          VMISTP(30)=DLKV0C
          VMISTP(31)=DLKR0C
          VMISTP(32)=DLKA0C
C
          VMISTP(33)=DLKXLA
          VMISTP(34)=DLKR0S
          VMISTP(35)=DLKA0S
C
          VMISTP(36)=DLKXRM
          VMISTP(37)=DLKRRM
          VMISTP(38)=DLKARM
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this KAPPA 
C 
          IFTAKE(30)=IFKV0C_NEUTRS
          IFTAKE(31)=IFKR0C_NEUTRS
          IFTAKE(32)=IFKA0C_NEUTRS
C          
          IFTAKE(33)=IFKXLA_NEUTRS
          IFTAKE(34)=IFKR0S_NEUTRS
          IFTAKE(35)=IFKA0S_NEUTRS
C          
          IFTAKE(36)=IFKXRM_NEUTRS
          IFTAKE(37)=IFKRRM_NEUTRS
          IFTAKE(38)=IFKARM_NEUTRS
C_______________________________________________________________________
C
          DO I=1,NDPARS
             DPARAM(I)=VMISTP(I)
          END DO
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Density-dependent spin-orbit Hamiltonian
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFTAKEDENS') THEN
C
          READ (*,*) IF_XPP,IF_XPN,IF_XNP,IF_XNN
C
          IF (IFDENS.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)')KEYWOR
C
              WRITE(LOGFIL,'(9X,''IF_XPP  IF_XPN  IF_XNP  IF_XNN'')')
              WRITE(LOGFIL,'(9X,4(I6,2X))')IF_XPP,IF_XPN,IF_XNP,IF_XNN
C
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         39 -> lambda  proton-proton
C         40 -> lambda  proton-neutron
C         41 -> lambda neutron-proton
C         42 -> lambda neutron-neutron
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C 
C         Default starting values of parameters 
C 
          VMISTR(39)=ALAMPP
          VMISTR(40)=ALAMPN
          VMISTR(41)=ALAMNP
          VMISTR(42)=ALAMNN
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          VMIMIN(39)=XPPMIN
          VMIMIN(40)=XPNMIN
          VMIMIN(41)=XNPMIN
          VMIMIN(42)=XNNMIN
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          VMIMAX(39)=XPPMAX
          VMIMAX(40)=XPNMAX
          VMIMAX(41)=XNPMAX
          VMIMAX(42)=XNNMAX
C_______________________________________________________________________
C
C         Step values (for calculating the derivatives)
C
          VMISTP(39)=DL_XPP
          VMISTP(40)=DL_XPN
          VMISTP(41)=DL_XNP
          VMISTP(42)=DL_XNN
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          IFTAKE(39)=IF_XPP
          IFTAKE(40)=IF_XPN
          IFTAKE(41)=IF_XNP
          IFTAKE(42)=IF_XNN
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Tensor part for SO-Potential
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFTAKETENS') THEN
C
          READ (*,*) IF_YPP,IF_YPN,IF_YNP,IF_YNN
C
          IF (IFTENS.EQ.1 .AND. ISORBT.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''IF_YPP  IF_YPN  IF_YNP  IF_YNN'')')
              WRITE(LOGFIL,'(9X,4(I6,2X))')IF_YPP,IF_YPN,IF_YNP,IF_YNN
C
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         43 -> tensor lambda  proton-proton
C         44 -> tensor lambda  proton-neutron
C         45 -> tensor lambda neutron-proton
C         46 -> tensor lambda neutron-neutron
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C 
C         Default starting values of parameters 
C 
          VMISTR(43)=TLAMPP
          VMISTR(44)=TLAMPN
          VMISTR(45)=TLAMNP
          VMISTR(46)=TLAMNN
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          VMIMIN(43)=YPPMIN
          VMIMIN(44)=YPNMIN
          VMIMIN(45)=YNPMIN
          VMIMIN(46)=YNNMIN
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          VMIMAX(43)=YPPMAX
          VMIMAX(44)=YPNMAX
          VMIMAX(45)=YNPMAX
          VMIMAX(46)=YNNMAX
C_______________________________________________________________________
C
C         Step values (for calculating the derivatives)
C
          VMISTP(43)=DL_YPP
          VMISTP(44)=DL_YPN
          VMISTP(45)=DL_YNP
          VMISTP(46)=DL_YNN
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          IFTAKE(43)=IF_YPP
          IFTAKE(44)=IF_YPN
          IFTAKE(45)=IF_YNP
          IFTAKE(46)=IF_YNN
C_______________________________________________________________________
C
          DO I=1,NDPARS
             DPARAM(I)=VMISTP(I)
          END DO
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Tensor part for Central-Potential
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFTAKECNTN') THEN
C
          READ (*,*) IF_CPP,IF_CPN,IF_CNP,IF_CNN
C
          IF (IFTENS.EQ.1 .AND. ICENTT.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''IF_CPP  IF_CPN  IF_CNP  IF_CNN'')')
              WRITE(LOGFIL,'(9X,4(I6,2X))')IF_CPP,IF_CPN,IF_CNP,IF_CNN
C
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         47 -> central tensor lambda  proton-proton
C         48 -> central tensor lambda  proton-neutron
C         49 -> central tensor lambda neutron-proton
C         50 -> central tensor lambda neutron-neutron
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C 
C         Default starting values of parameters 
C 
          VMISTR(47)=CLAMPP
          VMISTR(48)=CLAMPN
          VMISTR(49)=CLAMNP
          VMISTR(50)=CLAMNN
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          VMIMIN(47)=CPPMIN
          VMIMIN(48)=CPNMIN
          VMIMIN(49)=CNPMIN
          VMIMIN(50)=CNNMIN
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          VMIMAX(47)=CPPMAX
          VMIMAX(48)=CPNMAX
          VMIMAX(49)=CNPMAX
          VMIMAX(50)=CNNMAX
C_______________________________________________________________________
C
C         Step values (for calculating the derivatives)
C
          VMISTP(47)=DL_CPP
          VMISTP(48)=DL_CPN
          VMISTP(49)=DL_CNP
          VMISTP(50)=DL_CNN
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          IFTAKE(47)=IF_CPP
          IFTAKE(48)=IF_CPN
          IFTAKE(49)=IF_CNP
          IFTAKE(50)=IF_CNN
C_______________________________________________________________________
C
          DO I=1,NDPARS
             DPARAM(I)=VMISTP(I)
          END DO
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Kappa parametrization: Central Potential
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'IFTAKEKAPC') THEN
C
          READ(*,*) IFTV0C,IFTKVC,IFTR0C,IFTKRC,IFTA0C,IFTKAC
C
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(9X,''IFTV0C  IFTKVC  IFTR0C  IFTKRC  '',
     *                      ''IFTA0C  IFTKAC'')')
          WRITE(LOGFIL,'(9X,6(I6,2X))')IFTV0C,IFTKVC,IFTR0C,
     *                                 IFTKRC,IFTA0C,IFTKAC
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         51 -> V_0
C         52 -> kappa for V_0
C         53 -> r_0
C         54 -> kappa for r_0
C         55 -> a_0
C         56 -> kappa for a_0
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C 
C         Default starting values of parameters 
C 
          VMISTR(51)=V0CENT_KAPPAR
          VMISTR(52)=XK_V0C_KAPPAR
          VMISTR(53)=R0CENT_KAPPAR
          VMISTR(54)=XK_R0C_KAPPAR
          VMISTR(55)=A0CENT_KAPPAR
          VMISTR(56)=XK_A0C_KAPPAR
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          VMIMIN(51)=V0CMIN_KAPPAR
          VMIMIN(52)=XKCMIN_KAPPAR
          VMIMIN(53)=R0CMIN_KAPPAR
          VMIMIN(54)=XRCMIN_KAPPAR
          VMIMIN(55)=A0CMIN_KAPPAR
          VMIMIN(56)=XACMIN_KAPPAR
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          VMIMAX(51)=V0CMAX_KAPPAR
          VMIMAX(52)=XKCMAX_KAPPAR
          VMIMAX(53)=R0CMAX_KAPPAR
          VMIMAX(54)=XRCMAX_KAPPAR
          VMIMAX(55)=A0CMAX_KAPPAR
          VMIMAX(56)=XACMAX_KAPPAR
C_______________________________________________________________________
C
C         Step values (for calculating the derivatives)
C
          VMISTP(51)=DL_V0C_KAPPAR
          VMISTP(52)=DLKV0C_KAPPAR
          VMISTP(53)=DL_R0C_KAPPAR
          VMISTP(54)=DLKR0C_KAPPAR
          VMISTP(55)=DL_A0C_KAPPAR
          VMISTP(56)=DLKA0C_KAPPAR
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          IFTAKE(51)=IFTV0C
          IFTAKE(52)=IFTKVC
          IFTAKE(53)=IFTR0C
          IFTAKE(54)=IFTKRC
          IFTAKE(55)=IFTA0C
          IFTAKE(56)=IFTKAC
C_______________________________________________________________________
C
          DO I=1,NDPARS
             DPARAM(I)=VMISTP(I)
          END DO
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Kappa parametrization: Pure SO WS Potential
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'IFTAKEKAPS') THEN
C
          READ(*,*) IFTV0S,IFTKVS,IFTR0S,IFTKRS,IFTA0S,IFTKAS
C
          WRITE(LOGFIL,'(A)') KEYWOR
          WRITE(LOGFIL,'(9X,''IFTV0S  IFTKVS  IFTR0S  IFTKRS  '',
     *                      ''IFTA0S  IFTKAS'')')
          WRITE(LOGFIL,'(9X,6(I6,2X))')IFTV0S,IFTKVS,IFTR0S,
     *                                 IFTKRS,IFTA0S,IFTKAS
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         57 -> lambda_0
C         58 -> kappa for lambda_0
C         59 -> r_0
C         60 -> kappa for r_0
C         61 -> a_0
C         62 -> kappa for a_0
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C 
C         Default starting values of parameters 
C 
          VMISTR(57)=V0SORB_KAPPAR
          VMISTR(58)=XK_V0S_KAPPAR
          VMISTR(59)=R0SORB_KAPPAR
          VMISTR(60)=XK_R0S_KAPPAR
          VMISTR(61)=A0SORB_KAPPAR
          VMISTR(62)=XK_A0S_KAPPAR
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          VMIMIN(57)=XL_MIN_KAPPAR
          VMIMIN(58)=XKSMIN_KAPPAR
          VMIMIN(59)=R0SMIN_KAPPAR
          VMIMIN(60)=XRSMIN_KAPPAR
          VMIMIN(61)=A0SMIN_KAPPAR
          VMIMIN(62)=XASMIN_KAPPAR
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          VMIMAX(57)=XL_MAX_KAPPAR
          VMIMAX(58)=XKSMAX_KAPPAR
          VMIMAX(59)=R0SMAX_KAPPAR
          VMIMAX(60)=XRSMAX_KAPPAR
          VMIMAX(61)=A0SMAX_KAPPAR
          VMIMAX(62)=XASMAX_KAPPAR
C_______________________________________________________________________
C
C         Step values (for calculating the derivatives)
C
          VMISTP(57)=DL_VSO_KAPPAR
          VMISTP(58)=DLKXLA_KAPPAR
          VMISTP(59)=DL_R0S_KAPPAR
          VMISTP(60)=DLKR0S_KAPPAR
          VMISTP(61)=DL_A0S_KAPPAR
          VMISTP(62)=DLKA0S_KAPPAR
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          IFTAKE(57)=IFTV0S
          IFTAKE(58)=IFTKVS
          IFTAKE(59)=IFTR0S
          IFTAKE(60)=IFTKRS
          IFTAKE(61)=IFTA0S
          IFTAKE(62)=IFTKAS
C_______________________________________________________________________
C
          DO I=1,NDPARS
             DPARAM(I)=VMISTP(I)
          END DO
C_______________________________________________________________________
C
      END IF
C 
C=======================================================================
C=======================================================================
C     Central potential parameters  - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'CENTMESHLM') THEN
C
          READ (N_READ,*) V0CMIN_IFMESH,V0CMAX_IFMESH,NOPV0C,
     *                    A0CMIN_IFMESH,A0CMAX_IFMESH,NOPA0C,
     *                    R0CMIN_IFMESH,R0CMAX_IFMESH,NOPR0C,
     *                    CouMIN_IFMESH,CouMAX_IFMESH,NOPCou
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''V0CMIN  V0CMAX  NOPV0C  '',
     *                          ''A0CMIN  A0CMAX  NOPA0C  '',
     *                          ''R0CMIN  R0CMAX  NOPR0C  '',
     *                          ''CouMIN  CouMAX  NPOCou'',/,9X,
     *                            F6.1,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                            V0CMIN_IFMESH,V0CMAX_IFMESH,NOPV0C,
     *                            A0CMIN_IFMESH,A0CMAX_IFMESH,NOPA0C,
     *                            R0CMIN_IFMESH,R0CMAX_IFMESH,NOPR0C,
     *                            CouMIN_IFMESH,CouMAX_IFMESH,NOPCou
          END IF
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     Spin-orbit potential parameter  ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'SORBMESHLM') THEN
C
          READ (N_READ,*) XL_MIN_IFMESH,XL_MAX_IFMESH,NOP_XL,
     *                    A0SMIN_IFMESH,A0SMAX_IFMESH,NOPA0S,
     *                    R0SMIN_IFMESH,R0SMAX_IFMESH,NOPR0S
C
          IF (IFDENS.EQ.0 .AND. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''XL_MIN  XL_MAX  NOP_XL  '',
     *                          ''A0SMIN  A0SMAX  NOPA0S  '',
     *                          ''R0SMIN  R0SMAX  NOPR0S'',/,9X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                            XL_MIN_IFMESH,XL_MAX_IFMESH,NOP_XL,
     *                            A0SMIN_IFMESH,A0SMAX_IFMESH,NOPA0S,
     *                            R0SMIN_IFMESH,R0SMAX_IFMESH,NOPR0S
          END IF
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     Effective-mass term parameters, ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'EFFMMESHLM') THEN
C
          READ (N_READ,*) XEFMIN_IFMESH,XEFMAX_IFMESH,NOPXEF,
     *                    AEFMIN_IFMESH,AEFMAX_IFMESH,NOPAEF,
     *                    REFMIN_IFMESH,REFMAX_IFMESH,NOPREF
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''XEFMIN  XEFMAX  NOPXEF  '',
     *                          ''AEFMIN  AEFMAX  NOPAEF  '',
     *                          ''REFMIN  REFMAX  NOPREF'',/,9X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                            XEFMIN_IFMESH,XEFMAX_IFMESH,NOPXEF,
     *                            AEFMIN_IFMESH,AEFMAX_IFMESH,NOPAEF,
     *                            REFMIN_IFMESH,REFMAX_IFMESH,NOPREF
          END IF
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     Density dependent S-O pot. parameters - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'DENSMESHLM') THEN
C
          READ (N_READ,*) XPPMIN_IFMESH,XPPMAX_IFMESH,NOPXPP,
     *                    XPNMIN_IFMESH,XPNMAX_IFMESH,NOPXPN,
     *                    XNPMIN_IFMESH,XNPMAX_IFMESH,NOPXNP,
     *                    XNNMIN_IFMESH,XNNMAX_IFMESH,NOPXNN
C
          IF (IFDENS.EQ.1 .AND. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''XPPMIN  XPPMAX  NOPXPP  '',
     *                          ''XPNMIN  XPNMAX  NOPXPN  '',
     *                          ''XNPMIN  XNPMAX  NOPXNP  '',
     *                          ''XNNMIN  XNNMAX  NOPXNN'',/,9X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                            XPPMIN_IFMESH,XPPMAX_IFMESH,NOPXPP,
     *                            XPNMIN_IFMESH,XPNMAX_IFMESH,NOPXPN,
     *                            XNPMIN_IFMESH,XNPMAX_IFMESH,NOPXNP,
     *                            XNNMIN_IFMESH,XNNMAX_IFMESH,NOPXNN
          END IF
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     SO-Tensor parameters - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'TENSMESHLM') THEN
C
          READ (N_READ,*) YPPMIN_IFMESH,YPPMAX_IFMESH,NOPYPP,
     *                    YPNMIN_IFMESH,YPNMAX_IFMESH,NOPYPN,
     *                    YNPMIN_IFMESH,YNPMAX_IFMESH,NOPYNP,
     *                    YNNMIN_IFMESH,YNNMAX_IFMESH,NOPYNN
C
          IF (IFTENS.EQ.1 .AND. ISORBT.EQ.1 .AND. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''YPPMIN  YPPMAX  NOPYPP  '',
     *                          ''YPNMIN  YPNMAX  NOPYPN  '',
     *                          ''YNPMIN  YNPMAX  NOPYNP  '',
     *                          ''YNNMIN  YNNMAX  NOPYNN'',/,9X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                            YPPMIN_IFMESH,YPPMAX_IFMESH,NOPYPP,
     *                            YPNMIN_IFMESH,YPNMAX_IFMESH,NOPYPN,
     *                            YNPMIN_IFMESH,YNPMAX_IFMESH,NOPYNP,
     *                            YNNMIN_IFMESH,YNNMAX_IFMESH,NOPYNN
          END IF
C
      END IF 
C 
C=======================================================================
C=======================================================================
C     Central-Tensor parameters - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'CNTNMESHLM') THEN
C
          READ (N_READ,*) CPPMIN_IFMESH,CPPMAX_IFMESH,NOPCPP,
     *                    CPNMIN_IFMESH,CPNMAX_IFMESH,NOPCPN,
     *                    CNPMIN_IFMESH,CNPMAX_IFMESH,NOPCNP,
     *                    CNNMIN_IFMESH,CNNMAX_IFMESH,NOPCNN
C
          IF (IFTENS.EQ.1 .AND. ICENTT.EQ.1 .AND. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''CPPMIN  CPPMAX  NOPCPP  '',
     *                          ''CPNMIN  CPNMAX  NOPCPN  '',
     *                          ''CNPMIN  CNPMAX  NOPCNP  '',
     *                          ''CNNMIN  CNNMAX  NOPCNN'',/,9X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                            CPPMIN_IFMESH,CPPMAX_IFMESH,NOPCPP,
     *                            CPNMIN_IFMESH,CPNMAX_IFMESH,NOPCPN,
     *                            CNPMIN_IFMESH,CNPMAX_IFMESH,NOPCNP,
     *                            CNNMIN_IFMESH,CNNMAX_IFMESH,NOPCNN
          END IF
C
      END IF 
C 
C=======================================================================
C=======================================================================
C     Central potential KAPPA parameters - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'CENTKAPMSH') THEN
C
          READ (N_READ,*) XKCMIN_IFMESH,XKCMAX_IFMESH,NOPXKC,            
     *                    XACMIN_IFMESH,XACMAX_IFMESH,NOPXAC,
     *                    XRCMIN_IFMESH,XRCMAX_IFMESH,NOPXRC,
     *                    XCoMIN_IFMESH,XCoMAX_IFMESH,NOPXCo
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''XKCMIN  XKCMAX  NOPXKC  '',
     *                          ''XACMIN  XACMAX  NOPXAC  '',
     *                          ''XRCMIN  XRCMAX  NOPXRC  '',
     *                          ''XCoMIN  XCoMAX  NOPXCo'',/,9X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                            XKCMIN_IFMESH,XKCMAX_IFMESH,NOPXKC,            
     *                            XACMIN_IFMESH,XACMAX_IFMESH,NOPXAC,
     *                            XRCMIN_IFMESH,XRCMAX_IFMESH,NOPXRC,
     *                            XCoMIN_IFMESH,XCoMAX_IFMESH,NOPXCo
          END IF
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     Spin-orbit potential KAPPA parameters - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'SORBKAPMSH') THEN
C
          READ (N_READ,*) XKSMIN_IFMESH,XKSMAX_IFMESH,NOPXKS,
     *                    XASMIN_IFMESH,XASMAX_IFMESH,NOPXAS,
     *                    XRSMIN_IFMESH,XRSMAX_IFMESH,NOPXRS
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''XKSMIN  XKSMAX  NOPXKS  '',
     *                          ''XASMIN  XASMAX  NOPXAS  '',
     *                          ''XRSMIN  XRSMAX  NOPXRS'',/,9X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                            XKSMIN_IFMESH,XKSMAX_IFMESH,NOPXKS,
     *                            XASMIN_IFMESH,XASMAX_IFMESH,NOPXAS,
     *                            XRSMIN_IFMESH,XRSMAX_IFMESH,NOPXRS
          END IF
C
      END IF          
C 
C=======================================================================
C=======================================================================
C     Reduced-mass term KAPPA parameters - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'EFFMKAPMSH') THEN
C
          READ (N_READ,*) XKEMIN_IFMESH,XKEMAX_IFMESH,NOPXKE,
     *                    XAEMIN_IFMESH,XAEMAX_IFMESH,NOPXAE,
     *                    XREMIN_IFMESH,XREMAX_IFMESH,NOPXRE
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''XKEMIN  XKEMAX  NOPXKE  '',
     *                          ''XAEMIN  XAEMAX  NOPXAE  '',
     *                          ''XREMIN  XREMAX  NOPXRE'',/,9X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                            XKEMIN_IFMESH,XKEMAX_IFMESH,NOPXKE,
     *                            XAEMIN_IFMESH,XAEMAX_IFMESH,NOPXAE,
     *                            XREMIN_IFMESH,XREMAX_IFMESH,NOPXRE
          END IF
C
      END IF     
          
C 
C=======================================================================
C=======================================================================
C     V_o, r_o and a_o for KAPPA parameters - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'CNTVRAMESH') THEN
C
          READ (N_READ,*) VC_MIN_IFMESH,VC_MAX_IFMESH,NOP_VC,
     *                    AC_MIN_IFMESH,AC_MAX_IFMESH,NOP_AC,
     *                    RC_MIN_IFMESH,RC_MAX_IFMESH,NOP_RC
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''V0CMIN  V0CMAX  NOPV0C  '',
     *                          ''A0CMIN  A0CMAX  NOPA0C  '',
     *                          ''R0CMIN  R0CMAX  NOPR0C  '',/,9X,
     *                            F6.1,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                    VC_MIN_IFMESH,VC_MAX_IFMESH,NOP_VC,
     *                    AC_MIN_IFMESH,AC_MAX_IFMESH,NOP_AC,
     *                    RC_MIN_IFMESH,RC_MAX_IFMESH,NOP_RC
          END IF
C
      END IF    
C 
C=======================================================================
C=======================================================================
C  kappa V_o, r_o and a_o for KAPPA parameters - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'CNTKAPMESH') THEN
C
          READ (N_READ,*) VCKMIN_IFMESH,VCKMAX_IFMESH,NOPVCK,
     *                    ACKMIN_IFMESH,ACKMAX_IFMESH,NOPACK,
     *                    RCKMIN_IFMESH,RCKMAX_IFMESH,NOPRCK
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''V0CMIN  V0CMAX  NOPV0C  '',
     *                          ''A0CMIN  A0CMAX  NOPA0C  '',
     *                          ''R0CMIN  R0CMAX  NOPR0C  '',/,9X,
     *                            F6.1,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                    VCKMIN_IFMESH,VCKMAX_IFMESH,NOPVCK,
     *                    ACKMIN_IFMESH,ACKMAX_IFMESH,NOPACK,
     *                    RCKMIN_IFMESH,RCKMAX_IFMESH,NOPRCK
          END IF
C
      END IF            
C 
C=======================================================================
C=======================================================================
C     V_o, r_o and a_o for KAPPA parameters - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'SORLRAMESH') THEN
C
          READ (N_READ,*) VS_MIN_IFMESH,VS_MAX_IFMESH,NOP_VS,
     *                    AS_MIN_IFMESH,AS_MAX_IFMESH,NOP_AS,
     *                    RS_MIN_IFMESH,RS_MAX_IFMESH,NOP_RS
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''V0CMIN  V0CMAX  NOPV0C  '',
     *                          ''A0CMIN  A0CMAX  NOPA0C  '',
     *                          ''R0CMIN  R0CMAX  NOPR0C  '',/,9X,
     *                            F6.1,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                    VS_MIN_IFMESH,VS_MAX_IFMESH,NOP_VS,
     *                    AS_MIN_IFMESH,AS_MAX_IFMESH,NOP_AS,
     *                    RS_MIN_IFMESH,RS_MAX_IFMESH,NOP_RS
          END IF
C
      END IF    
C 
C=======================================================================
C=======================================================================
C  kappa V_o, r_o and a_o for KAPPA parameters - ranges for mesh option
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'SORKAPMESH') THEN
C
          READ (N_READ,*) VSKMIN_IFMESH,VSKMAX_IFMESH,NOPVSK,
     *                    ASKMIN_IFMESH,ASKMAX_IFMESH,NOPASK,
     *                    RSKMIN_IFMESH,RSKMAX_IFMESH,NOPRSK
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''V0CMIN  V0CMAX  NOPV0C  '',
     *                          ''A0CMIN  A0CMAX  NOPA0C  '',
     *                          ''R0CMIN  R0CMAX  NOPR0C  '',/,9X,
     *                            F6.1,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X,
     *                            F6.2,2X,F6.2,2X,I6,2X)')
     *
     *                    VSKMIN_IFMESH,VSKMAX_IFMESH,NOPVSK,
     *                    ASKMIN_IFMESH,ASKMAX_IFMESH,NOPASK,
     *                    RSKMIN_IFMESH,RSKMAX_IFMESH,NOPRSK
          END IF
C
      END IF            
C=======================================================================
C=======================================================================
C     Protons
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFMESHPARP') THEN
C
          READ (*,*) IM_V0C_PROTON,IM_A0C_PROTON,IM_R0C_PROTON,
     *               IM_XLA_PROTON,IM_A0S_PROTON,IM_R0S_PROTON,
     *               IM_XRM_PROTON,IM_ARM_PROTON,IM_RRM_PROTON,
     *                                                  IM_COU
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''IM_V0C  IM_A0C  IM_R0C  IM_XLA  '',
     *                          ''IM_A0S  IM_R0S  IM_XRM  IM_ARM  '',
     *                          ''IM_RRM  IM_COU'')')
C
              WRITE(LOGFIL,'(9X,10(I6,2X))')
     *                       IM_V0C_PROTON,IM_A0C_PROTON,IM_R0C_PROTON,
     *                       IM_XLA_PROTON,IM_A0S_PROTON,IM_R0S_PROTON,
     *                       IM_XRM_PROTON,IM_ARM_PROTON,IM_RRM_PROTON,
     *                                                          IM_COU
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         1 -> central potential depth (p)
C         2 -> central potential radius (p)
C         3 -> central potential diffuseness (p)
C
C         4 -> spin-orbit strength (p)
C         5 -> spin-orbit potential radius (p)
C         6 -> spin-orbit potential diffuseness (p)
C
C         7 -> effective mass strength (p)
C         8 -> effective mass radius (p) 
C         9 -> effective mass diffuseness (p) 
C
C         10-> Coulomb radius parameter 
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          XMIN_I(1)=V0CMIN_IFMESH
          XMIN_I(2)=R0CMIN_IFMESH
          XMIN_I(3)=A0CMIN_IFMESH
C          
          XMIN_I(4)=XL_MIN_IFMESH
          XMIN_I(5)=R0SMIN_IFMESH
          XMIN_I(6)=A0SMIN_IFMESH
C
          XMIN_I(7)=XEFMIN_IFMESH
          XMIN_I(8)=REFMIN_IFMESH
          XMIN_I(9)=AEFMIN_IFMESH
C_______________________________________________________________________
C
          XMIN_I(10)=CouMIN_IFMESH
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          XMAX_I(1)=V0CMAX_IFMESH
          XMAX_I(2)=R0CMAX_IFMESH
          XMAX_I(3)=A0CMAX_IFMESH
C
          XMAX_I(4)=XL_MAX_IFMESH
          XMAX_I(5)=R0SMAX_IFMESH
          XMAX_I(6)=A0SMAX_IFMESH
C
          XMAX_I(7)=XEFMAX_IFMESH
          XMAX_I(8)=REFMAX_IFMESH
          XMAX_I(9)=AEFMAX_IFMESH
C_______________________________________________________________________
C
          XMAX_I(10)=CouMAX_IFMESH
C_______________________________________________________________________
C
C         Maximum number of points (user's choice)
C
          MAXPAR(1)=NOPV0C
          MAXPAR(2)=NOPR0C
          MAXPAR(3)=NOPA0C
C          
          MAXPAR(4)=NOP_XL
          MAXPAR(5)=NOPR0S
          MAXPAR(6)=NOPA0S
C
          MAXPAR(7)=NOPXEF
          MAXPAR(8)=NOPREF
          MAXPAR(9)=NOPAEF
C_______________________________________________________________________
C
          MAXPAR(10)=NOPCou
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          I_MESH(1)=IM_V0C_PROTON
          I_MESH(2)=IM_R0C_PROTON
          I_MESH(3)=IM_A0C_PROTON
C          
          I_MESH(4)=IM_XLA_PROTON
          I_MESH(5)=IM_R0S_PROTON
          I_MESH(6)=IM_A0S_PROTON
C          
          I_MESH(7)=IM_XRM_PROTON
          I_MESH(8)=IM_RRM_PROTON
          I_MESH(9)=IM_ARM_PROTON
C_______________________________________________________________________
C          
          I_MESH(10)=IM_COU
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'IFMESHKAPP') THEN
C
          READ (*,*) IMKV0C_PROTON,IMKA0C_PROTON,IMKR0C_PROTON,
     *	             IMKXLA_PROTON,IMKA0S_PROTON,IMKR0S_PROTON,
     *               IMKXRM_PROTON,IMKARM_PROTON,IMKRRM_PROTON,
     *                                                  IMKCOU
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''IMKV0C  IMKA0C  IMKR0C  IMKXLA  '',
     *                          ''IMKA0S  IMKR0S  IMKXRM  IMKARM  '',
     *                          ''IMKRRM  IMKCOU'')')
C
              WRITE(LOGFIL,'(9X,10(I6,2X))')
     *                       IMKV0C_PROTON,IMKA0C_PROTON,IMKR0C_PROTON,
     *	                     IMKXLA_PROTON,IMKA0S_PROTON,IMKR0S_PROTON,
     *                       IMKXRM_PROTON,IMKARM_PROTON,IMKRRM_PROTON,
     *                                                          IMKCOU
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         11-> central potential depth       (p)
C         12-> central potential radius      (p)
C         13-> central potential diffuseness (p)
C
C         14-> spin-orbit strength              (p)
C         15-> spin-orbit potential radius      (p)
C         16-> spin-orbit potential diffuseness (p)
C
C         17-> effective mass strength    (p)
C         18-> effective mass radius      (p) 
C         19-> effective mass diffuseness (p) 
C
C         20-> Coulomb radius parameter 
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          XMIN_I(11)=XKCMIN_IFMESH
          XMIN_I(12)=XRCMIN_IFMESH
          XMIN_I(13)=XACMIN_IFMESH
C          
          XMIN_I(14)=XKSMIN_IFMESH
          XMIN_I(15)=XRSMIN_IFMESH
          XMIN_I(16)=XASMIN_IFMESH
C
          XMIN_I(17)=XKEMIN_IFMESH
          XMIN_I(18)=XREMIN_IFMESH
          XMIN_I(19)=XAEMIN_IFMESH
C_______________________________________________________________________
C
          XMIN_I(20)=XCoMIN_IFMESH
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          XMAX_I(11)=XKCMAX_IFMESH
          XMAX_I(12)=XRCMAX_IFMESH
          XMAX_I(13)=XACMAX_IFMESH
C
          XMAX_I(14)=XKSMAX_IFMESH
          XMAX_I(15)=XRSMAX_IFMESH
          XMAX_I(16)=XASMAX_IFMESH
C
          XMAX_I(17)=XKEMAX_IFMESH
          XMAX_I(18)=XREMAX_IFMESH
          XMAX_I(19)=XAEMAX_IFMESH
C_______________________________________________________________________
C
          XMAX_I(20)=XCoMAX_IFMESH
C_______________________________________________________________________
C
C         Maximum number of points (user's choice)
C
          MAXPAR(11)=NOPXKC
          MAXPAR(12)=NOPXRC
          MAXPAR(13)=NOPXAC
C          
          MAXPAR(14)=NOPXKS
          MAXPAR(15)=NOPXRS
          MAXPAR(16)=NOPXAS
C
          MAXPAR(17)=NOPXKE
          MAXPAR(18)=NOPXRE
          MAXPAR(19)=NOPXAE
C_______________________________________________________________________
C
          MAXPAR(20)=NOPXCo
C_______________________________________________________________________
C
C         Yes/No decision: take or not to take this KAPPA 
C 
          I_MESH(11)=IMKV0C_PROTON
          I_MESH(12)=IMKR0C_PROTON
          I_MESH(13)=IMKA0C_PROTON
C          
          I_MESH(14)=IMKXLA_PROTON
          I_MESH(15)=IMKR0S_PROTON
          I_MESH(16)=IMKA0S_PROTON
C          
          I_MESH(17)=IMKXRM_PROTON
          I_MESH(18)=IMKRRM_PROTON
          I_MESH(19)=IMKARM_PROTON
C_______________________________________________________________________
C          
          I_MESH(20)=IMKCOU
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Neutrons
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFMESHPARN') THEN
C
          READ (*,*) IM_V0C_NEUTRS,IM_A0C_NEUTRS,IM_R0C_NEUTRS,
     *               IM_XLA_NEUTRS,IM_A0S_NEUTRS,IM_R0S_NEUTRS,
     *               IM_XRM_NEUTRS,IM_ARM_NEUTRS,IM_RRM_NEUTRS
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''IM_V0C  IM_A0C  IM_R0C  IM_XLA  '',
     *                          ''IM_A0S  IM_R0S  IM_XRM  IM_ARM  '',
     *                          ''IM_RRM  IM_COU'')')
C
              WRITE(LOGFIL,'(9X,9(I6,2X))')
     *                       IM_V0C_NEUTRS,IM_A0C_NEUTRS,IM_R0C_NEUTRS,
     *                       IM_XLA_NEUTRS,IM_A0S_NEUTRS,IM_R0S_NEUTRS,
     *                       IM_XRM_NEUTRS,IM_ARM_NEUTRS,IM_RRM_NEUTRS
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         21 -> central potential depth       (n)
C         22 -> central potential radius      (n)
C         23 -> central potential diffuseness (n)
C
C         24 -> spin-orbit strength              (n)
C         25 -> spin-orbit potential radius      (n)
C         26 -> spin-orbit potential diffuseness (n)
C
C         27 -> effective mass strength    (n)
C         28 -> effective mass radius      (n) 
C         29 -> effective mass diffuseness (n) 
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          XMIN_I(21)=V0CMIN_IFMESH
          XMIN_I(22)=R0CMIN_IFMESH
          XMIN_I(23)=A0CMIN_IFMESH
C          
          XMIN_I(24)=XL_MIN_IFMESH
          XMIN_I(25)=R0SMIN_IFMESH
          XMIN_I(26)=A0SMIN_IFMESH
C
          XMIN_I(27)=XEFMIN_IFMESH
          XMIN_I(28)=REFMIN_IFMESH
          XMIN_I(29)=AEFMIN_IFMESH
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          XMAX_I(21)=V0CMAX_IFMESH
          XMAX_I(22)=R0CMAX_IFMESH
          XMAX_I(23)=A0CMAX_IFMESH
C
          XMAX_I(24)=XL_MAX_IFMESH
          XMAX_I(25)=R0SMAX_IFMESH
          XMAX_I(26)=A0SMAX_IFMESH
C
          XMAX_I(27)=XEFMAX_IFMESH
          XMAX_I(28)=REFMAX_IFMESH
          XMAX_I(29)=AEFMAX_IFMESH
C_______________________________________________________________________
C
C         Maximum number of points (user's choice)
C
          MAXPAR(21)=NOPV0C
          MAXPAR(22)=NOPR0C
          MAXPAR(23)=NOPA0C
C          
          MAXPAR(24)=NOP_XL
          MAXPAR(25)=NOPR0S
          MAXPAR(26)=NOPA0S
C
          MAXPAR(27)=NOPXEF
          MAXPAR(28)=NOPREF
          MAXPAR(29)=NOPAEF
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          I_MESH(21)=IM_V0C_NEUTRS
          I_MESH(22)=IM_R0C_NEUTRS
          I_MESH(23)=IM_A0C_NEUTRS
C          
          I_MESH(24)=IM_XLA_NEUTRS
          I_MESH(25)=IM_R0S_NEUTRS
          I_MESH(26)=IM_A0S_NEUTRS
C          
          I_MESH(27)=IM_XRM_NEUTRS
          I_MESH(28)=IM_RRM_NEUTRS
          I_MESH(29)=IM_ARM_NEUTRS
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFMESHKAPN') THEN
C
          READ (*,*) IMKV0C_NEUTRS,IMKA0C_NEUTRS,IMKR0C_NEUTRS,
     *	             IMKXLA_NEUTRS,IMKA0S_NEUTRS,IMKR0S_NEUTRS,
     *               IMKXRM_NEUTRS,IMKARM_NEUTRS,IMKRRM_NEUTRS 
C
          IF (IFMESH.EQ.1) THEN

              WRITE(LOGFIL,'(A)') KEYWOR

              WRITE(LOGFIL,'(9X,''IMKV0C  IMKA0C  IMKR0C  IMKXLA  '',
     *                          ''IMKA0S  IMKR0S  IMKXRM  IMKARM  '',
     *                          ''IMKRRM  '')')
C
              WRITE(LOGFIL,'(9X,9(I6,2X))')
     *                       IMKV0C_NEUTRS,IMKA0C_NEUTRS,IMKR0C_NEUTRS,
     *	                     IMKXLA_NEUTRS,IMKA0S_NEUTRS,IMKR0S_NEUTRS,
     *                       IMKXRM_NEUTRS,IMKARM_NEUTRS,IMKRRM_NEUTRS 
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         30-> central potential depth       (p)
C         31-> central potential radius      (p)
C         32-> central potential diffuseness (p)
C
C         33-> spin-orbit strength              (p)
C         34-> spin-orbit potential radius      (p)
C         35-> spin-orbit potential diffuseness (p)
C
C         36-> effective mass strength    (p)
C         37-> effective mass radius      (p) 
C         38-> effective mass diffuseness (p) 
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          XMIN_I(30)=XKCMIN_IFMESH
          XMIN_I(31)=XRCMIN_IFMESH
          XMIN_I(32)=XACMIN_IFMESH
C          
          XMIN_I(33)=XKSMIN_IFMESH
          XMIN_I(34)=XRSMIN_IFMESH
          XMIN_I(35)=XASMIN_IFMESH
C
          XMIN_I(36)=XKEMIN_IFMESH
          XMIN_I(37)=XREMIN_IFMESH
          XMIN_I(38)=XAEMIN_IFMESH
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          XMAX_I(30)=XKCMAX_IFMESH
          XMAX_I(31)=XRCMAX_IFMESH
          XMAX_I(32)=XACMAX_IFMESH
C
          XMAX_I(33)=XKSMAX_IFMESH
          XMAX_I(34)=XRSMAX_IFMESH
          XMAX_I(35)=XASMAX_IFMESH
C
          XMAX_I(36)=XKEMAX_IFMESH
          XMAX_I(37)=XREMAX_IFMESH
          XMAX_I(38)=XAEMAX_IFMESH
C_______________________________________________________________________
C
C         Maximum number of points (user's choice)
C
          MAXPAR(30)=NOPXKC
          MAXPAR(31)=NOPXRC
          MAXPAR(32)=NOPXAC
C          
          MAXPAR(33)=NOPXKS
          MAXPAR(34)=NOPXRS
          MAXPAR(35)=NOPXAS
C
          MAXPAR(36)=NOPXKE
          MAXPAR(37)=NOPXRE
          MAXPAR(38)=NOPXAE
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this KAPPA 
C 
          I_MESH(30)=IMKV0C_NEUTRS
          I_MESH(31)=IMKR0C_NEUTRS
          I_MESH(32)=IMKA0C_NEUTRS
C          
          I_MESH(33)=IMKXLA_NEUTRS
          I_MESH(34)=IMKR0S_NEUTRS
          I_MESH(35)=IMKA0S_NEUTRS
C          
          I_MESH(36)=IMKXRM_NEUTRS
          I_MESH(37)=IMKRRM_NEUTRS
          I_MESH(38)=IMKARM_NEUTRS
C          
      END IF 
C
C=======================================================================
C=======================================================================
C     Density-dependent spin-orbit Hamiltonian
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFMESHDENS') THEN
C
          READ (*,*) IM_XPP,IM_XPN,IM_XNP,IM_XNN
C
          IF (IFDENS.EQ.1 .AND. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''IM_XPP  IM_XPN  IM_XNP  IM_XNN'')')
              WRITE(LOGFIL,'(9X,4(I6,2X))')IM_XPP,IM_XPN,IM_XNP,IM_XNN
C
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         39 -> lambda  proton-proton
C         40 -> lambda  proton-neutron
C         41 -> lambda neutron-proton
C         42 -> lambda neutron-neutron
C ###     43 -> alpha spin-orbit
C ###     44 -> beta spin-orbit
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          XMIN_I(39)=XPPMIN_IFMESH
          XMIN_I(40)=XPNMIN_IFMESH
          XMIN_I(41)=XNPMIN_IFMESH
          XMIN_I(42)=XNNMIN_IFMESH
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          XMAX_I(39)=XPPMAX_IFMESH
          XMAX_I(40)=XPNMAX_IFMESH
          XMAX_I(41)=XNPMAX_IFMESH
          XMAX_I(42)=XNNMAX_IFMESH
C_______________________________________________________________________
C
C         Maximum number of points (user's choice)
C
          MAXPAR(39)=NOPXPP
          MAXPAR(40)=NOPXPN
          MAXPAR(41)=NOPXNP
          MAXPAR(42)=NOPXNN          
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          I_MESH(39)=IM_XPP
          I_MESH(40)=IM_XPN
          I_MESH(41)=IM_XNP
          I_MESH(42)=IM_XNN
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     SO-Tensor part
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFMESHTENS') THEN
C
          READ (*,*) IM_YPP,IM_YPN,IM_YNP,IM_YNN
C
          IF (IFTENS.EQ.1 .AND. ISORBT.EQ.1 .AND. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR

              WRITE(LOGFIL,'(9X,''IM_YPP  IM_YPN  IM_YNP  IM_YNN'')')
              WRITE(LOGFIL,'(9X,4(I6,2X))') IM_YPP,IM_YPN,IM_YNP,IM_YNN
C
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         45 -> tensor lambda  proton-proton
C         46 -> tensor lambda  proton-neutron
C         47 -> tensor lambda neutron-proton
C         48 -> tensor lambda neutron-neutron
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          XMIN_I(43)=YPPMIN_IFMESH
          XMIN_I(44)=YPNMIN_IFMESH
          XMIN_I(45)=YNPMIN_IFMESH
          XMIN_I(46)=YNNMIN_IFMESH
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          XMAX_I(43)=YPPMAX_IFMESH
          XMAX_I(44)=YPNMAX_IFMESH
          XMAX_I(45)=YNPMAX_IFMESH
          XMAX_I(46)=YNNMAX_IFMESH
C_______________________________________________________________________
C
C         Maximum number of points (user's choice)
C
          MAXPAR(43)=NOPYPP
          MAXPAR(44)=NOPYPN
          MAXPAR(45)=NOPYNP
          MAXPAR(46)=NOPYNN            
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          I_MESH(43)=IM_YPP
          I_MESH(44)=IM_YPN
          I_MESH(45)=IM_YNP
          I_MESH(46)=IM_YNN
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Central-potential tensor part
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFMESHCNTN') THEN
C
          READ (*,*) IM_CPP,IM_CPN,IM_CNP,IM_CNN
C
          IF (IFTENS.EQ.1 .AND. ICENTT.EQ.1 .AND. IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''IM_CPP  IM_CPN  IM_CNP  IM_CNN'')')
              WRITE(LOGFIL,'(9X,4(I6,2X))')IM_CPP,IM_CPN,IM_CNP,IM_CNN
C
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         45 -> tensor lambda  proton-proton
C         46 -> tensor lambda  proton-neutron
C         47 -> tensor lambda neutron-proton
C         48 -> tensor lambda neutron-neutron
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          XMIN_I(47)=CPPMIN_IFMESH
          XMIN_I(48)=CPNMIN_IFMESH
          XMIN_I(49)=CNPMIN_IFMESH
          XMIN_I(50)=CNNMIN_IFMESH
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          XMAX_I(47)=CPPMAX_IFMESH
          XMAX_I(48)=CPNMAX_IFMESH
          XMAX_I(49)=CNPMAX_IFMESH
          XMAX_I(50)=CNNMAX_IFMESH
C_______________________________________________________________________
C
C         Maximum number of points (user's choice)
C
          MAXPAR(47)=NOPCPP
          MAXPAR(48)=NOPCPN
          MAXPAR(49)=NOPCNP
          MAXPAR(50)=NOPCNN            
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          I_MESH(47)=IM_CPP
          I_MESH(48)=IM_CPN
          I_MESH(49)=IM_CNP
          I_MESH(50)=IM_CNN
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Central-potential KAPPA parametrization
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFMESHCNTK') THEN
C
          READ (*,*) IM_V0C,IM_KVC,IM_R0C,IM_KRC,IM_A0C,IM_KAC
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''IM_V0C  IM_KVC  IM_R0C  IM_KRC  '',
     *                          ''IM_A0C  IM_KAC'')')
              WRITE(LOGFIL,'(9X,4(I6,2X))')IM_V0C,IM_KVC,IM_R0C,
     *                                     IM_KRC,IM_A0C,IM_KAC
C
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         51 -> Vo central
C         52 -> kappa Vo central
C         53 -> ro central
C         54 -> kappa ro central
C         55 -> ao central
C         56 -> kappa ao central
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          XMIN_I(51)=VC_MIN_IFMESH
          XMIN_I(52)=VCKMIN_IFMESH
          XMIN_I(53)=RC_MIN_IFMESH
          XMIN_I(54)=RCKMIN_IFMESH
          XMIN_I(55)=AC_MIN_IFMESH
          XMIN_I(56)=ACKMIN_IFMESH
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          XMAX_I(51)=VC_MAX_IFMESH
          XMAX_I(52)=VCKMAX_IFMESH
          XMAX_I(53)=RC_MAX_IFMESH
          XMAX_I(54)=RCKMAX_IFMESH
          XMAX_I(55)=AC_MAX_IFMESH
          XMAX_I(56)=ACKMAX_IFMESH
C_______________________________________________________________________
C
C         Maximum number of points (user's choice)
C
          MAXPAR(51)=NOP_VC
          MAXPAR(52)=NOPVCK
          MAXPAR(53)=NOP_RC
          MAXPAR(54)=NOPRCK
          MAXPAR(55)=NOP_AC
          MAXPAR(56)=NOPACK      
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          I_MESH(51)=IM_V0C
          I_MESH(52)=IM_KVC
          I_MESH(53)=IM_R0C
          I_MESH(54)=IM_KRC
          I_MESH(55)=IM_A0C
          I_MESH(56)=IM_KAC
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Central-potential KAPPA parametrization
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IFMESHSORK') THEN
C
          READ (*,*) IM_VSO,IM_KVS,IM_RSO,IM_KRS,IM_ASO,IM_KAS
C
          IF (IFMESH.EQ.1) THEN
C
              WRITE(LOGFIL,'(A)') KEYWOR
C
              WRITE(LOGFIL,'(9X,''IM_VSO  IM_KVS  IM_RSO  IM_KRS  '',
     *                          ''IM_ASO  IM_KAS  '')')
              WRITE(LOGFIL,'(9X,4(I6,2X))')IM_VSO,IM_KVS,IM_RSO,
     *                                     IM_KRS,IM_ASO,IM_KAS
C
          END IF
C_______________________________________________________________________
C 
C         The values of the vector index below are associated
C         with the potential parameters. We have:
C_______________________________________________________________________
C
C         57 -> Vo spin-orbit
C         58 -> kappa Vo spin-orbit
C         59 -> ro spin-orbit
C         60 -> kappa ro spin-orbit
C         61 -> ao spin-orbit
C         62 -> kappa ao spin-orbit
C_______________________________________________________________________
C 
C         Below, the we use the following coding: 
C 
C         "V" - variable, "STR" - starting value,
C         "MIN" -> minimal value of the interval,
C         "MAX" -> maximal value of the interval,
C         "STP" -> step to calculate derivatives
C_______________________________________________________________________
C
C         Minimum values (lower bounds of the intervals)
C
          XMIN_I(57)=VS_MIN_IFMESH
          XMIN_I(58)=VSKMIN_IFMESH
          XMIN_I(59)=RS_MIN_IFMESH
          XMIN_I(60)=RSKMIN_IFMESH
          XMIN_I(61)=AS_MIN_IFMESH
          XMIN_I(62)=ASKMIN_IFMESH
C_______________________________________________________________________
C
C         Maximum values (upper bounds of the intervals)
C
          XMAX_I(57)=VS_MAX_IFMESH
          XMAX_I(58)=VSKMAX_IFMESH
          XMAX_I(59)=RS_MAX_IFMESH
          XMAX_I(60)=RSKMAX_IFMESH
          XMAX_I(61)=AS_MAX_IFMESH
          XMAX_I(62)=ASKMAX_IFMESH
C_______________________________________________________________________
C
C         Maximum number of points (user's choice)
C
          MAXPAR(57)=NOP_VS
          MAXPAR(58)=NOPVSK
          MAXPAR(59)=NOP_RS
          MAXPAR(60)=NOPRSK
          MAXPAR(61)=NOP_AS
          MAXPAR(62)=NOPASK      
C_______________________________________________________________________
C 
C         Yes/No decision: take or not to take this is the question 
C 
          I_MESH(57)=IM_VSO
          I_MESH(58)=IM_KVS
          I_MESH(59)=IM_RSO
          I_MESH(60)=IM_KRS
          I_MESH(61)=IM_ASO
          I_MESH(62)=IM_KAS
C_______________________________________________________________________
C
      END IF
C
C=======================================================================
C=======================================================================
C     Entering to the Monte-Carlo Part. 
C
C     Reading the number of M-C restarts and the number of bins
C     that we want for the future histograms.
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'MONTECARLO') THEN
C
          READ(*,*) IFPSEU,IFPARA,LDMONT,LDBINS
C
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''LDMONT  LDBINS'',/,9X,I6,2X,I6)')
     *                            LDMONT, LDBINS
          END IF
C
          IF (LDMONT.GT.NDMONT) THEN
              WRITE(LOGFIL,'(''Stop in NAMELI: '',
     *                       ''LDMONT= '',I6,'' is GT NDMONT= '',I6)')
     *                         LDMONT,                NDMONT
              STOP 'STOP in NAMELI: LDMONT.GT.NDMONT'
          END IF
C
          IF (LDMONT.GT.NDRAND) THEN
              WRITE(NOUTPT,'(''LDMONT='',I6,'' exceeds NDRAND='',I6)')
     *                         LDMONT,                 NDRAND
              STOP 'STOP in NAMELI: LDMONT.GT.NDRAND'
          END IF
C
          IF (LDBINS.GT.NDBINS) THEN
              WRITE(LOGFIL,'(''Stop in NAMELI: '',
     *                       ''LDBINS= '',I6,'' is GT NDBINS= '',I6)')
     *                         LDBINS,                NDBINS
              STOP 'STOP in NAMELI: LDBINS.GT.NDBINS'
          END IF
C
      END IF
C
C=======================================================================
C=======================================================================
C     Reading the mean values of the parameters
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'CENTPROT_M') THEN
          READ(*,*) VPCENT_XMEANS,RPCENT_XMEANS,APCENT_XMEANS,
     *              XK_VPC_XMEANS,XK_RPC_XMEANS,XK_APC_XMEANS,
     *              R0COUL_XMEANS,XK_COU_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0CENT  R0CENT  A0CENT  '',
     *                          ''XK_V0C  XK_R0C  XK_A0C  '',
     *                          ''R0COUL  XK_COU'')')
              WRITE(LOGFIL,'(9X,8(F6.2,2X))')
     *                            VPCENT_XMEANS,RPCENT_XMEANS,
     *                                          APCENT_XMEANS,
     *                            XK_VPC_XMEANS,XK_RPC_XMEANS,
     *                                          XK_APC_XMEANS,
     *                            R0COUL_XMEANS,XK_COU_XMEANS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'CENTNEUT_M') THEN
          READ(*,*) VNCENT_XMEANS,RNCENT_XMEANS,ANCENT_XMEANS,
     *              XK_VNC_XMEANS,XK_RNC_XMEANS,XK_ANC_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0CENT  R0CENT  A0CENT  '',
     *                          ''XK_V0C  XK_R0C  XK_A0C  '',/,
     *                           9X,6(F6.2,2X))')
     *                            VNCENT_XMEANS,RNCENT_XMEANS,
     *                                          ANCENT_XMEANS,
     *                            XK_VNC_XMEANS,XK_RNC_XMEANS,
     *                                          XK_ANC_XMEANS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'SORBPROT_M') THEN
          READ(*,*) VPSORB_XMEANS,RPSORB_XMEANS,APSORB_XMEANS,
     *              XK_VPS_XMEANS,XK_RPS_XMEANS,XK_APS_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0SORB  R0SORB  A0SORB  '',
     *                          ''XK_V0S  XK_R0S  XK_A0S  '',/,
     *                          9X,6(F6.2,2X))')
     *                     VPSORB_XMEANS,RPSORB_XMEANS,APSORB_XMEANS,
     *                     XK_VPS_XMEANS,XK_RPS_XMEANS,XK_APS_XMEANS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'SORBNEUT_M') THEN
          READ(*,*) VNSORB_XMEANS,RNSORB_XMEANS,ANSORB_XMEANS,
     *              XK_VNS_XMEANS,XK_RNS_XMEANS,XK_ANS_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0SORB  R0SORB  A0SORB  '',
     *                          ''XK_V0S  XK_R0S  XK_A0S  '',/,
     *                          9X,6(F6.2,2X))')
     *                     VNSORB_XMEANS,RNSORB_XMEANS,ANSORB_XMEANS,
     *                     XK_VNS_XMEANS,XK_RNS_XMEANS,XK_ANS_XMEANS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'EFFEPROT_M') THEN
          READ(*,*) VPEFFM_XMEANS,RPEFFM_XMEANS,APEFFM_XMEANS,
     *              XK_VPE_XMEANS,XK_RPE_XMEANS,XK_APE_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0EFFM  R0EFFM  A0EFFM  '',
     *                          ''XK_LEF  XK_REF  XK_AEF  '',/,
     *                          9X,6(F6.2,2X))')
     *                     VPEFFM_XMEANS,RPEFFM_XMEANS,APEFFM_XMEANS,
     *                     XK_VPE_XMEANS,XK_RPE_XMEANS,XK_APE_XMEANS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'EFFENEUT_M') THEN
          READ(*,*) VNEFFM_XMEANS,RNEFFM_XMEANS,ANEFFM_XMEANS,
     *              XK_VNE_XMEANS,XK_RNE_XMEANS,XK_ANE_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0EFFM  R0EFFM  A0EFFM  '',
     *                          ''XK_LEF  XK_REF  XK_AEF  '',/,
     *                          9X,6(F6.2,2X))')
     *                     VNEFFM_XMEANS,RNEFFM_XMEANS,ANEFFM_XMEANS,
     *                     XK_VNE_XMEANS,XK_RNE_XMEANS,XK_ANE_XMEANS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'SORBDENS_M') THEN
          READ(*,*) ALAMPP_XMEANS,ALAMPN_XMEANS,ALAMNP_XMEANS,
     *                                          ALAMNN_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''ALAMPP  ALAMPN  ALAMNP  ALAMNN'',/,
     *                       9X,4(F6.2,2X))')
     *                     ALAMPP_XMEANS,ALAMPN_XMEANS,
     *                     ALAMNP_XMEANS,ALAMNN_XMEANS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'SORBTENS_M') THEN
          READ(*,*) TLAMPP_XMEANS,TLAMPN_XMEANS,TLAMNP_XMEANS,
     *                                          TLAMNN_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''TLAMPP  TLAMPN  TLAMNP  TLAMNN'',/,
     *                       9X,4(F6.2,2X))')
     *                     TLAMPP_XMEANS,TLAMPN_XMEANS,
     *                     TLAMNP_XMEANS,TLAMNN_XMEANS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'CENTTENS_M') THEN
          READ(*,*) CLAMPP_XMEANS,CLAMPN_XMEANS,CLAMNP_XMEANS,
     *                                          CLAMNN_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''TLAMPP  TLAMPN  TLAMNP  TLAMNN'',/,
     *                       9X,4(F6.2,2X))')
     *                     CLAMPP_XMEANS,CLAMPN_XMEANS,
     *                     CLAMNP_XMEANS,CLAMNN_XMEANS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'KAPACENT_M') THEN
          READ(*,*) V0CENT_XMEANS,XK_V0C_XMEANS,R0CENT_XMEANS,
     *              XK_R0C_XMEANS,A0CENT_XMEANS,XK_A0C_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0CENT  XK_V0C  R0CENT  XK_R0C  '',
     *                          ''A0CENT  XK_A0C'',/,
     *                       9X,6(F6.2,2X))')
     *              V0CENT_XMEANS,XK_V0C_XMEANS,R0CENT_XMEANS,
     *              XK_R0C_XMEANS,A0CENT_XMEANS,XK_A0C_XMEANS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'KAPASORB_M') THEN
          READ(*,*) V0SORB_XMEANS,XK_V0S_XMEANS,R0SORB_XMEANS,
     *              XK_R0S_XMEANS,A0SORB_XMEANS,XK_A0S_XMEANS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0CENT  XK_V0C  R0CENT  XK_R0C  '',
     *                          ''A0CENT  XK_A0C'',/,
     *                       9X,6(F6.2,2X))')
     *              V0SORB_XMEANS,XK_V0S_XMEANS,R0SORB_XMEANS,
     *              XK_R0s_XMEANS,A0SORB_XMEANS,XK_A0S_XMEANS
          END IF
      END IF
C
C=======================================================================
C=======================================================================
C     Reading the sigma values of the parameters
C=======================================================================
C=======================================================================
C
      IF (KEYWOR.EQ.'CENTPROT_S') THEN
          READ(*,*) VPCENT_SIGMAS,RPCENT_SIGMAS,APCENT_SIGMAS,
     *              XK_VPC_SIGMAS,XK_RPC_SIGMAS,XK_APC_SIGMAS,
     *              R0COUL_SIGMAS,XK_COU_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0CENT  R0CENT  A0CENT  '',
     *                          ''XK_V0C  XK_R0C  XK_A0C  '',
     *                          ''R0COUL  XK_COU'',/,9X,8(F6.2,2X))')
     *                            VPCENT_SIGMAS,RPCENT_SIGMAS,
     *                                          APCENT_SIGMAS,
     *                            XK_VPC_SIGMAS,XK_RPC_SIGMAS,
     *                                          XK_APC_SIGMAS,
     *                            R0COUL_SIGMAS,XK_COU_SIGMAS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'CENTNEUT_S') THEN
          READ(*,*) VNCENT_SIGMAS,RNCENT_SIGMAS,ANCENT_SIGMAS,
     *              XK_VNC_SIGMAS,XK_RNC_SIGMAS,XK_ANC_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0CENT  R0CENT  A0CENT  '',
     *                          ''XK_V0C  XK_R0C  XK_A0C  '',/,
     *                       9X,6(F6.2,2X))')
     *                            VNCENT_SIGMAS,RNCENT_SIGMAS,
     *                                          ANCENT_SIGMAS,
     *                            XK_VNC_SIGMAS,XK_RNC_SIGMAS,
     *                                          XK_ANC_SIGMAS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'SORBPROT_S') THEN
          READ(*,*) VPSORB_SIGMAS,RPSORB_SIGMAS,APSORB_SIGMAS,
     *              XK_VPS_SIGMAS,XK_RPS_SIGMAS,XK_APS_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0SORB  R0SORB  A0SORB  '',
     *                          ''XK_V0S  XK_R0S  XK_A0S  '',/,
     *                       9X,6(F6.2,2X))')
     *                     VPSORB_SIGMAS,RPSORB_SIGMAS,APSORB_SIGMAS,
     *                     XK_VPS_SIGMAS,XK_RPS_SIGMAS,XK_APS_SIGMAS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'SORBNEUT_S') THEN
          READ(*,*) VNSORB_SIGMAS,RNSORB_SIGMAS,ANSORB_SIGMAS,
     *              XK_VNS_SIGMAS,XK_RNS_SIGMAS,XK_ANS_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0SORB  R0SORB  A0SORB  '',
     *                          ''XK_V0S  XK_R0S  XK_A0S  '',/,
     *                       9X,6(F6.2,2X))')
     *                     VNSORB_SIGMAS,RNSORB_SIGMAS,ANSORB_SIGMAS,
     *                     XK_VNS_SIGMAS,XK_RNS_SIGMAS,XK_ANS_SIGMAS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'EFFEPROT_S') THEN
          READ(*,*) VPEFFM_SIGMAS,RPEFFM_SIGMAS,APEFFM_SIGMAS,
     *              XK_VPE_SIGMAS,XK_RPE_SIGMAS,XK_APE_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0EFFM  R0EFFM  A0EFFM  '',
     *                          ''XK_LEF  XK_REF  XK_AEF  '',/,
     *                       9X,6(F6.2,2X))')
     *                     VPEFFM_SIGMAS,RPEFFM_SIGMAS,APEFFM_SIGMAS,
     *                     XK_VPE_SIGMAS,XK_RPE_SIGMAS,XK_APE_SIGMAS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'EFFENEUT_S') THEN
          READ(*,*) VNEFFM_SIGMAS,RNEFFM_SIGMAS,ANEFFM_SIGMAS,
     *              XK_VNE_SIGMAS,XK_RNE_SIGMAS,XK_ANE_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0EFFM  R0EFFM  A0EFFM  '',
     *                          ''XK_LEF  XK_REF  XK_AEF  '',/,
     *                       9X,6(F6.2,2X))')
     *                     VNEFFM_SIGMAS,RNEFFM_SIGMAS,ANEFFM_SIGMAS,
     *                     XK_VNE_SIGMAS,XK_RNE_SIGMAS,XK_ANE_SIGMAS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'SORBDENS_S') THEN
          READ(*,*) ALAMPP_SIGMAS,ALAMPN_SIGMAS,ALAMNP_SIGMAS,
     *                                          ALAMNN_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''ALAMPP  ALAMPN  ALAMNP  ALAMNN'',/,
     *                       9X,4(F6.2,2X))')
     *                     ALAMPP_SIGMAS,ALAMPN_SIGMAS,
     *                     ALAMNP_SIGMAS,ALAMNN_SIGMAS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'SORBTENS_S') THEN
          READ(*,*) TLAMPP_SIGMAS,TLAMPN_SIGMAS,TLAMNP_SIGMAS,
     *                                          TLAMNN_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''TLAMPP  TLAMPN  TLAMNP  TLAMNN'',/,
     *                       9X,4(F6.2,2X))')
     *                     TLAMPP_SIGMAS,TLAMPN_SIGMAS,
     *                     TLAMNP_SIGMAS,TLAMNN_SIGMAS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'CENTTENS_S') THEN
          READ(*,*) CLAMPP_SIGMAS,CLAMPN_SIGMAS,CLAMNP_SIGMAS,
     *                                          CLAMNN_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''TLAMPP  TLAMPN  TLAMNP  TLAMNN'',/,
     *                       9X,4(F6.2,2X))')
     *                     CLAMPP_SIGMAS,CLAMPN_SIGMAS,
     *                     CLAMNP_SIGMAS,CLAMNN_SIGMAS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'KAPACENT_S') THEN
          READ(*,*) V0CENT_SIGMAS,XK_V0C_SIGMAS,R0CENT_SIGMAS,
     *              XK_R0C_SIGMAS,A0CENT_SIGMAS,XK_A0C_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0CENT  XK_V0C  R0CENT  XK_R0C  '',
     *                          ''A0CENT  XK_A0C'',/,
     *                       9X,6(F6.2,2X))')
     *              V0CENT_SIGMAS,XK_V0C_SIGMAS,R0CENT_SIGMAS,
     *              XK_R0C_SIGMAS,A0CENT_SIGMAS,XK_A0C_SIGMAS
          END IF
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'KAPASORB_S') THEN
          READ(*,*) V0SORB_SIGMAS,XK_V0S_SIGMAS,R0SORB_SIGMAS,
     *              XK_R0S_SIGMAS,A0SORB_SIGMAS,XK_A0S_SIGMAS
          IF (IFMOCA.EQ.1) THEN
              WRITE(LOGFIL,'(A)') KEYWOR
              WRITE(LOGFIL,'(9X,''V0CENT  XK_V0C  R0CENT  XK_R0C  '',
     *                          ''A0CENT  XK_A0C'',/,
     *                       9X,6(F6.2,2X))')
     *              V0SORB_SIGMAS,XK_V0S_SIGMAS,R0SORB_SIGMAS,
     *              XK_R0S_SIGMAS,A0SORB_SIGMAS,XK_A0S_SIGMAS
          END IF
      END IF
C
C=======================================================================
C=======================================================================
C     Reading the dangerous information about optional NOT
C     taking into account certain experimental levels
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'WHATNOTAKE') THEN
C
          REMOVE_PROTON='NOT'
          REMOVE_NEUTRS='NOT'
C
          DO I=1,NDRAUS
             INDNEU_LETOUT(I)=1
             INDPRO_LETOUT(I)=1
          END DO
C
          DO I=1,NDRAUS
C
             READ (*,'(3X,I10,2X,A6,A10,I10,2X,A6)') 
     *                 INDNEU_LETOUT(I),LABNEU_REMOVE(I),SPACIN,
     *                 INDPRO_LETOUT(I),LABPRO_REMOVE(I)             
          END DO
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          DO I=1,NDRAUS
C
             WRITE(LOGFIL,'(9X,I1,2X,A6,10X,I2,2X,A6)') 
     *                      INDNEU_LETOUT(I),LABNEU_REMOVE(I),
     *                      INDPRO_LETOUT(I),LABPRO_REMOVE(I) 
          END DO
C_______________________________________________________________________
C
          NOTNEU=0
          NOTPRO=0
C
          DO I=1,NDRAUS
             IF (INDNEU_LETOUT(I).EQ.1) THEN
                 NOTNEU=NOTNEU+1
             END IF
             IF (INDPRO_LETOUT(I).EQ.1) THEN
                 NOTPRO=NOTPRO+1
             END IF
          END DO
C
C=======================================================================
C=======================================================================
C
          IF (NOTNEU.NE.0) THEN
C_______________________________________________________________________
C
              REMOVE_NEUTRS='YES'
C
              IF (ISCREN.EQ.1) THEN
                  WRITE(LSCREN,'()')
                  DO I=1,15
                     WRITE(LSCREN,'(9X,''YOU REMOVED'',I2,
     *                                 '' VALID EXPERIMENTAL '',
     *                                ''NEUTRON LEVELS FROM THE FIT'')')
     *                                                      NOTNEU
                  END DO
                  WRITE(LSCREN,'()')
              END IF
C_______________________________________________________________________
C
              WRITE(LOGFIL,'()')
C
              DO I=1,15
                 WRITE(LOGFIL,'(9X,''YOU REMOVED'',I2,
     *                             '' VALID EXPERIMENTAL '',
     *                             ''NEUTRON LEVELS FROM THE FIT'')')
     *                                                    NOTNEU
              END DO
C
              WRITE(LOGFIL,'()')
C
              WRITE(LOGFIL,'()')
              DO I=1,15
                 WRITE(LOGFIL,'(9X,''YOU REMOVED'',I2,1X,
     *                             ''VALID EXPERIMENTAL '',
     *                             ''NEUTRON LEVELS FROM THE FIT'')')
     *                                                    NOTNEU
              END DO
C
              WRITE(LOGFIL,'()')
C
              DO I=1,NDRAUS
                 IF (INDNEU_LETOUT(I).EQ.1) THEN
                     WRITE(LOGFIL,'(''Removed neutron '',a6,'' level'')
     *                                                               ')
     *                                LABNEU_REMOVE(I)
                 END IF
              END DO
C_______________________________________________________________________
C
              DO I=1,NDRAUS
C
                 IF (ISCREN.EQ.1 .AND. INDNEU_LETOUT(I).EQ.1) THEN
C
                     WRITE(LSCREN,'(''Removed neutron '',a6,'' level'')
     *                                                               ')
     *                                LABNEU_REMOVE(I)
                 END IF
              END DO
C
          END IF
C
C=======================================================================
C=======================================================================
C
          IF (NOTPRO.NE.0) THEN
C
              REMOVE_PROTON='YES'
C
              IF (ISCREN.EQ.1) THEN
C
                  WRITE(LSCREN,'()')
C
                  DO I=1,15
                     WRITE(LSCREN,'(9X,''YOU REMOVED'',I2,1X,
     *                                 ''VALID EXPERIMENTAL '',
     *                                ''PROTON  LEVELS FROM THE FIT'')')
     *                                                      NOTPRO
                  END DO
                  WRITE(LSCREN,'()')
              END IF
C
              WRITE(LOGFIL,'()')
              DO I=1,15
                 WRITE(LOGFIL,'(9X,''YOU REMOVED'',I2,1X,
     *                             ''VALID EXPERIMENTAL '',
     *                             ''PROTON  LEVELS FROM THE FIT'')')
     *                                                    NOTPRO
              END DO
C
              WRITE(LOGFIL,'()')
              WRITE(LOGFIL,'()')
C
              DO I=1,15
                 WRITE(LOGFIL,'(9X,''YOU REMOVED'',I2,1X,
     *                             ''VALID EXPERIMENTAL '',
     *                             ''PROTON  LEVELS FROM THE FIT'')')
     *                                                    NOTPRO
              END DO
C
              WRITE(LOGFIL,'()')
C
              DO I=1,NDRAUS
                 IF (INDPRO_LETOUT(I).EQ.1) THEN
                     WRITE(LSCREN,'(''Removed proton '',a6,'' level'')')
     *                     LABPRO_REMOVE(I)                            
                 END IF
              END DO
C
              DO I=1,NDRAUS
                 IF (ISCREN.EQ.1 .AND. INDPRO_LETOUT(I).EQ.1) THEN
                     WRITE(LSCREN,'(''Removed proton '',a6,'' level'')')
     *                     LABPRO_REMOVE(I)                            
                 END IF
              END DO
C
          END IF
C
      END IF 
C
C=======================================================================
C=======================================================================
C=======================================================================
C     Reading the dangerous information about optional NOT taking
C                        into account certain experimental levels
C=======================================================================
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'IDENTIFIER') THEN
C
          READ (*,*) EXTENT_NEUTRS
          READ (*,*) EXTENT_PROTON
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          LENGTH=0
          DO I=1,40
             IF (EXTENT_NEUTRS(I:I).NE.' ') LENGTH=LENGTH+1
          END DO
C
          WRITE(LOGFIL,'(9X,''Summary of the results '',
     *                       ''goes to the files with extensions:'',/,
     *                    9X,''EXTENT_NEUTRS='',A,''.dat'')') 
     *                         EXTENT_NEUTRS(1:LENGTH)
          LENGTH=0
          DO I=1,40
             IF (EXTENT_PROTON(I:I).NE.' ') LENGTH=LENGTH+1
          END DO
C
          WRITE(LOGFIL,'(9X,''EXTENT_PROTON='',A,''.dat'')') 
     *                        EXTENT_PROTON(1:LENGTH)
C
          LENGTH=0
          DO I=1,40
             IF (EXTENT_NEUTRS(I:I).NE.' ') LENGTH=LENGTH+1
          END DO
C
          WRITE(LSCREN,'()')
          WRITE(LSCREN,'(''Summary of the results '',
     *                   ''goes to the files with extensions:'',/,
     *                   ''EXTENT_NEUTRS='',A,''.dat'')') 
     *                     EXTENT_NEUTRS(1:LENGTH)
          LENGTH=0
          DO I=1,40
             IF (EXTENT_PROTON(I:I).NE.' ') LENGTH=LENGTH+1
          END DO
          WRITE(LSCREN,'(''EXTENT_PROTON='',A,''.dat'')') 
     *                     EXTENT_PROTON(1:LENGTH)
C
      END IF
C
C=======================================================================
C=======================================================================
C=======================================================================
C     Reading the length of the energy levels (plotting reasons)
C=======================================================================
C=======================================================================
C=======================================================================
C 
      IF (KEYWOR.EQ.'LEV_LENGTH') THEN
C
          READ(*,*) XMIN_T,XMAX_T,XMIN_E,XMAX_E
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''XMIN_T  XMAX_T  XMIN_E  XMAX_E'')')
          WRITE(LOGFIL,'(9X,4F6.2)')XMIN_T,XMAX_T,XMIN_E,XMAX_E
C
      END IF
C
C=======================================================================
C      
      IF (KEYWOR.EQ.'ATTRIBUTES') THEN
C
          READ(*,*) ISTYLE,I_TYPE
          READ(*,*) STRING
C
          READ(*,*) (ICOLOR(I),I=1,NDCOLO)
          READ(*,*) STRING
C
          READ(*,*) (ITHICK(I),I=1,NDCOLO)
C
          WRITE(LOGFIL,'(A)') KEYWOR
C
          WRITE(LOGFIL,'(9X,''STYLE1  TYPEPN'')')
C
          WRITE(LOGFIL,'(9X,I6,2X,I6)') ISTYLE,I_TYPE
C
          WRITE(LOGFIL,'(9X,<NDCOLO>(''COLO'',I2.2,2X))') (I,I=1,NDCOLO)
          WRITE(LOGFIL,'(9X,<NDCOLO>(I6,2X))')    (ICOLOR(I),I=1,NDCOLO)
          WRITE(LOGFIL,'(9X,<NDCOLO>(''ITHI'',I2.2,2X))') (I,I=1,NDCOLO)
          WRITE(LOGFIL,'(9X,<NDCOLO>(I6,2X))')    (ITHICK(I),I=1,NDCOLO)
C
      END IF
C
C=======================================================================
C=======================================================================
C                         Ready to run ?
C=======================================================================
C=======================================================================
C @@@ WE WILL NEED INTELLIGENT PRINT OF THIS INFORMATION - LET'S DISCUSS
      IF (KEYWOR.EQ.'EXECUTE!!!') THEN
C
          PARPOT( 1)=V0CENT_PROTON
          PARPOT( 2)=R0CENT_PROTON
          PARPOT( 3)=A0CENT_PROTON
          PARPOT( 4)=V0SORB_PROTON
          PARPOT( 5)=R0SORB_PROTON
          PARPOT( 6)=A0SORB_PROTON
          PARPOT( 7)=V0EFFM_PROTON
          PARPOT( 8)=R0EFFM_PROTON
          PARPOT( 9)=A0EFFM_PROTON
          PARPOT(10)=R0COUL
     
          PARPOT(11)=XK_V0C_PROTON
          PARPOT(12)=XK_R0C_PROTON
          PARPOT(13)=XK_A0C_PROTON
          PARPOT(14)=XK_LAM_PROTON
          PARPOT(15)=XK_RSO_PROTON
          PARPOT(16)=XK_ASO_PROTON
          PARPOT(17)=XK_LEF_PROTON
          PARPOT(18)=XK_REF_PROTON
          PARPOT(19)=XK_AEF_PROTON
          PARPOT(20)=XK_COU
     
          PARPOT(21)=V0CENT_NEUTRS
          PARPOT(22)=R0CENT_NEUTRS
          PARPOT(23)=A0CENT_NEUTRS
          PARPOT(24)=V0SORB_NEUTRS
          PARPOT(25)=R0SORB_NEUTRS
          PARPOT(26)=A0SORB_NEUTRS
          PARPOT(27)=V0EFFM_NEUTRS
          PARPOT(28)=R0EFFM_NEUTRS
          PARPOT(29)=A0EFFM_NEUTRS
     
          PARPOT(30)=XK_V0C_NEUTRS
          PARPOT(31)=XK_R0C_NEUTRS
          PARPOT(32)=XK_A0C_NEUTRS
          PARPOT(33)=XK_LAM_NEUTRS
          PARPOT(34)=XK_RSO_NEUTRS
          PARPOT(35)=XK_ASO_NEUTRS
          PARPOT(36)=XK_LEF_NEUTRS
          PARPOT(37)=XK_REF_NEUTRS
          PARPOT(38)=XK_AEF_NEUTRS
     
          PARPOT(39)=ALAMPP
          PARPOT(40)=ALAMPN
          PARPOT(41)=ALAMNP
          PARPOT(42)=ALAMNN

          PARPOT(43)=TLAMPP
          PARPOT(44)=TLAMPN
          PARPOT(45)=TLAMNP
          PARPOT(46)=TLAMNN
          
          PARPOT(47)=CLAMPP
          PARPOT(48)=CLAMPN
          PARPOT(49)=CLAMNP
          PARPOT(50)=CLAMNN
C
          PARPOT(51)=V0CENT_KAPPAR
          PARPOT(52)=XK_V0C_KAPPAR
          PARPOT(53)=R0CENT_KAPPAR
          PARPOT(54)=XK_R0C_KAPPAR
          PARPOT(55)=A0CENT_KAPPAR
          PARPOT(56)=XK_A0C_KAPPAR
C
          PARPOT(57)=V0SORB_KAPPAR
          PARPOT(58)=XK_V0S_KAPPAR
          PARPOT(59)=R0SORB_KAPPAR
          PARPOT(60)=XK_R0S_KAPPAR
          PARPOT(61)=A0SORB_KAPPAR
          PARPOT(62)=XK_A0S_KAPPAR
C
C=======================================================================
C
          PARPOT_XMEANS( 1)=VPCENT_XMEANS
          PARPOT_XMEANS( 2)=RPCENT_XMEANS
          PARPOT_XMEANS( 3)=APCENT_XMEANS
          PARPOT_XMEANS( 4)=VPSORB_XMEANS
          PARPOT_XMEANS( 5)=RPSORB_XMEANS
          PARPOT_XMEANS( 6)=APSORB_XMEANS
          PARPOT_XMEANS( 7)=VPEFFM_XMEANS
          PARPOT_XMEANS( 8)=RPEFFM_XMEANS
          PARPOT_XMEANS( 9)=APEFFM_XMEANS
          PARPOT_XMEANS(10)=R0COUL_XMEANS
     
          PARPOT_XMEANS(11)=XK_VPC_XMEANS
          PARPOT_XMEANS(12)=XK_RPC_XMEANS
          PARPOT_XMEANS(13)=XK_APC_XMEANS
          PARPOT_XMEANS(14)=XK_VPS_XMEANS
          PARPOT_XMEANS(15)=XK_RPS_XMEANS
          PARPOT_XMEANS(16)=XK_APS_XMEANS
          PARPOT_XMEANS(17)=XK_VPE_XMEANS
          PARPOT_XMEANS(18)=XK_RPE_XMEANS
          PARPOT_XMEANS(19)=XK_APE_XMEANS
          PARPOT_XMEANS(20)=XK_COU_XMEANS
     
          PARPOT_XMEANS(21)=VNCENT_XMEANS
          PARPOT_XMEANS(22)=RNCENT_XMEANS
          PARPOT_XMEANS(23)=ANCENT_XMEANS
          PARPOT_XMEANS(24)=VNSORB_XMEANS
          PARPOT_XMEANS(25)=RNSORB_XMEANS
          PARPOT_XMEANS(26)=ANSORB_XMEANS
          PARPOT_XMEANS(27)=VNEFFM_XMEANS
          PARPOT_XMEANS(28)=RNEFFM_XMEANS
          PARPOT_XMEANS(29)=ANEFFM_XMEANS
     
          PARPOT_XMEANS(30)=XK_VNC_XMEANS
          PARPOT_XMEANS(31)=XK_RNC_XMEANS
          PARPOT_XMEANS(32)=XK_ANC_XMEANS
          PARPOT_XMEANS(33)=XK_VNS_XMEANS
          PARPOT_XMEANS(34)=XK_RNS_XMEANS
          PARPOT_XMEANS(35)=XK_ANS_XMEANS
          PARPOT_XMEANS(36)=XK_VNE_XMEANS
          PARPOT_XMEANS(37)=XK_RNE_XMEANS
          PARPOT_XMEANS(38)=XK_ANE_XMEANS
     
          PARPOT_XMEANS(39)=ALAMPP_XMEANS
          PARPOT_XMEANS(40)=ALAMPN_XMEANS
          PARPOT_XMEANS(41)=ALAMNP_XMEANS
          PARPOT_XMEANS(42)=ALAMNN_XMEANS

          PARPOT_XMEANS(43)=TLAMPP_XMEANS
          PARPOT_XMEANS(44)=TLAMPN_XMEANS
          PARPOT_XMEANS(45)=TLAMNP_XMEANS
          PARPOT_XMEANS(46)=TLAMNN_XMEANS
          
          PARPOT_XMEANS(47)=CLAMPP_XMEANS
          PARPOT_XMEANS(48)=CLAMPN_XMEANS
          PARPOT_XMEANS(49)=CLAMNP_XMEANS
          PARPOT_XMEANS(50)=CLAMNN_XMEANS
C
          PARPOT_XMEANS(51)=V0CENT_XMEANS
          PARPOT_XMEANS(52)=XK_V0C_XMEANS
          PARPOT_XMEANS(53)=R0CENT_XMEANS
          PARPOT_XMEANS(54)=XK_R0C_XMEANS
          PARPOT_XMEANS(55)=A0CENT_XMEANS
          PARPOT_XMEANS(56)=XK_A0C_XMEANS
C
          PARPOT_XMEANS(57)=V0SORB_XMEANS
          PARPOT_XMEANS(58)=XK_V0S_XMEANS
          PARPOT_XMEANS(59)=R0SORB_XMEANS
          PARPOT_XMEANS(60)=XK_R0S_XMEANS
          PARPOT_XMEANS(61)=A0SORB_XMEANS
          PARPOT_XMEANS(62)=XK_A0S_XMEANS
C
C=======================================================================
C
          PARPOT_SIGMAS( 1)=VPCENT_SIGMAS
          PARPOT_SIGMAS( 2)=RPCENT_SIGMAS
          PARPOT_SIGMAS( 3)=APCENT_SIGMAS
          PARPOT_SIGMAS( 4)=VPSORB_SIGMAS
          PARPOT_SIGMAS( 5)=RPSORB_SIGMAS
          PARPOT_SIGMAS( 6)=APSORB_SIGMAS
          PARPOT_SIGMAS( 7)=VPEFFM_SIGMAS
          PARPOT_SIGMAS( 8)=RPEFFM_SIGMAS
          PARPOT_SIGMAS( 9)=APEFFM_SIGMAS
          PARPOT_SIGMAS(10)=R0COUL_SIGMAS
     
          PARPOT_SIGMAS(11)=XK_VPC_SIGMAS
          PARPOT_SIGMAS(12)=XK_RPC_SIGMAS
          PARPOT_SIGMAS(13)=XK_APC_SIGMAS
          PARPOT_SIGMAS(14)=XK_VPS_SIGMAS
          PARPOT_SIGMAS(15)=XK_RPS_SIGMAS
          PARPOT_SIGMAS(16)=XK_APS_SIGMAS
          PARPOT_SIGMAS(17)=XK_VPE_SIGMAS
          PARPOT_SIGMAS(18)=XK_RPE_SIGMAS
          PARPOT_SIGMAS(19)=XK_APE_SIGMAS
          PARPOT_SIGMAS(20)=XK_COU_SIGMAS
     
          PARPOT_SIGMAS(21)=VNCENT_SIGMAS
          PARPOT_SIGMAS(22)=RNCENT_SIGMAS
          PARPOT_SIGMAS(23)=ANCENT_SIGMAS
          PARPOT_SIGMAS(24)=VNSORB_SIGMAS
          PARPOT_SIGMAS(25)=RNSORB_SIGMAS
          PARPOT_SIGMAS(26)=ANSORB_SIGMAS
          PARPOT_SIGMAS(27)=VNEFFM_SIGMAS
          PARPOT_SIGMAS(28)=RNEFFM_SIGMAS
          PARPOT_SIGMAS(29)=ANEFFM_SIGMAS
     
          PARPOT_SIGMAS(30)=XK_VNC_SIGMAS
          PARPOT_SIGMAS(31)=XK_RNC_SIGMAS
          PARPOT_SIGMAS(32)=XK_ANC_SIGMAS
          PARPOT_SIGMAS(33)=XK_VNS_SIGMAS
          PARPOT_SIGMAS(34)=XK_RNS_SIGMAS
          PARPOT_SIGMAS(35)=XK_ANS_SIGMAS
          PARPOT_SIGMAS(36)=XK_VNE_SIGMAS
          PARPOT_SIGMAS(37)=XK_RNE_SIGMAS
          PARPOT_SIGMAS(38)=XK_ANE_SIGMAS
     
          PARPOT_SIGMAS(39)=ALAMPP_SIGMAS
          PARPOT_SIGMAS(40)=ALAMPN_SIGMAS
          PARPOT_SIGMAS(41)=ALAMNP_SIGMAS
          PARPOT_SIGMAS(42)=ALAMNN_SIGMAS

          PARPOT_SIGMAS(43)=TLAMPP_SIGMAS
          PARPOT_SIGMAS(44)=TLAMPN_SIGMAS
          PARPOT_SIGMAS(45)=TLAMNP_SIGMAS
          PARPOT_SIGMAS(46)=TLAMNN_SIGMAS
          
          PARPOT_SIGMAS(47)=CLAMPP_SIGMAS
          PARPOT_SIGMAS(48)=CLAMPN_SIGMAS
          PARPOT_SIGMAS(49)=CLAMNP_SIGMAS
          PARPOT_SIGMAS(50)=CLAMNN_SIGMAS
C
          PARPOT_SIGMAS(51)=V0CENT_SIGMAS
          PARPOT_SIGMAS(52)=XK_V0C_SIGMAS
          PARPOT_SIGMAS(53)=R0CENT_SIGMAS
          PARPOT_SIGMAS(54)=XK_R0C_SIGMAS
          PARPOT_SIGMAS(55)=A0CENT_SIGMAS
          PARPOT_SIGMAS(56)=XK_A0C_SIGMAS
C
          PARPOT_SIGMAS(57)=V0SORB_SIGMAS
          PARPOT_SIGMAS(58)=XK_V0S_SIGMAS
          PARPOT_SIGMAS(59)=R0SORB_SIGMAS
          PARPOT_SIGMAS(60)=XK_R0S_SIGMAS
          PARPOT_SIGMAS(61)=A0SORB_SIGMAS
          PARPOT_SIGMAS(62)=XK_A0S_SIGMAS
C
C=======================================================================
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,''Exiting  NAMELI'')')
          END IF
C
          RETURN
C
      END IF
C
C=======================================================================
C                           Scanning continues
C=======================================================================
C
      GO TO  1
C
C=======================================================================
C
   2  CONTINUE
C
C=======================================================================
C     Illegal end of file in the input data stream
C=======================================================================
C
      WRITE(NOUTPT,'(//,''Something wrong with the structure of the '',
     *             ''input file - perhaps forgotten <EXECUTESET> ?'')')
C
C=======================================================================
C                    Forgotten 'EXECUTESET' statement ? ?
C=======================================================================
C
      WRITE(NOUTPT,'(''No "EXECUTE!!!" in the input data stream '',
     *               ''(in NAMELI)'')')
C   
      STOP
     *
     *   'Wrong input structure, eof not allowed here, STOP from NAMELI'
C
      END
C
C=======================================================================
C=======================================================================
C=======================================================================
C FILE NAME = wspher03_readex_15.f ! Keep this symbol:    $ident@string$
C=======================================================================
C=======================================================================
C=======================================================================
C      
C=======================================================================
C=======================================================================
C                READING EXPERIMENTAL SINGLE PARTICLE LEVELS
C=======================================================================
C=======================================================================
C
      SUBROUTINE READEX_LEVELS(IFEXPE,IDEFCN)
C
      INCLUDE  'MATDIM/NDLEXP.f'
      INCLUDE  'MATDIM/NDNUEX.f'
C
      CHARACTER
     *          FILEXP*256,SYMBNU_AUXILI*5,KEYWOR*5
      CHARACTER
     *                     SYMBEX*6,SYMBPL*10
      DIMENSION
     *          SYMBNU_AUXILI(1:NDNUEX)
C
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /EXPZ_N/ IZEXPE(1:NDNUEX),INEXPE(1:NDNUEX),
     *                                 NOFEXP(1:NDNUEX)
      COMMON
     *       /EXPLMB/ BINDLV(1:NDNUEX),BINDOR(1:NDNUEX),
     *                                 DELPAI(1:NDNUEX)
      COMMON
     *       /EXPENE/ ENEXPE(1:NDNUEX,1:NDLEXP),
     *                E_OROS(1:NDNUEX,1:NDLEXP),
     *                ESHELM(1:NDNUEX,1:NDLEXP),
     *                ENEWEX(1:NDNUEX,1:NDLEXP)
      COMMON
     *       /EXPIND/ LNEXPE(1:NDNUEX,1:NDLEXP),
     *                L_OROS(1:NDNUEX,1:NDLEXP),
     *                LSHELM(1:NDNUEX,1:NDLEXP)
      COMMON
     *       /EXPSLV/ SYMBEX(1:NDNUEX,1:NDLEXP),
     *                SYMBPL(1:NDNUEX,1:NDLEXP)
      COMMON
     *       /EXPNUC/ NUCEXP
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C_______________________________________________________________________
C
      DATA
     *     N_UNIT / 10 /
C
C=======================================================================
C     Subroutine reading the experimental data in NAMELIST style
C=======================================================================
C
      IF (IDEFCN.GT.1) THEN
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(12X,''Exiting  READEX_LEVELS, no action''
     *                                                             )')
          END IF
          RETURN
      END IF
C
C     IDEFCN above =>> iteration count in minimising routines
C
C=======================================================================
C
      IF (IFDEEP.EQ.0 .AND. IFPRON.EQ.0) THEN
      
          FILEXP='ws_exper/exp_lev_sph.d'
C
          OPEN(N_UNIT,FILE=FILEXP,STATUS='UNKNOWN',FORM='FORMATTED')
C
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(12X,''Opening Unit='',I2,1X,
     *                           ''File=ws_exper/exp_lev_sph.d'')')
     *                                                  N_UNIT
          END IF    
      
      END IF
C
C=======================================================================
C
      IF (IFDEEP.EQ.1 .AND. IFPRON.EQ.0) THEN
      
          FILEXP='ws_exper/exp_lev_sph_ifdeep.d'
C
          OPEN(N_UNIT,FILE=FILEXP,STATUS='UNKNOWN',FORM='FORMATTED')
C
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(12X,''Opening Unit='',I2,1X,
     *                         ''File=ws_exper/exp_lev_sph_ifdeep.d''
     *                                                            )') 
     *                                                      N_UNIT
          END IF    
      
      END IF
C
C=======================================================================
C
      IF (IFDEEP.EQ.0 .AND. IFPRON.EQ.1) THEN
      
          FILEXP='ws_exper/exp_lev_sph_ifpron.d'
C
          OPEN(N_UNIT,FILE=FILEXP,STATUS='UNKNOWN',FORM='FORMATTED')
C
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(12X,''Opening Unit='',I2,1X,
     *                        ''File=ws_exper/exp_lev_sph_ifpron.d'')') 
     *                                                      N_UNIT
          END IF    
      
      END IF
C
C=======================================================================
C      
      IF (IFDEEP.EQ.1 .AND. IFPRON.EQ.1) THEN
      
          FILEXP='ws_exper/exp_lev_sph_ifdeep_ifpron.d'
C
          OPEN(N_UNIT,FILE=FILEXP,STATUS='UNKNOWN',FORM='FORMATTED')
C
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(12X,''Opening Unit='',I2,1X,
     *                ''File=ws_exper/exp_lev_sph_ifdeep_ifpron.d'')') 
     *                                                      N_UNIT
          END IF    
      
      END IF
C
C=======================================================================
C
      DO NO_EXP=1,NDNUEX
         DO IEXPER=1,NDLEXP
            SYMBEX(NO_EXP,IEXPER)='      '
            SYMBPL(NO_EXP,IEXPER)='yyyyyy'
         END DO
      END DO
C
C=======================================================================
C
      NO_EXP=0
C
   1  CONTINUE
C
C=======================================================================
C
      IF (NO_EXP.GT.NDNUEX) THEN
C
          WRITE(LSCREN,'(//,''NO_EXP='',I3,'' exceeds NDNUEX='',I2)')
     *                        NO_EXP,                 NDNUEX
          STOP 'NO_EXP.GT.NDNUEX in READEX_LEVELS'
C
      END IF
C
C=======================================================================
C
      KEYWOR='     '
C
      READ (N_UNIT,'(A5)',END=2) KEYWOR
C
C=======================================================================
C
      IF (KEYWOR.EQ.'ENDGO') THEN
          NUCEXP=NO_EXP
          CLOSE(N_UNIT)
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(12X,''Closing UNIT='',I2)') N_UNIT
              WRITE(LOGFIL,'( 9X,''Exiting  READEX_LEVELS'')')
          END IF
          RETURN
      END IF
C
C=======================================================================
C
      IF (KEYWOR(2:3).NE.'  ') THEN
C
          NO_EXP=NO_EXP+1
C
          SYMBNU_AUXILI(NO_EXP)=KEYWOR
C
          READ(N_UNIT,*) IZEXPE(NO_EXP),INEXPE(NO_EXP),
     *                   BINDOR(NO_EXP),BINDLV(NO_EXP),
     *                                  DELPAI(NO_EXP)
C_______________________________________________________________________
C
          WRITE(NOUTPT,'(/,''Z='',I2,'' N='',I3,/,T10,''Bexp='',f7.3,
     *                     ''   DPair='',F6.4,/)') 
     *
     *                       IZEXPE(NO_EXP),INEXPE(NO_EXP),
     *                                      BINDLV(NO_EXP),
     *                                      DELPAI(NO_EXP)
C_______________________________________________________________________
C
          IF (LOGWRI.GT.5)
     *          
     *    WRITE(LOGFIL,'(/,9X,''Z='',I2,'' N='',I3,/,T10,''Bexp='',f7.3,
     *                                           ''   DPair='',F6.4)') 
     *
     *                          IZEXPE(NO_EXP),INEXPE(NO_EXP),
     *                                         BINDLV(NO_EXP),
     *                                         DELPAI(NO_EXP)
C_______________________________________________________________________
C
          WRITE(NOUTPT,'(T16,''Oros    Eexp   E_shm   E_new'')')
C
          IF (LOGWRI.GT.5)
     *          
     *    WRITE(LOGFIL,'(T16,''Oros    Eexp   E_shm   E_new'')')
C_______________________________________________________________________
C
          DO IEXPER=1,NDLEXP
C
             READ(N_UNIT,'(20X,A6,43X,A10)') SYMBEX(NO_EXP,IEXPER),
     *                                       SYMBPL(NO_EXP,IEXPER)
C
             IF (SYMBEX(NO_EXP,IEXPER).EQ.'xxxxxx') THEN
                 NOFEXP(NO_EXP)=IEXPER-1
                 GO TO 1
             ELSE
                 READ(N_UNIT,*) E_OROS(NO_EXP,IEXPER),
     *                          L_OROS(NO_EXP,IEXPER),
     *                          ENEXPE(NO_EXP,IEXPER),
     *                          LNEXPE(NO_EXP,IEXPER),
     *                          ESHELM(NO_EXP,IEXPER),
     *                          ENEWEX(NO_EXP,IEXPER)
             END IF
C
             WRITE(NOUTPT,'(''#   '',i1,'')'',4f8.2,2x,a6)')
     *                                                 IEXPER,
     *             E_OROS(NO_EXP,IEXPER),ENEXPE(NO_EXP,IEXPER),
     *             ESHELM(NO_EXP,IEXPER),ENEWEX(NO_EXP,IEXPER),
     *                                   SYMBEX(NO_EXP,IEXPER)
C
          IF (LOGWRI.GT.5)
     *          
     *       WRITE(LOGFIL,'(T10,i1,'')'',4f8.2,2x,a6)')
     *                                                 IEXPER,
     *             E_OROS(NO_EXP,IEXPER),ENEXPE(NO_EXP,IEXPER),
     *             ESHELM(NO_EXP,IEXPER),ENEWEX(NO_EXP,IEXPER),
     *                                   SYMBEX(NO_EXP,IEXPER)
C
          END DO
C
      END IF
C
C=======================================================================
C
      GO TO 1
C
C=======================================================================
C
   2  CONTINUE
C
      WRITE(LSCREN,'(//,''Reading experimental data - '',
     *             ''END OF FILE encountered'',//,
     *             ''This file should end with  ENDGO  statement'')')
C
C=======================================================================
C
      STOP 'ENDGO statement missing READEX_LEVELS'
      END      
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE PREPAR_EXPLEV(IZ_FIX,IN_FIX,FERMEX,GAPEXP,DENSUP,
     *                                                     DENSDW,
     *                         IDEFCN,WHATEX,ISOSPI,IFEXPE,INUCLI)
C      
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDNUEX.f'
      INCLUDE   'MATDIM/NDRAUS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
C_______________________________________________________________________
C
      CHARACTER
     *          SYMBPL*10,SYMBEX*6,LABEXP*6,LABAUX*6,WHATEX*06
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          LABPRO_REMOVE*6,LABNEU_REMOVE*6,
     *          REMOVE_PROTON*3,REMOVE_NEUTRS*3
C_______________________________________________________________________
C
      DIMENSION
     *          ENEAUX(1:NDSPEC),INDAUX(1:NDSPEC),
     *          LABAUX(1:NDSPEC),IDEAUX(1:NDSPEC)
      DIMENSION
     *          EXPEXP(1:NDLEXP),IDEGEX(1:NDLEXP)
      DIMENSION
     *          LABEXP(1:NDLEXP)
C_______________________________________________________________________
C
      COMMON
     *       /REMLAB/ REMOVE_PROTON,REMOVE_NEUTRS
      COMMON
     *       /OUTLAB/ LABPRO_REMOVE(1:NDRAUS),
     *                LABNEU_REMOVE(1:NDRAUS)
      COMMON
     *       /OUTIND/ INDPRO_LETOUT(1:NDRAUS),
     *                INDNEU_LETOUT(1:NDRAUS)
C
C=======================================================================
C     Follows the full information about experimental spherical
C                                                   l e v e l s
C=======================================================================
C
      COMMON
     *       /EXPZ_N/ IZEXPE(1:NDNUEX),INEXPE(1:NDNUEX),
     *                                 NOFEXP(1:NDNUEX)
      COMMON
     *       /EXPLMB/ BINDLV(1:NDNUEX),BINDOR(1:NDNUEX),
     *                                 DELPAI(1:NDNUEX)
      COMMON
     *       /EXPENE/ ENEXPE(1:NDNUEX,1:NDLEXP),
     *                E_OROS(1:NDNUEX,1:NDLEXP),
     *                ESHELM(1:NDNUEX,1:NDLEXP),
     *                ENEWEX(1:NDNUEX,1:NDLEXP)
      COMMON
     *       /EXPSLV/ SYMBEX(1:NDNUEX,1:NDLEXP),
     *                SYMBPL(1:NDNUEX,1:NDLEXP)
      COMMON
     *       /EXPNUC/ NUCEXP
C                               <<<=== HERE: Final experimental
C                                      energies and level SYMBS
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
C
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON
     *       /WHERBE/ IRUNMI,NEWOLD 
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C
C=======================================================================
C
C     This subroutine provides experimental spectra for magic spherical
C     nuclei (based on the data-bank information) read by READEX_LEVELS
C
C     More precisely, binding energies are transformed into s.p. levels
C
C=======================================================================
C
C     Meaning of some parameters:
C
C     FERMEX - experimental estimate  of  the  Fermi level
C
C     GAPEXP - experimental estimate of the main shell gap
C
C     DENSUP - experimental estimate of the level  density
C                      a b o v e    the main shell closure
C     DENSDW - experimental estimate of the level  density
C                      b e l o w    the main shell closure
C
C=======================================================================
C 
C         IDEFCN=1 ->> for the frist iteration in MINIMI
C 
      IF (IDEFCN.GT.1) THEN
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(9X,''Exiting  PREPAR_EXPLEV, no action'')')
          END IF
          RETURN
      END IF
C
C=======================================================================
C
      NEXIST=1
C
C=======================================================================
C
      IF (MOD(IZ_FIX,2).NE.0) THEN
C
          WRITE(LSCREN,'(/,80(''|''),/,''|'',78X,''|'',/,
     *                   ''|   Comparison with experiment for odd Z='',
     *                     I3,
     *                   '' impossible with the existing data  |'',/,
     *                   ''|'',78X,''|'',/,80(''|''),/)') IZ_FIX
C
          IF (LOGWRI.GT.5)
     *
     *    WRITE(LOGFIL,'(/,80(''|''),/,''|'',78X,''|'',/,
     *                   ''|   Comparison with experiment for odd Z='',
     *                     I3,
     *                   '' impossible with the existing data  |'',/,
     *                   ''|'',78X,''|'',/,80(''|''),/)') IZ_FIX
C
          STOP 'Comparison with experiment impossible (Z-case)'
C
      END IF
C
C=======================================================================
C
      IF (MOD(IN_FIX,2).NE.0) THEN
C
          WRITE(LSCREN,'(/,80(''|''),/,''|'',78X,''|'',/,
     *                   ''|   Comparison with experiment for odd N='',
     *                     I3,
     *                   '' impossible with the existing data  |'',/,
     *                   ''|'',78X,''|'',/,80(''|''),/)') IN_FIX
C
          IF (LOGWRI.GT.5)
     *
     *    WRITE(LOGFIL,'(/,80(''|''),/,''|'',78X,''|'',/,
     *                   ''|   Comparison with experiment for odd N='',
     *                     I3,
     *                   '' impossible with the existing data  |'',/,
     *                   ''|'',78X,''|'',/,80(''|''),/)') IN_FIX
C
          STOP 'Comparison with experiment impossible (N-case)'
C
      END IF
C                
C=======================================================================
C
      DO LEVELS=1,NDLEXP
         EXPEXP(LEVELS)=999.999
      END DO
C
      LEVEXP=0
      LEVEXD=0
C
      DO NUCLEU=1,NUCEXP
C
C=======================================================================
C        Extracting the energies of the PROTON hole-states
C=======================================================================
C
         IF (IZEXPE(NUCLEU).EQ.IZ_FIX-1 .AND. ISOSPI.EQ.1
     *                                  .AND.
     *       INEXPE(NUCLEU).EQ.IN_FIX)               THEN
C
             DO LEVELS=1,NOFEXP(NUCLEU)
C
C=======================================================================
C               True experimental levels
C=======================================================================
C
                IF (WHATEX.EQ.'EXTRUE'.AND.
     *                         ENEXPE(NUCLEU,LEVELS).GE.0.000) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDLV(NUCLEU)
     *                            -ENEXPE(NUCLEU,LEVELS)
C @@@ IRENE, What are EXPLOW??? LEAVE A COMMENT
                    IF (LEVEXP.EQ.1) EXPLOW=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               Experiment plus corrections from A. Oros
C=======================================================================
C
                IF (WHATEX.EQ.'EXOROS'.AND.
     *                         E_OROS(NUCLEU,LEVELS).GE.0.000) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDOR(NUCLEU)
     *                            -E_OROS(NUCLEU,LEVELS)
C
                    IF (LEVEXP.EQ.1) EXPLOW=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               Using the shell model instead of experiment
C=======================================================================
C
                IF (WHATEX.EQ.'SHELLM'.AND.
     *                         ESHELM(NUCLEU,LEVELS).GE.0.000) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDLV(NUCLEU)
     *                            -ESHELM(NUCLEU,LEVELS)
C
                    IF (LEVEXP.EQ.1) EXPLOW=EXPEXP(LEVEXP)
C
                END IF
C  @@@ IRENE - PLEASE CONFIRM: PORQUET?
C=======================================================================
C               NEW experimental levels MG PORQUET ??
C=======================================================================
C
                IF (WHATEX.EQ.'EXPNEW'.AND.
     *                         ENEWEX(NUCLEU,LEVELS).NE.-.99)  THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=ENEWEX(NUCLEU,LEVELS)
C
                    IF (LEVEXP.EQ.1) EXPLOW=EXPEXP(LEVEXP)

                END IF
C
C=======================================================================
C               Defining the spectroscopic labels
C=======================================================================
C
                IF (LEVEXD.NE.LEVEXP) THEN
C
                    LEVEXD=LEVEXP
                    LABEXP(LEVEXP)=SYMBEX(NUCLEU,LEVELS)
C
                END IF
C
C=======================================================================
C
             END DO
C
             NEXIST=0
C
         END IF
C
C=======================================================================
C
         LVPRIM=0
C
C=======================================================================
C        Extracting the energies of the PROTON particle states
C=======================================================================
C
         IF (IZEXPE(NUCLEU).EQ.IZ_FIX+1.AND.ISOSPI.EQ.1
     *                                 .AND.
     *       INEXPE(NUCLEU).EQ.IN_FIX) THEN
C
             DO LEVELS=1,NOFEXP(NUCLEU)
C
C=======================================================================
C               True experimental levels
C=======================================================================
C
                IF (WHATEX.EQ.'EXTRUE'.AND.
     *                         ENEXPE(NUCLEU,LEVELS).GE.0.000) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDLV(NUCLEU)
     *                            +ENEXPE(NUCLEU,LEVELS)
                    LVPRIM=LVPRIM+1
C
                    IF (LVPRIM.EQ.1) EXPUPP=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               Experiment plus corrections from A. Oros
C=======================================================================
C
C @@@ IRENE, WHAT ARE THESE "CORRECTIONS" SUPPOSED OT BE ???
C
                IF (WHATEX.EQ.'EXOROS'.AND.
     *                         E_OROS(NUCLEU,LEVELS).GE.0.000) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDOR(NUCLEU)
     *                            +E_OROS(NUCLEU,LEVELS)
                    LVPRIM=LVPRIM+1
C
                    IF (LVPRIM.EQ.1) EXPUPP=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               Using the shell model instead of experiment
C=======================================================================
C
                IF (WHATEX.EQ.'SHELLM'.AND.
     *                         ESHELM(NUCLEU,LEVELS).GE.0.000) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDLV(NUCLEU)
     *                            +ESHELM(NUCLEU,LEVELS)
                    LVPRIM=LVPRIM+1
C
                    IF (LVPRIM.EQ.1) EXPUPP=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               NEW experimental levels
C=======================================================================
C
C @@@ IRENE - WHAT ARE "NEW" LEVELS ???
C
                IF (WHATEX.EQ.'EXPNEW'.AND.
     *                         ENEWEX(NUCLEU,LEVELS).NE.-.99) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=ENEWEX(NUCLEU,LEVELS)
C
                    LVPRIM=LVPRIM+1
C
                    IF (LVPRIM.EQ.1) EXPUPP=EXPEXP(LEVEXP)

                END IF
C
C=======================================================================
C
                IF (LEVEXD.NE.LEVEXP) THEN
C
                    LEVEXD=LEVEXP
                    LABEXP(LEVEXP)=SYMBEX(NUCLEU,LEVELS)
C
                END IF
C
C=======================================================================
C
             END DO
C
             NEXIST=0
C
         END IF
C
C=======================================================================
C        Extracting the energies of the NEUTRON hole states
C=======================================================================
C
         IF (INEXPE(NUCLEU).EQ.IN_FIX-1 .AND. ISOSPI.EQ.0
     *                                  .AND.
     *       IZEXPE(NUCLEU).EQ.IZ_FIX)               THEN
C
             DO LEVELS=1,NOFEXP(NUCLEU)
C
C=======================================================================
C               Here true experimental data
C=======================================================================
C
                IF (WHATEX.EQ.'EXTRUE'.AND.
     *                         ENEXPE(NUCLEU,LEVELS).GE.0.0) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDLV(NUCLEU)
     *                            -ENEXPE(NUCLEU,LEVELS)
C
                    IF (LEVEXP.EQ.1) EXPLOW=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               Here corrections from A. Oros
C=======================================================================
C
                IF (WHATEX.EQ.'EXOROS'.AND.
     *                         E_OROS(NUCLEU,LEVELS).GE.0.0) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDOR(NUCLEU)
     *                            -E_OROS(NUCLEU,LEVELS)
C
                    IF (LEVEXP.EQ.1) EXPLOW=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               Here shell model instead of experiment
C=======================================================================
C
                IF (WHATEX.EQ.'SHELLM'.AND.
     *                         ESHELM(NUCLEU,LEVELS).GE.0.0) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDLV(NUCLEU)
     *                            -ESHELM(NUCLEU,LEVELS)
C
                    IF (LEVEXP.EQ.1) EXPLOW=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               NEW experimental levels
C=======================================================================
C
                IF (WHATEX.EQ.'EXPNEW'.AND.
     *                         ENEWEX(NUCLEU,LEVELS).NE.-.99)THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=ENEWEX(NUCLEU,LEVELS)
C
                   IF (LEVEXP.EQ.1) EXPLOW=EXPEXP(LEVEXP)

                END IF
C
C=======================================================================
C
                IF (LEVEXD.NE.LEVEXP) THEN
C
                    LEVEXD=LEVEXP
                    LABEXP(LEVEXP)=SYMBEX(NUCLEU,LEVELS)
C
                END IF
C
C=======================================================================
C
             END DO
C
             NEXIST=0
C
         END IF
C
C=======================================================================
C
         LVPRIM=0
C
C=======================================================================
C        Extracting the energies of the NEUTRON particle states
C=======================================================================
C
         IF (INEXPE(NUCLEU).EQ.IN_FIX+1.AND.ISOSPI.EQ.0
     *                                 .AND.
     *       IZEXPE(NUCLEU).EQ.IZ_FIX)             THEN
C
             DO LEVELS=1,NOFEXP(NUCLEU)
C
C=======================================================================
C               Here true experimental data
C=======================================================================
C
                IF (WHATEX.EQ.'EXTRUE'.AND.
     *                         ENEXPE(NUCLEU,LEVELS).GE.0.0) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDLV(NUCLEU)
     *                            +ENEXPE(NUCLEU,LEVELS)
C
                    LVPRIM=LVPRIM+1
C
                    IF (LVPRIM.EQ.1) EXPUPP=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               Here corrections from A. Oros
C=======================================================================
C
                IF (WHATEX.EQ.'EXOROS'.AND.
     *                         E_OROS(NUCLEU,LEVELS).GE.0.0) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDOR(NUCLEU)
     *                            +E_OROS(NUCLEU,LEVELS)
C
                    LVPRIM=LVPRIM+1
C
                    IF (LVPRIM.EQ.1) EXPUPP=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               Here shell model instead of experiment
C=======================================================================
C
                IF (WHATEX.EQ.'SHELLM'.AND.
     *                         ESHELM(NUCLEU,LEVELS).GE.0.0) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=BINDLV(NUCLEU)
     *                            +ESHELM(NUCLEU,LEVELS)
C
                    LVPRIM=LVPRIM+1
C
                    IF (LVPRIM.EQ.1) EXPUPP=EXPEXP(LEVEXP)
C
                END IF
C
C=======================================================================
C               NEW experimental levels
C=======================================================================
C
                IF (WHATEX.EQ.'EXPNEW'.AND.
     *                         ENEWEX(NUCLEU,LEVELS).NE.-.99) THEN
C
                    LEVEXP=LEVEXP+1
                    EXPEXP(LEVEXP)=ENEWEX(NUCLEU,LEVELS)
C
                    LVPRIM=LVPRIM+1
C
                    IF (LVPRIM.EQ.1) EXPUPP=EXPEXP(LEVEXP)

                END IF
C
C=======================================================================
C
                IF (LEVEXD.NE.LEVEXP) THEN
C
                    LEVEXD=LEVEXP
                    LABEXP(LEVEXP)=SYMBEX(NUCLEU,LEVELS)
C
                END IF
C
C=======================================================================
C
             END DO
C
             NEXIST=0
C
         END IF
C
C=======================================================================
C
      END DO
C
C=======================================================================
C     Ready with the determination of the experimental spectrum
C=======================================================================
C
      FERMEX=0.5*(EXPUPP+EXPLOW)
      GAPEXP=     EXPUPP-EXPLOW
C
      IEXPUP=0
      IEXPDW=0
C
      UPPMAX=-1000.0
      UPPMIN=+1000.0
      DWNMIN=+1000.0
      DWNMAX=-1000.0
C
      DO IEXPER=1,LEVEXP
C
         IF (EXPEXP(IEXPER).GT.FERMEX) THEN
C
             IF (UPPMAX.LE.EXPEXP(IEXPER)) UPPMAX=EXPEXP(IEXPER)
             IF (UPPMIN.GT.EXPEXP(IEXPER)) UPPMIN=EXPEXP(IEXPER)
C
C            Definig level degeneracies out of spectrscopic labels
C
             CALL READEG(IDEGEX(IEXPER),LABEXP(IEXPER))
C
             IEXPUP=IEXPUP+IDEGEX(IEXPER)
C
         END IF
C
         IF (EXPEXP(IEXPER).LT.FERMEX) THEN
C
             IF (DWNMIN.GE.EXPEXP(IEXPER)) DWNMIN=EXPEXP(IEXPER)
             IF (DWNMAX.LT.EXPEXP(IEXPER)) DWNMAX=EXPEXP(IEXPER)
C
C            Definig level degeneracies out of spectrscopic labels
C
             CALL READEG(IDEGEX(IEXPER),LABEXP(IEXPER))
C
             IEXPDW=IEXPDW+IDEGEX(IEXPER)
C
         END IF
C
      END DO
C
      RANGUP=UPPMAX-UPPMIN
      RANGDW=DWNMAX-DWNMIN
C
                       DENSUP=0.0
      IF (IEXPUP.NE.0) DENSUP=REAL(IEXPUP)/RANGUP
C
                       DENSDW=0.0
      IF (IEXPDW.NE.0) DENSDW=REAL(IEXPDW)/RANGDW
C
C=======================================================================
C=======================================================================
C     Ready with the reconstruction of the experimental spectra
C=======================================================================
C=======================================================================
C
      IF (NEXIST.EQ.1) THEN
C
          WRITE(LSCREN,'(//,80(''|''),/,''|'',78X,''|'',/,
     *                   ''|   WARNING: The experimental data for '',
     *                   ''the nucleus Z='',I3,'' N='',I3,
     *                   '' <=> NONEXISTING  |'',/,''|'',78X,''|'',/,
     *                                                   80(''|''),/)')
     *
     *                                                   IZ_FIX,IN_FIX
C
          IF (LOGWRI.GT.0)
     *    WRITE(LOGFIL,'(//,80(''|''),/,''|'',78X,''|'',/,
     *                   ''|   WARNING: The experimental data for '',
     *                   ''the nucleus Z='',I3,'' N='',I3,
     *                   '' <=> NONEXISTING  |'',/,''|'',78X,''|'',/,
     *                                                   80(''|''),/)')
     *
     *                                                   IZ_FIX,IN_FIX
C
          STOP 'No experimental data to fit to for this nucleus'
C
      END IF
C
C=======================================================================
C
      NORMAL=0
C
      DO IEXPER=1,LEVEXP
         NORMAL=NORMAL+IDEGEX(IEXPER)
      END DO
C
C=======================================================================
C     Ordering the experimental levels before writing them on disc
C=======================================================================
C
      DO LEVELS=1,LEVEXP
         ENEAUX(LEVELS)=EXPEXP(LEVELS)
         INDAUX(LEVELS)=LEVELS
      END DO
C
      CALL ORDHEA(ENEAUX,INDAUX,LEVEXP,NDSPEC)
C
C=======================================================================
C
      IF (ISOSPI.EQ.0) THEN
C
          IF (LOGWRI.GT.0) WRITE(LOGCHN,'(/,''From PREPAR_EXPLEV'',/)')
C
          IF (LOGWRI.GT.0) 
     * 
     *    WRITE(LOGCHN,'(/,80(''#''),/,''#'',78X,''#'',/,
     *           ''#  Experimental Levels for the Spherical '',
     *           ''Nucleus    Z ='',I3,''  N ='',I3,
     *           '' [Neutrons]  #'',
     *           /,''#                                         '',
     *           ''          Version ===>>>>   '',A6,''   #'',/,
     *           ''#'',78X,''#'',/,80(''#''),/,''#'',78X,''#'',/,
     *           ''#     Level              Energy        '',
     *           ''    State               Degen.          #'',/,
     *           ''#'',78X,''#'')')
     *
     *                                           IZ_FIX,IN_FIX,WHATEX
C
          IF (LOGWRI.GT.5)
     *
     *        WRITE(LOGFIL,'(9X,
     *                       ''Experimental Levels for the Spherical '',
     *                       ''Nucleus    Z ='',I3,''  N ='',I3,
     *                       '' [Neutrons]'',/,T59,
     *                       ''Version ===>>>>   '',A6,/,9X,
     *                       ''Level   Energy    State    Degen.'')')
     *
     *                                           IZ_FIX,IN_FIX,WHATEX
      ELSE
C
          IF (LOGWRI.GT.0) WRITE(LOGCHP,'(/,''From PREPAR_EXPLEV'',/)')
C
          IF (LOGWRI.GT.0)
     * 
     *    WRITE(LOGCHP,'(/,80(''#''),/,''#'',78X,''#'',/,
     *          ''#  Experimental Levels for the Spherical '',
     *          ''Nucleus    Z ='',I3,''  N ='',I3,
     *          ''  [Protons]  #'',
     *          /,''#                                         '',
     *          ''          Version ===>>>>   '',A6,''   #'',/,
     *          ''#'',78X,''#'',/,80(''#''),/,''#'',78X,''#'',/,
     *          ''#     Level              Energy        '',
     *          ''    State               Degen.          #'',/,
     *          ''#'',78X,''#'')')
     *
     *                                          IZ_FIX,IN_FIX,WHATEX
C
          IF (LOGWRI.GT.5)
     *
     *        WRITE(LOGFIL,'(9X,
     *                       ''Experimental Levels for the Spherical '',
     *                       ''Nucleus    Z ='',I3,''  N ='',I3,
     *                       ''  [Protons]'',/,T59,
     *                       ''Version ===>>>>   '',A6,/,9X,
     *                       ''Level   Energy    State    Degen.'')')
     *
     *                                          IZ_FIX,IN_FIX,WHATEX
C
      END IF
C
C=======================================================================
C
      DO IEXPER=1,LEVEXP
         LABAUX(IEXPER)=LABEXP(INDAUX(IEXPER))
         IDEAUX(IEXPER)=IDEGEX(INDAUX(IEXPER))
      END DO
C
      DO IEXPER=1,LEVEXP
         LABEXP(IEXPER)=LABAUX(IEXPER)
         IDEGEX(IEXPER)=IDEAUX(IEXPER)
         EXPEXP(IEXPER)=ENEAUX(IEXPER)
      END DO
C
C=======================================================================
C     This is the normal run with full experimental information
C=======================================================================
C
      IF (ISOSPI.EQ.1) THEN
C
          LEVEXP_PROTON(INUCLI)=LEVEXP
C	  
          DO IEXPER=1,LEVEXP
             LABEXP_PROTON(INUCLI,IEXPER)=LABEXP(IEXPER)
             IDEGEX_PROTON(INUCLI,IEXPER)=IDEGEX(IEXPER)
             EXPEXP_PROTON(INUCLI,IEXPER)=EXPEXP(IEXPER)
          END DO
C
      END IF
C
      IF (ISOSPI.EQ.0) THEN
C
          LEVEXP_NEUTRS(INUCLI)=LEVEXP
C	  
          DO IEXPER=1,LEVEXP
             LABEXP_NEUTRS(INUCLI,IEXPER)=LABEXP(IEXPER)
             IDEGEX_NEUTRS(INUCLI,IEXPER)=IDEGEX(IEXPER)
             EXPEXP_NEUTRS(INUCLI,IEXPER)=EXPEXP(IEXPER)
          END DO
C
      END IF
C
C=======================================================================
C     and this is a user-requested massacre of the real experiment
C     It consists in removing certain experimental levels from the
C     fit in order to study their influence on the parametrisation
C=======================================================================
C @@@ IRENE!  Is it in agreement with WHATNOTAKE?
      IF (REMOVE_PROTON.EQ.'YES') THEN
C
          IF (ISOSPI.EQ.1) THEN
C
              IXREAL=0
C	  
              DO IEXPER=1,LEVEXP
                 DO I=1,NDRAUS
                    IF (LABEXP(IEXPER).EQ.LABPRO_REMOVE(I)) THEN
                        IF (INDPRO_LETOUT(I).EQ.0) THEN
                            IXREAL=IXREAL+1 
                            LABEXP_PROTON(INUCLI,IXREAL)=LABEXP(IEXPER)
                            IDEGEX_PROTON(INUCLI,IXREAL)=IDEGEX(IEXPER)
                            EXPEXP_PROTON(INUCLI,IXREAL)=EXPEXP(IEXPER)
                        END IF
                    END IF
                 END DO
              END DO
C
              LEVEXP_PROTON(INUCLI)=IXREAL
C
          END IF
C
      END IF
C_______________________________________________________________________
C
      IF (REMOVE_NEUTRS.EQ.'YES') THEN
C
          IF (ISOSPI.EQ.0) THEN
C
              IXREAL=0
C	  
              DO IEXPER=1,LEVEXP
                 DO I=1,NDRAUS
                    IF (LABEXP(IEXPER).EQ.LABNEU_REMOVE(I)) THEN
                        IF (INDNEU_LETOUT(I).EQ.0) THEN
                            IXREAL=IXREAL+1 
                            LABEXP_NEUTRS(INUCLI,IXREAL)=LABEXP(IEXPER)
                            IDEGEX_NEUTRS(INUCLI,IXREAL)=IDEGEX(IEXPER)
                            EXPEXP_NEUTRS(INUCLI,IXREAL)=EXPEXP(IEXPER)
                        END IF
                    END IF
                 END DO
              END DO
C
              LEVEXP_NEUTRS(INUCLI)=IXREAL
C
          END IF
C
      END IF
C
C=======================================================================
C     Final printout Table
C=======================================================================
C
      DO IEXPER=1,LEVEXP
C        
         IF (LOGWRI.GT.0) THEN
             IF (ISOSPI.EQ.1) THEN
C
                 WRITE(LOGCHP,'(''#'',I8,14X,F8.4,12X,A6,15X,I2,
     *                                         ''             #'')')
     *                                       IEXPER,EXPEXP(IEXPER),
     *                                              LABEXP(IEXPER),
     *                                              IDEGEX(IEXPER)
             END IF
C
             IF (ISOSPI.EQ.0) THEN
C
                 WRITE(LOGCHN,'(''#'',I8,14X,F8.4,12X,A6,15X,I2,
     *                                         ''             #'')')
     *                                       IEXPER,EXPEXP(IEXPER),
     *                                              LABEXP(IEXPER),
     *                                              IDEGEX(IEXPER)
             END IF 
         END IF
C
         IF (LOGWRI.GT.5) THEN
C
             WRITE(LOGFIL,'(I12,4X,F7.3,4X,A6,4X,I2)')
     *                                       IEXPER,EXPEXP(IEXPER),
     *                                              LABEXP(IEXPER),
     *                                              IDEGEX(IEXPER)
         END IF
C
      END DO ! End IEXPER
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          IF (ISOSPI.EQ.1) THEN
              WRITE(LOGCHP,'(''#'',78X,''#'',/,80(''#''),/)')
          ELSE
              WRITE(LOGCHN,'(''#'',78X,''#'',/,80(''#''),/)')
          END IF
      END IF
C
C=======================================================================
C     The final level choice and possibly modified printout Table
C=======================================================================
C
      IF (REMOVE_PROTON.EQ.'YES') THEN
C
          IF (ISOSPI.EQ.1 .AND. LOGWRI.GT.0) THEN
C
              WRITE(LOGCHP,'(/,''Instead of the above: '',
     *                         ''The Actual Proton Table used'',/)')        
C
              WRITE(LOGCHP,'(/,80(''#''),/,''#'',78X,''#'',/,
     *              ''#  Experimental Levels for the Spherical '',
     *              ''Nucleus    Z ='',I3,''  N ='',I3,
     *              '' [Protons]   #'',
     *              /,''#                                         '',
     *              ''          Version ===>>>>   '',A6,''   #'',/,
     *              ''#'',78X,''#'',/,80(''#''),/,''#'',78X,''#'',/,
     *              ''#     Level              Energy        '',
     *              ''    State               Degen.          #'',/,
     *              ''#'',78X,''#'')')
     *                                       IZ_FIX,IN_FIX,WHATEX
C
              DO IEXPER=1,LEVEXP_PROTON(INUCLI)
C  
                 WRITE(LOGCHP,'(''#'',I8,14X,F8.4,12X,A6,15X,I2,
     *                                         ''             #'')')
     *                 IEXPER,EXPEXP_PROTON(INUCLI,IEXPER),
     *                        LABEXP_PROTON(INUCLI,IEXPER),
     *                        IDEGEX_PROTON(INUCLI,IEXPER)
C
              END DO
C
              WRITE(LOGCHP,'(''#'',78X,''#'',/,80(''#''),/)')
C
          END IF          
C
      END IF          
C_______________________________________________________________________
C
      IF (REMOVE_NEUTRS.EQ.'YES') THEN
C
          IF (ISOSPI.EQ.0 .AND. LOGWRI.GT.0) THEN
C
              WRITE(LOGCHN,'(/,''Instead of the above: '',
     *                         ''The Actual Neutron Table used'',/)')        
C
              WRITE(LOGCHN,'(/,80(''#''),/,''#'',78X,''#'',/,
     *              ''#  Experimental Levels for the Spherical '',
     *              ''Nucleus    Z ='',I3,''  N ='',I3,
     *              '' [Neutrons]  #'',
     *              /,''#                                         '',
     *              ''          Version ===>>>>   '',A6,''   #'',/,
     *              ''#'',78X,''#'',/,80(''#''),/,''#'',78X,''#'',/,
     *              ''#     Level              Energy        '',
     *              ''    State               Degen.          #'',/,
     *              ''#'',78X,''#'')')
     *
     *                                       IZ_FIX,IN_FIX,WHATEX
C        
              DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
C      
                 WRITE(LOGCHN,'(''#'',I8,14X,F8.4,12X,A6,15X,I2,
     *                                         ''             #'')')
     *                 IEXPER,EXPEXP_NEUTRS(INUCLI,IEXPER),
     *                        LABEXP_NEUTRS(INUCLI,IEXPER),
     *                        IDEGEX_NEUTRS(INUCLI,IEXPER)
C
              END DO
C         
              WRITE(LOGCHN,'(''#'',78X,''#'',/,80(''#''),/)')
C
          END IF         
C
      END IF         
C
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(9X,''Exiting  PREPAR_EXPLEV'')')
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE RDPROT_RMSRAD(NDRADZ,RADPRO,CHGRMS,RERROR,IZ_FIX,
     *                                                     IN_FIX,
     *                                              IFEXPE,IPRINT)
C
      CHARACTER
     *          FILNAM*256
C
      DIMENSION
     *          IZNUCL(1:NDRADZ),INNUCL(1:NDRADZ),I_MASS(1:NDRADZ)
      DIMENSION
     *          RMSCHG(1:NDRADZ),CHGERR(1:NDRADZ),RMSPRO(1:NDRADZ)
      DIMENSION
     *          DELRAD(1:NDRADZ),DELERR(1:NDRADZ),
     *          AUXRMS(1:NDRADZ),AUXERR(1:NDRADZ)
      DIMENSION
     *          SPINGS(1:NDRADZ)
C
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON
     *       /WHERBE/ IRUNMI,NEWOLD 
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C
      DATA
     *     CHPROT / +0.743 /,
     *     CHNEUT / -0.119 /
      DATA
     *     N_READ / 80 /
C
C=======================================================================
C
C     Subroutine reading the experimental proton root-mean-square
C     radii from the data file ws_exper/exp_rms_radii one nucleus
C                                                       at a time
C=======================================================================
C
C     CHPROT and CHNEUT are the mean square radii of the charge
C     distributions in a proton and a neutron, respectively.
C     (cf. Eq.(3) J. Dobaczewski et al., Z.Phys A354, 27-35 (1996))
C
C=======================================================================
C
      RADPRO=-1.0
      CHGRMS=-1.0
      RERROR= 0.0
C
      IFOUND=0
C
C=======================================================================
C
      WRITE(NOUTPT,'(//3(80(1H*),/),                             /,
     *         9(1H*),''   READING  THE  EXPERIMENTAL  RESULTS '',
     *                 '' FROM  RDPROT_RMSRAD   ''
     *          9(1H*),//,                              3(80(1H*),/))')
C
C=======================================================================
C
      FILNAM='ws_exper/exp_rms_radii.d'
C
      OPEN(N_READ,FILE=FILNAM,STATUS='UNKNOWN',FORM='FORMATTED')
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(12X,''Opening the file '',
     *                       ''ws_exper/exp_rms_radii for protons'')')
      END IF
C
      READ(N_READ,'(A80)') STRING
C
      NCOUNT=1
C
C=======================================================================
C
   1  CONTINUE
C
C=======================================================================
C
      READ (N_READ,*,END=2) IZNUCL(NCOUNT),INNUCL(NCOUNT),
     *                                     I_MASS(NCOUNT),
     *                                     SPINGS(NCOUNT),
     *                      DELRAD(NCOUNT),DELERR(NCOUNT),
     *                      AUXRMS(NCOUNT),AUXERR(NCOUNT)
C
C=======================================================================
C
      RMSCHG(NCOUNT)=AUXRMS(NCOUNT)+DELRAD(NCOUNT)
C
      IF (AUXRMS(NCOUNT).LT.0.0001) RMSCHG(NCOUNT)=-1.0
C
      CHGERR(NCOUNT)=AUXERR(NCOUNT)+DELERR(NCOUNT)
C
C=======================================================================
C
      IF (RMSCHG(NCOUNT).GT.0.0001) THEN
C
          RMSPRO(NCOUNT)=SQRT(RMSCHG(NCOUNT)**2
     *                  -CHPROT
     *                  -CHNEUT*REAL(INNUCL(NCOUNT))
     *                         /REAL(IZNUCL(NCOUNT)))
      ELSE
          RMSPRO(NCOUNT)=-1.0
      END IF
C
C=======================================================================
C
      IF (IZNUCL(NCOUNT).EQ.0) GO TO 2
C
C=======================================================================
C
      NCOUNT=NCOUNT+1
C
      GO TO 1
C
   2  CONTINUE
C
C=======================================================================
C     If the experimental information about our nucleus exists in
C     the data-bank, this is perfect
C=======================================================================
C
      DO I=1,NCOUNT
C
         IF ((IZNUCL(I).EQ.IZ_FIX).AND.(INNUCL(I).EQ.IN_FIX)) THEN
C
             IFOUND=1
C
             RADPRO=RMSPRO(I)
             CHGRMS=RMSCHG(I)
             RERROR=CHGERR(I)
             IFOUNX=IFOUND
C
         END IF
      END DO
C 
C=======================================================================
C     If the experimental information does not exist we calculate
C     the RMS radii using the Pomorski & Pomorski formula. 
C
C     ID has verified (23/03/2016) that for the PROTONS, 
C     the Pomorski & Pomorski formula fits better to the 
C     experimental results that the one from Dobaczewski 
C                                                article.
C=======================================================================
C
      IF (IFOUND.EQ.0) THEN
C
          A_MASS=REAL(IN_FIX+IZ_FIX)
          GEOMFA=SQRT(3.0000/5.0000)
C
          RADPOM=1.240*GEOMFA*(1.0+1.646/A_MASS
     *                            -0.191/A_MASS*REAL(IN_FIX-IZ_FIX))
     *                       *A_MASS**(1.0/3.0)
C
          RADPRO=SQRT(RADPOM**2-0.743
     *                         +0.119*REAL(IN_FIX)/REAL(IZ_FIX))     
          CHGRMS=RADPOM
C
C         Using the typical formula of RMSD with the ones known 
C         experimentally and the theory, we get RERROR=0.04
C
          RERROR=0.04   
C
          IFOUNX=IFOUND
C
          IFOUND=1
C      
      END IF
C
C=======================================================================
C
      IF (IFOUND.EQ.1) THEN
C
          IF (LOGWRI.GT.4) THEN
C
              WRITE(LOGFIL,'(12X,''Experimental proton radius '',
     *                           ''information: RADPRO='',F5.3,1X,
     *                           ''CHGRMS='',F5.3,1X,
     *                           ''RERROR='',F5.3,2X,''IFOUND='',I2)')
     *                             RADPRO,CHGRMS,RERROR,IFOUND
C
          END IF
          
          WRITE(NOUTPT,'(''IZ_FIX= '',I3,3X,''IN_FIX= '',I3)') IZ_FIX,
     *                                                         IN_FIX
          WRITE(NOUTPT,'(''RADPRO='',F5.3,'' CHGRMS='',F5.3,1X,
     *                   ''RERROR='',F5.3)') RADPRO,CHGRMS,RERROR
C
      ELSE
C
          IF (LOGWRI.GT.4) THEN
C
              WRITE(LOGFIL,'(9X,''No experimental information about '',
     *                          ''proton radii for the nucleus Z='',I3,
     *                                                     ''  N='',I3
     *                                                              )')
     *
     *                                                    IZ_FIX,IN_FIX
C
          END IF
C
      END IF
C
C=======================================================================
C
      CLOSE(N_READ)
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(9X,''Exiting  RDPROT_RMSRAD'')')
      END IF 
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE PROVID_RMS_NR(NDRADN,RADNEU,ERRNEU,IZ_FIX,IN_FIX,
     *                                       IDEFCN,IFEXPE,IPRINT)
C
      DIMENSION
     *          IZNUCL(1:NDRADN),INNUCL(1:NDRADN)
      DIMENSION
     *          ERRORN(1:NDRADN),RMSNEU(1:NDRADN)
C
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON
     *       /WHERBE/ IRUNMI,NEWOLD 
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C     Subroutine providing the experimental neutron r.m.s. radii
C=======================================================================
C
      IF (IDEFCN.GT.1) THEN
          RETURN
      END IF
C
C=======================================================================
C 
C     Experimental neutron rms radii: Table 1, J. Dobaczewski et al.,
C                                              Z.Phys. A354, 27 (1996) 
C
      RADNEU=-1.0
      ERRNEU= 0.0
C
      IFOUND=0
C
      NCOUNT=1
      IZNUCL(NCOUNT)=20
      INNUCL(NCOUNT)=20
      RMSNEU(NCOUNT)=3.49
      ERRORN(NCOUNT)=0.05
C
      NCOUNT=2
      IZNUCL(NCOUNT)=20
      INNUCL(NCOUNT)=28
      RMSNEU(NCOUNT)=3.63
      ERRORN(NCOUNT)=0.05
C
      NCOUNT=3
      IZNUCL(NCOUNT)=28
      INNUCL(NCOUNT)=30
      RMSNEU(NCOUNT)=3.70
      ERRORN(NCOUNT)=0.05
C
      NCOUNT=4
      IZNUCL(NCOUNT)=28
      INNUCL(NCOUNT)=36
      RMSNEU(NCOUNT)=3.91
      ERRORN(NCOUNT)=0.05
C
      NCOUNT=5
      IZNUCL(NCOUNT)=40
      INNUCL(NCOUNT)=50
      RMSNEU(NCOUNT)=4.29
      ERRORN(NCOUNT)=0.07
C
      NCOUNT=6
      IZNUCL(NCOUNT)=50
      INNUCL(NCOUNT)=66
      RMSNEU(NCOUNT)=4.69
      ERRORN(NCOUNT)=0.05
C
      NCOUNT=7
      IZNUCL(NCOUNT)=50
      INNUCL(NCOUNT)=74
      RMSNEU(NCOUNT)=4.85
      ERRORN(NCOUNT)=0.05
C
      NCOUNT=8
      IZNUCL(NCOUNT)=82
      INNUCL(NCOUNT)=126
      RMSNEU(NCOUNT)=5.59
      ERRORN(NCOUNT)=0.04
C
C=======================================================================
C     This in the case where the experimental information on the current
C                                                         nucleus exists
C=======================================================================
C
      DO I=1,NCOUNT
C
         IF (IZNUCL(I).EQ.IZ_FIX.AND.INNUCL(I).EQ.IN_FIX) THEN
C
             RADNEU=RMSNEU(I)
             ERRNEU=ERRORN(I)
C
             IFOUND=1
C
             IF (LOGWRI.GT.4) THEN
C
                 WRITE(LOGFIL,'(12X,
     *                         ''The corresponding neutron radius'',
     *                          3X,''RMSNEU='',F5.3,''  ERRNEU='',F5.3
     *                                                              )')
     *                               RADNEU,            ERRNEU
             END IF
C
         END IF
C
      END DO
C
C=======================================================================
C     In the opposite case i.e. the experimental information does not 
C     exist, we estimate the neutron radius using Pomorski & Pomorski
C     formula
C=======================================================================
C
      IF (IFOUND.EQ.0) THEN
C
C=======================================================================
C
C         It has been verified,  that the experimentally known  neutron
C         data points agree slightly better with results from  
C
C                              'PHENOM_RMSRAD',
C
C         rather than  with the formula(s) by Pomorski & Pomorski, from 
C         Nucl.Phys. A635, 1998, 484. We keep it however as a comment
C
CID:
C         The authors have verified it...: citing textually:
C
C         Formula (6) improves the expression used in [30] by adding
C         terms proportional to A^{-2}
C
C         Where formula (6) is the one from Dobaczewski et al., 
C         and [30] refers to Pomorska and Pomorski article.
CID.
C
C=======================================================================
C
C         Neutron RMS Radii coming from Nucl.Phys. A635, 1998, 484
C
C         A_MASS=REAL(IN_FIX+IZ_FIX)
C         GEOMFA=SQRT(3.0/5.0)
C
C         RADNEU=1.176*GEOMFA*(1.0+0.250*REAL(IN_FIX-IZ_FIX)/A_MASS
C     *                           +2.806/A_MASS)*A_MASS**(1.0/3.0)
C
C=======================================================================
C 
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(12X,''Entering PHENOM_RMSRAD from '',
     *                           ''PROVID_RMS_NR - case IFOUND=0'')')
          END IF
C
          CALL PHENOM_RMSRAD(IZ_FIX,IN_FIX,RADNEU,RADUMY)
C
C         Using the typical formula of RMSD with the ones known 
C         experimentally and the theory, we get RERROR=0.07
C 
          ERRNEU=0.07
C
          IFOUND=1
C
      END IF
C
C=======================================================================
C
      IF (IFOUND.EQ.0) THEN
C
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(9X,''No neutron  information  found '',
     *                          ''case IFOUND=0'')')
          END IF
C
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(9X,''Exiting  PROVID_RMS_NR'')')
      END IF 
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE PHENOM_RMSRAD(IZ_FIX,IN_FIX,RADNEU,RADPRO)
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C
      DATA
     *     R0PARN, R0PARP / 1.1760,+1.2140 /
      DATA
     *     ALFA1N, ALFA1P / 0.1341,-0.1233 /
      DATA
     *     ALFA2N, ALFA2P / 4.8280,-3.4840 /
      DATA
     *     XAPA1N, XAPA1P / 3.2640,+2.6390 /
      DATA
     *     XAPA2N, XAPA2P / -.7121,+0.2543 /
C
C=======================================================================
C
C     This subroutine defines simple fit expressions, based on rather 
C     extensive HF Skyrme calculations, with the SkP parameterisation
C     from J. Dobaczewski et al., Z.Phys. A354, 27 (1996) 
C
C @@@ IRENE, please verify on some occasion whether this is true???????????
C
C     It has been verified, that the experimentally known data points
C     agree slightly better with this,  rather than with the formulas 
C     by Pomorska & Pomorski from Nucl. Phys. A635, 1998, 484.
C
C=======================================================================
C
      A_MASS=REAL(IN_FIX+IZ_FIX)
      DIFFER=REAL(IN_FIX-IZ_FIX)
C
      EXPRES=1.0+XAPA1N/A_MASS
     *          +ALFA1N*DIFFER/A_MASS
     *          +XAPA2N/A_MASS**2
     *          +ALFA2N*DIFFER/A_MASS**2
C
      FACTOR=SQRT(3./5.)*R0PARN*A_MASS**(1./3.)
C      
      RADNEU=FACTOR*EXPRES     
C
C=======================================================================
C
      EXPRES=1.0+XAPA1P/A_MASS
     *          +ALFA1P*DIFFER/A_MASS
     *          +XAPA2P/A_MASS**2
     *          +ALFA2P*DIFFER/A_MASS**2
C
      FACTOR=SQRT(3./5.)*R0PARP*A_MASS**(1./3.)
C      
      RADPRO=FACTOR*EXPRES     
C
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(16X,''From PHENOM_RMSRAD: Fit to HF with SkP'',
     *                 /,16X,''(since no real experimental data found)''
     *                                                               )')
          WRITE(LOGFIL,'(16X,''RADPRO='',F6.3,'' RADNEU='',F6.3)')
     *                         RADPRO,           RADNEU
      END IF
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(12X,''Exiting  PHENOM_RMSRAD'')')
      END IF
C
C=======================================================================
C
      RETURN
      END                
C
C=======================================================================
C=======================================================================
C 
      SUBROUTINE PREPAR_DENEXP
C      
      INCLUDE  'MATDIM/N_SUMS.f'
      INCLUDE  'MATDIM/ND_RHO.f'
      INCLUDE  'MATDIM/N_NOYX.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/NDIM_N.f'
C
      EXTERNAL
     *         DENEXP_INTEGR,RMSEXP_INTEGR
C      
      CHARACTER 
     *          SYMBNU*5,NUCSYM*6  
C
      DIMENSION
     *          COEFFI(1:N_SUMS,1:N_NOYX),RADIUS(1:N_NOYX)
C
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)   
      COMMON
     *       /EXPDEN/ LABELN(1:N_NOYX,1:2),
     *                R_MESH(1:ND_RHO,1:N_NOYX),
     *                RHOEXP(1:ND_RHO,1:N_NOYX)
     *
     *       /EXPSYM/ SYMBNU(1:N_NOYX)
      COMMON
     *       /BESSEL/ COEFFI_BESSEL(1:N_SUMS,1:NDNUCL)
      COMMON
     *       /CUTOFF/ RADIUS_CUTOFF(1:NDNUCL) 
      COMMON
     *       /ARGUMN/ IARG_R,IARG_Z
      COMMON
     *       /SIMUSE/ AOSCIL,RADCUT,INUCLI
      COMMON
     *       /NUCLEU/ IX_FIX,IN_FIX,ISOSPI
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C
C=======================================================================
C
C     This SUBROUTINE reads the experimental data for charge-densities
C
C=======================================================================
C
C     IARG_R and IARG_Z are used in order to choose if we want to 
C     integrate over small r or over z.
C
C     IARG_R=1 - the integration will be done over r
C
C     IARG_Z=1 - the integration will be done over z
C
C=======================================================================
C
      PINUMB=4.0*ATAN(1.0)
C
C=======================================================================
C 
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(/,12X,''Entering READEX_DENSIT from '',
     *                         ''PREPAR_DENEXP, protons only'')')
      END IF
C
      CALL READEX_DENSIT(N_SUMS,N_NOYX,COEFFI,SYMBNU,LABELN,RADIUS)
C
C=======================================================================
C
      ISOSPI=1
C
C=======================================================================
C
C     Rearranging the vectors COEFFI and RADIUS to the new vectors
C     COEFFI_BESSEL and RADIUS_CUTOFF, respectively, in order to
C     have them referenced to INUCLI and not to I_NOYX.
C
      DO INUCLI=1,LDNUCL
         RADIUS_CUTOFF(INUCLI)=0.0
         DO I_SUMS=1,N_SUMS
            COEFFI_BESSEL(I_SUMS,INUCLI)=0.0
         END DO
      END DO
C
      DO INUCLI=1,LDNUCL
         DO I_NOYX=1,N_NOYX
C
            IF (LABELN(I_NOYX,1).EQ.NUMB_Z(INUCLI) .AND.
     *          LABELN(I_NOYX,2).EQ.NUMB_N(INUCLI)) THEN
C
                RADIUS_CUTOFF(INUCLI)=RADIUS(I_NOYX)
C
                DO I_SUMS=1,N_SUMS
                   COEFFI_BESSEL(I_SUMS,INUCLI)=COEFFI(I_SUMS,I_NOYX)
                END DO
C
            END IF
         END DO
      END DO
C
C=======================================================================
C
C     Checking if we obtain the particle number with the experimental
C     charge density. We also compare the rms radius that we obtain
C     using this density with RMSEXP_PROTON (read from RDPROT_RMSRAD)
C
C     The integration is done with the Simpson Method.
C
      IARG_R=1
      IARG_Z=0
C
      DO INUCLI=1,LDNUCL
C                                      INUCLI,AOSCIL,RADCUT pass via 
         AOSCIL=AOSCIL_PROTON(INUCLI)                       ! COMMON
         RADCUT=RADIUS_CUTOFF(INUCLI)
C
         DO I_NOYX=1,N_NOYX
C
            IF (LABELN(I_NOYX,1).EQ.NUMB_Z(INUCLI) .AND.
     *          LABELN(I_NOYX,2).EQ.NUMB_N(INUCLI)) THEN
C
                IZ_FIX=NUMB_Z(INUCLI)
                A=0.00001
                B=12.0
                N=40
C_______________________________________________________________________
C
                IF (LOGWRI.GT.4) THEN
                    WRITE(LOGFIL,'(/,12X,''Entering SIMPSN_INTEGR '',
     *                             ''from PREPAR_DENEXP to test '',
     *                             ''DENEXP'')')
                END IF
C
                CALL SIMPSN_INTEGR(A,B,N,DENEXP_INTEGR,SIMDEN,ERROR1)
C
                DIFFER=ABS(SIMDEN-IZ_FIX)
C
                IF (LOGWRI.GT.4) THEN
C
                    WRITE(LOGFIL,'(/,12X,''Test summary: DENSITY'')')
C
                    WRITE(LOGFIL,'(15X,''Integral of DENEXP for '',
     *                 ''INUCLI= '',I1,'' with N='',i3,1X,
     *                 ''from A=0 to B=12 is:'',2X,f20.13)') INUCLI,N,
     *                                                       SIMDEN
C
                    WRITE(LOGFIL,'(15X,''Nominal integration error '',
     *                          ''df/dx=1, in SIMPSN_INTEGR:      '',
     *                          ''ERRORS= '',F20.13)') ERROR1
C
                    IF (DIFFER.GT.10.0*ERROR1) THEN
C
                        WRITE(LOGFIL,'(15X,''WARNING: DIFFER='',F20.13,
     *                                 1X,''is > 10*ERROR1= '',F20.13)')
     *                                                  DIFFER,10*ERROR1
                    END IF
C
                END IF
C_______________________________________________________________________
C
                IF (LOGWRI.GT.4) THEN
                    WRITE(LOGFIL,'(/,12X,''Entering SIMPSN_INTEGR '',
     *                                   ''from PREPAR_DENEXP for '',
     *                                   ''RMSEXP'')')
                END IF
C
                CALL SIMPSN_INTEGR(A,B,N,RMSEXP_INTEGR,SIMRMS,ERROR2)
C
                ERRORT=(SIMRMS/SIMDEN)*(ERROR1/SIMDEN+ERROR2/SIMRMS)
C
                SIMRMS=SIMRMS/SIMDEN 
C
                DIFFER=(SQRT(SIMRMS)-RMSEXP_PROTON(INUCLI))
C
                IF (LOGWRI.GT.4) THEN
C
                    WRITE(LOGFIL,'(/,12X,''Test summary: RADIUS'')')
C
                    WRITE(LOGFIL,'(12X,''R.M.S. from RMSEXP for '',
     *               ''INUCLI= '',I3,'' from A=0 to B=12 is:'',2X,
     *               f20.13,/,T57,''R.M.S.-exp='',f22.13)')INUCLI,
     *                                               SQRT(SIMRMS),
     *                                      RMSEXP_PROTON(INUCLI)
C
                    WRITE(LOGFIL,'(12X,''The difference between '',
     *                               ''expected and obtained is:'',
     *                                               9X,f20.13)') DIFFER
C
                    WRITE(LOGFIL,'(9X,''Nominal integration error '',
     *                         ''df/dx=1 in SIMPSN_INTEGR: ERRORS= '',
     *                                               F20.13)') ERRORT
C
                END IF
C_______________________________________________________________________
C
            END IF
C
         END DO
C
      END DO
C 
C=======================================================================
C 
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(/,''Exiting  PREPAR_DENEXP'')')
      END IF
C
C=======================================================================
C          
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE READEX_DENSIT(N_SUMS,N_NOYX,COEFFI,SYMBNU,LABELN,
     *                                                     RADIUS)
C 
      PARAMETER 
     *         (N_UNIT=60)
C       
      CHARACTER 
     *          FILENA*80,KEYWOR*5,ENDNOY*5,SYMBNU*5
C
      DIMENSION
     *          RADIUS(1:N_NOYX),COEFFI(1:N_SUMS,1:N_NOYX)
      DIMENSION
     *          LABELN(1:N_NOYX,1:2)
      DIMENSION
     *          SYMBNU(1:N_NOYX)
C
      COMMON
     *         /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                  LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                  NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                     LOGBIS                                                 
C
C=======================================================================
C
C     This subroutine  reads the coefficients of the Bessel expansion 
C     expressing the nuclear charge density. Data in "data_densities"
C
C=======================================================================
C        
      FILENA='dens_exper/data_density.d'
C       
      OPEN(N_UNIT,FILE=FILENA,FORM='FORMATTED',IOSTAT=IRC) 
C     
      IF (IRC.NE.0) STOP 'Error in opening the file - READEX_DENSIT'
C
C=======================================================================
C       
      I_NOYX=0
      RADAUX=0.0
C
C=======================================================================
C      
   1  CONTINUE
                                                    KEYWOR='      '
      READ(N_UNIT,'(A5,2X,I3,2X,I3,4X,F7.4)',END=2) KEYWOR,
     *                                IZ_FIX,IN_FIX,RADAUX
C 
      IF (KEYWOR.EQ.'ENDGO') THEN
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(12X,''Exiting  READEX_DENSIT'')')
          END IF
          RETURN
      END IF      
C      
      IF (KEYWOR(3:4).NE.'  ') THEN
          
          I_NOYX=I_NOYX+1
          LABELN(I_NOYX,1)=IZ_FIX
          LABELN(I_NOYX,2)=IN_FIX         
          SYMBNU(I_NOYX)=KEYWOR
          RADIUS(I_NOYX)=RADAUX
C          
          DO I_SERI=1,N_SUMS
             READ(N_UNIT,'(9X,E13.5)') COEFFI(I_SERI,I_NOYX)
          END DO
         
          READ(N_UNIT,*) ENDNOY
         
          IF (ENDNOY.EQ.'XXXXXX') THEN
              GO TO 1
          END IF
C     
      END IF
C      
      GO TO 1
C      
   2  CONTINUE
C
      STOP 'ENDGO STATEMENT MISSING'
C
C=======================================================================
C      
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE WRITIT_DENPLO(ND_RHO,N_NOYX,R_MESH,RHOEXP,SYMBNU,
     *                                                     LABELN)
C
      PARAMETER 
     *         (N_UNIT=70)
C           
      CHARACTER 
     *          FILENA*256,FILTAB*256,SYMBNU*5
C
      DIMENSION 
     *          RHOEXP(1:ND_RHO,1:N_NOYX),R_MESH(1:ND_RHO,1:N_NOYX)
      DIMENSION
     *          LABELN(1:N_NOYX,1:2)
      DIMENSION 
     *          SYMBNU(1:N_NOYX),
     *          FILTAB(1:N_NOYX)
C
      COMMON
     *         /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                  LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                  NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                     LOGBIS
C
C======================================================================
C
C     This subroutine writes the nuclear charge density in the files
C     "density_zXXX_nXXX.dat" in the format ready for plotting
C
C======================================================================
C       
      FILTAB(1)='dens_exper/density_z008_n008.dat'
      FILTAB(2)='dens_exper/density_z020_n020.dat'
      FILTAB(3)='dens_exper/density_z020_n028.dat'
      FILTAB(4)='dens_exper/density_z040_n050.dat'
      FILTAB(5)='dens_exper/density_z082_n126.dat'
C
C======================================================================
C     
      DO I_NOYX=1,N_NOYX 
C   
         FILENA=FILTAB(I_NOYX)
C
         IF (LOGWRI.GT.0) THEN
             WRITE(LOGFIL,'(15X,''Writing densities to: '',A)') FILENA
         END IF
C          
         OPEN(N_UNIT,FILE=FILENA,FORM='FORMATTED',IOSTAT=IRC) 
C     
         IF (IRC.NE.0) STOP 'Error in opening the file - WRITIT_DENPLO'
           
         WRITE(N_UNIT,'(A5,2X,I3,2X,I3)') SYMBNU(I_NOYX),
     *                   LABELN(I_NOYX,1),LABELN(I_NOYX,2)       
C          
         DO ID_RHO=1,ND_RHO
            WRITE(N_UNIT,'(10X,F7.4,2X,F7.4)') R_MESH(ID_RHO,I_NOYX),
     *                                         RHOEXP(ID_RHO,I_NOYX)
         END DO
C
         WRITE(N_UNIT,'(A6)') 'XXXXXX'
C          
         REWIND(N_UNIT)
C
         CLOSE (N_UNIT)
C        
      END DO
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(12X,''Exiting  WRITIT_DENPLO'')')
      END IF
C
C======================================================================
C      
      RETURN
      END        
C
C=======================================================================
C=======================================================================
C
      FUNCTION DENEXP(XARGUM)
C      
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/N_SUMS.f'
C
      COMMON
     *       /BESSEL/ COEFFI_BESSEL(1:N_SUMS,1:NDNUCL)
      COMMON
     *       /ARGUMN/ IARG_R,IARG_Z
      COMMON
     *       /SIMUSE/ AOSCIL,RADCUT,INUCLI
C
C=======================================================================
C
C     IARG_R and IARG_Z are used in order to choose if we want to 
C     integrate over small r or over z.
C
C     IARG_R=1 - the integration will be done over r
C
C     IARG_Z=1 - the integration will be done over z
C
C=======================================================================
C
      PINUMB=4*ATAN(1.0)
C
C=======================================================================
C
      IF (IARG_R.EQ.1) THEN
          RARGUM=XARGUM
      END IF
      IF (IARG_Z.EQ.1) THEN
          RARGUM=AOSCIL*SQRT(XARGUM)
      END IF
C
C=======================================================================
C
      IF (RARGUM.LE.RADCUT) THEN
          AUXILI=0.0
          DO I_SUMS=1,N_SUMS
             AUXARG=I_SUMS*PINUMB*RARGUM/RADCUT
             AUXILI=AUXILI+COEFFI_BESSEL(I_SUMS,INUCLI)
     *                    *SIN(AUXARG)/AUXARG
          END DO
      END IF
C
      IF (RARGUM.GT.RADCUT) THEN
          AUXILI=0.0
      END IF
C
C=======================================================================
C
      DENEXP=AUXILI
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE READIN_PSEUDO
C
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDLEXP.f'
C
      CHARACTER
     *          KEYWOR*10,STRING*10,
     *          LABPRO_PSEUDO*6,LABNEU_PSEUDO*6
C
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /PSEUDO_ZN_NUM/ IZ_PSE(1:NDNUCL),
     *                       IN_PSE(1:NDNUCL)
      COMMON
     *       /PSEUDO_LEVELS/ LEVNEU_PSEUDO(1:NDNUCL),
     *                       LEVPRO_PSEUDO(1:NDNUCL)
      COMMON
     *       /PSEUDO_PROTON/ ENEPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LABPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       SIGPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       IDEPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LEVTAK_PROTON(1:NDLEXP,1:NDNUCL)
      COMMON
     *       /PSEUDO_NEUTRS/ ENENEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LABNEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       SIGNEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       IDENEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LEVTAK_NEUTRS(1:NDLEXP,1:NDNUCL)
      COMMON
     *         /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                  LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                  NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                     LOGBIS
C     
C=======================================================================
C
      N_READ_PSEUDO=8
C
      IF (IFDENS.EQ.0)
     *    OPEN(UNIT=N_READ_PSEUDO,FILE='ws15_pseudo-exper_IFDENS-0.d')
      IF (IFDENS.EQ.1)
     *    OPEN(UNIT=N_READ_PSEUDO,FILE='ws15_pseudo-exper_IFDENS-1.d')
C
      WRITE(LOGFIL,'(/,''Opening ws15_pseudo-exper.d for reading it'',
     *                                                            /)')
C
   1  CONTINUE     
C     
C=======================================================================
C     
      READ (N_READ_PSEUDO,'(A10)',END=2)  KEYWOR  
C
C=======================================================================
C
      IF (KEYWOR.EQ.'HOWMANYNUC') THEN
C
          READ(N_READ_PSEUDO,*) LDNUCL
          WRITE(LOGFIL,'(A10,I4)') KEYWOR,LDNUCL
C
          DO I=1,LDNUCL
C
             READ(N_READ_PSEUDO,*)STRING                  ! NUCLEUS-XX
             WRITE(LOGFIL,'(A,/)') STRING
C
             READ(N_READ_PSEUDO,*)IZ_PSE(I),IN_PSE(I)
             READ(N_READ_PSEUDO,*)STRING                  ! ISOSPI  NUMLEV
             READ(N_READ_PSEUDO,*)ISOSPI,LEVNEU_PSEUDO(I)
             READ(N_READ_PSEUDO,*)STRING                  ! PSEUDO...
C
             DO J=1,LEVNEU_PSEUDO(I)
                READ(N_READ_PSEUDO,'(11X,F17.13,2X,I6,2X,A6,2X,F6.4,
     *                                4X,I1)') ENENEU_PSEUDO(J,I),
     *                                         IDENEU_PSEUDO(J,I),
     *                                         LABNEU_PSEUDO(J,I),
     *                                         SIGNEU_PSEUDO(J,I),
     *                                         LEVTAK_NEUTRS(J,I)
C
                WRITE(LOGFIL,'(11X,F17.13,2X,I6,2X,A6,2X,F6.4,4X,I1)')
     *                               ENENEU_PSEUDO(J,I),
     *                               IDENEU_PSEUDO(J,I),
     *                               LABNEU_PSEUDO(J,I),
     *                               SIGNEU_PSEUDO(J,I),
     *                               LEVTAK_NEUTRS(J,I)
             END DO
C
             READ(N_READ_PSEUDO,*)STRING                  ! ISOSPI  NUMLEV
             READ(N_READ_PSEUDO,*)ISOSPI,LEVPRO_PSEUDO(I)
             READ(N_READ_PSEUDO,*)STRING                  ! PSEUDO...
C
             WRITE(LOGFIL,'()')
C
             DO J=1,LEVPRO_PSEUDO(I)
                READ(N_READ_PSEUDO,'(11X,F17.13,2X,I6,2X,A6,2X,F6.4,
     *                                4X,I1)')
     *                               ENEPRO_PSEUDO(J,I),
     *                               IDEPRO_PSEUDO(J,I),
     *                               LABPRO_PSEUDO(J,I),
     *                               SIGPRO_PSEUDO(J,I),
     *                               LEVTAK_PROTON(J,I)
C
                WRITE(LOGFIL,'(11X,F17.13,2X,I6,2X,A6,2X,F6.4,4X,I1)')
     *                               ENEPRO_PSEUDO(J,I),
     *                               IDEPRO_PSEUDO(J,I),
     *                               LABPRO_PSEUDO(J,I),
     *                               SIGPRO_PSEUDO(J,I),
     *                               LEVTAK_PROTON(J,I)
             END DO
C
             READ(N_READ_PSEUDO,*)STRING                  ! <<>>
C
          END DO
C
      END IF
C
C=======================================================================
C
      IF (KEYWOR.EQ.'EXECUTE-GO') THEN
C
C=======================================================================
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,''Exiting  READIN_PSEUDO'')')
          END IF
C
          RETURN
C
      END IF
C
C=======================================================================
C                           Scanning continues
C=======================================================================
C
      GO TO  1
C
C=======================================================================
C
   2  CONTINUE
C
C=======================================================================
C     Illegal end of file in the input data stream
C=======================================================================
C
      WRITE(NOUTPT,'(//,''Something wrong with the structure of the '',
     *             ''input file - perhaps forgotten <EXECUTESET> ?'')')
C
C=======================================================================
C                    Forgotten 'EXECUTESET' statement ? ?
C=======================================================================
C
      WRITE(NOUTPT,'(''No "EXECUTE-GO" in the input data stream '',
     *               ''(in READIN_PSEUDO)'')')
C   
      STOP
     *
     *   'Wrong input structure, eof not allowed here, STOP from PSEUDO'
C
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE CREATG_TITLES(NDTITL,NDNUCL,TITLES,TITLES_LATEXS,
     *                                PARPOT_UNITSS,NUCNAM_LATEXS)
C
      INCLUDE
     *         'MATDIM/NDPARS.f'
      CHARACTER
     *          TITLES*012,TITLES_LATEXS*050,NUCNAM_LATEXS*010,
     *                                       PARPOT_UNITSS*040
      DIMENSION
     *          TITLES(1:NDTITL),
     *          TITLES_LATEXS(1:NDTITL),
     *          NUCNAM_LATEXS(1:NDNUCL),
     *          PARPOT_UNITSS(1:NDPARS)
C
C=======================================================================
C
C     This subroutines defines the name of the titles once forever.
C     It is called from the main part of the program. In this way,
C     we avoid having useless time the large column of the defini-
C     tion of the titles each time we want them. 
C
C     It also defines the parameter and nuclei names under latex 
C     format (plotting-output purposes)
C
C=======================================================================
C
      TITLES(01)='  V0CENT_p  '  
      TITLES(02)='  R0CENT_p  '   
      TITLES(03)='  A0CENT_p  '  
      TITLES(04)='  V0SORB_p  '
      TITLES(05)='  R0SORB_p  '
      TITLES(06)='  A0SORB_p  '         
      TITLES(07)='  V0EFFM_p  '        
      TITLES(08)='  R0EFFM_p  '        
      TITLES(09)='  A0EFFM_p  '        
      TITLES(10)='  R0COUL_p  '         
C
      TITLES(11)='  XK_V0C_p  '	  
      TITLES(12)='  XK_R0C_p  '	  
      TITLES(13)='  XK_A0C_p  '	  
      TITLES(14)='  XK_LAM_p  '	  
      TITLES(15)='  XK_RSO_p  '	  
      TITLES(16)='  XK_ASO_p  '	  
      TITLES(17)='  XK_LEF_p  '	 
      TITLES(18)='  XK_REF_p  '	 
      TITLES(19)='  XK_AEF_p  '	 
      TITLES(20)='  XK_COU_p  '
C
      TITLES(21)='  V0CENT_n  '	  
      TITLES(22)='  R0CENT_n  '	  
      TITLES(23)='  A0CENT_n  '	  
      TITLES(24)='  V0SORB_n  '	  
      TITLES(25)='  R0SORB_n  '	  
      TITLES(26)='  A0SORB_n  '	  
      TITLES(27)='  V0EFFM_n  '	 
      TITLES(28)='  R0EFFM_n  '	 
      TITLES(29)='  A0EFFM_n  '
C
      TITLES(30)='  XK_V0C_n  '	  
      TITLES(31)='  XK_R0C_n  '	  
      TITLES(32)='  XK_A0C_n  '	  
      TITLES(33)='  XK_LAM_n  '	  
      TITLES(34)='  XK_RSO_n  '	  
      TITLES(35)='  XK_ASO_n  '	  
      TITLES(36)='  XK_LEF_n  '	 
      TITLES(37)='  XK_REF_n  '	 
      TITLES(38)='  XK_AEF_n  '
C
      TITLES(39)='  XLAMB_pp  '	  
      TITLES(40)='  XLAMB_pn  '	  
      TITLES(41)='  XLAMB_np  '	  
      TITLES(42)='  XLAMB_nn  '
C
      TITLES(43)='  YLAMB_PP  '	  
      TITLES(44)='  YLAMB_PN  '	  
      TITLES(45)='  YLAMB_NP  '	  
      TITLES(46)='  YLAMB_NN  '
C
      TITLES(47)='  CLAMB_PP  '	  
      TITLES(48)='  CLAMB_PN  '	  
      TITLES(49)='  CLAMB_NP  '	  
      TITLES(50)='  CLAMB_NN  '  
C
      TITLES(51)='  V0CENTRL  '
      TITLES(52)='  KAPA_V0C  '
      TITLES(53)='  R0CENTRL  ' 
      TITLES(54)='  KAPA_R0C  '
      TITLES(55)='  A0CENTRL  ' 
      TITLES(56)='  KAPA_A0C  '
C
      TITLES(57)='  LAMBDASO  '
      TITLES(58)='  KAPA_LSO  '
      TITLES(59)='  R0_SORBT  '
      TITLES(60)='  KAPA_RSO  '
      TITLES(61)='  A0_SORBT  '
      TITLES(62)='  KAPA_A0S  '
C_______________________________________________________________________
C
      TITLES(63)='  GAPEXP_P  '	  
      TITLES(64)='  GAPTHE_P  '	  
      TITLES(65)='  RMSEXP_P  '	  
      TITLES(66)='  RMSTHE_P  '	  
C
      TITLES(67)='  EABSAV_P  '	  
      TITLES(68)='  ERRMAX_P  '	  
      TITLES(69)='  DENUPP_P  '	  
      TITLES(70)='  DENSUP_P  '	  
      TITLES(71)='  DENLOW_P  '	  
      TITLES(72)='  DENSDW_P  '	  
C
      TITLES(73)='  CHISQU_P  '	  
      TITLES(74)='  INVERS_P  '
C
      TITLES(75)='  GAPEXP_N  '	  
      TITLES(76)='  GAPTHE_N  '	  
      TITLES(77)='  RMSEXP_N  '	  
      TITLES(78)='  RMSTHE_N  '	  
C
      TITLES(79)='  EABSAV_N  '	  
      TITLES(80)='  ERRMAX_N  '	  
      TITLES(81)='  DENUPP_N  '	  
      TITLES(82)='  DENSUP_N  '	  
      TITLES(83)='  DENLOW_N  '	  
      TITLES(84)='  DENSDW_N  '	  
C
      TITLES(85)='  CHISQU_N  '	  
      TITLES(86)='  INVERS_N  '	  
C
      TITLES(87)='  CHI__SUM  '
C
C=======================================================================
C
C     Parameter names with LaTeX
C
      TITLES_LATEXS(01)='$V_{p}^c$'  
      TITLES_LATEXS(02)='$r_{p}^c$'   
      TITLES_LATEXS(03)='$a_{p}^c$'  
      TITLES_LATEXS(04)='$\\lambda_{p}^{so}$'  
      TITLES_LATEXS(05)='$r_{p}^{so}$'
      TITLES_LATEXS(06)='$a_{p}^{so}$'         
      TITLES_LATEXS(07)='$V_{p}^{eff}$'        
      TITLES_LATEXS(08)='$r_{p}^{eff}$'           
      TITLES_LATEXS(09)='$a_{p}^{eff}$'           
      TITLES_LATEXS(10)='$r_{Coul}$'         
C
      TITLES_LATEXS(11)='$\\kappa_{V_{p}^c}$'  
      TITLES_LATEXS(12)='$\\kappa_{r_{p}^c}$'  
      TITLES_LATEXS(13)='$\\kappa_{a_{p}^c}$'  
      TITLES_LATEXS(14)='$\\kappa_{\\lambda_{p}^{so}}$'  
      TITLES_LATEXS(15)='$\\kappa_{r_{p}^{so}}$'
      TITLES_LATEXS(16)='$\\kappa_{a_{p}^{so}}$'
      TITLES_LATEXS(17)='$\\kappa_{V_{p}^{eff}}$'  
      TITLES_LATEXS(18)='$\\kappa_{r_{p}^{eff}}$'   
      TITLES_LATEXS(19)='$\\kappa_{a_{p}^{eff}}$'  
      TITLES_LATEXS(20)='$\\kappa_{r_{Coul}}$'  
C
      TITLES_LATEXS(21)='$V_{n}^c$'  
      TITLES_LATEXS(22)='$r_{n}^c$'   
      TITLES_LATEXS(23)='$a_{n}^c$'  
      TITLES_LATEXS(24)='$\\lambda_{n}^{so}$'  
      TITLES_LATEXS(25)='$r_{n}^{so}$'
      TITLES_LATEXS(26)='$a_{n}^{so}$'         
      TITLES_LATEXS(27)='$V_{n}^{eff}$'        
      TITLES_LATEXS(28)='$r_{n}^{eff}$'           
      TITLES_LATEXS(29)='$a_{n}^{eff}$'      
C
      TITLES_LATEXS(30)='$\\kappa_{V_{n}^c}$'  
      TITLES_LATEXS(31)='$\\kappa_{r_{n}^c}$'  
      TITLES_LATEXS(32)='$\\kappa_{a_{n}^c}$'  
      TITLES_LATEXS(33)='$\\kappa_{\\lambda_{n}^{so}}$'  
      TITLES_LATEXS(34)='$\\kappa_{r_{n}^{so}}$'
      TITLES_LATEXS(35)='$\\kappa_{a_{n}^{so}}$'
      TITLES_LATEXS(36)='$\\kappa_{V_{n}^{eff}}$'  
      TITLES_LATEXS(37)='$\\kappa_{r_{n}^{eff}}$'   
      TITLES_LATEXS(38)='$\\kappa_{a_{n}^{eff}}$' 
C
      TITLES_LATEXS(39)='$\\lambda_{\\pi\\pi}$'	  
      TITLES_LATEXS(40)='$\\lambda_{\\pi\\nu}$'	  
      TITLES_LATEXS(41)='$\\lambda_{\\nu\\pi}$'	  
      TITLES_LATEXS(42)='$\\lambda_{\\nu\\nu}$'
C
      TITLES_LATEXS(43)='$\\lambda_{\\pi\\pi}^{so}$'	  
      TITLES_LATEXS(44)='$\\lambda_{\\pi\\nu}^{so}$'	  
      TITLES_LATEXS(45)='$\\lambda_{\\nu\\pi}^{so}$'	  
      TITLES_LATEXS(46)='$\\lambda_{\\nu\\nu}^{so}$'
C
      TITLES_LATEXS(47)='$\\lambda_{\\pi\\pi}^{c}$'	  
      TITLES_LATEXS(48)='$\\lambda_{\\pi\\nu}^{c}$'	  
      TITLES_LATEXS(49)='$\\lambda_{\\nu\\pi}^{c}$'	  
      TITLES_LATEXS(50)='$\\lambda_{\\nu\\nu}^{c}$'
C
      TITLES_LATEXS(51)='$V_0^c$'
      TITLES_LATEXS(52)='$\\kappa_{V_0^c}$'
      TITLES_LATEXS(53)='$r_0^c$' 
      TITLES_LATEXS(54)='$\\kappa_{r_0^c}$'
      TITLES_LATEXS(55)='$a_0^c$' 
      TITLES_LATEXS(56)='$\\kappa_{a_0^c}$'
C
      TITLES_LATEXS(57)='$\\lambda_0^{so}$'
      TITLES_LATEXS(58)='$\\kappa_{\\lambda_0^{so}}$'
      TITLES_LATEXS(59)='$r_0^{so}$'
      TITLES_LATEXS(60)='$\\kappa_{r_0^{so}}$'
      TITLES_LATEXS(61)='$a_0^{so}$' 
      TITLES_LATEXS(62)='$\\kappa_{a_0^{so}}$'
C
C=======================================================================
C
C     Parameter units
C
      PARPOT_UNITSS(01)='MeV'
      PARPOT_UNITSS(02)='fm'
      PARPOT_UNITSS(03)='fm'
      PARPOT_UNITSS(04)='MeV\\,fm$^2/\\hbar^2$'
      PARPOT_UNITSS(05)='fm'
      PARPOT_UNITSS(06)='fm'
      PARPOT_UNITSS(07)='XX'
      PARPOT_UNITSS(08)='XX'
      PARPOT_UNITSS(09)='XX'
      PARPOT_UNITSS(10)='fm'
C
      DO I=11,20
         PARPOT_UNITSS(I)='XX'
      END DO
C
      PARPOT_UNITSS(21)='MeV'
      PARPOT_UNITSS(22)='fm'
      PARPOT_UNITSS(23)='fm'
      PARPOT_UNITSS(24)='MeV\\,fm$^2/\\hbar^2$'
      PARPOT_UNITSS(25)='fm'
      PARPOT_UNITSS(26)='fm'
      PARPOT_UNITSS(27)='XX'
      PARPOT_UNITSS(28)='XX'
      PARPOT_UNITSS(29)='XX'
C
      DO I=30,38
         PARPOT_UNITSS(I)='XX'
      END DO
C
      PARPOT_UNITSS(39)='MeV\\,fm$^5/\\hbar^2$'
      PARPOT_UNITSS(40)='MeV\\,fm$^5/\\hbar^2$'
      PARPOT_UNITSS(41)='MeV\\,fm$^5/\\hbar^2$'
      PARPOT_UNITSS(42)='MeV\\,fm$^5/\\hbar^2$'
C
      DO I=43,62
         PARPOT_UNITSS(I)='XX'
      END DO
C
C=======================================================================
C
C     Nuclei names
C
      NUCNAM_LATEXS(01)='$^{16}$O'
      NUCNAM_LATEXS(02)='$^{40}$Ca'
      NUCNAM_LATEXS(03)='$^{48}$Ca'
      NUCNAM_LATEXS(04)='$^{56}$Ni'
      NUCNAM_LATEXS(05)='$^{90}$Zr'
      NUCNAM_LATEXS(06)='$^{132}$Sn'
      NUCNAM_LATEXS(07)='$^{146}$Gd'
      NUCNAM_LATEXS(08)='$^{208}$Pb'
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE LATEXS_LABELS(LABEXP,LABTEX)
C
      CHARACTER
     *          LABEXP*6,LABTEX*11
C
C=======================================================================
C
C     This subroutine transforms the energy labels written in the form
C     like 1h11/2 to latex form, i.e.: $1h_{11/2}$
C
C     LABEXP - input label 1h11/2
C
C     LABTEX - output label $1h_{11/2}$
C
C=======================================================================
C   
      IF (LABEXP(4:4).EQ.'/') THEN
C
          WRITE(LABTEX,'(''$'',A2,''_{'',A3,''}$'')')
     *                                    LABEXP(1:2),
     *                                    LABEXP(3:5)
      ELSE
C
          WRITE(LABTEX,'(''$'',A2,''_{'',A4,''}$'')')
     *                                    LABEXP(1:2),
     *                                    LABEXP(3:6)
      END IF
        
      DO K=1,11
         IF (LABTEX(K:K).EQ.'/') LABTEX(K:K)='@'
      END DO
C
C=======================================================================
C      
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE LATEXS_TITLES(AUXTIT,TITTEX)
C          
      CHARACTER
     *          AUXTIT*10,TITTEX*14
C
C=======================================================================
C
C     This subroutine transforms the parameter titles written according
C     to the style e.g. V0CENT_P to the latex form i.e.: $V_{0,cent}^p$
C
C     AUXTIT - input title V0CENT_P
C
C     TITTEX - output title $V_{0,cent}^p$
C
C=======================================================================
C   
      IF (AUXTIT(4:7).EQ.'CENT') THEN
C
          IF (AUXTIT(8:9).EQ.'_p') THEN
              WRITE(TITTEX,'(''$'',A1,''_{0,cent}^p$'')')AUXTIT(2:2)
          END IF
          IF (AUXTIT(8:9).EQ.'_n') THEN
              WRITE(TITTEX,'(''$'',A1,''_{0,cent}^n$'')')AUXTIT(2:2)
          END IF
C
      END IF
C_______________________________________________________________________
C        
      IF (AUXTIT(4:7).EQ.'SORB') THEN
C
          IF (AUXTIT(8:9).EQ.'_p') THEN
             WRITE(TITTEX,'(''$'',A1,''_{0,so}^p$'')')AUXTIT(2:2)
          END IF
          IF (AUXTIT(8:9).EQ.'_n') THEN
            WRITE(TITTEX,'(''$'',A1,''_{0,so}^n$'')')AUXTIT(2:2)
          END IF
C
      END IF
C_______________________________________________________________________
C        
      IF (AUXTIT(4:7).EQ.'COUL') THEN
          WRITE(TITTEX,'(''$'',A1,''_{0,coul}$'')')AUXTIT(2:2)
      END IF
C
C=======================================================================
C      
      RETURN
      END      
C
C=======================================================================
C=======================================================================
C
C FILE NAME = wspher04_gaussl_15.f ! Keep this symbol:    $ident@string$
C
C=======================================================================
C=======================================================================
C============      G A U S S    R O U T I N E   S E T   ================
C=======================================================================
C=======================================================================
C
      SUBROUTINE GENBAS(NDIM_N,NDIM_L,NDGAUS,NGAUSS,ANODES,AWEIGH,
     *                  NSHELL,BAUXIL,CAUXIL,EPSLAG,QRNODE,QRWEIG,
     *                         QNORNL,QDFLAG,QFLAGN,QPOLYN,QDPOLY,
     *                         IALPHA,QPOLYN_DENSIT,QDPOLY_DENSIT)
C
      IMPLICIT  REAL*16 (A-H,O-Z)
C
      DIMENSION
     *          QPOLYN(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *          QDPOLY(1:NDGAUS,0:NDIM_N,0:NDIM_L)  
      DIMENSION
     *          QFLAGN(0:NDIM_N,0:NDIM_L),
     *          QDFLAG(0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          QRNODE(1:NDGAUS,0:NDIM_L),
     *          QRWEIG(1:NDGAUS,0:NDIM_L)
      DIMENSION 
     *          QNORNL(0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          ANODES(1:NDGAUS),
     *          AWEIGH(1:NDGAUS)
      DIMENSION
     *          BAUXIL(1:NDGAUS),
     *          CAUXIL(1:NDGAUS)
      DIMENSION
     *          QFLEPS(0:NDIM_N,0:NDIM_L),
     *          QDFEPS(0:NDIM_N,0:NDIM_L) 
      DIMENSION
     *          QPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *          QDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
C
      COMMON
     *         /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                  LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                  NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                     LOGBIS                                                 
C_______________________________________________________________________
C
      DATA
     *        EPSORT / 1.0Q-30 /     
C
C=======================================================================
C             Harmonic-Oscillator Basis-Generating Routine
C=======================================================================
C
C     Subroutine GENBAS:  Provides the Gauss-Laguerre integration 
C     points and weights with the indices alpha=LQNUMB-1/2 rather
C     than usual <alpha=LQNUMB+1/2> for the kinetic energy matrix
C     elements integration.  This part of the result  is provided
C     through call to subroutine LAGAUS for LQNUMB in [0,NDIM_L].
C
C     This subroutine  also provides the numerical values  of the 
C     generalised  Laguerre polynomials  and corresponding  first 
C     order derivatives. This part comes through  <<call LAGUER>>
C
C     Finally it calculates the norms of the Laguerre polynomials
C     and verifies the functioning  of the integration by testing
C     the Laguerre orthogonality relations.
C
C     Meaning of some parameters:
C
C     NSHELL - The maximum value of the LQNUMB index  of Laguerre 
C              functions to be  calculated.  At the end, we store 
C              the polynomials with indices LQNUMB in [0,NSHELL]
C
C              The NQNUMB indices run between 0 and NSHELL/2 
C
C=======================================================================
C
      IF (NGAUSS.GT.NDGAUS) THEN
          WRITE(LSCREN,'(/,''NGAUSS='',I2,'' exceeds NDGAUS='',I2,/)')
     *                       NGAUSS,                 NDGAUS
          STOP 'Stop! NGAUSS > NDGAUS in GENBAS'
      END IF
C
C=======================================================================
C     Proceeding to define the Gauss quadrature nodes and weights
C     for the series of the L-values; L are integer, ALPHAL=L+0.5
C=======================================================================
C
      MAXIML=NSHELL
C
      DO LQNUMB=0,MAXIML      
C
C        Attention: Below we define the weight factor 
C                   as proportional to   z^{\ell-1/2}
C                   rather then the standard exponent z^{\ell+1/2}
C
         IF (IALPHA.EQ.0) ALPHAL=QFLOAT(LQNUMB)-0.5Q0
         IF (IALPHA.EQ.1) ALPHAL=QFLOAT(LQNUMB)+0.5Q0
C
         DO NPOINT=1,NGAUSS
            BAUXIL(NPOINT)= ALPHAL+QFLOAT(2*NPOINT-1)
            CAUXIL(NPOINT)=(ALPHAL+QFLOAT(  NPOINT-1))*QFLOAT(NPOINT-1)
         END DO
C
         IF (LOGWRI.GT.4) THEN
             WRITE(LOGFIL,'(9X,''Entering LAGAUS from GENBAS, '',
     *                         ''Orbital momentum L='',i2, 1X,
     *                         ''Weight function z^{\ell-1/2}'')') 
     *                                            LQNUMB
         END IF
C
         CALL LAGAUS(NGAUSS,ANODES,AWEIGH,ALPHAL,BAUXIL,CAUXIL,
     *                                           EPSLAG,NDGAUS)
         DO IPOINT=1,NGAUSS
C
            QRNODE(IPOINT,LQNUMB)=ANODES(IPOINT)
            QRWEIG(IPOINT,LQNUMB)=AWEIGH(IPOINT)
C
         END DO
C
C=======================================================================
C @@@ IRENE
C     ATTENTION: Le test suivant demande a reduire NGAUSS, dans le
C                fichier de donnees, suffisamment pour ne pas depasser
C                NDIM_N (qui est ici de 20). Dans le cas contraire,
C                le test est evite via le go to 1.
C
C=======================================================================
C @@@ IRENE VERIFY THIS NONSENSE
C
         IF (LOGWRI.GT.1) THEN
             WRITE(LOGFIL,'(12x,''LQNUMB='',I3,''  NGAUSS='',I3,2X,
     *                         ''NDIM_N='',I3,'' check the nonsense'')')
     *                           LQNUMB,          NGAUSS,NDIM_N
         END IF
C
         IF (NGAUSS.GT.NDIM_N) GO TO 1
C
C=======================================================================
C
         KIND_L=1
C
         NQNUMB=NGAUSS
         LORDER=LQNUMB
C
C=======================================================================
C
         IF (IALPHA.EQ.1) THEN
C
             DO IPOINT=1,NQNUMB
C
                XARGUM=QRNODE(IPOINT,LQNUMB)
C
                CALL LAGUER(XARGUM,QFLAGN,QDFLAG,NQNUMB,LORDER,KIND_L,
     *                                                  NDIM_L,NDIM_N)
             END DO
C
         END IF
C
C=======================================================================
C
         IF (IALPHA.NE.1) THEN
C
             DO IPOINT=1,NQNUMB
C
                XARGUM=QRNODE(IPOINT,LQNUMB)
C
                CALL LAGUER(XARGUM,QFLAGN,QDFLAG,NQNUMB,LORDER,KIND_L,
     *                                                  NDIM_L,NDIM_N)    
             END DO
C
         END IF
C
C=======================================================================
C
   1  CONTINUE
C
C=======================================================================
C
      END DO
C
C=======================================================================
C     Calculating the normalisation constants for the HO functions
C=======================================================================
C
      NORDER=NSHELL/2
      LORDER=NSHELL
      KIND_L=1
C
      CALL NORMNL(QNORNL,NORDER,LORDER,NDIM_N,NDIM_L,KIND_L)
C
C=======================================================================
C     Below we calculate the values of the generalised Laguerre
C     polynomials and their first derivatives using recurrences;
C     In other words: we generate the spatial representation of
C     the harmonic oscillator basis in terms of n & l q-numbers
C=======================================================================
C       
       DO N_MAIN=NSHELL,0,-1
C
          DO LQNUMB=N_MAIN,0,-2
             NQNUMB=(N_MAIN-LQNUMB)/2
C
             DO IPOINT=1,NGAUSS
C
                RARGUM=QRNODE(IPOINT,LQNUMB)
C
                CALL LAGUER(RARGUM,QFLAGN,QDFLAG,NQNUMB,LQNUMB,KIND_L,
     *                                                  NDIM_L,NDIM_N)
C
                QPOLYN(IPOINT,NQNUMB,LQNUMB)=QFLAGN(NQNUMB,LQNUMB)
     *                                      *QNORNL(NQNUMB,LQNUMB)
C
                QDPOLY(IPOINT,NQNUMB,LQNUMB)=QDFLAG(NQNUMB,LQNUMB)
     *                                      *QNORNL(NQNUMB,LQNUMB)
            END DO
C
         END DO
      END DO
C      
      DO LQNUMB=NSHELL,0,-1
         DO IPOINT=1,NGAUSS
C            
            RARGUM=QRNODE(IPOINT,LQNUMB)
C
            CALL LAGUER(RARGUM,QFLAGN,QDFLAG,NORDER,LORDER,KIND_L,
     *                                              NDIM_L,NDIM_N)
            DO NAUXIL=0,NORDER
               DO LAUXIL=0,LORDER
C                       
                  QPOLYN_DENSIT(IPOINT,NAUXIL,LAUXIL,LQNUMB)
     *            =
     *            QFLAGN(NAUXIL,LAUXIL)*QNORNL(NAUXIL,LAUXIL)
C     
                  QDPOLY_DENSIT(IPOINT,NAUXIL,LAUXIL,LQNUMB)
     *            =
     *            QDFLAG(NAUXIL,LAUXIL)*QNORNL(NAUXIL,LAUXIL)
C     
               END DO
            END DO
             
         END DO
      END DO
C
C=======================================================================
C     Below we are verifying correctness of the numerical result
C     by testing the precision  of the orthonormality relations 
C=======================================================================
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(/,12X,''Testing precision of orthogonality'',
     *                                                             /)')
      END IF
C
      DO LQNUMB=NSHELL,0,-1
C
C        Here we are going to verify the orthonormality relations
C        at fixed  L <<==>> LQNUMB values for L=0 to NSHELL
C_______________________________________________________________________
C
         IF (LOGWRI.GT.5) THEN
             WRITE(LOGFIL,'(/,9X,''LGNUMB='',I3)') LQNUMB
             WRITE(LOGFIL,'(36X,''.123456789 123456789'',
     *                          '' 123456789 123'')')
         END IF
C_______________________________________________________________________
C
         ORTMAX=-999.0
C
         DO N1NUMB=0,(NSHELL-LQNUMB)/2
            DO N2NUMB=0,(NSHELL-LQNUMB)/2       
C  
               ORTOGO=0.0Q0
C       
               DO I_PNTS=1,NGAUSS
C
                  IF (IALPHA.EQ.0) THEN
C
C                     We are using the weight factor e^{-z} z^{l-1/2}
C                     and THEREFORE the polynomials will be multiplied 
C                     by an extra factor "z"...
C
                      ZNODES=QRNODE(I_PNTS,LQNUMB)
C
                      ORTOGO=ORTOGO+QPOLYN(I_PNTS,N1NUMB,LQNUMB)
     *                             *QPOLYN(I_PNTS,N2NUMB,LQNUMB)
     *                             *QRWEIG(I_PNTS,LQNUMB)
     *                             *ZNODES                     
                  END IF
C
                  IF (IALPHA.EQ.1) THEN
C
C                     ... whereas: 
C                         the usual weight function is e^{-z} z^{l+1/2}
C
                      ORTOGO=ORTOGO+QPOLYN(I_PNTS,N1NUMB,LQNUMB)
     *                             *QPOLYN(I_PNTS,N2NUMB,LQNUMB)
     *                             *QRWEIG(I_PNTS,LQNUMB)
                  END IF
C
               END DO
C
               IF (N1NUMB.NE.N2NUMB) THEN
                   IF (ORTMAX.LT.ORTOGO) ORTMAX=ORTOGO
               END IF
C
               IF (LOGWRI.GT.5) THEN
C
               WRITE(LOGFIL,'(9X,''N1='',I2,'' N2='',I2,3X,''ORTOGO='',
     *                                                       F40.33)')
     *                             N1NUMB,     N2NUMB,       ORTOGO
               END IF
C______________________________________________________________________
C
                                     TESVAL=ORTOGO
               IF (N1NUMB.EQ.N2NUMB) TESVAL=ORTOGO-1.0Q0
C
               IF (ABS(TESVAL).GT.EPSORT) THEN
C
                   WRITE(LSCREN,'(/,''You requested the quadruple '',
     *                         ''precision; found non-orthogonality '',
     *                         ''on the level of EPSORT='',e12.5)') 
     *                                                      EPSORT
                   WRITE(LSCREN,'(''with LQNUMB='',i2,'' NGAUSS='',i2,
     *                          /,''     N1NUMB='',i2,'' N2NUMB='',i2)')
     *                                   LQNUMB,         NGAUSS,
     *                                   N1NUMB,         N2NUMB
                   WRITE(LSCREN,'(''TESVAL='',E32.24)') TESVAL
C
                   STOP 'Stop! - from integration precision test'
C
               END IF
C______________________________________________________________________
C      
            END DO ! N2NUMB
         END DO ! N1NUMB
C
         IF (LOGWRI.GT.5 .AND. LQNUMB.LT.(NSHELL-1)) THEN
             WRITE(LOGFIL,'(13X,''LQNUMB='',I2,'' ORTMAX='',E12.5)')
     *                            LQNUMB,         ORTMAX
         END IF
C      
      END DO ! LGNUMB
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(T24,''EPSLAG='',E12.5)') EPSLAG
      END IF
C
C=======================================================================
C
      CALL SET_FACTORIAL      
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(9X,''Exiting  GENBAS'')')
      END IF
C
C=======================================================================
C      
      RETURN
      END      
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE NORMNL(XNORNL,NORDER,LORDER,NDIM_N,NDIM_L,KIND_L)
C
C                Here QUADRUPLE precision; its impact begins for L>30
      IMPLICIT
     *          REAL*16 (A-H,O-Z)
C
      DIMENSION 
     *          XNORNL(0:NDIM_N,0:NDIM_L)
      DIMENSION 
     *          FACTOR(0:40)
C       
C=======================================================================
C     This subroutine  calculates the normalisation constants
C     for the radial wave-functions of the spherical harmonic
C     oscillator solutions. The stretching factor is ignored.
C-----------------------------------------------------------------------
CID:
C     The formula is (for KIND_L=1):
C
C     N_{nl} = SQRT[ ( 2^{n+l} * n! ) / (( 2n + 2l + 1 )!! * sqrt(pi)) ]
CID.
C=======================================================================
C
      FACTOR(0)=1.0Q0
      FACTOR(1)=1.0Q0
C
      DO L=2,40
         FACTOR(L)=QSQRT(QFLOAT(L))*FACTOR(L-1)
C
C        WRITE(65,'(''L='',I2,3X,''FACTOR(L)='',F40.2)') L,FACTOR(L)
C
      END DO
C

      IF (KIND_L.EQ.0) THEN
C
          IF (NORDER+LORDER.GT.40) STOP 'Maupa oraz Bauvann in NORML'
C                
C                          Normalisation for full-integer L-values
          DO N=0,NORDER
             DO L=1,LORDER
                XNORNL(N,L)=1.0Q0/(FACTOR(L+N)/FACTOR(N))
             END DO
          END DO
C
      ELSE
C                          Normalisation for half-integer L-values
C
          PINUMB=4.Q0*QATAN(1.0Q0)
          SQRTPI=QSQRT(PINUMB)
          FRACTN=1.Q0/SQRTPI
C
          FRACT1=FRACTN
C
          DO J=0,LORDER
             FRACT1=FRACT1*2.0Q0/(2.0Q0*QFLOAT(J)+1.0Q0)
             XNORNL(0,J)=QSQRT(FRACT1)
          END DO
C
          DO I=1,NORDER
             FRACTN=FRACTN*2.0Q0*QFLOAT(I)/(2.0Q0*QFLOAT(I)-1.0Q0)
             FRACT2=1.0Q0
C
             DO K=0,LORDER
                FRACT2=FRACT2*2.0Q0/(2.0Q0*QFLOAT(I)
     *		          +2.0Q0*QFLOAT(K)+1.0Q0)
                XNORNL(I,K)=QSQRT(FRACTN*FRACT2)           
             END DO
          END DO
C
      END IF
C
C=======================================================================
C
      RETURN
      END  
C
C=======================================================================
C
      SUBROUTINE SET_FACTORIAL

      INTEGER MAX_FACTORIAL
      PARAMETER(MAX_FACTORIAL=150)

      REAL*16 FACLOG(0:MAX_FACTORIAL)
      COMMON  /FACLOG_TABLE/ FACLOG

      REAL*16 FN
      INTEGER N

      CALL CPUTIM('FACTOR',1)

      FACLOG(0)=0.Q0
      FN=0.Q0
      DO N=1,MAX_FACTORIAL
         FN=FN+1.Q0
         FACLOG(N)=FACLOG(N-1)+QLOG(FN)
      END DO

      CALL CPUTIM('FACTOR',0)

      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE LAGUER(XARGUM,FLAGNL,DFLAGN,NORDER,LORDER,KIND_L,
     *                                              NDIM_L,NDIM_N)
      IMPLICIT REAL*16 (A-H,O-Z)
C
      DIMENSION
     *          FLAGNL(0:NDIM_N,0:NDIM_L),
     *          DFLAGN(0:NDIM_N,0:NDIM_L)
C
C=======================================================================
C
C     This subroutine  calculates the values  of the generalised
C     Laguerre functions at the argument  <xargum>; we calculate
C     simultaneously all the Laguerre functions with the indices
C     n=0,1, ... NORDER, for the largest L-index, and next apply
C     the recurrence 
C                      L^{a-1}_n = L^a_n - L^a_{n-1}
C     Attention!
C               Here we calculate only those Laguerre functions
C               that are needed as solutions of the Schrodinger
C               equation for the spherically-symmetric harm-osc
C               potential i.e. alpha=L+1/2  
C
C     KIND_L - either 0 (integer L-indices) or 1 (half-integer)
C
C=======================================================================
C
      CALL CPUTIM('LAGUER',1)
C
C=======================================================================
C
      IF (NORDER.GT.NDIM_N) THEN
          WRITE(0,'(''NORDER='',I3,3X,''NDIM_N='',I3)') NORDER,NDIM_N
          STOP 'NORDER > NDIM_N in LAGUER'
      END IF
C
      IF (NORDER.LT.000000) STOP 'NORDER negative in LAGUER'
C
      IF (LORDER.GE.NDIM_L) STOP 'LORDER geNDIM_L in LAGUER'
      IF (LORDER.LT.000000) STOP 'LORDER negative in LAGUER'
C
      IF (.NOT.(KIND_L.EQ.0.OR.KIND_L.EQ.1)) THEN
          STOP 'Param. KIND_L must be zero or one in LAGUER'
      END IF
C
C=======================================================================
C
C     Attention: Below, removing +0.5 allows to calculate the Lag.
C                functions for the integer order-L polynomials ...
C
      L_HELP=LORDER+1
C
      IF (KIND_L.EQ.0) THEN
          XALPHA=QFLOAT(L_HELP)
      ELSE
          XALPHA=QFLOAT(L_HELP)+0.5Q0
      END IF
C
      X_LAG0=1.0Q0
      X_LAG1=1.0Q0+XALPHA-XARGUM
C
      FLAGNL(0,L_HELP)=X_LAG0
      FLAGNL(1,L_HELP)=X_LAG1
C
C=======================================================================
C
C            In what follows we are using the recurrence:
C
C     L^a_{n+1}=\frac{1}{n+1}[(2n+a+1-x) L^a_n - (n+a) L^a_{n-1}]
C
C     rewritten as
C
C     L^a_{n} = \frac{1}{n}[(2n+a-1-x) L^a_{n-1} - (n-1+a) L^a_{n-2}] 
C
C=======================================================================
C
      DO N=2,NORDER
C
         X_LAG2=((QFLOAT(2*N-1)+XALPHA-XARGUM) *X_LAG1
     *         - (QFLOAT(N-1)  +XALPHA       ) *X_LAG0)/QFLOAT(N)
C
         X_LAG0=X_LAG1
         X_LAG1=X_LAG2
C
         FLAGNL(N,L_HELP)=X_LAG2
C
      END DO        
C_______________________________________________________________________
C
C     Defining generalissd Laguerre polynomials n=0 for all L-indices
C
      DO L=0,L_HELP
         FLAGNL(0,L)=1.0Q0
         DFLAGN(0,L)=0.0Q0
      END DO
C_______________________________________________________________________
C
C     Applying the recurrence: L^{a-1}_n = L^a_n - L^a_{n-1}; n>0
C
      DO L=L_HELP,1,-1
         DO N=NORDER,1,-1
            FLAGNL(N,L-1)=FLAGNL(N,L)-FLAGNL(N-1,L)
         END DO
      END DO
C
C_______________________________________________________________________
C
C     Calculating derivatives of the generld. Laguerre functions
C
      DO L=LORDER,0,-1
         DO N=NORDER,1,-1
            DFLAGN(N,L)=-FLAGNL(N-1,L+1) ! dL^a_n=-L^{a+1}_{n-1}
         END DO
      END DO
C
C=======================================================================
C
      CALL CPUTIM('LAGUER',0)
C
C=======================================================================
C      
      RETURN 
      END 
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE LAGAUS(NGAUSS,XNODES,WEIGHT,ALPHAG,BAUXIL,CAUXIL,
     *                                              EPSLAG,NDLAGR)
      IMPLICIT  REAL*16 (A-H,O-Z)
C
      DIMENSION
     *          XNODES(NDLAGR),WEIGHT(NDLAGR)
      DIMENSION
     *          BAUXIL(NDLAGR),CAUXIL(NDLAGR)
C
      COMMON
     *         /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                  LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                  NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                     LOGBIS                                                  
C
C=======================================================================
C
C     LAGAUS - calculates zeros and weights of the Gauss-Laguerre
C              integration formula with the L-dependent weights
C
C=======================================================================
C
C     Karolina ???
C @@@
C ### attention - here we fix LINDEX from alpha=l+1/2
C
      FLOATN=QFLOAT(NGAUSS)
C
      LINDEX=ALPHAG-0.5Q0
C
      CSXSUM=0.0Q0
      CSWSUM=0.0Q0
C
      PINUMB=4.Q0*QATAN(1.0Q0)
      SQRTPI=QSQRT(PINUMB)
C
      IF (LINDEX.EQ.-1) THEN
          FRECUR=SQRTPI
      ELSE
          FRECUR=SQRTPI/2.000Q0
      END IF
C
      DO I=1,LINDEX
         FRECUR=FRECUR*(2.0Q0*QFLOAT(I)+1.0Q0)/2.0Q0
      END DO
C
      DO J=2,NGAUSS
         FRECUR=FRECUR*CAUXIL(J)
      END DO
C
C=======================================================================
C
      DO I=1,NGAUSS
C
         IF (I-1) 6,2,3
C
C            Smallest zero
C
   2     CONTINUE    
C
         X_TERM=(1.0Q0+ALPHAG)*(3.000Q0+.920Q0*ALPHAG)
     *         /(1.0Q0+2.40000Q0*FLOATN+1.80Q0*ALPHAG)
C
         GO TO 6
C
   3     CONTINUE
C   
         IF (I-2) 6,4,5
C
C            Second zero
C
   4     CONTINUE
C   
         X_TERM=X_TERM+(15.0Q0+6.2500Q0*ALPHAG)
     *         /(1.000Q0+.9000Q0*ALPHAG+2.5000Q0*FLOATN)
C
         GO TO 6
C
C            All other zeros
C
   5     CONTINUE
C   
         FLOATI=QFLOAT(I-2)
C   
         R1TERM=(1.00Q0+2.5500Q0*FLOATI)/(1.9Q0*FLOATI)
         R2TERM= 1.26Q0*FLOATI*ALPHAG /(1.0Q0+3.5000Q0*FLOATI)
C  
         RATIOS=(R1TERM+R2TERM)/(1.000Q0+0.3000Q0*ALPHAG)
C
         X_TERM= X_TERM+RATIOS*(X_TERM-XNODES(I-2))
C
   6     CONTINUE
   
         XTITER=X_TERM
         ALITER=ALPHAG
         EPSITE=EPSLAG
C
         IF (LOGWRI.GT.5) THEN
C
             WRITE(LOGFIL,'(12X,''Entering LGROOT from LAGAUS, '',
     *                          ''I_NODE='',I3)') I    
         END IF
C
         CALL LGROOT(XTITER,NGAUSS,ALITER,DPNAUX,XPOLYN,BAUXIL,CAUXIL,
     *                                                  EPSITE,NDLAGR)
         X_TERM=XTITER
C
         XNODES(I)=X_TERM
         WEIGHT(I)=FRECUR/DPNAUX/XPOLYN
C
         CSXSUM=CSXSUM+X_TERM
         CSWSUM=CSWSUM+WEIGHT(I)
C
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(9X,''Exiting  LAGAUS'')')
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE LGROOT(XARGUM,NGAUSS,ALPHAG,DPNAUX,XPOLYN,
     *                         BAUXIL,CAUXIL,EPSLAG,NDLAGR)
C
      IMPLICIT  REAL*16 (A-H,O-Z)
C
      DIMENSION
     *          BAUXIL(NDLAGR),CAUXIL(NDLAGR)
C
      COMMON
     *         /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                  LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                  NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                     LOGBIS                                                  
C
C=======================================================================
C
C     This SUBROUTINE improves approximation root XARGUM
C     In addition we also obtain:
C
C                    DPNAUX=derivative of P(N) at XARGUM
C                and XPOLYN=value of P(N-1) at XARGUM
C
C=======================================================================
C
      ITERAT=0
C
   1  CONTINUE
C
C=======================================================================
C
      ITERAT=ITERAT+1
C
      CALL LGRECR(PNITER,DPITER,XPOLYN,XARGUM,NGAUSS,ALPHAG,
     *                                 BAUXIL,CAUXIL,NDLAGR)
C
      D=PNITER/DPITER
      XARGUM=XARGUM-D
C
      IF (ABS(D/XARGUM)-EPSLAG) 3,3,2
C
   2  IF (ITERAT-10) 1,3,3
C
   3  CONTINUE
C
C=======================================================================
C
      IF (LOGWRI.GT.5) THEN
C
          IF (ITERAT.GE.10) THEN
              WRITE(LOGFIL,'(16X,''From LGROOT ITERAT='',i3,1X,
     *                           ''maximum 10 are allowed, '',
     *                           ''precision EPSLAG='',D12.5,1X,
     *                           ''not respected'')') ITERAT,EPSLAG
          ELSE
              WRITE(LOGFIL,'(16X,''From LGROOT ITERAT='',i3,1X,
     *                           ''maximum 10 are allowed, '',
     *                           ''precision EPSLAG='',D12.5,1X,
     *                           ''satisfied'')') ITERAT,EPSLAG
          END IF
C
      END IF
C
C=======================================================================
C   
      DPNAUX=DPITER
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE LGRECR(PNITER,DPITER,XPOLYN,XARGUM,NGAUSS,ALPHAG,
     *                                       BAUXIL,CAUXIL,NDLAGR)
      IMPLICIT  REAL*16 (A-H,O-Z)
C
      DIMENSION
     *          BAUXIL(NDLAGR),CAUXIL(NDLAGR)
C
C=======================================================================
C     Auxiliary routine - recurrences (called from LGROOT)
C=======================================================================
C
      PLAGUE=1.0000Q0
C
      P_ITER=XARGUM-ALPHAG-1.0Q0
C
      DP1AUX=0.0Q0
      DP_AUX=1.0Q0
C
      DO J=2,NGAUSS
C
         Q_AUXI=(XARGUM-BAUXIL(J))*P_ITER-CAUXIL(J)*PLAGUE
         DQAUXI=(XARGUM-BAUXIL(J))*DP_AUX-CAUXIL(J)*DP1AUX+P_ITER
C
         PLAGUE=P_ITER
         P_ITER=Q_AUXI
         DP1AUX=DP_AUX
         DP_AUX=DQAUXI
C
      END DO
C
      PNITER=P_ITER
      DPITER=DP_AUX
      XPOLYN=PLAGUE
C
C=======================================================================
C
      RETURN
      END
C       
C=======================================================================
C=======================================================================
C       
      SUBROUTINE ORDHEA(VECTOR,INDEXV,MAXVEC,NDVECT)
      DIMENSION
     *          VECTOR(1:NDVECT),INDEXV(1:NDVECT)
C
C=======================================================================
C
C        This routine rearranges vector 'VECTOR' of dimension 'MAXVEC'
C        so that it is in ascending order on return.   Vector 'INDEXV'
C        contains on return,  in its k-th element, the original index
C        of resulting VECTOR(K).
C
C        On input 'INDEXV' must contain original indices.
C
C=======================================================================
C                                   Method used: heapsort of Williams
C=======================================================================
C                  Based on  "numerical  recipes"
C=======================================================================
C
      IF (MAXVEC.LT.1) THEN
          STOP 'ORDHEA called with negative number of vector elements'
      END IF
C
      IF (MAXVEC.EQ.1) RETURN
C
      IF (MAXVEC.GT.NDVECT) STOP 'MAXVEC > NDVECT in ORDHEA'
C
C=======================================================================
C
      LACTIV=MAXVEC/2+1
      INDACT=MAXVEC
C
C=======================================================================
C
    1 CONTINUE
C
C=======================================================================
C
      IF (LACTIV.GT.1) THEN
C
          LACTIV=LACTIV-1
C
          VELEMT=VECTOR(LACTIV)
          IELEMT=INDEXV(LACTIV)
C
      ELSE
C
          VELEMT=VECTOR(INDACT)
          IELEMT=INDEXV(INDACT)
C
          VECTOR(INDACT)=VECTOR(1)
          INDEXV(INDACT)=INDEXV(1)
C
          INDACT=INDACT-1
C
          IF (INDACT.EQ.1) THEN
              VECTOR(1)=VELEMT
              INDEXV(1)=IELEMT
C
              RETURN
C
          END IF
C
      END IF
C
C=======================================================================
C
      I=LACTIV
      J=LACTIV+LACTIV
C
C=======================================================================
C
    2 CONTINUE
C
C=======================================================================
C
      IF (J.LE.INDACT) THEN
C
          IF (J.LT.INDACT.AND.VECTOR(J).LT.VECTOR(J+1)) J=J+1
C
          IF (VELEMT.LT.VECTOR(J)) THEN
C
              VECTOR(I)=VECTOR(J)
              INDEXV(I)=INDEXV(J)
C
              I=J
              J=J+J
C
          ELSE
              J=INDACT+1
          END IF
C
          GO TO 2
C
      END IF
C
C=======================================================================
C
      VECTOR(I)=VELEMT
      INDEXV(I)=IELEMT
C
C=======================================================================
C
      GO TO 1
C
C=======================================================================
C
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE ORDLAB(NDIM_N,NDIM_L,LABORD_PROTON,LABORD_NEUTRS,
     *                                LABSYM_PROTON,LABSYM_NEUTRS,
     *                                              NDNUCL,INUCLI)
C      
      INCLUDE  'MATDIM/NDIMaN.f'
      
      PARAMETER
     *         (LEVDIM=30,NDIMaL=NDIMaN)
C
      CHARACTER 
     *          LABSYM_PROTON*6,LABSYM_NEUTRS*6
      CHARACTER 
     *          KEYWOR*7,STRING*6,FILEXP*256
C
      DIMENSION
     *          LABORD_PROTON(1:NDNUCL,0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *          LABORD_NEUTRS(1:NDNUCL,0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          LABSYM_PROTON(1:NDNUCL,0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *          LABSYM_NEUTRS(1:NDNUCL,0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          LABORD(0:NDIMaN,0:NDIMaL,0:2*NDIMaL+1)
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS                                                  
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI    
C      
      DATA
     *        N_UNIT / 10 /
C
C=======================================================================     
C     The purpose of this routine is ??? byc moze do wywalenia
C=======================================================================     
C
      LABORD(0,0, 1)=1 ! 1s1/2
C                      !        N=0 full
      LABORD(0,1, 3)=1 ! 1p3/2
      LABORD(0,1, 1)=1 ! 1p1/2
C                      !        N=1 full
      LABORD(0,2, 5)=1 ! 1d5/2
C                      !        Intruder from N=2
      LABORD(1,0, 1)=1 ! 2s2/2
      LABORD(0,2, 3)=1 ! 1d3/2
C                      !        N=2 full
      LABORD(0,3, 7)=1 ! 1f7/2
C                      !        Intruder from N=3
      LABORD(1,1, 3)=1 ! 2p3/2 
      LABORD(0,3, 5)=1 ! 1f5/2  
      LABORD(1,1, 1)=1 ! 2p1/2
C                      !        N=3 full
      LABORD(0,4, 9)=1 ! 1g9/2
C                      !        Intruder from N=4  
      LABORD(0,4, 7)=1 ! 1g7/2 
      LABORD(1,2, 5)=1 ! 2d5/2
      LABORD(1,2, 3)=1 ! 2d3/2 
      LABORD(2,0, 1)=1 ! 3s1/2 
C                      !        N=4 full
      LABORD(0,5,11)=1 ! 1h11/2
C                      !        Intruder from N=5  
      LABORD(0,5, 9)=1 ! 1h9/2 
      LABORD(1,3, 7)=1 ! 2f7/2 
      LABORD(1,3, 5)=1 ! 2f5/2 
      LABORD(2,1, 3)=1 ! 3p3/2 
      LABORD(2,1, 1)=1 ! 3p1/2
C                      !        N=5 full 
      LABORD(0,6,13)=1 ! 1i13/2
C                      !        Intruder from N=6 
      LABORD(1,4, 9)=1 ! 2g9/2 
      LABORD(2,2, 5)=1 ! 3d5/2 
      LABORD(0,6,11)=1 ! 1i11/2 
      LABORD(1,4, 7)=1 ! 2g7/2 
      LABORD(3,0, 1)=1 ! 4s1/2 
      LABORD(2,2, 3)=1 ! 3d3/2 
C                      !        N=6 full 
      LABORD(0,7,15)=1 ! 1j15/2 
C                      !        Intruder from N=7    
C
C=======================================================================
C      
      FILEXP='ws_exper/levels.new.d'
C      
      OPEN (N_UNIT,FILE=FILEXP,STATUS='UNKNOWN',FORM='FORMATTED')
C
      IF (LOGWRI.GT.5) THEN
C
          WRITE(LOGFIL,'(/,9X,''Opening UNIT='',I2,1x,
     *                        ''File=ws_exper/levels.new.d'',/)') N_UNIT
C
          WRITE(LOGFIL,'(  9X,''IZ_FIX='',I3,'' IN_FIX='',I3,1X,
     *                        ''ISOSPI='',I1,/)')                   
     *                          IZ_FIX,         IN_FIX,ISOSPI
      END IF
C      
      DO N=0,NDIM_N
         DO L=0,NDIM_L
            DO J=0,2*NDIM_L+1
               LABORD_PROTON(INUCLI,N,L,J)=0
               LABORD_NEUTRS(INUCLI,N,L,J)=0	       
            END DO
         END DO
      END DO
C
C=======================================================================
C
   2  CONTINUE
C
C=======================================================================
C   
      READ (N_UNIT,'(A7)',END=3)  KEYWOR
C
C=======================================================================
C      
      IF (KEYWOR.EQ.'n>>l>>j') THEN
C      
          NUMOCC_PROTON=0
          NUMOCC_NEUTRS=0
C	  
          DO I=1,LEVDIM
C
C             WRITE(0,*)I,IN_FIX,NUMOCC_NEUTRS
C             WRITE(0,*)I,IZ_FIX,NUMOCC_PROTON
C
             IF (NUMOCC_NEUTRS.LT.IN_FIX) THEN
C             
                 READ (N_UNIT,*) NNUMBR,LNUMBR,JNUMBR,STRING
C
                 IF (LOGWRI.GT.5)                 
     *               WRITE(LOGFIL,'(7X,3I3,2X,A)') NNUMBR,LNUMBR,JNUMBR,
     *                                                           STRING            
                 LABORD_NEUTRS(INUCLI,NNUMBR-1,LNUMBR,JNUMBR)=1
                 LABSYM_NEUTRS(INUCLI,NNUMBR-1,LNUMBR,JNUMBR)=STRING
C
                 IF (LABORD_NEUTRS(INUCLI,NNUMBR-1,LNUMBR,JNUMBR).NE.
     *                      LABORD(NNUMBR-1,LNUMBR,JNUMBR)) THEN
C
                     IF (ISCREN.NE.0) THEN
C
                         WRITE(LSCREN,'(9X,''LABORD_N('',I1,'','',I1,
     *                            '','',I2,'')='',I1,'' LABORD='',I1)')
     *                                  NNUMBR-1,LNUMBR,JNUMBR,
     *                    LABORD_NEUTRS(INUCLI,NNUMBR-1,LNUMBR,JNUMBR),
     *                                  LABORD(NNUMBR-1,LNUMBR,JNUMBR)
                     END IF
C
                     STOP 'Occupation structure inconsistency in LABORD'            
C
                 END IF             
C             
                 NUMOCC_NEUTRS=NUMOCC_NEUTRS+JNUMBR+1
C          
                 IF (NUMOCC_PROTON.LT.IZ_FIX) THEN
C             
                     LABORD_PROTON(INUCLI,NNUMBR-1,LNUMBR,JNUMBR)=1
                     LABSYM_PROTON(INUCLI,NNUMBR-1,LNUMBR,JNUMBR)=STRING
C		     
                     NUMOCC_PROTON=NUMOCC_PROTON+JNUMBR+1
C
                 END IF
             ELSE
                 GO TO 1
             END IF
          END DO
      END IF
C     
C=======================================================================
C     
   1  CONTINUE   
C     
C=======================================================================
C       
      IF (KEYWOR.EQ.'ENDFILE') THEN
C
          IF (LOGWRI.GT.3) WRITE(LOGFIL,'()')
C 
          LBPCNT=0
          LBNCNT=0
C
          DO N=0,NDIM_N
             DO L=0,NDIM_L
                DO J=1,2*NDIM_L+1,2
C
                   IF (LABORD_PROTON(INUCLI,N,L,J).EQ.1) THEN
C
                       LBPCNT=LBPCNT+1                   
C
                       IF (LOGWRI.GT.5)
     *                       
     *                     WRITE(LOGFIL,'(9X,''p'',3I3,I5,2x,a)') 
     *                           N,L,J,LABORD_PROTON(INUCLI,N,L,J),
     *                                 LABSYM_PROTON(INUCLI,N,L,J)
                   END IF
C
                   IF (LABORD_NEUTRS(INUCLI,N,L,J).EQ.1) THEN
C
                       LBNCNT=LBNCNT+1                   
C                   
                       IF (LOGWRI.GT.5)
     *                       
     *                     WRITE(LOGFIL,'(9X,''n'',3I3,I5,2x,a)') 
     *                           N,L,J,LABORD_NEUTRS(INUCLI,N,L,J),
     *                                 LABSYM_NEUTRS(INUCLI,N,L,J)
                   END IF
C                   
                END DO ! end N
             END DO ! end L
          END DO ! end J
C       
          CLOSE(N_UNIT)
C       
          IF (LOGWRI.GT.5) THEN
C
              WRITE(LOGFIL,'()')
              WRITE(LOGFIL,'(9X,''In total LBPCNT='',I2,1x,
     *                          ''proton  labels and'',/,9X, 
     *                          ''         LBNCNT='',I2,1x,
     *                          ''neutron labels'')')LBPCNT,LBNCNT
              WRITE(LOGFIL,'(/,9X,''Closing UNIT='',i2,/)') N_UNIT
C
              WRITE(LOGFIL,'(/,''Exiting  ORDLAB'')')
C
          END IF
C
          RETURN
C
      END IF
C               
C=======================================================================
C      
      GO TO 2
C               
C=======================================================================
C
   3  CONTINUE
C
       WRITE(100,'()')
       
       DO N=0,NDIM_N
          DO L=0,NDIM_L
             DO J=0,2*NDIM_L+1
 	              IF (LABORD_PROTON(INUCLI,N,L,J).EQ.1) THEN
C
                    WRITE(LSCREN,'(''p'',4I3)')
     *                               N,L,J,LABORD_PROTON(INUCLI,N,L,J)
                END IF
             END DO
          END DO
       END DO
       
       WRITE(100,'()')
C_______________________________________________________________________
C       
       DO N=0,NDIM_N
          DO L=0,NDIM_L
             DO J=0,2*NDIM_L+1
 	              IF (LABORD_NEUTRS(INUCLI,N,L,J).EQ.1) THEN
C
                    WRITE(LSCREN,'(''n'',4I3)')
     *                               N,L,J,LABORD_NEUTRS(INUCLI,N,L,J)
                END IF
             END DO
          END DO
       END DO
C      
C=======================================================================
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(/,''Exiting  ORDLAB'')')
      END IF
C      
C=======================================================================
C  
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE CHEKHO(POLYNL,DPOLYN,POLYNX,RNODES,RWEIGH,HOMEGA,
     *                  NDBASE,NDIM_N,NDIM_L,NSHELL,NDGAUS,NGAUSS,
     *                                       IALPHA,NDNUCL,INUCLI)
C
      DIMENSION
     *          ENKIN4(1:NDBASE,1:NDBASE,0:NDIM_L),
     *          ENPHO4(1:NDBASE,1:NDBASE,0:NDIM_L),
     *          ENPOHO(1:NDBASE,1:NDBASE,0:NDIM_L)
      DIMENSION
     *          POLYNL(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *          POLYNX(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *          DPOLYN(1:NDGAUS,0:NDIM_N,0:NDIM_L) 
      DIMENSION
     *          RNODES(1:NDGAUS,0:NDIM_L),
     *          RWEIGH(1:NDGAUS,0:NDIM_L)
      DIMENSION
     *          HOMEGA(1:NDNUCL)
C
      COMMON
     *         /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                  LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                  NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                     LOGBIS  
C
C=======================================================================
C
C     This an intrinsic-test routine checking the fact that the total 
C     HO hamiltonian  (the sum of the kinetic and potential energies) 
C     is diagonal in the  {|n l s j m_j>}  basis,  the diagonal terms 
C     being the eigen-energies E_nl=(2n+l+3/2)*homega.
C
C     Furthermore according to the virial theorem, the diagonal terms 
C     of the kinetic and potential energies must be equal, both being 
C     equal to 0.5*E_nl.  In order to perform the accuracy tests,  it 
C     will be of advantage to express the matrix elements in units of 
C     HOMEGA.
C
C     This subroutine is identical to KINMAT but here the calculation 
C     of the HO potential has been included,  and the discussed check 
C     performed  together  with the calculation  of the  HO potential 
C     matrix elements, and therefore, the kinetic energy test  (valid 
C     then for all potentials) is performed.
C                                                           H.M. 2008 
C=======================================================================     
C
C=======================================================================     
C     This subroutine  calculates  the matrix elements of the kinetic
C     energy term  [the H.O. scaling factors  may be dependent on the 
C     nucleonic mass]
C=======================================================================     
C
C @@@ ???
CID      EPSTST=1.Q-29 ! These two definitions of EPSTST serve
CID      EPSTST=1.Q-28 ! when working with quadruple precision
C
      EPSTST=1.E-12 ! Working in double precision
C
      HOMAUX=HOMEGA(INUCLI)
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C=======================================================================     
C
      DO LQNUMB=NSHELL,0,-1
         DO NQNUMB=0,(NSHELL-LQNUMB)/2
            DO I_PNTS=1,NGAUSS
C
               ZNODES=RNODES(I_PNTS,LQNUMB)
C
               TERM_1=0.50*(FLOAT(LQNUMB+1)-ZNODES)
C
               POLYNX(I_PNTS,NQNUMB,LQNUMB)=TERM_1
     *	                                    *POLYNL(I_PNTS,NQNUMB,LQNUMB)
     *                                     +ZNODES
     *                                     *DPOLYN(I_PNTS,NQNUMB,LQNUMB)
            END DO
         END DO
      END DO
C_______________________________________________________________________
C
      DO LQNUMB=NSHELL,0,-1
C
C        Here we are going to construct the T-sub-block at given L
C
         ETOTA4_MAXABS=-99999.0
         ENEDI4_MAXABS=-99999.0
C
         DO N1NUMB=0,(NSHELL-LQNUMB)/2
C
            IF (N1NUMB+1.GT.NDBASE) THEN
                STOP 'N1NUMB+1.GT.NDBASE in CHEKHO'
            END IF
C
            DO N2NUMB=0,(NSHELL-LQNUMB)/2       
C       
               T_ELEM=0.00 ! Kinetic Energy
               HOELEM=0.00 ! Harmonic Oscillator Potential
C       
               DO I_PNTS=1,NGAUSS
C
                  IF (IALPHA.EQ.0) THEN
C
                      ZNODES=RNODES(I_PNTS,LQNUMB)
C
                      TERM_1=POLYNX(I_PNTS,N1NUMB,LQNUMB)
     *                      *POLYNX(I_PNTS,N2NUMB,LQNUMB)
C
                      TERM_2=0.250*FLOAT(LQNUMB*(LQNUMB+1))
     *		                    *POLYNL(I_PNTS,N1NUMB,LQNUMB)
     *                      *POLYNL(I_PNTS,N2NUMB,LQNUMB)
C
                      TERMHO=POLYNL(I_PNTS,N1NUMB,LQNUMB)
     *                      *ZNODES*ZNODES
     *                      *POLYNL(I_PNTS,N2NUMB,LQNUMB)
C
                      T_ELEM=T_ELEM+(TERM_1+TERM_2)
     *                      *RWEIGH(I_PNTS,LQNUMB)
C                 
                      HOELEM=HOELEM+TERMHO*RWEIGH(I_PNTS,LQNUMB)
C
                  END IF
C_______________________________________________________________________
C
                  IF (IALPHA.EQ.1) THEN
C
                      ZNODES=RNODES(I_PNTS,LQNUMB)
C 
                      TERM_1=POLYNX(I_PNTS,N1NUMB,LQNUMB)
     *                      *POLYNX(I_PNTS,N2NUMB,LQNUMB)/ZNODES
C
                      TERM_2=0.250*FLOAT(LQNUMB*(LQNUMB+1))
     *		                    *POLYNL(I_PNTS,N1NUMB,LQNUMB)
     *                      *POLYNL(I_PNTS,N2NUMB,LQNUMB)/ZNODES
C
                      TERMHO=POLYNL(I_PNTS,N1NUMB,LQNUMB)
     *                      *POLYNL(I_PNTS,N2NUMB,LQNUMB)*ZNODES
C 
                      T_ELEM=T_ELEM
     *                      +
     *                      (TERM_1+TERM_2)*RWEIGH(I_PNTS,LQNUMB)
C                 
                      HOELEM=HOELEM+TERMHO*RWEIGH(I_PNTS,LQNUMB)
C
                  END IF ! IALPHA=1
C
               END DO ! I_PNTS =>> NGAUSS
C
C              The factor of 2.0 in the following line takes into
C              account the fact that  XNORNL  are defined without
C              the factor sqrt(2). XNORNL are defined without the 
C              stretching factor "a" either, but this one cancels 
C              out in the calculations.
C
               ENKIN4(N1NUMB+1,N2NUMB+1,LQNUMB)=2.00*QEXT(HOMAUX)
     *                                              *T_ELEM
C
               ENPHO4(N1NUMB+1,N2NUMB+1,LQNUMB)=2.00*0.50*0.50
     *                                         *HOMAUX
     *                                         *HOELEM
C
C=======================================================================
C
               ETOTA4=ENKIN4(N1NUMB+1,N2NUMB+1,LQNUMB)
     *	              +ENPHO4(N1NUMB+1,N2NUMB+1,LQNUMB)
C
C=======================================================================
C
               IF (N1NUMB.NE.N2NUMB) THEN
                   ABSET4=ABS(ETOTA4)
                   IF (ETOTA4_MAXABS.LT.ABSET4) ETOTA4_MAXABS=ABSET4
                   IF (ABSET4.GT.EPSTST) THEN
                       STOP 'HO oscillator - tot in CHEKHO'
                   END IF
               END IF
C
C=======================================================================
C
               IF (N1NUMB.EQ.N2NUMB) THEN
C
                   EVERI4=(2.0000*FLOAT(N1NUMB)+FLOAT(LQNUMB)+1.50)
     *                   * HOMAUX
C
                   ENEDI4=ABS(ENKIN4(N1NUMB+1,N2NUMB+1,LQNUMB)
     * 		                -0.5*EVERI4)
C
                   IF (ENEDI4_ABSMAX.LT.ENEDI4) ENEDI4_ABSMAX=ENEDI4 
C
                   IF (ENEDI4.GT.EPSTST) THEN
C
                       WRITE(LSCREN ,'(''ENEDI4='',F38.33,3X,
     *		                               ''EPSTST='',F38.33)')
     *                                   ENEDI4,EPSTST
C
                       STOP 'HO oscillator - kinetic energy in CHEKHO'
C
                   END IF
C
                   ENEDI4=ABS(ENPHO4(N1NUMB+1,N2NUMB+1,LQNUMB)
     * 		                -0.5*EVERI4)
C
                   IF (ENEDI4.GT.EPSTST) THEN
C
                       WRITE(0,'(''ENEDI4='',F38.33,3X,
     *		                         ''EPSTST='',F38.33)')
     *                             ENEDI4,EPSTST
C
                       STOP 'HO oscillator - potential energy in CHEKHO'
C
                    END IF
C
                END IF
C
C=======================================================================
C
            END DO
C
         END DO
C
         IF (LOGWRI.GT.0 .AND. LQNUMB.LT.(NSHELL-1)) THEN
             WRITE(LOGFIL,'(9X,''LQNUMB='',I2,'' ETOTA4='',F20.15,1X,
     *                                        '' ENEDI4='',F20.15)')
     *                           LQNUMB,         ETOTA4_MAXABS,
     *                                           ENEDI4_ABSMAX
         END IF
C      
      END DO
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(19X,''EPSTST='',F20.15,''  EPSTST='',F20.15)')
     *                         EPSTST,              EPSTST
      END IF
C
C=======================================================================
C
C     Evaluating directly the matrix elements for the HO potential:
C
C     Diagonal matrix elements  of the kinetic energy operator must 
C     always be equal, in the present basis, to the diagonal matrix 
C     elements of the HO potential, both being equal to half of the
C     total energy (virial theorem).
C
C     It follows  that off-diagonal matrix elements  of the kinetic 
C     energy operator are exactly opposite in sign  to those of the 
C     HO potential.
C
C=======================================================================
C
      DO LQNUMB=NSHELL,0,-1
C
         DO N1NUMB=0,(NSHELL-LQNUMB)/2
C
            DO N2NUMB=0,(NSHELL-LQNUMB)/2       
C
               ENPOHO(N1NUMB+1,N2NUMB+1,LQNUMB)=0.00
C
               IF (N1NUMB.EQ.N2NUMB) THEN
C
                   ENPOHO(N1NUMB+1,N1NUMB+1,LQNUMB)
     *		          =0.500*(2.0000*FLOAT(N1NUMB)+FLOAT(LQNUMB)+1.50)
     *            *HOMAUX

               END IF
C
               IF (N1NUMB.EQ.(N2NUMB-1)) THEN
C
                   ENPOHO(N1NUMB+1,N2NUMB+1,LQNUMB)
     *		          =-0.500*HOMAUX
     *            *SQRT(FLOAT(N2NUMB)*(FLOAT(N2NUMB+LQNUMB)+0.50))
C
	              END IF
C
               IF (N1NUMB.EQ.(N2NUMB+1)) THEN
C
                   ENPOHO(N1NUMB+1,N2NUMB+1,LQNUMB)
     *		          =-0.500*HOMAUX
     *                   *SQRT(FLOAT(N2NUMB+1)
     *                       *(FLOAT(N2NUMB+LQNUMB)+1.500))
C
	              END IF
C
C=======================================================================     
C
               IF (N1NUMB.EQ.N2NUMB) THEN
C
                   DIFFMA=ENPOHO(N1NUMB+1,N2NUMB+1,LQNUMB)
     *                   -ENKIN4(N1NUMB+1,N2NUMB+1,LQNUMB)
               ELSE
C
                   DIFFMA=ENPOHO(N1NUMB+1,N2NUMB+1,LQNUMB)
     *                 -(-ENKIN4(N1NUMB+1,N2NUMB+1,LQNUMB))
	           END IF
C
            IF (ABS(DIFFMA).GT.EPSTST) THEN
                STOP 'ABS(DIFFMA).GT.EPSTST in CHEKHO'
            END IF
C
C=======================================================================     
C
            END DO
C
         END DO
C      
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.3) THEN
          WRITE(LOGFIL,'(''Exiting  CHEKHO'')')
      END IF
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C 
C FILE NAME = wspher05_hamilt_15.f ! Keep this symbol:    $ident@string$
C      
C=======================================================================
C=======================================================================
C          CONSTRUCTION OF THE HAMILTONIAN MATRIX AND RELATED
C=======================================================================
C=======================================================================
C
      SUBROUTINE WS_UNI(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,I_FLAG,
     *                                CHISQU_PROTON,CHISQU_NEUTRS)
C
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDGAUS.f'
      INCLUDE   'MATDIM/NDIM_N.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDMAIN.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1)
C
      CHARACTER
     *          WHATEX*6,TYPCHI*6,INPSYM*6,NUCSYM*6
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
C
      DIMENSION
     *          LABORD_AUXILP(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *          LABORD_AUXILN(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          RFUNUP_PROTON(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNDN_PROTON(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNUP_NEUTRS(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNDN_NEUTRS(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          RAD_UP(0:NDIM_L,0:NDIM_N),
     *         	RAD_DN(0:NDIM_L,0:NDIM_N)
      DIMENSION
     *          HSORUP(1:NDBASE,1:NDBASE),
     *          HSORDN(1:NDBASE,1:NDBASE)
      DIMENSION
     *          SPENUP(1:NDBASE),
     *          SPENDN(1:NDBASE),     
     *          AUXVEC(1:NDBASE)  
C
      COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /EKINET/ ENEKIN_PROTON(1:NDNUCL,1:NDBASE,
     *                                       1:NDBASE,0:NDIM_L),
     *                ENEKIN_NEUTRS(1:NDNUCL,1:NDBASE,
     *                                       1:NDBASE,0:NDIM_L)
      COMMON
     *       /CFACTO/ CMATUP_PROTON(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_PROTON(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_NEUTRS(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_NEUTRS(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                              LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                              LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /NODWEI/ XRNODE(1:NDGAUS,0:NDIM_L),
     *                XRWEIG(1:NDGAUS,0:NDIM_L)
      COMMON
     *       /POLPOL/ XPOLYN(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *                XDPOLY(1:NDGAUS,0:NDIM_N,0:NDIM_L) 
      COMMON
     *       /V2COEF/ VCOEUP_PROTON(0:NDIM_L,1:NDBASE),
     *                VCOEDN_PROTON(0:NDIM_L,1:NDBASE),
     *
     *                VCOEUP_NEUTRS(0:NDIM_L,1:NDBASE),
     *                VCOEDN_NEUTRS(0:NDIM_L,1:NDBASE)
      COMMON
     *       /ENUPDN/ ENERUP_PROTON(0:NDIM_L,1:NDBASE),
     *                ENERDN_PROTON(0:NDIM_L,1:NDBASE),

     *
     *                ENERUP_NEUTRS(0:NDIM_L,1:NDBASE),
     *                ENERDN_NEUTRS(0:NDIM_L,1:NDBASE)
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /FERGPS/ FERMEX_PROTON(1:NDNUCL),GAPEXP_PROTON(1:NDNUCL),
     *                DENSUP_PROTON(1:NDNUCL),DENSDW_PROTON(1:NDNUCL),
     *
     *                FERMEX_NEUTRS(1:NDNUCL),GAPEXP_NEUTRS(1:NDNUCL),
     *                DENSUP_NEUTRS(1:NDNUCL),DENSDW_NEUTRS(1:NDNUCL) 
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
C     
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)   
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI   
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON
     *       /DENSIF/ ITRNUM
     *       /WHENST/ DIFFVA
     *       /DENSTR/ IFDENS
     *       /GNUPLO/ IGNUPL
      COMMON
     *       /ACTIVE/ IACTIV,IwMODE
     *       /FEVALS/ IFUNCT_EVALUS
     *       /MASSIV/ IMASIV_PRODUC
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C  @@@ IRENE - WHAT IS THE ROLE OF THIS EPSSIL ???
      DATA 
     *        EPSSIL / 1.0e-3 /
      DATA
     *        SPENER_MXPRIN / 10.000 / ! No print above that energy
C
C=======================================================================
C
C     This subroutine functions as the standard WS-ODD code. Its form
C     has been adapted to enable the connection with the minimisation
C     subroutines.
C
C     Some extra routines, allowing a comparison with experiment, and 
C     facilitating the definition of the ch^2 type routines are:
C
C     RDPROT_RMSRAD - reads the experimental  proton  mean square radii;
C     PROVID_RMS_NR - gives the experimental  neutron mean square radii;
C     READEX_LEVELS - reads the experimental spherical levels for doubly
C                     magic nuclei;
C
C     PREPAR_EXPLEV - transforms single particle excitation energies of
C                     one-hole and one-particle nuclei,  which are read 
C                     in SUBROUTINE READEX_LEVELS, into format suitable
C                     for comparisons with the calculations;
C
C     SERVIS - internal control subroutine
C     EXPTHE - internal control subroutine
C
C=======================================================================
C
      CALL CPUTIM('WS_UNI',1)
C
C=======================================================================
C
      IwMODE=I_MODE
C
      IF (I_MODE.EQ.0.OR.I_MODE.EQ.2) THEN
          IF (LOGWRI.GT.4) WRITE(IRESUL,'(/,''IwMODE='',I1)') IwMODE
      ELSE
          IF (LOGWRI.GT.4) WRITE(IRESUL,'(  ''IwMODE='',I1)') IwMODE
      END IF
C      
C     IFEXPE=IFFITS
C
C @@@ IRENE - what is is nonsense? NOUTPT is Standard output = 6 always
C      NOUTPT=IRESUL
      IABORT=0
C
C      IDEFCN=IDEFCN+1
C
C=======================================================================
C
      IF (IDEFCN.GT.ITECHI) THEN
C
CID          WRITE(ICONVE,'(/,80(''!''),/,''!WS_UNI'',72x,''!''/,
C     *                 ''!   The allowed maximum number of function'',
C     *                 '' evaluations ITECHI='',i4,''  exceeded   !'',/,
C     *                 ''!'',78x,''!''/,80(''!''))')
C     *                                                           ITECHI
C          
          WRITE(LOGAUX,'(/,80(''!''),/,''!WS_UNI'',72x,''!''/,
     *                 ''!   The allowed maximum number of function'',
     *                 '' evaluations ITECHI='',i4,''  exceeded   !'',/,
     *                 ''!'',78x,''!''/,80(''!''))')
     *                                                           ITECHI
          IABORT=1
C          
CID          WRITE(ICONVE,'(''RETURN from WS_UNI - before WSSTAN'')')
C          
          WRITE(LOGAUX,'(''RETURN from WS_UNI - before WSSTAN'')')
C          
          RETURN
C
      END IF
C
C=======================================================================
C     Solving the Schroedinger Equation (params in POTPOT)
C=======================================================================
C
      IZ_FIX=NUMB_Z(INUCLI)
      IN_FIX=NUMB_N(INUCLI)
C
      IF (IFDENS.EQ.0) THEN
C
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(15X,''Entering WSSTAN from WS_UNI [1], '',
     *                           ''IFDENS=0 IZ_FIX='',I2,
     *                                   '' IN_FIX='',I3)') 
     *                                      IZ_FIX,IN_FIX
          END IF 
C
          CALL WSSTAN(INUCLI,
     *                XPOLYN,XRNODE,XRWEIG,NGAUSS,NSHELL_PROTON,
     *                NDGAUS,NDIM_N,NDIM_L,NDBASE,NSHELL_NEUTRS,
     *                       HSORUP,HSORDN,SPENUP,SPENDN,AUXVEC,IABORT,
     *                                     CMATUP_PROTON,CMATDN_PROTON,
     *                                     CMATUP_NEUTRS,CMATDN_NEUTRS,
     *                                     ENERUP_PROTON,ENERDN_PROTON,
     *                                     ENERUP_NEUTRS,ENERDN_NEUTRS,
     *                                     ENEKIN_PROTON,ENEKIN_NEUTRS)
C
      END IF
C
C=======================================================================
C      
      DO N=0,NDIM_N
         DO L=0,NDIM_L
            DO J=0,2*NDIM_L+1
               LABORD_AUXILP(N,L,J)=LABORD_PROTON(INUCLI,N,L,J)
               LABORD_AUXILN(N,L,J)=LABORD_NEUTRS(INUCLI,N,L,J)
            END DO
         END DO
      END DO
C
      RMSTHE_PROTON=0.
      RMSTHE_NEUTRS=0.
C
      ISOSPI=1      
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(/,15X,''Entering NUCRAD from WS_UNI'',1X,
     *                                             ''ISOSPI='',I1)')
     *                                               ISOSPI
      END IF  
C
                         LDSPEC=LDSING_PROTON
      CALL NUCRAD(NDSPEC,LDSPEC,NDGAUS,NGAUSS,NDBASE,XPOLYN,
     *            NDIM_L,NDIM_N,RAD_UP,RAD_DN,XRNODE,XRWEIG,
     *            AOSCIL_PROTON,RFUNUP_PROTON,RFUNDN_PROTON,
     *            NSHELL_PROTON,ENERUP_PROTON,ENERDN_PROTON,
     *            NWSSPH_PROTON,LWSSPH_PROTON,JWSSPH_PROTON,
     *            RMSTHE_PROTON,RMSPAI_PROTON,RMSNOP_PROTON,
     *            LABORD_AUXILP,CMATUP_PROTON,CMATDN_PROTON,  
     *            ENETHE_PROTON,VCOEUP_PROTON,VCOEDN_PROTON,
     *                                 ISOSPI,IZ_FIX,INUCLI)
C
      ISOSPI=0      
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(/,15X,''Entering NUCRAD from WS_UNI'',1X,
     *                                             ''ISOSPI='',I1)')
     *                                               ISOSPI
      END IF  
                         LDSPEC=LDSING_NEUTRS
      CALL NUCRAD(NDSPEC,LDSPEC,NDGAUS,NGAUSS,NDBASE,XPOLYN,
     *            NDIM_L,NDIM_N,RAD_UP,RAD_DN,XRNODE,XRWEIG,
     *            AOSCIL_NEUTRS,RFUNUP_NEUTRS,RFUNDN_NEUTRS,
     *            NSHELL_NEUTRS,ENERUP_NEUTRS,ENERDN_NEUTRS,
     *            NWSSPH_NEUTRS,LWSSPH_NEUTRS,JWSSPH_NEUTRS,
     *            RMSTHE_NEUTRS,RMSPAI_NEUTRS,RMSNOP_NEUTRS,
     *            LABORD_AUXILN,CMATUP_NEUTRS,CMATDN_NEUTRS,  
     *            ENETHE_NEUTRS,VCOEUP_NEUTRS,VCOEDN_NEUTRS,
     *                                 ISOSPI,IN_FIX,INUCLI)
C
C=======================================================================
C     Testing the quality of the experimental spectra for
C     doubly-magic, spherical nuclei           (IFEXPE=1)
C=======================================================================
C
      ISOSPI=1
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(/,15X,''Entering EXPTHE from WS_UNI'',1X,
     *                                             ''ISOSPI='',I1)')
     *                                               ISOSPI
      END IF  
C      
      CALL EXPTHE(IZ_FIX,IN_FIX,DENSUP_PROTON,DENSDW_PROTON,
     *            FERMEX_PROTON,GAPEXP_PROTON,IDEFCN,ISOSPI,
     *                   IPARAM,CHISQU_CHOICE,I_FLAG,INUCLI)
C
      CHISQU_PROTON=CHISQU_CHOICE
C
      ISOSPI=0
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(/,15X,''Entering EXPTHE from WS_UNI'',1X,
     *                                             ''ISOSPI='',I1)')
     *                                               ISOSPI
      END IF  
C
      CALL EXPTHE(IZ_FIX,IN_FIX,DENSUP_NEUTRS,DENSDW_NEUTRS,
     *            FERMEX_NEUTRS,GAPEXP_NEUTRS,IDEFCN,ISOSPI,
     *                   IPARAM,CHISQU_CHOICE,I_FLAG,INUCLI)
C
      CHISQU_NEUTRS=CHISQU_CHOICE
C 
      IFUNCT_EVALUS=IFUNCT_EVALUS+1
C
C=======================================================================     
C
      WRITE(NOUTPT,'()')
C
      WRITE(NOUTPT,'(80(''#''),/,''#'',78X,''#'')')
      WRITE(NOUTPT,'(''#'',20X,''IZ_FIX='',I3,20X,
     *                                    ''IN_FIX='',I3,
     *                                   18X,''#'',/,''#'',78X,''#'')')
     *                                 IZ_FIX,            IN_FIX
       
      WRITE(NOUTPT,'(80(''#''),/,''#'',78X,''#'')')
      WRITE(NOUTPT,'(''#'',2X,''NEUTRONS: Theoretical vs. '',
     *                            ''Experimental Energies'',29x,''#'')')
      WRITE(NOUTPT,'(''#'',78X,''#'',/,80(''#''))')
      WRITE(NOUTPT,'(''#'',78X,''#'')')
       
      WRITE(NOUTPT,'(''#'',3X,''No)'',7x,''Labels'',7x,
     *                                              ''EneThe'',
     *                      14X,''No)'',7x,''Labels'',7x,''EneExp'',3X,
     *                                                         ''#'')')
C
      DO ITHEOR=1,LDSING_NEUTRS
C
         IF (ENETHE_NEUTRS(ITHEOR+1).GT.SPENER_MXPRIN) THEN
             GO TO 7
         END IF
C
         DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
C
            IF (LABEXP_NEUTRS(INUCLI,IEXPER) .EQ.
     *          LABTHE_NEUTRS(ITHEOR))       THEN
C
                WRITE(NOUTPT,'(''#'',i5,'')'',7x,a6,f20.13,
     *                              4X,i5,'')'',7x,a6,f15.4,1X,''#'')')
     *                                  ITHEOR,
     *                                  LABTHE_NEUTRS(ITHEOR),
     *                                  ENETHE_NEUTRS(ITHEOR),
     *                                  IEXPER,
     *                                  LABEXP_NEUTRS(INUCLI,IEXPER),
     *                                  EXPEXP_NEUTRS(INUCLI,IEXPER)
                 GO TO 5
            END IF
         END DO
           
         WRITE(NOUTPT,'(''#'',i5,'')'',7x,a6,f20.13,39X,    
     *                            ''#'')')ITHEOR,LABTHE_NEUTRS(ITHEOR),
     *                                           ENETHE_NEUTRS(ITHEOR)
  5      CONTINUE
C
      END DO
C
  7   CONTINUE
C
      WRITE(NOUTPT,'(''#'',78X,''#'',/,80(''#''),/,''#'',78X,''#'')')
C
      WRITE(NOUTPT,'(''#'',2X,''PROTONS: Theoretical vs. '',
     *                            ''Experimental Energies'',30x,''#'')')
      WRITE(NOUTPT,'(''#'',78X,''#'',/,80(''#''))')
      WRITE(NOUTPT,'(''#'',78X,''#'')')
      
      WRITE(NOUTPT,'(''#'',3X,''No)'',7x,''Labels'',7x,
     *                                              ''EneThe'',
     *                      14X,''No)'',7x,''Labels'',7x,''EneExp'',3X,
     *                                                         ''#'')')
      DO ITHEOR=1,LDSING_PROTON
C
         IF (ENETHE_NEUTRS(ITHEOR+1).GT.SPENER_MXPRIN) THEN
             GO TO 8
         END IF
C
         DO IEXPER=1,LEVEXP_PROTON(INUCLI)
C
            IF (LABEXP_PROTON(INUCLI,IEXPER) .EQ.
     *          LABTHE_PROTON(ITHEOR))       THEN
C
                WRITE(NOUTPT,'(''#'',i5,'')'',7x,a6,f20.13,
     *                           4X,i5,'')'',7x,a6,f15.4,1X,''#'')')
     *                                  ITHEOR,
     *                                  LABTHE_PROTON(ITHEOR),
     *                                  ENETHE_PROTON(ITHEOR),
     *                                  IEXPER,
     *                                  LABEXP_PROTON(INUCLI,IEXPER),
     *                                  EXPEXP_PROTON(INUCLI,IEXPER)
                GO TO 6
            END IF
         END DO
           
         WRITE(NOUTPT,'(''#'',i5,'')'',7x,a6,f20.13,39X, 
     *                            ''#'')')ITHEOR,LABTHE_PROTON(ITHEOR),
     *                                           ENETHE_PROTON(ITHEOR)
  6      CONTINUE
C
      END DO
C
  8   CONTINUE
C
      WRITE(NOUTPT,'(''#'',78X,''#'',/,80(''#''))')
C
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(12X,''Exiting  WS_UNI'')')
      END IF
C      
C=======================================================================
C
      CALL CPUTIM('WS_UNI',0)   
C      
C=======================================================================
C      
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,I_FLAG,
     *                                CHISQU_PROTON,CHISQU_NEUTRS)
C
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDGAUS.f'
      INCLUDE   'MATDIM/NDIM_N.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDMAIN.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1)
C
      CHARACTER
     *          WHATEX*6,TYPCHI*6,INPSYM*6,NUCSYM*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
C
      DIMENSION
     *          LABORD_AUXILP(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *          LABORD_AUXILN(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          RFUNUP_PROTON(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNDN_PROTON(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNUP_NEUTRS(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNDN_NEUTRS(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          RAD_UP(0:NDIM_L,0:NDIM_N),
     *         	RAD_DN(0:NDIM_L,0:NDIM_N)
      DIMENSION
     *          HSORUP(1:NDBASE,1:NDBASE),
     *          HSORDN(1:NDBASE,1:NDBASE)
      DIMENSION
     *          SPENUP(1:NDBASE),
     *          SPENDN(1:NDBASE),     
     *          AUXVEC(1:NDBASE)  
C
      COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /EKINET/ ENEKIN_PROTON(1:NDNUCL,1:NDBASE,
     *                                       1:NDBASE,0:NDIM_L),
     *                ENEKIN_NEUTRS(1:NDNUCL,1:NDBASE,
     *                                       1:NDBASE,0:NDIM_L)
      COMMON
     *       /CFACTO/ CMATUP_PROTON(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_PROTON(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_NEUTRS(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_NEUTRS(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                              LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                              LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /NODWEI/ XRNODE(1:NDGAUS,0:NDIM_L),
     *                XRWEIG(1:NDGAUS,0:NDIM_L)
      COMMON
     *       /POLPOL/ XPOLYN(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *                XDPOLY(1:NDGAUS,0:NDIM_N,0:NDIM_L) 
      COMMON
     *       /V2COEF/ VCOEUP_PROTON(0:NDIM_L,1:NDBASE),
     *                VCOEDN_PROTON(0:NDIM_L,1:NDBASE),
     *
     *                VCOEUP_NEUTRS(0:NDIM_L,1:NDBASE),
     *                VCOEDN_NEUTRS(0:NDIM_L,1:NDBASE)
      COMMON
     *       /ENUPDN/ ENERUP_PROTON(0:NDIM_L,1:NDBASE),
     *                ENERDN_PROTON(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_NEUTRS(0:NDIM_L,1:NDBASE),
     *                ENERDN_NEUTRS(0:NDIM_L,1:NDBASE)
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /FERGPS/ FERMEX_PROTON(1:NDNUCL),GAPEXP_PROTON(1:NDNUCL),
     *                DENSUP_PROTON(1:NDNUCL),DENSDW_PROTON(1:NDNUCL),
     *
     *                FERMEX_NEUTRS(1:NDNUCL),GAPEXP_NEUTRS(1:NDNUCL),
     *                DENSUP_NEUTRS(1:NDNUCL),DENSDW_NEUTRS(1:NDNUCL) 
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
C     
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)   
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI   
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON
     *       /DENSIF/ ITRNUM
     *       /WHENST/ DIFFVA
     *       /DENSTR/ IFDENS
     *       /GNUPLO/ IGNUPL
      COMMON
     *       /ACTIVE/ IACTIV,IwMODE
     *       /FEVALS/ IFUNCT_EVALUS
     *       /MASSIV/ IMASIV_PRODUC
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS                                                  
C  @@@ IRENE - WHAT IS THE ROLE OF THIS EPSSIL ???
      DATA 
     *        EPSSIL / 1.0e-3 /
C
C=======================================================================
C
C     This subroutine functions as the standard WS-ODD code. Its form
C     has been adapted to enable the connection with the minimisation
C     subroutines.
C
C     Some extra routines, allowing a comparison with experiment, and 
C     facilitating the definition of the ch^2 type routines are:
C
C     RDPROT_RMSRAD - reads the experimental  proton  mean square radii;
C     PROVID_RMS_NR - gives the experimental  neutron mean square radii;
C     READEX_LEVELS - reads the experimental spherical levels for doubly
C                     magic nuclei;
C
C     PREPAR_EXPLEV - transforms single particle excitation energies of
C                     one-hole and one-particle nuclei,  which are read 
C                     in SUBROUTINE READEX_LEVELS, into format suitable
C                     for comparisons with the calculations;
C
C     SERVIS - internal control subroutine
C     EXPTHE - internal control subroutine
C
C=======================================================================
C
      CALL CPUTIM('WS_RUN',1)
C
C=======================================================================
C
      IwMODE=I_MODE
C
      IF (I_MODE.EQ.0.OR.I_MODE.EQ.2) THEN
          IF (LOGWRI.GT.4) WRITE(IRESUL,'(/,''IwMODE='',I1)') IwMODE
      ELSE
          IF (LOGWRI.GT.4) WRITE(IRESUL,'(  ''IwMODE='',I1)') IwMODE
      END IF
C      
C     IFEXPE=IFFITS
C
C @@@ IRENE - what is is nonsense? NOUTPT is Standard output = 6 always
C      NOUTPT=IRESUL
      IABORT=0
C
C      IDEFCN=IDEFCN+1
C
C=======================================================================
C
      IF (IDEFCN.GT.ITECHI) THEN
C
CID          WRITE(ICONVE,'(/,80(''!''),/,''!WS_RUN'',72x,''!''/,
C     *                 ''!   The allowed maximum number of function'',
C     *                 '' evaluations ITECHI='',i4,''  exceeded   !'',/,
C     *                 ''!'',78x,''!''/,80(''!''))')
C     *                                                           ITECHI
C          
          WRITE(LOGAUX,'(/,80(''!''),/,''!WS_RUN'',72x,''!''/,
     *                 ''!   The allowed maximum number of function'',
     *                 '' evaluations ITECHI='',i4,''  exceeded   !'',/,
     *                 ''!'',78x,''!''/,80(''!''))')
     *                                                           ITECHI
          IABORT=1
C          
CID          WRITE(ICONVE,'(''RETURN from WS_RUN - before HAMMAT'')')
C          
          WRITE(LOGAUX,'(''RETURN from WS_RUN - before HAMMAT'')')
C
          WRITE(000000,'(''RETURN from WS_RUN - before HAMMAT'')')
C
          CALL CPUTIM('WS_RUN',0)
C          
          RETURN
C
      END IF
C
C=======================================================================
C     Solving the Schroedinger Equation (params in POTPOT)
C=======================================================================
C
      DIFFVA=999.
      ITRNUM=0
C
      IZ_FIX=NUMB_Z(INUCLI)
      IN_FIX=NUMB_N(INUCLI)
C
      IF (IFDENS.EQ.0) THEN
C
          IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(15X,''Entering HAMMAT from WS_RUN [1], '',
     *                           ''IFDENS=0 IZ_FIX='',I2,
     *                                   '' IN_FIX='',I3)') 
     *                                      IZ_FIX,IN_FIX
          END IF 
C
          CALL HAMMAT(INUCLI,XPOLYN,XDPOLY,XRNODE,XRWEIG,NGAUSS,
     *                       NSHELL_PROTON,NDGAUS,NSHELL_NEUTRS,
     *                HSORUP,HSORDN,SPENUP,SPENDN,AUXVEC,IABORT,
     *                              CMATUP_PROTON,CMATDN_PROTON,
     *                              CMATUP_NEUTRS,CMATDN_NEUTRS,
     *                              ENEKIN_PROTON,ENEKIN_NEUTRS,
     *                              LABORD_PROTON,LABORD_NEUTRS)
C
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.1) THEN
C      
   1      CONTINUE 
C
          IF (SQRT(DIFFVA).GE.EPSSIL) THEN 
C
              IF (LOGWRI.GT.4) THEN
              WRITE(LOGFIL,'(15X,''Entering HAMMAT from WS_RUN [2], '',
     *                           ''DIFFVA= '',F22.13,/,45X,
     *                           ''EPSSIL= '',F22.13)') DIFFVA,EPSSIL
              END IF 
C
              CALL HAMMAT(INUCLI,XPOLYN,XDPOLY,XRNODE,XRWEIG,NGAUSS,
     *                           NSHELL_PROTON,NDGAUS,NSHELL_NEUTRS,
     *                    HSORUP,HSORDN,SPENUP,SPENDN,AUXVEC,IABORT,
     *                                  CMATUP_PROTON,CMATDN_PROTON,
     *                                  CMATUP_NEUTRS,CMATDN_NEUTRS,
     *                                  ENEKIN_PROTON,ENEKIN_NEUTRS,
     *                                  LABORD_PROTON,LABORD_NEUTRS)
              IF (IFTEST.EQ.1) THEN
C              
                  WRITE(21,'()')
                  WRITE(21,'(''ITRUM='',I3.2,''  DIFFVA='',ES15.5,
     *                       ''  SQRT(DIFFVA)='',ES15.5)')
     *                         ITRNUM,DIFFVA,SQRT(DIFFVA)
              END IF
               
              ITRNUM=ITRNUM+1
C
	      IF (IABORT.EQ.1) THEN
C
                  WRITE(LOGAUX,'(''RETURN in WS_RUN after HAMMAT: '',
     *                           ''IABORT= '',I1,'' and ITRNUM= '',I5)')
     *                             IABORT,              ITRNUM
                  WRITE(LOGFIL,'(''RETURN in WS_RUN after HAMMAT: '',
     *                           ''IABORT= '',I1,'' and ITRNUM= '',I5)')
     *                             IABORT,              ITRNUM
                  WRITE(000000,'(''RETURN in WS_RUN after HAMMAT: '',
     *                           ''IABORT= '',I1,'' and ITRNUM= '',I5)')
     *                             IABORT,              ITRNUM 
C
                  CALL CPUTIM('WS_RUN',0)
C
                  RETURN
C
              END IF
          ELSE
              GO TO 2
          END IF
C
          GO TO 1
C
   2      CONTINUE 
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(15X,''WS_RUN: ITRNUM='',I3)') ITRNUM
          END IF
C
      END IF
C
C=======================================================================
C      
      DO N=0,NDIM_N
         DO L=0,NDIM_L
            DO J=0,2*NDIM_L+1
               LABORD_AUXILP(N,L,J)=LABORD_PROTON(INUCLI,N,L,J)
               LABORD_AUXILN(N,L,J)=LABORD_NEUTRS(INUCLI,N,L,J)
            END DO
         END DO
      END DO
C
      RMSTHE_PROTON=0.
      RMSTHE_NEUTRS=0.
C
      ISOSPI=1      
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(/,15X,''Entering NUCRAD from WS_RUN'',1X,
     *                                             ''ISOSPI='',I1)')
     *                                               ISOSPI
      END IF  
C
C=======================================================================
C
      IF (IZ_FIX.GT.82) GO TO 100
C
C=======================================================================
C
                         LDSPEC=LDSING_PROTON
      CALL NUCRAD(NDSPEC,LDSPEC,NDGAUS,NGAUSS,NDBASE,XPOLYN,
     *            NDIM_L,NDIM_N,RAD_UP,RAD_DN,XRNODE,XRWEIG,
     *            AOSCIL_PROTON,RFUNUP_PROTON,RFUNDN_PROTON,
     *            NSHELL_PROTON,ENERUP_PROTON,ENERDN_PROTON,                                           
     *            NWSSPH_PROTON,LWSSPH_PROTON,JWSSPH_PROTON,
     *            RMSTHE_PROTON,RMSPAI_PROTON,RMSNOP_PROTON,
     *            LABORD_AUXILP,CMATUP_PROTON,CMATDN_PROTON,  
     *            ENETHE_PROTON,VCOEUP_PROTON,VCOEDN_PROTON,
     *                                 ISOSPI,IZ_FIX,INUCLI)
C
      ISOSPI=0      
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(/,15X,''Entering NUCRAD from WS_RUN'',1X,
     *                                             ''ISOSPI='',I1)')
     *                                               ISOSPI
      END IF  
                         LDSPEC=LDSING_NEUTRS
      CALL NUCRAD(NDSPEC,LDSPEC,NDGAUS,NGAUSS,NDBASE,XPOLYN,
     *            NDIM_L,NDIM_N,RAD_UP,RAD_DN,XRNODE,XRWEIG,
     *            AOSCIL_NEUTRS,RFUNUP_NEUTRS,RFUNDN_NEUTRS,
     *            NSHELL_NEUTRS,ENERUP_NEUTRS,ENERDN_NEUTRS,                                           
     *            NWSSPH_NEUTRS,LWSSPH_NEUTRS,JWSSPH_NEUTRS,
     *            RMSTHE_NEUTRS,RMSPAI_NEUTRS,RMSNOP_NEUTRS,
     *            LABORD_AUXILN,CMATUP_NEUTRS,CMATDN_NEUTRS,  
     *            ENETHE_NEUTRS,VCOEUP_NEUTRS,VCOEDN_NEUTRS,
     *                                 ISOSPI,IN_FIX,INUCLI)
C
C=======================================================================
C
      IF (IZ_FIX.GT.82) GO TO 100
C
C=======================================================================
C     Testing the quality of the experimental spectra for
C     doubly-magic, spherical nuclei           (IFEXPE=1)
C=======================================================================
C
      ISOSPI=1
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(/,15X,''Entering EXPTHE from WS_RUN'',1X,
     *                                             ''ISOSPI='',I1)')
     *                                               ISOSPI
      END IF  
C      
      CALL EXPTHE(IZ_FIX,IN_FIX,DENSUP_PROTON,DENSDW_PROTON,
     *            FERMEX_PROTON,GAPEXP_PROTON,IDEFCN,ISOSPI,
     *                   IPARAM,CHISQU_CHOICE,I_FLAG,INUCLI)
C
      CHISQU_PROTON=CHISQU_CHOICE
C
      ISOSPI=0
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(/,15X,''Entering EXPTHE from WS_RUN'',1X,
     *                                             ''ISOSPI='',I1)')
     *                                               ISOSPI
      END IF  
C
      CALL EXPTHE(IZ_FIX,IN_FIX,DENSUP_NEUTRS,DENSDW_NEUTRS,
     *            FERMEX_NEUTRS,GAPEXP_NEUTRS,IDEFCN,ISOSPI,
     *                   IPARAM,CHISQU_CHOICE,I_FLAG,INUCLI)
C
      CHISQU_NEUTRS=CHISQU_CHOICE
C 
      IFUNCT_EVALUS=IFUNCT_EVALUS+1
C
C=======================================================================
C
 100  CONTINUE
C
C=======================================================================
C     Printing actual parameters and corresponding Chi^2 (AS ORIG.)
C=======================================================================
C
c ###      IF (I_FLAG.EQ.1) THEN 
c ###          CALL INPRIN(IDEFCN,IACTIV,I_MODE,CHISQU_PROTON,
c ###     *                                     CHISQU_NEUTRS)
c ###      END IF
C ###
C ###    !!!!  NOW THE 'CALL' IS IN SUBROUTINE FUNMIN   !!!!
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(12X,''Exiting  WS_RUN'')')
      END IF
C      
C=======================================================================
C
      CALL CPUTIM('WS_RUN',0)   
C      
C=======================================================================
C      
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE KINMAT(POLYNL,DPOLYN,POLYNX,RNODES,RWEIGH,ENEKIN,
     *                  HOMEGA,NDBASE,NDIM_N,NDIM_L,NSHELL,NDGAUS,
     *                                       NGAUSS,NDNUCL,INUCLI)
C
      DIMENSION
     *          HOMEGA(1:NDNUCL)
      DIMENSION
     *          ENEKIN(1:NDNUCL,1:NDBASE,1:NDBASE,0:NDIM_L)
      DIMENSION
     *          POLYNL(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *          POLYNX(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *          DPOLYN(1:NDGAUS,0:NDIM_N,0:NDIM_L) 
      DIMENSION
     *          RNODES(1:NDGAUS,0:NDIM_L),
     *          RWEIGH(1:NDGAUS,0:NDIM_L)
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
C @@@ How does this routine distinguish
C     between the protons and the neutrons? MASS DIFFEENCES?
C=======================================================================     
C     This subroutine calculates the matrix elements of the kinetic
C     energy term [the H.O. scaling factors may be dependent on the 
C     nucleonic mass]. Formally the difference between the neutrons
C     and protons comes only through the numbers of shells, because
C     the matrix elements take the same form.
C=======================================================================     
C
      DO LQNUMB=NSHELL,0,-1
         DO NQNUMB=0,(NSHELL-LQNUMB)/2
            DO I_PNTS=1,NGAUSS
C
            TERM_1=0.50*(FLOAT(LQNUMB+1)-RNODES(I_PNTS,LQNUMB))
C
            POLYNX(I_PNTS,NQNUMB,LQNUMB)=POLYNL(I_PNTS,NQNUMB,LQNUMB)
     *                                  *TERM_1
     *                                  +DPOLYN(I_PNTS,NQNUMB,LQNUMB)
     *                                  *RNODES(I_PNTS,LQNUMB)
            END DO
         END DO
      END DO
C_______________________________________________________________________
C
      DO LQNUMB=NSHELL,0,-1
C
C        Here we are going to construct the T-sub-block at given L
C
         DO N1NUMB=0,(NSHELL-LQNUMB)/2
            DO N2NUMB=0,(NSHELL-LQNUMB)/2       
C       
               T_ELEM=0.00
C       
               DO I_PNTS=1,NGAUSS
C
                  TERM_1=POLYNX(I_PNTS,N1NUMB,LQNUMB)
     *                  *POLYNX(I_PNTS,N2NUMB,LQNUMB)
C
                  TERM_2=POLYNL(I_PNTS,N1NUMB,LQNUMB)*0.250
     *                  *POLYNL(I_PNTS,N2NUMB,LQNUMB)
     *                  *FLOAT(LQNUMB*(LQNUMB+1))
C       
                  T_ELEM=T_ELEM+(TERM_1+TERM_2)*RWEIGH(I_PNTS,LQNUMB)    
C                  
               END DO
C
C              The factor of 2.0 in the following line takes into
C              account the fact that  XNORNL  are defined without
C              the factor sqrt(2). XNORNL are defined without the 
C              stretching factor "a" either, but this one cancels 
C              out in the calculations.
C
               ENEKIN(INUCLI,N1NUMB+1,N2NUMB+1,LQNUMB)=2.00
     *	                                               *HOMEGA(INUCLI)
     *                                                *T_ELEM
C
C=======================================================================
C      
            END DO
         END DO
C      
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(''Exiting  KINMAT'')')
      END IF
C
C=======================================================================
C
      RETURN
      END      
C
C=======================================================================     
C=======================================================================     
C      
      SUBROUTINE HAMMAT(INUCLI,POLYNL,DPOLYN,RNODES,RWEIGH,NGAUSS,
     *                         NSHELL_PROTON,NDGAUS,NSHELL_NEUTRS,
     *                  HSORUP,HSORDN,SPENUP,SPENDN,AUXVEC,IABORT,
     *                                CMATUP_PROTON,CMATDN_PROTON,
     *                                CMATUP_NEUTRS,CMATDN_NEUTRS,
     *                                ENEKIN_PROTON,ENEKIN_NEUTRS,
     *                                LABORD_PROTON,LABORD_NEUTRS)
C     
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NITERA.f'
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/NDPARS.f'
      INCLUDE  'MATDIM/NDIMaN.f'
      INCLUDE  'MATDIM/LDGAUS.f'
      INCLUDE  'MATDIM/NSIMPS.f'
      INCLUDE  'MATDIM/NDIM_N.f'
C      
      PARAMETER
     *         (NDIMaL=NDIMaN,NDIM_L=NDIM_N,NDBASE=NDIM_N+1)
C
      CHARACTER
     *          STRNG1*1,STRNG2*23
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6
      DIMENSION
     *          ENEKIN_PROTON(1:NDNUCL,1:NDBASE,1:NDBASE,0:NDIM_L),
     *          ENEKIN_NEUTRS(1:NDNUCL,1:NDBASE,1:NDBASE,0:NDIM_L)
      DIMENSION
     *          CAUXUP_PROTON(0:NDIM_N,1:NDBASE),
     *          CAUXDN_PROTON(0:NDIM_N,1:NDBASE),
     *
     *          CAUXUP_NEUTRS(0:NDIM_N,1:NDBASE),
     *          CAUXDN_NEUTRS(0:NDIM_N,1:NDBASE)
      DIMENSION
     *          CMATUP_PROTON(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN_PROTON(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *          CMATUP_NEUTRS(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN_NEUTRS(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          POLYNL(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          DPOLYN(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          LAUXIL(1:NDSPEC),JAUXIL(1:NDSPEC),
     *                           NAUXIL(1:NDSPEC)
      DIMENSION
     *          HSORUP(1:NDBASE,1:NDBASE),
     *          HSORDN(1:NDBASE,1:NDBASE)
      DIMENSION
     *          VPOTUP(1:NDBASE,1:NDBASE),
     *          VPOTDN(1:NDBASE,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          RNODES(1:NDGAUS,0:NDIM_L),
     *          RWEIGH(1:NDGAUS,0:NDIM_L)
      DIMENSION
     *          INDEXS(1:NDSPEC)
      DIMENSION
     *          SPENUP(1:NDBASE),
     *          SPENDN(1:NDBASE),     
     *          AUXVEC(1:NDBASE)     
      DIMENSION
     *          ENETHE(1:NDSPEC)
      DIMENSION
     *          LABORD_PROTON(1:NDNUCL,
     *                        0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *          LABORD_NEUTRS(1:NDNUCL,
     *                        0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
C
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                              LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                              LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /ENUPDN/ ENERUP_PROTON(0:NDIM_L,1:NDBASE),
     *                ENERDN_PROTON(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_NEUTRS(0:NDIM_L,1:NDBASE),
     *                ENERDN_NEUTRS(0:NDIM_L,1:NDBASE)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /ENRGYY/ ENERGY_PROTON(1:NDSPEC,0:NITERA), 
     *                ENERGY_NEUTRS(1:NDSPEC,0:NITERA)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)  
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /V2COEF/ VCOEUP_PROTON(0:NDIM_L,1:NDBASE),
     *                VCOEDN_PROTON(0:NDIM_L,1:NDBASE),
     *
     *                VCOEUP_NEUTRS(0:NDIM_L,1:NDBASE),
     *                VCOEDN_NEUTRS(0:NDIM_L,1:NDBASE)
      COMMON
     *       /V2_COE/ V2_PUP_VECTOR(0:NDIM_L,1:NDBASE),
     *                V2_PDW_VECTOR(0:NDIM_L,1:NDBASE),
     *                DUP_LN(0:NDIM_L,1:NDBASE),
     *                DDW_LN(0:NDIM_L,1:NDBASE),
     *                ENERGY,XLAMBD,DELTA2
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI    
      COMMON
     *       /DENSIF/ ITRNUM
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON
     *       /MASSIV/ IMASIV_PRODUC
      COMMON
     *       /CNTCNT/ ICOUNT_DENGRD,ICOUNT_FUNMIN,ICOUNT_HAMMAT,
     *                ICOUNT_EXPTHE,ICOUNT_CHOICE,ICOUNT_DIAMAT
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
      DATA
     *        EPSTSH        / 1.0E-4 / ! Hermiticity test
      DATA
     *        SPENER_MXPRIN / 10.000 / ! No print above that energy
C
C=======================================================================     
C     This subroutine calculates the matrix elements of the Hamiltonian
C     and diagonalises (through DIAMAT) the corresponding blocks of the
C     Hamiltonian with parallel, and anti-parallel "l-s" configurations
C=======================================================================     
C
C     We refer to the programmed mathematical expressions using Chapter
C     and equation numbers in the following documents:
C
C     Document 1: "Interactions and mean field Hamiltonians" =>> D1
C
C     Document 2: "Nuclear Pairing, Nuclear Superfludity..." =>> D2
C
      CALL CPUTIM('HAMMAT',1)
C
C=======================================================================     
C      
      ICOUNT_HAMMAT=ICOUNT_HAMMAT+1
C
C=======================================================================     
C
      IF (IMASIV_PRODUC.EQ.1 .AND. LOGWRI.GT.4) THEN
C
          WRITE(LOGFIL,'(/,15X,''Entering HAMMAT '',
     *                         ''for massive production'')')
C
          WRITE(LOGFIL,'(15X,''IZ_FIX= '',I3,'' IN_FIX= '',I3,1X,
     *                       ''AOSCIL_PROTON= '',F8.4,1X,
     *                       ''AOSCIL_NEUTRS= '',F8.4,/)')
     *                         IZ_FIX,IN_FIX,AOSCIL_PROTON(INUCLI),
     *                                       AOSCIL_NEUTRS(INUCLI)
C
          WRITE(LOGFIL,'(12X,''Parameters: '',/)')
C
          DO IPARAM=1,NDPARS
              IF (IFTAKE(IPARAM).EQ.1) THEN
                  WRITE(LOGFIL,'(12X,I3,f9.4)') IPARAM,PARPOT(IPARAM)
              END IF
          END DO
C         
      END IF
C
C=======================================================================     
C
      IABORT=0
C
C=======================================================================     
C
C     Begin by introducing all the constant constants ...
C
      CALL INTROD(INUCLI)
C
C=======================================================================
C=======================================================================
C     Beginning with the algorithm for the  p r o t o n s
C=======================================================================
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(NOUTPT,'(/)')
C
      NCOUNT=0
      ISOSPI=1
C
      IF (IFFITS.EQ.1 .OR. IFMESH.EQ.1) THEN
C
          IF (LOGWRI.GT.5) THEN
              WRITE(LOGFIL,'(15X,''Entering SELECT_VSODEN from '',
     *                                                 ''HAMMAT'')')
          END IF
C
          CALL SELECT_VSODEN
C
      END IF
C
C=======================================================================
C
C     Product L * S :
C
C     FACTUP - spin parallel configuration s=1/2 
C     
C     FACTDN - spin antiparallel anti-configuration s=-1/2 
C
C=======================================================================
C  
      DO LQNUMB=NSHELL_PROTON,0,-1
C          
         FACTUP=+0.5*LQNUMB
         FACTDN=-0.5*(LQNUMB+1)     
C
C        Here we are going to construct the H-sub-block at given L
C 
         DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
            SPENUP(N1NUMB+1)=0.0
            SPENDN(N1NUMB+1)=0.0
            DO N2NUMB=0,(NSHELL_PROTON-LQNUMB)/2       
               HSORUP(N1NUMB+1,N2NUMB+1)=0.0
               HSORDN(N1NUMB+1,N2NUMB+1)=0.0
               VPOTUP(N1NUMB+1,N2NUMB+1)=0.0
               VPOTDN(N1NUMB+1,N2NUMB+1)=0.0
            END DO
         END DO
C
C        We are within the l-do-loop
C_______________________________________________________________________
C       
         VCELEM=0.0
         VSELEM=0.0
C_______________________________________________________________________
C                                                            Integration
         DO I_PNTS=1,NGAUSS
C
C           We are using the weight factor e^{-z} z^{l-1/2} and
C           consequently the potential is multiplied by "z" for
C           details, cf. D1, eqs.(4.8.8) - (4.8.10)
C
C           We selected to program Eq.(4.8.10) because this one
C           corresponds directly to the form of the kinetic energy
C
            ZNODES=RNODES(I_PNTS,LQNUMB) 
            ZWEIGH=RWEIGH(I_PNTS,LQNUMB)
         
            VCELEM=VCENTR(INUCLI,ZNODES,I_PNTS,LQNUMB)
         
            IF (ITRNUM.EQ.0) THEN ! Using the analytical SO-Potential
C                
                VSELEM=V_SORB(INUCLI,ZNODES)
C
            ELSE   ! Using the density-dependent SO-Potential
C             
                VSELEM=V_SORB_DENSIT(INUCLI,ZNODES,I_PNTS,LQNUMB)
C
            END IF
C_______________________________________________________________________
C         
            DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
               DO N2NUMB=0,(NSHELL_PROTON-LQNUMB)/2       
C
                  FACTOR=ZNODES*ZWEIGH
     *                  *POLYNL(I_PNTS,N1NUMB,LQNUMB)
     *                  *POLYNL(I_PNTS,N2NUMB,LQNUMB)
C
                  VPOTUP(N1NUMB+1,N2NUMB+1)=VPOTUP(N1NUMB+1,N2NUMB+1)
     *                                     +VCELEM       *FACTOR
     *                                     +VSELEM*FACTUP*FACTOR
C     
                  VPOTDN(N1NUMB+1,N2NUMB+1)=VPOTDN(N1NUMB+1,N2NUMB+1)
     *                                     +VCELEM       *FACTOR
     *                                     +VSELEM*FACTDN*FACTOR
C
               END DO ! End of the n2 do-loop 
C            
            END DO ! End of the n1 do-loop  
C_______________________________________________________________________
C             
         END DO ! Ending Gauss-Laguerre integration for the potentials
C_______________________________________________________________________
C   
C        Adding the kinetic energy matrix elements already calculated 
C        in KINMAT to the matrix elements of the potential       
C         
         DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
            DO N2NUMB=0,(NSHELL_PROTON-LQNUMB)/2  
C         
               EKINET=ENEKIN_PROTON(INUCLI,N1NUMB+1,N2NUMB+1,LQNUMB)
C
               HSORUP(N1NUMB+1,N2NUMB+1)
     *        =
     *         EKINET+VPOTUP(N1NUMB+1,N2NUMB+1)
C               
               HSORDN(N1NUMB+1,N2NUMB+1)
     *        =
     *         EKINET+VPOTDN(N1NUMB+1,N2NUMB+1)
C                      
             END DO ! End of the n2 do-loop 
         END DO ! End of the n1 do-loop  
C
C=======================================================================
C
         LDBASE=(NSHELL_PROTON-LQNUMB)/2+1       
C
C=======================================================================
C        Symmetry test for the Hamiltonian matrix under the l do-loop
C=======================================================================
C
         DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
            DO N2NUMB=N1NUMB,(NSHELL_PROTON-LQNUMB)/2       
C
               IF (ABS(HSORUP(N1NUMB+1,N2NUMB+1)
     *                -HSORUP(N2NUMB+1,N1NUMB+1)).GT.EPSTSH) THEN
C
                   WRITE(NOUTPT,'(''ITRNUM='',I3,3X,''N1='',I3,3X,
     *                                              ''N2='',I3,3X,
     *                            ''HSORUP(N1,N2)='',F30.25,3X,
     *                            ''HSORUP(N2,N1)='',F30.25)')
     *
     *                              ITRNUM,N1NUMB,N2NUMB,
     *                              HSORUP(N1NUMB+1,N2NUMB+1),
     *                              HSORUP(N2NUMB+1,N1NUMB+1)
C
                   STOP 'Non-hermiticity in matrix HSORUP -PROTONS- !'
               END IF
C
               IF (ABS(HSORDN(N1NUMB+1,N2NUMB+1)
     *                -HSORDN(N2NUMB+1,N1NUMB+1)).GT.EPSTSH) THEN
C
                   WRITE(NOUTPT,'(''ITRNUM='',I3,3X,''N1='',I3,3X,
     *                                              ''N2='',I3,3X,
     *                            ''HSORDN(N1,N2)='',F30.25,3X,
     *                            ''HSORDN(N2,N1)='',F30.25)')
     *
     *                              ITRNUM,N1NUMB,N2NUMB,
     *                              HSORDN(N1NUMB+1,N2NUMB+1),
     *                              HSORDN(N2NUMB+1,N1NUMB+1)
C
                   STOP 'Non hermiticity in matrix HSORDN -PROTONS- !'
               END IF
C
            END DO
         END DO
C
C=======================================================================
C
C        Diagonalising  the real-symmetric Hamiltonian-matrix
C        including the calculation of eigenvectors by setting:
C                                                EIGVEC=.TRUE. 
C                                                                
         CALL DIAMAT(HSORUP,SPENUP,AUXVEC,NDBASE,LDBASE,.TRUE.)
C
C        Normalised eigenvectors are stored in columns HSORUP
C
C=======================================================================
C
C        For every l-value we have there is a spin-parallel-L
C        configuration, say spin-up,  and another one that is
C        anti-parallel, say spin-down, the latter exclusively
C        for L>0.  We proceed by storing the spin-up results:
C
         DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
            DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
C
               CAUXUP_PROTON(N1NUMB,NWSNUM)=HSORUP(N1NUMB+1,NWSNUM)
C               
               CMATUP_PROTON(LQNUMB,N1NUMB+1,NWSNUM)
     *        =              HSORUP(N1NUMB+1,NWSNUM)
C 
               ENERUP_PROTON(LQNUMB,NWSNUM)=SPENUP(NWSNUM)
C
            END DO
            
         END DO  
C
C=======================================================================
C
         DO I=1,LDBASE
                   NCOUNT =NCOUNT+1
            ENETHE(NCOUNT)=SPENUP(I)
            LAUXIL(NCOUNT)=LQNUMB
            JAUXIL(NCOUNT)=LQNUMB+LQNUMB+1
            NAUXIL(NCOUNT)=I-1
            INDEXS(NCOUNT)=NCOUNT
         END DO    
C
C=======================================================================
C
C        If L>0, we proceed to treat the spin-antiparallel-L case
C
         IF (LQNUMB.NE.0) THEN  ! Diagonalisation for L > 0, DOWN
C                                                    EIGVEC=.TRUE.
             CALL DIAMAT(HSORDN,SPENDN,AUXVEC,NDBASE,LDBASE,.TRUE.)
C
             DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
                DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2 
C
                   CAUXDN_PROTON(N1NUMB,NWSNUM)=HSORDN(N1NUMB+1,NWSNUM)
                   
                   CMATDN_PROTON(LQNUMB,N1NUMB+1,NWSNUM)
     *        =                  HSORDN(N1NUMB+1,NWSNUM)
C
                   ENERDN_PROTON(LQNUMB,NWSNUM)=SPENDN(NWSNUM)
C
                END DO
             END DO
C
             DO I=1,LDBASE
                       NCOUNT =NCOUNT+1
                ENETHE(NCOUNT)=SPENDN(I)
                LAUXIL(NCOUNT)=LQNUMB
                JAUXIL(NCOUNT)=LQNUMB+LQNUMB-1
                NAUXIL(NCOUNT)=I-1
                INDEXS(NCOUNT)=NCOUNT
             END DO 
C
         END IF 
C______________________________________________________________________
C      
      END DO   !LQNUMB   
C
C=======================================================================
C
      DO I=1,NCOUNT
          INDEXS(I)=I
      END DO
      
      CALL ORDHEA(ENETHE,INDEXS,NCOUNT,NDSPEC)
C           
C=======================================================================
C
      LDSING_PROTON=NCOUNT
C
      NOCCUP_PROTON=0
C
      DO I=1,NCOUNT
C
         INDOLD=INDEXS(I)
C
         NWSSPH_PROTON(I)=NAUXIL(INDOLD)
         LWSSPH_PROTON(I)=LAUXIL(INDOLD)
         JWSSPH_PROTON(I)=JAUXIL(INDOLD)
C
         ENERGY_PROTON(I,ITRNUM)=ENETHE(I)
         ENETHE_PROTON(I       )=ENETHE(I)
C
         IF (IZ_FIX.GT.82 .AND. NOCCUP_PROTON.LT.IZ_FIX) THEN
C
            NOCCUP_PROTON=NOCCUP_PROTON+JWSSPH_PROTON(I)+1
            LABORD_PROTON(INUCLI,NWSSPH_PROTON(I),LWSSPH_PROTON(I),
     *                                            JWSSPH_PROTON(I))=1
C
         END IF
C      
      END DO
C
C=======================================================================
C=======================================================================
C     Repeating the same algorithm  for   n e u t r o n s
C=======================================================================
C=======================================================================
C
      NCOUNT=0
      ISOSPI=0
C      
      XNUMBN=0.0
C
C=======================================================================
C
C     Product L * S :
C
C     FACTUP - spin parallel configuration s=1/2 
C     
C     FACTDN - spin antiparallel anti-configuration s=-1/2 
C
C=======================================================================
C  
      DO LQNUMB=NSHELL_NEUTRS,0,-1
C          
         FACTUP=+0.5*LQNUMB
         FACTDN=-0.5*(LQNUMB+1)         
C
C       Here we are going to construct the H-sub-block at given L
C
         DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
C
            SPENUP(N1NUMB+1)=0.0
            SPENDN(N1NUMB+1)=0.0
C
            DO N2NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2       
               HSORUP(N1NUMB+1,N2NUMB+1)=0.0
               HSORDN(N1NUMB+1,N2NUMB+1)=0.0
               VPOTUP(N1NUMB+1,N2NUMB+1)=0.0
               VPOTDN(N1NUMB+1,N2NUMB+1)=0.0
            END DO
C
         END DO
C
C        We are within the l-do-loop
C_______________________________________________________________________
C       
         VCELEM=0.0
         VSELEM=0.0
C_______________________________________________________________________
C                                                         Integration
         DO I_PNTS=1,NGAUSS
C
C        We are using the weight factor e^{-z} z^{l-1/2}
C        and consequently the potential is multiplied by "z"
C
            ZNODES=RNODES(I_PNTS,LQNUMB) 
            ZWEIGH=RWEIGH(I_PNTS,LQNUMB)
         
            VCELEM=VCENTR(INUCLI,ZNODES,I_PNTS,LQNUMB)
         
            IF (ITRNUM.EQ.0) THEN ! Using the analytical SO-Potential
C                
                VSELEM=V_SORB(INUCLI,ZNODES)
C
            ELSE   ! Using the density-dependent SO-Potential
C                
                VSELEM=V_SORB_DENSIT(INUCLI,ZNODES,I_PNTS,LQNUMB)
C
            END IF
C_______________________________________________________________________
C         
            DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
               DO N2NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2       
C
                  FACTOR=ZNODES*ZWEIGH
     *                  *POLYNL(I_PNTS,N1NUMB,LQNUMB)
     *                  *POLYNL(I_PNTS,N2NUMB,LQNUMB)
C
                  VPOTUP(N1NUMB+1,N2NUMB+1)=VPOTUP(N1NUMB+1,N2NUMB+1)
     *                                     +VCELEM*FACTOR
     *                                     +VSELEM*FACTUP*FACTOR
C     
                  VPOTDN(N1NUMB+1,N2NUMB+1)=VPOTDN(N1NUMB+1,N2NUMB+1)
     *                                     +VCELEM*FACTOR
     *                                     +VSELEM*FACTDN*FACTOR
C
               END DO ! End of the n2 do-loop 
C            
            END DO ! End of the n1 do-loop  
C_______________________________________________________________________
C             
         END DO ! Ending Gauss-Laguerre integration for the potentials
C_______________________________________________________________________
C   
C        Adding the kinetic energy matrix elements already calculated 
C        in KINMAT to the matrix elements of the potential       
C
         DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
            DO N2NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2  
C         
               EKINET=ENEKIN_NEUTRS(INUCLI,N1NUMB+1,N2NUMB+1,LQNUMB)
C
               HSORUP(N1NUMB+1,N2NUMB+1)
     *        =
     *         EKINET+VPOTUP(N1NUMB+1,N2NUMB+1)
C               
               HSORDN(N1NUMB+1,N2NUMB+1)
     *        =
     *         EKINET+VPOTDN(N1NUMB+1,N2NUMB+1)
C         
             END DO ! End of the n2 do-loop 
         END DO ! End of the n1 do-loop  
C
C=======================================================================
C      
         LDBASE=(NSHELL_NEUTRS-LQNUMB)/2+1
C
C=======================================================================
C        Symmetry test for the Hamiltonian matrix
C=======================================================================
C
         DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
            DO N2NUMB=N1NUMB,(NSHELL_NEUTRS-LQNUMB)/2       
C
               IF (ABS(HSORUP(N1NUMB+1,N2NUMB+1)
     *                -HSORUP(N2NUMB+1,N1NUMB+1)).GT.EPSTSH) THEN
C
                   WRITE(NOUTPT,'(''N1='',I3,3X,''N2='',I3,3X,
     *                            ''HSORUP(N1,N2)='',F30.25,3X,
     *                            ''HSORUP(N2,N1)='',F30.25)')
     *
     *                   N1NUMB,N2NUMB,
     *                   HSORUP(N1NUMB+1,N2NUMB+1),
     *                   HSORUP(N2NUMB+1,N1NUMB+1)
C
                   STOP 'Non hermiticity in matrix HSORUP -NEUTRONS- !'
               END IF
C
               IF (ABS(HSORDN(N1NUMB+1,N2NUMB+1)
     *                -HSORDN(N2NUMB+1,N1NUMB+1)).GT.EPSTSH) THEN
C
                   WRITE(NOUTPT,'(''N1='',I3,3X,''N2='',I3,3X,
     *                            ''HSORDN(N1,N2)='',F30.25,3X,
     *                            ''HSORDN(N2,N1)='',F30.25)')
     *
     *                   N1NUMB,N2NUMB,
     *                   HSORDN(N1NUMB+1,N2NUMB+1),
     *                   HSORDN(N2NUMB+1,N1NUMB+1)
C
                   STOP 'Non-hermiticity in matrix HSORDN -NEUTRONS- !'
               END IF
C
            END DO
         END DO
C
C=======================================================================
C        Diagonalising the real-symmetric hamiltonian matrix
C=======================================================================
C                                                EIGVEC=.TRUE.
         CALL DIAMAT(HSORUP,SPENUP,AUXVEC,NDBASE,LDBASE,.TRUE.)
C_____________________________________________________________________
C
         DO NWSNUM=1,(NSHELL_NEUTRS-LQNUMB)/2+1            
            DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
C
               CAUXUP_NEUTRS(N1NUMB,NWSNUM)=HSORUP(N1NUMB+1,NWSNUM)
               
               CMATUP_NEUTRS(LQNUMB,N1NUMB+1,NWSNUM)
     *        =              HSORUP(N1NUMB+1,NWSNUM)
C
               ENERUP_NEUTRS(LQNUMB,NWSNUM)=SPENUP(NWSNUM)
C
            END DO
         END DO
C
         DO I=1,LDBASE
                   NCOUNT=NCOUNT+1
            ENETHE(NCOUNT)=SPENUP(I)
            LAUXIL(NCOUNT)=LQNUMB
            JAUXIL(NCOUNT)=LQNUMB+LQNUMB+1
            NAUXIL(NCOUNT)=I-1
            INDEXS(NCOUNT)=NCOUNT
         END DO    
C_____________________________________________________________________
C
         IF (LQNUMB.NE.0) THEN        ! Diagonalisation for L > 0
C                                                    EIGVEC=.TRUE.
             CALL DIAMAT(HSORDN,SPENDN,AUXVEC,NDBASE,LDBASE,.TRUE.)
C
             DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
                DO NWSNUM=1,(NSHELL_NEUTRS-LQNUMB)/2+1
C
                   CAUXDN_NEUTRS(N1NUMB,NWSNUM)=HSORDN(N1NUMB+1,NWSNUM)
                   
                   CMATDN_NEUTRS(LQNUMB,N1NUMB+1,NWSNUM)
     *        =                  HSORDN(N1NUMB+1,NWSNUM)
C
                   ENERDN_NEUTRS(LQNUMB,NWSNUM)=SPENDN(NWSNUM)
C
                END DO
             END DO
C
             DO I=1,LDBASE
                       NCOUNT =NCOUNT+1
                ENETHE(NCOUNT)=SPENDN(I)
                LAUXIL(NCOUNT)=LQNUMB
                JAUXIL(NCOUNT)=LQNUMB+LQNUMB-1
                NAUXIL(NCOUNT)=I-1
                INDEXS(NCOUNT)=NCOUNT
             END DO 
C
         END IF 
C______________________________________________________________________
C      
      END DO  ! LQNUMB   
C
C=======================================================================
C
      DO I=1,NCOUNT
          INDEXS(I)=I
      END DO
      
      CALL ORDHEA(ENETHE,INDEXS,NCOUNT,NDSPEC)
C           
C=======================================================================
C
      LDSING_NEUTRS=NCOUNT
C
      NOCCUP_NEUTRS=0
C
      DO I=1,NCOUNT
C
         INDOLD=INDEXS(I)
C
         NWSSPH_NEUTRS(I)=NAUXIL(INDOLD)
         LWSSPH_NEUTRS(I)=LAUXIL(INDOLD)
         JWSSPH_NEUTRS(I)=JAUXIL(INDOLD)
C
         ENERGY_NEUTRS(I,ITRNUM)=ENETHE(I)
         ENETHE_NEUTRS(I       )=ENETHE(I)
C
         IF (IN_FIX.GT.126 .AND. NOCCUP_NEUTRS.LT.IN_FIX) THEN
C
             NOCCUP_NEUTRS=NOCCUP_NEUTRS+JWSSPH_NEUTRS(I)+1
             LABORD_NEUTRS(INUCLI,NWSSPH_NEUTRS(I),LWSSPH_NEUTRS(I),
     *                                             JWSSPH_NEUTRS(I))=1
C
         END IF
C
      END DO
C
C=======================================================================
C 
C     Verifying the self-consistency condition, while iterating in 
C     the case of the solution-dependent Hamiltonian spin-orbit or
C                                                           tensor
C
      CALL CONSIS_VERIFS(IABORT)
C       
C=======================================================================
C     Below we prepare the spherical labels, e.g. for the plotting 
C     system and for the chi^2 minimisation, and in order to print 
C     the corresponding tables
C
      CALL SPHLAB(IZ_FIX,IN_FIX,EFERMI_PROTON,EFERMI_NEUTRS)
C       
C=======================================================================
C
C     Printing the energies and parameters in the standard output
C
      IF (LOGWRI.GT.0) THEN
          WRITE(NOUTPT,'(80(''#''),/,''#'',T80,''#'',/,
     *             ''#  ITRNUM= '',I2,5X,''IZ_FIX= '',I3,
     *             5X,''IN_FIX= '',I3,T80,''#'',/,''#'',T80,''#'',/,
     *             ''#  Theoretical PROTON Spectrum'',T80,''#'',/,
     *             ''#'',78X,''#'',/,80(''#''),/,''#'',T80,''#'')')
     *                                        ITRNUM,IZ_FIX,IN_FIX
          I_P=0
C
          DO INDEXX=1,LDSING_PROTON
C
             I_P=I_P+JWSSPH_PROTON(INDEXX)+1
C
             WRITE(NOUTPT,'(''# '',I4,'')'',3X,F20.13,6X,A,6X,I4,27X,
     *                                                         ''#'')')
     *         INDEXX,ENETHE_PROTON(INDEXX),LABTHE_PROTON(INDEXX),I_P
C
               IF (ENETHE_PROTON(INDEXX+1).GT.SPENER_MXPRIN) THEN
                  GO TO 1
               END IF
          END DO
C
          WRITE(NOUTPT,'(''#'',78X,''#'',/,80(''#''),/)')
C
   1      CONTINUE
C_______________________________________________________________________
C      
          WRITE(NOUTPT,'(80(''#''),/,''#'',T80,''#'',/,
     *             ''#  ITRNUM= '',I2,5X,''IZ_FIX= '',I3,
     *             5X,''IN_FIX= '',I3,T80,''#'',/,''#'',T80,''#'',/,
     *             ''#  Theoretical NEUTRON Spectrum'',T80,''#'',/,
     *             ''#'',78X,''#'',/,80(''#''),/,''#'',T80,''#'')')
     *                                        ITRNUM,IZ_FIX,IN_FIX
C
          I_N=0
          DO INDEXX=1,LDSING_NEUTRS
C
             I_N=I_N+JWSSPH_NEUTRS(INDEXX)+1
C
             WRITE(NOUTPT,'(''# '',I4,'')'',3X,F20.13,6X,A,6X,I4,27X,
     *                                                         ''#'')')
     *         INDEXX,ENETHE_NEUTRS(INDEXX),LABTHE_NEUTRS(INDEXX),I_N
C
             IF (ENETHE_NEUTRS(INDEXX+1).GT.SPENER_MXPRIN) THEN
                 GO TO 2
             END IF
          END DO
C
          WRITE(NOUTPT,'(''#'',78X,''#'',/,80(''#''),/)')
C
   2      CONTINUE
C
      END IF
C           
C=======================================================================
C
      DO LQNUMB=NSHELL_PROTON,0,-1
         DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
             
            ENERUP_AUXPRO(LQNUMB,NWSNUM)=ENERUP_PROTON(LQNUMB,NWSNUM)
            ENERDN_AUXPRO(LQNUMB,NWSNUM)=ENERDN_PROTON(LQNUMB,NWSNUM)
            
            DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
                
               CMATUP_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
     *        =CMATUP_PROTON(LQNUMB,N1NUMB+1,NWSNUM)
               
               CMATDN_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
     *        =CMATDN_PROTON(LQNUMB,N1NUMB+1,NWSNUM)
     
            END DO
            
         END DO
      END DO 
C           
C=======================================================================
C
      DO LQNUMB=NSHELL_NEUTRS,0,-1
         DO NWSNUM=1,(NSHELL_NEUTRS-LQNUMB)/2+1
             
            ENERUP_AUXNEU(LQNUMB,NWSNUM)=ENERUP_NEUTRS(LQNUMB,NWSNUM)
            ENERDN_AUXNEU(LQNUMB,NWSNUM)=ENERDN_NEUTRS(LQNUMB,NWSNUM)
            
            DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
                
               CMATUP_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
     *        =CMATUP_NEUTRS(LQNUMB,N1NUMB+1,NWSNUM)
               
               CMATDN_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
     *        =CMATDN_NEUTRS(LQNUMB,N1NUMB+1,NWSNUM)
     
            END DO
            
         END DO
      END DO   
C
C=======================================================================
C     Calling the pairing subroutine (optional)
C=======================================================================
C
      IF (IF_PAI.EQ.1) THEN 
C          
          ISOSPI=1
C          
          CALL PAIDEL(ENERUP_AUXPRO,ENERDN_AUXPRO,NSHELL_PROTON,
     *                ENEMAX,VCOEUP_PROTON,VCOEDN_PROTON,NDIM_L,
     *                                            NDBASE,INUCLI)
C          
          ENEMAX_BCSPAI(INUCLI,1)=ENEMAX
C_______________________________________________________________________
C         
          ISOSPI=0
C          
          CALL PAIDEL(ENERUP_AUXNEU,ENERDN_AUXNEU,NSHELL_NEUTRS,
     *                ENEMAX,VCOEUP_NEUTRS,VCOEDN_NEUTRS,NDIM_L,
     *                                            NDBASE,INUCLI)
C          
          ENEMAX_BCSPAI(INUCLI,2)=ENEMAX
C      
      END IF
C
C=======================================================================
C 
C     Checking the proton-density integral
C  
      XNUMBZ=0.0
C
      DO LQNUMB=NSHELL_PROTON,0,-1
         DO I_PNTS=1,NGAUSS
C
            ZNODES=RNODES(I_PNTS,LQNUMB)
C
            XNUMBZ=XNUMBZ+DENSIT_LAGUER(INUCLI,1,ZNODES,I_PNTS,LQNUMB)
     *                   *ZNODES*RWEIGH(I_PNTS,LQNUMB)*2
         END DO
      END DO
C______________________________________________________________________
C  
C     Pairing tests and checks
C        
      IF (IF_PAI.EQ.1) THEN
C      
          V2_SUM=0.0
C
          DO LQNUMB=NSHELL_PROTON,0,-1
C
             JQNUMB=2*LQNUMB+1
C
             DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
C
                XNUMBZ_STATUP=0.0
C
                DO I_PNTS=1,NGAUSS ! Integration over "z"
C
                   ZNODES=RNODES(I_PNTS,LQNUMB)
C
                   XNUMBZ_STATUP=XNUMBZ_STATUP
     *                          +DENSIT_STATES(INUCLI,1,ZNODES,I_PNTS,
     *                                           LQNUMB,NWSNUM,JQNUMB)
     *                          *ZNODES*RWEIGH(I_PNTS,LQNUMB)*2
C
                END DO
C
                V2_SUM=V2_SUM+V2_PUP_VECTOR(LQNUMB,NWSNUM)*(JQNUMB+1)
C
             END DO
C
          END DO
C
          DO LQNUMB=NSHELL_PROTON,0,-1
C
             JQNUMB=2*LQNUMB-1
C
             DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
C
                XNUMBZ_STATDN=0.0
C
                DO I_PNTS=1,NGAUSS
C
                   ZNODES=RNODES(I_PNTS,LQNUMB)
C
                   XNUMBZ_STATDN=XNUMBZ_STATDN
     *                          +DENSIT_STATES(INUCLI,1,ZNODES,I_PNTS,
     *                                           LQNUMB,NWSNUM,JQNUMB)
     *                          *ZNODES*RWEIGH(I_PNTS,LQNUMB)*2
C
                END DO
C
                V2_SUM=V2_SUM+V2_PDW_VECTOR(LQNUMB,NWSNUM)*(JQNUMB+1)
C
             END DO
C
          END DO
C
      END IF
C______________________________________________________________________
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(18X,''ITRNUM= '',I2,'' XNUMBZ='',F20.13,
     *                                       '' IZ_FIX='',I2)')
     *                         ITRNUM,XNUMBZ,IZ_FIX
      END IF
C
      IF (ISCREN.GT.5) THEN
          WRITE(0,'(''ITRNUM= '',I2)')ITRNUM
          WRITE(0,'(''In HAMMAT: XNUMBZ_PROTON='',F20.13)')XNUMBZ
          WRITE(0,'(11X,''IZ_FIX='',I6)')IZ_FIX
      END IF
C
      IF (ABS(XNUMBZ-IZ_FIX).GT.1.E-4) THEN
          DO I=1,15
             WRITE(LOGFIL,'(45X,''CHECK WHAT IS WRONG WITH THE '',
     *                          ''PROTON DENSITY'')')
          END DO
CID       STOP 'Stop in HAMMAT: Proton density not correct!'
      END IF
C
C=======================================================================
C 
C      Checking the neutron-density integral
C       
       XNUMBN=0.0
C       
       DO LQNUMB=NSHELL_PROTON,0,-1
          DO I_PNTS=1,NGAUSS
C           
             ZNODES=RNODES(I_PNTS,LQNUMB)
C                
             XNUMBN=XNUMBN+DENSIT_LAGUER(INUCLI,0,ZNODES,I_PNTS,LQNUMB)
     *                     *ZNODES*RWEIGH(I_PNTS,LQNUMB)*2
          END DO
      END DO
C_______________________________________________________________________
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(18X,''ITRNUM= '',I2,'' XNUMBN='',F20.13,
     *                                       '' IN_FIX='',I2)')
     *                         ITRNUM,XNUMBN,IN_FIX
      END IF
C
      IF (ISCREN.GT.5) THEN
          WRITE(0,'(''ITRNUM= '',I2)')ITRNUM
          WRITE(0,'(''In HAMMAT: XNUMBN='',F20.13)')XNUMBN
          WRITE(0,'(11X,''IN_FIX='',I6)')IN_FIX
      END IF
C
      IF (ABS(XNUMBN-IN_FIX).GT.1.E-4) THEN
          DO I=1,15
             WRITE(LOGFIL,'(45X,''CHECK WHAT IS WRONG WITH THE '',
     *                          ''NEUTRON DENSITY'')')
          END DO
CID       STOP 'Stop in HAMMAT: Proton density not correct!'
      END IF
C       
C=======================================================================
C
C      CALL PRTNG(INUCLI,1)  ! ID: Creating the Y/N file     
C       
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(15X,''Exiting  HAMMAT'')')
      END IF   
C    
C=======================================================================
C
      CALL CPUTIM('HAMMAT',0)   
C
C=======================================================================
C      
      RETURN
      END   
C
C=======================================================================     
C=======================================================================     
C      
      SUBROUTINE WSSTAN(INUCLI,
     *                  POLYNL,RNODES,RWEIGH,NGAUSS,NSHELL_PROTON,
     *                  NDGAUS,NDIM_N,NDIM_L,NDBASE,NSHELL_NEUTRS,
     *                  HSORUP,HSORDN,SPENUP,SPENDN,AUXVEC,IABORT,
     *                                CMATUP_PROTON,CMATDN_PROTON,
     *                                CMATUP_NEUTRS,CMATDN_NEUTRS,
     *                                ENERUP_PROTON,ENERDN_PROTON,
     *                                ENERUP_NEUTRS,ENERDN_NEUTRS,
     *                                ENEKIN_PROTON,ENEKIN_NEUTRS)
C
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NITERA.f'
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/NDPARS.f'
CID  
C      REAL*16   
C     *          POLYNL,RNODES,RWEIGH
CID
      DIMENSION
     *          POLYNL(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          INDEXS(1:NDSPEC)
      DIMENSION
     *          LAUXIL(1:NDSPEC),JAUXIL(1:NDSPEC),
     *                           NAUXIL(1:NDSPEC)
      DIMENSION
     *          ENEKIN_PROTON(1:NDNUCL,1:NDBASE,1:NDBASE,0:NDIM_L),
     *          ENEKIN_NEUTRS(1:NDNUCL,1:NDBASE,1:NDBASE,0:NDIM_L)
      DIMENSION
     *          CMATUP_PROTON(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN_PROTON(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *          CMATUP_NEUTRS(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN_NEUTRS(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          ENERUP_PROTON(0:NDIM_L,1:NDBASE),
     *          ENERDN_PROTON(0:NDIM_L,1:NDBASE),
     *
     *          ENERUP_NEUTRS(0:NDIM_L,1:NDBASE),
     *          ENERDN_NEUTRS(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          HSORUP(1:NDBASE,1:NDBASE),
     *          HSORDN(1:NDBASE,1:NDBASE)
      DIMENSION
     *          RNODES(1:NDGAUS,0:NDIM_L),
     *          RWEIGH(1:NDGAUS,0:NDIM_L)
      DIMENSION
     *          SPENUP(1:NDBASE),
     *          SPENDN(1:NDBASE),     
     *          AUXVEC(1:NDBASE)     
      DIMENSION
     *          ENETHE(1:NDSPEC)
C     
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS) 
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /KAPPAR/ V0CENT_KAPPAR,XK_V0C_KAPPAR,
     *                R0CENT_KAPPAR,XK_R0C_KAPPAR,
     *                A0CENT_KAPPAR,XK_A0C_KAPPAR,
     *                V0SORB_KAPPAR,XK_V0S_KAPPAR,
     *                R0SORB_KAPPAR,XK_R0S_KAPPAR,
     *                A0SORB_KAPPAR,XK_A0S_KAPPAR
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI    
      COMMON
     *       /HBAR_V/ HBAR_C
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)      
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /ENRGYY/ ENERGY_PROTON(1:NDSPEC,0:NITERA), 
     *                ENERGY_NEUTRS(1:NDSPEC,0:NITERA)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
      DATA
     *        EPSTSH / 1.0000E-6 /
      DATA
     *        ALFCON / 137.03602 /  
C
C=======================================================================     
C=======================================================================     
C
C          -> BASED ON FOLLOWING SUBROUTINES: HAMMAT, INTROD
C
C          -> USED IF ONE ONLY WANTS THE STANDARD WS HAMILTONIAN !
C
C=======================================================================     
C=======================================================================     
C
      IABORT=0
C
C=======================================================================     
C                    Universal Woods-Saxon parameters
C=======================================================================     
C
      X_MASS=938.9059
      HBAR_C=197.3289
C
      V0CENT=-49.60            
C
      AKACEN=0.7
      AKASOR=0.7
C
      XKAPPA=0.860000
C
      R0CENT_PROTON=1.275
      R0CENT_NEUTRS=1.347
C
      R0SORB_PROTON=1.320
      R0SORB_NEUTRS=1.310
C
      V0SORB_PROTON=36.0 ! Unitless
      V0SORB_NEUTRS=35.0 ! Unitless
C
      R0COUL=1.275
C
C=======================================================================     
C
      AOSCIL=HBAR_C**2/HOMEGA(INUCLI)/X_MASS
      AOSCIL=SQRT(AOSCIL)
C
      A_MASS=IN_FIX+IZ_FIX
C
      RKACOU=R0COUL*A_MASS**(1./3.)
C
      VKASOR=1.0
C
C=======================================================================
C
      V0CENT_KAPPAR=V0CENT
      XK_V0C_KAPPAR=XKAPPA
      R0CENT_KAPPAR=0.0000
      XK_R0C_KAPPAR=0.0000
      A0CENT_KAPPAR=0.0000
      XK_A0C_KAPPAR=0.0000
C
      V0SORB_KAPPAR=0.0000
      XK_V0S_KAPPAR=0.0000
      R0SORB_KAPPAR=0.0000
      XK_R0S_KAPPAR=0.0000
      A0SORB_KAPPAR=0.0000
      XK_A0S_KAPPAR=0.0000
C
C=======================================================================
C=======================================================================
C              Beginning with the algorithm for the protons
C=======================================================================
C=======================================================================
C
      WRITE(NOUTPT,'(/)')
C
      NCOUNT=0
      ISOSPI=1
C
C=======================================================================
C
      VKACEN=V0CENT*(1+XKAPPA*(IN_FIX-IZ_FIX)/A_MASS)
C
      RKACEN=R0CENT_PROTON*A_MASS**(1./3.)
C
      RKASOR=R0SORB_PROTON*A_MASS**(1./3.)
C
      V0UNIT=-0.25*V0SORB_PROTON*VKACEN*(HBAR_C/X_MASS)**2
     *                             /((A_MASS-1)/A_MASS)**2
C
C=======================================================================
C
      VKACEN_PROTON=VKACEN
      RKACEN_PROTON=RKACEN
      AKACEN_PROTON=AKACEN
C
      VKASOR_PROTON=V0UNIT
      RKASOR_PROTON=RKASOR
      AKASOR_PROTON=AKASOR
C
C=======================================================================
C     Below, we use the convention involving Pauli matrices
C     rather then  s = 1/2*sigma;  this implies eliminating
C     the factor of 1/2
C     Spin-Orbit Interaction: L * \sigma
C=======================================================================
C
      DO LQNUMB=NSHELL_PROTON,0,-1
C
C-----------------------------------------------------------------------
C        Spin-orbit parallel and anti-parallel configurations
C-----------------------------------------------------------------------
C
         FACTUP=+LQNUMB
C         
         FACTDN=-(LQNUMB+1)
C
C-----------------------------------------------------------------------
C        Here we are going to construct the H-sub-block at given L
C-----------------------------------------------------------------------
C
         DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
            SPENUP(N1NUMB+1)=0.0
            SPENDN(N1NUMB+1)=0.0
            DO N2NUMB=0,(NSHELL_PROTON-LQNUMB)/2       
               HSORUP(N1NUMB+1,N2NUMB+1)=0.0
               HSORDN(N1NUMB+1,N2NUMB+1)=0.0
            END DO
         END DO
C
         DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
            DO N2NUMB=0,(NSHELL_PROTON-LQNUMB)/2       
C       
               VCELEM=0.0
               VSELEM=0.0
C       
               DO I_PNTS=1,NGAUSS
C
C-----------------------------------------------------------------------
C                 We are using the weight factor e^{-z} z^{l-1/2}
C                 and consequently the potential is multiplied by "z"
C-----------------------------------------------------------------------
C
                  ZNODES=RNODES(I_PNTS,LQNUMB)
C
                  FACTOR=ZNODES*RWEIGH(I_PNTS,LQNUMB)
     *                  *POLYNL(I_PNTS,N1NUMB,LQNUMB)
     *                  *POLYNL(I_PNTS,N2NUMB,LQNUMB)
C
C=======================================================================
C                 Following structure taken from function VCENTR(ZNODES)
C=======================================================================
C 
                  RADIUS=AOSCIL*SQRT(ZNODES) ! Radius in Fermi
C
                  VCENWS=VKACEN/(1.0+EXP((RADIUS-RKACEN)/AKACEN))
C            
                  IF (RADIUS.LE.RKACOU) THEN
                      V_COUL=HBAR_C*(IZ_FIX-1)/ALFCON/RKACOU
     *                      *(1.500-0.5000000*(RADIUS/RKACOU)**2)   
                  ELSE
                      V_COUL=HBAR_C*(IZ_FIX-1)/(ALFCON*RADIUS)
                  END IF
C
                  VCELEM=VCELEM+(VCENWS+V_COUL)*FACTOR
C
C=======================================================================
C                 Following structure taken from function V_SORB(ZNODES)
C=======================================================================
C      
                  VSOELM=-VKASOR
     *		        *V0UNIT/AKASOR*EXP((RADIUS-RKASOR)/AKASOR)
     *                  /(1.000+EXP((RADIUS-RKASOR)/AKASOR))**2
     *                  /RADIUS
C
                  VSELEM=VSELEM+VSOELM*FACTOR
C
C=======================================================================
C
               END DO
C
C=======================================================================
C
               EKINET=ENEKIN_PROTON(INUCLI,N1NUMB+1,N2NUMB+1,LQNUMB)
C
C=======================================================================
C
               HSORUP(N1NUMB+1,N2NUMB+1)=EKINET+VCELEM+VSELEM*FACTUP
C
               HSORDN(N1NUMB+1,N2NUMB+1)=EKINET+VCELEM+VSELEM*FACTDN
C
C=======================================================================
C
            END DO
         END DO
C
C=======================================================================
C      
         LDBASE=(NSHELL_PROTON-LQNUMB)/2+1
C
C=======================================================================
C        Testing hermiticity of proton up and down blocs
C=======================================================================
C
         DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
            DO N2NUMB=N1NUMB,(NSHELL_PROTON-LQNUMB)/2       
C
               IF (ABS(HSORUP(N1NUMB+1,N2NUMB+1)
     *                -HSORUP(N2NUMB+1,N1NUMB+1)).GT.EPSTSH) THEN
C
                  WRITE(NOUTPT,'(''N1='',I3,3X,''N2='',I3,3X,
     *                      ''HSORUP(N1,N2)='',F30.25,3X,
     *                      ''HSORUP(N2,N1)='',F30.25)')
     *
     *                  N1NUMB,N2NUMB,
     *                  HSORUP(N1NUMB+1,N2NUMB+1),
     *                  HSORUP(N2NUMB+1,N1NUMB+1)
C
                  STOP 'Non hermiticity in HSORUP -PROTONS- WSSTAN'
C
               END IF
C
               IF (ABS(HSORDN(N1NUMB+1,N2NUMB+1)
     *                -HSORDN(N2NUMB+1,N1NUMB+1)).GT.EPSTSH) THEN
C
                  WRITE(NOUTPT,'(''N1='',I3,3X,''N2='',I3,3X,
     *                      ''HSORDN(N1,N2)='',F30.25,3X,
     *                      ''HSORDN(N2,N1)='',F30.25)')
     *
     *                  N1NUMB,N2NUMB,
     *                  HSORDN(N1NUMB+1,N2NUMB+1),
     *                  HSORDN(N2NUMB+1,N1NUMB+1)
C
                  STOP 'Non hermiticity in HSORDN -PROTONS- WSSTAN'
C
               END IF
C
            END DO
         END DO
C
C=======================================================================
C        Diagonalizing the proton spin-up matrix (l parralel s)
C=======================================================================
C
         CALL DIAMAT(HSORUP,SPENUP,AUXVEC,NDBASE,LDBASE,.TRUE.)
C
C=======================================================================
C
         DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
            DO N2NUMB=0,(NSHELL_PROTON-LQNUMB)/2 
C
               CMATUP_PROTON(LQNUMB,N1NUMB+1,N2NUMB+1) 
     *         =             HSORUP(N1NUMB+1,N2NUMB+1)
C
               ENERUP_PROTON(LQNUMB,N1NUMB+1)=SPENUP(N1NUMB+1)
C
            END DO
         END DO
C
         DO I=1,LDBASE
            NCOUNT=NCOUNT+1
            ENETHE(NCOUNT)=SPENUP(I)
            LAUXIL(NCOUNT)=LQNUMB
            JAUXIL(NCOUNT)=LQNUMB+LQNUMB+1
            NAUXIL(NCOUNT)=I-1
            INDEXS(NCOUNT)=NCOUNT
         END DO    
C
C=======================================================================
C        Diagonalizing the proton spin-down matrix (l anti-parralel s)
C=======================================================================
C
         IF (LQNUMB.NE.0) THEN
C
C=======================================================================
C
             CALL DIAMAT(HSORDN,SPENDN,AUXVEC,NDBASE,LDBASE,.TRUE.)
C
C=======================================================================
C
             DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
                DO N2NUMB=0,(NSHELL_PROTON-LQNUMB)/2 
C
                   CMATDN_PROTON(LQNUMB,N1NUMB+1,N2NUMB+1) 
     *             =             HSORDN(N1NUMB+1,N2NUMB+1)
C
                   ENERDN_PROTON(LQNUMB,N1NUMB+1)=SPENDN(N1NUMB+1)
C
                END DO
             END DO
C
             DO I=1,LDBASE
                NCOUNT=NCOUNT+1
                ENETHE(NCOUNT)=SPENDN(I)
                LAUXIL(NCOUNT)=LQNUMB
                JAUXIL(NCOUNT)=LQNUMB+LQNUMB-1
                NAUXIL(NCOUNT)=I-1
                INDEXS(NCOUNT)=NCOUNT
             END DO 
C
         END IF             
C
      END DO            
C
C=======================================================================
C     Ordering the mixed spin-up/spin-down spectra
C=======================================================================
C
      CALL ORDHEA(ENETHE,INDEXS,NCOUNT,NDSPEC)
C           
C=======================================================================
C
      LDSING_PROTON=NCOUNT
C
      DO I=1,NCOUNT
C
         INDOLD=INDEXS(I)
C
         NWSSPH_PROTON(I)=NAUXIL(INDOLD)
         LWSSPH_PROTON(I)=LAUXIL(INDOLD)
         JWSSPH_PROTON(I)=JAUXIL(INDOLD)
C
         ENERGY_PROTON(I,0)=ENETHE(I)
         ENETHE_PROTON(I  )=ENETHE(I)
C
      END DO
C
C=======================================================================
C=======================================================================
C            Repeating the same algorithm for the neutrons
C=======================================================================
C=======================================================================
C
      WRITE(NOUTPT,'(/)')
C
      NCOUNT=0
      ISOSPI=0
C
C=======================================================================
C
      VKACEN=V0CENT*(1-XKAPPA*(IN_FIX-IZ_FIX)/A_MASS)
C
      RKACEN=R0CENT_NEUTRS*A_MASS**(1./3.)
C
      RKASOR=R0SORB_NEUTRS*A_MASS**(1./3.)
C
      V0UNIT=-0.25*V0SORB_NEUTRS*VKACEN*(HBAR_C/X_MASS)**2
     *                             /((A_MASS-1)/A_MASS)**2
C
C=======================================================================
C
      VKACEN_NEUTRS=VKACEN
      RKACEN_NEUTRS=RKACEN
      AKACEN_NEUTRS=AKACEN
C
      VKASOR_NEUTRS=V0UNIT
      RKASOR_NEUTRS=RKASOR
      AKASOR_NEUTRS=AKASOR
C
C-----------------------------------------------------------------------
C     Below, we use the convention involving Pauli matrices
C     rather then  s = 1/2*sigma;  this implies eliminating
C     the factor of 1/2
C     Spin-Orbit Interaction: L * \sigma
C-----------------------------------------------------------------------
C
      DO LQNUMB=NSHELL_NEUTRS,0,-1
C
C-----------------------------------------------------------------------
C        Spin-orbit parallel configuration
C-----------------------------------------------------------------------
C
         FACTUP=     LQNUMB
C
C-----------------------------------------------------------------------
C        Spin-orbit anti-parallel configuration
C-----------------------------------------------------------------------
C
         FACTDN=-    (LQNUMB+1)
C
C-----------------------------------------------------------------------
C        Here we are going to construct the H-sub-block at given L
C-----------------------------------------------------------------------
C
         DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
            SPENUP(N1NUMB+1)=0.0
            SPENDN(N1NUMB+1)=0.0
            DO N2NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2       
               HSORUP(N1NUMB+1,N2NUMB+1)=0.0
               HSORDN(N1NUMB+1,N2NUMB+1)=0.0
            END DO
         END DO
C
         DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
            DO N2NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2       
C       
               VCELEM=0.0
               VSELEM=0.0
C       
               DO I_PNTS=1,NGAUSS
C
C-----------------------------------------------------------------------
C                 We are using the weight factor e^{-z} z^{l-1/2}
C                 and consequently the potential is multiplied by "z"
C-----------------------------------------------------------------------
C
                  ZNODES=RNODES(I_PNTS,LQNUMB)
C
                  FACTOR=ZNODES*RWEIGH(I_PNTS,LQNUMB)
     *                  *POLYNL(I_PNTS,N1NUMB,LQNUMB)
     *                  *POLYNL(I_PNTS,N2NUMB,LQNUMB)
C
C=======================================================================
C                 Following structure taken from function VCENTR(ZNODES)
C=======================================================================
C 
                  RADIUS=AOSCIL*SQRT(ZNODES) ! Radius in Fermi
C
                  VCENWS=VKACEN/(1.0+EXP((RADIUS-RKACEN)/AKACEN))
C
                  VCELEM=VCELEM+VCENWS*FACTOR
C
C=======================================================================
C                 Following structure taken from function V_SORB(ZNODES)
C=======================================================================
C      
                  VSOELM=-VKASOR
     *		        *V0UNIT/AKASOR*EXP((RADIUS-RKASOR)/AKASOR)
     *                  /(1.000+EXP((RADIUS-RKASOR)/AKASOR))**2
     *                  /RADIUS
C
                  VSELEM=VSELEM+VSOELM*FACTOR
C
C=======================================================================
C                 
               END DO
C
C=======================================================================
C
               EKINET=ENEKIN_NEUTRS(INUCLI,N1NUMB+1,N2NUMB+1,LQNUMB)
C
C=======================================================================
C
               HSORUP(N1NUMB+1,N2NUMB+1)=EKINET+VCELEM+VSELEM*FACTUP
               HSORDN(N1NUMB+1,N2NUMB+1)=EKINET+VCELEM+VSELEM*FACTDN
C
C=======================================================================
C
            END DO
         END DO
C      
         LDBASE=(NSHELL_NEUTRS-LQNUMB)/2+1
C
C=======================================================================
C        Testing hermiticity of neutron up and down blocs
C=======================================================================
C
         DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
            DO N2NUMB=N1NUMB,(NSHELL_PROTON-LQNUMB)/2       
C
               IF (ABS(HSORUP(N1NUMB+1,N2NUMB+1)
     *                -HSORUP(N2NUMB+1,N1NUMB+1)).GT.EPSTSH) THEN
C
                  WRITE(NOUTPT,'(''N1='',I3,3X,''N2='',I3,3X,
     *                      ''HSORUP(N1,N2)='',F30.25,3X,
     *                      ''HSORUP(N2,N1)='',F30.25)')
     *
     *                  N1NUMB,N2NUMB,
     *                  HSORUP(N1NUMB+1,N2NUMB+1),
     *                  HSORUP(N2NUMB+1,N1NUMB+1)
C
                  STOP 'NON HERMITICITY IN MATRIX HSORUP -NEUTRONS- !'
C
               END IF
C
               IF (ABS(HSORDN(N1NUMB+1,N2NUMB+1)
     *                -HSORDN(N2NUMB+1,N1NUMB+1)).GT.EPSTSH) THEN
C
                  WRITE(NOUTPT,'(''N1='',I3,3X,''N2='',I3,3X,
     *                      ''HSORDN(N1,N2)='',F30.25,3X,
     *                      ''HSORDN(N2,N1)='',F30.25)')
     *
     *                  N1NUMB,N2NUMB,
     *                  HSORDN(N1NUMB+1,N2NUMB+1),
     *                  HSORDN(N2NUMB+1,N1NUMB+1)
C
                  STOP 'NON HERMITICITY IN MATRIX HSORDN -NEUTRONS- !'
C
               END IF
C
            END DO
         END DO
C
C=======================================================================
C        Diagonalising the neutron spin-up matrix (l parallel s)
C=======================================================================
C
         CALL DIAMAT(HSORUP,SPENUP,AUXVEC,NDBASE,LDBASE,.TRUE.)
C
C=======================================================================
C
         DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
            DO N2NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2 
C
               CMATUP_NEUTRS(LQNUMB,N1NUMB+1,N2NUMB+1) 
     *         =             HSORUP(N1NUMB+1,N2NUMB+1)
C
               ENERUP_NEUTRS(LQNUMB,N1NUMB+1)=SPENUP(N1NUMB+1)
C
            END DO
         END DO
C
         DO I=1,LDBASE
            NCOUNT=NCOUNT+1
            ENETHE(NCOUNT)=SPENUP(I)
            LAUXIL(NCOUNT)=LQNUMB
            JAUXIL(NCOUNT)=LQNUMB+LQNUMB+1
            NAUXIL(NCOUNT)=I-1
            INDEXS(NCOUNT)=NCOUNT
         END DO    
C
C=======================================================================
C        Diagonalising the neutron spin-down matrix (l anti-parallel s)
C=======================================================================
C
         IF (LQNUMB.NE.0) THEN
C
C=======================================================================
C
             CALL DIAMAT(HSORDN,SPENDN,AUXVEC,NDBASE,LDBASE,.TRUE.)
C
C=======================================================================
C
             DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
                DO N2NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2 
C
                   CMATDN_NEUTRS(LQNUMB,N1NUMB+1,N2NUMB+1) 
     *             =             HSORDN(N1NUMB+1,N2NUMB+1)
C
                   ENERDN_NEUTRS(LQNUMB,N1NUMB+1)=SPENDN(N1NUMB+1)
C
                END DO
             END DO
C
             DO I=1,LDBASE
                NCOUNT=NCOUNT+1
                ENETHE(NCOUNT)=SPENDN(I)
                LAUXIL(NCOUNT)=LQNUMB
                JAUXIL(NCOUNT)=LQNUMB+LQNUMB-1
                NAUXIL(NCOUNT)=I-1
                INDEXS(NCOUNT)=NCOUNT
             END DO 
C
         END IF             
C
      END DO            
C
C=======================================================================
C
      CALL ORDHEA(ENETHE,INDEXS,NCOUNT,NDSPEC)
C           
C=======================================================================
C
      LDSING_NEUTRS=NCOUNT
C
      DO I=1,NCOUNT
C
         INDOLD=INDEXS(I)
C
         NWSSPH_NEUTRS(I)=NAUXIL(INDOLD)
         LWSSPH_NEUTRS(I)=LAUXIL(INDOLD)
         JWSSPH_NEUTRS(I)=JAUXIL(INDOLD)
C
         ENERGY_NEUTRS(I,0)=ENETHE(I)
         ENETHE_NEUTRS(I  )=ENETHE(I)
C
      END DO
C       
C=======================================================================
C     Below we prepare the spherical labels e.g. for the plotting 
C     system and for the chi^2 minimisation, and print the tables 
C=======================================================================
C
      CALL SPHLAB(IZ_FIX,IN_FIX,EFERMI_PROTON,EFERMI_NEUTRS)
C       
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE ONERUN_WSUNIV
C
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDMESH.f'
      INCLUDE   'MATDIM/ND_RHO.f'
      INCLUDE   'MATDIM/N_NOYX.f'
      INCLUDE   'MATDIM/NDIM_N.f'
      INCLUDE   'MATDIM/NDTITL.f'
C      
      EXTERNAL
     *         DENSIT,DENTHE_INTEGR,DENEXP,DENEXP_INTEGR,
     *         DENTHE_DENEXP
c
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1)
C
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6,
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,
     *          LABTHE_PRONUC*6,LABTHE_NEUNUC*6,
     *          LABTHE_PRINTG*6
      CHARACTER
     *          L_CURV_PROTON*6,L_CURV_NEUTRS*6
      CHARACTER
     *          CURNAM*020,L_CURV*100,CURLAB*100,MAIN_T*256,
     *          XTITLE*256,YTITLE*256,TITLES*012,
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010
C
      DIMENSION
     *          PARPOT_PRINTG(1:NDPARS)
      DIMENSION
     *          RMSTHE_PRONUC(1:NDNUCL),
     *          LEVTHE_PRONUC(1:NDNUCL),
     *          ENETHE_PRONUC(1:NDSPEC,1:NDNUCL),
     *          LABTHE_PRONUC(1:NDSPEC,1:NDNUCL)
      DIMENSION
     *          RMSTHE_NEUNUC(1:NDNUCL),
     *          LEVTHE_NEUNUC(1:NDNUCL),
     *          ENETHE_NEUNUC(1:NDSPEC,1:NDNUCL),
     *          LABTHE_NEUNUC(1:NDSPEC,1:NDNUCL)
      DIMENSION
     *          ENETHE_PRINTG(1:NDSPEC),
     *          LABTHE_PRINTG(1:NDSPEC)
      DIMENSION
     *          EABSAV_PRONUC(1:NDNUCL),
     *          EABSAV_NEUNUC(1:NDNUCL),
     *          RMSVAL_PRONUC(1:NDNUCL),
     *          RMSVAL_NEUNUC(1:NDNUCL),
     *          ERRMAX_PRONUC(1:NDNUCL),
     *          ERRMAX_NEUNUC(1:NDNUCL)
      DIMENSION
     *          X_CURV_PROTON(1:NDMESH,1:NDSPEC),
     *          Y_CURV_PROTON(1:NDMESH,1:NDSPEC),
     *          L_CURV_PROTON(1:NDMESH,1:NDSPEC)
      DIMENSION
     *          X_CURV_NEUTRS(1:NDMESH,1:NDSPEC),
     *          Y_CURV_NEUTRS(1:NDMESH,1:NDSPEC),
     *          L_CURV_NEUTRS(1:NDMESH,1:NDSPEC)
      DIMENSION
     *          ND_MAX(1:NDSPEC),
     *          X_CURV(1:NDMESH,1:NDSPEC),
     *          Y_CURV(1:NDMESH,1:NDSPEC),
     *          L_CURV(1:NDMESH,1:NDSPEC)
      DIMENSION 
     *          ENERUP_PRONUC(0:NDIM_L,1:NDBASE,1:NDNUCL),
     *          ENERDN_PRONUC(0:NDIM_L,1:NDBASE,1:NDNUCL),
     *
     *          ENERUP_NEUNUC(0:NDIM_L,1:NDBASE,1:NDNUCL),
     *          ENERDN_NEUNUC(0:NDIM_L,1:NDBASE,1:NDNUCL)
      DIMENSION  
     *          CMATUP_PRONUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL),
     *          CMATDN_PRONUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL),
     *
     *          CMATUP_NEUNUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL),
     *          CMATDN_NEUNUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL)
C          
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL) 
      COMMON
     *       /EXPDEN/ LABELN(1:N_NOYX,1:2),
     *                R_MESH(1:ND_RHO,1:N_NOYX),
     *                RHOEXP(1:ND_RHO,1:N_NOYX)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                              LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                              LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR    
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS 
      COMMON
     *       /NUCWEI/ WEINUC_PROTON(1:NDNUCL),
     *                WEINUC_NEUTRS(1:NDNUCL),
     *                WEIRAD_PROTON(1:NDNUCL),
     *                WEIRAD_NEUTRS(1:NDNUCL) 
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI
      COMMON
     *       /ARGUMN/ IARG_R,IARG_Z
      COMMON
     *       /CHI_PN/ CHISQU_PROTON,CHISQU_NEUTRS
      COMMON
     *       /CHICHO/ VALCHI
     *       /DENSTR/ IFDENS
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /FITTED/ IFITED
     *       /MASSIV/ IMASIV_PRODUC
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /SIMUSE/ AOSCIL,RADCUT,INUCLI
      COMMON
     *       /CUTOFF/ RADIUS_CUTOFF(1:NDNUCL)
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /KAPPAR/ V0CENT_KAPPAR,XK_V0C_KAPPAR,
     *                R0CENT_KAPPAR,XK_R0C_KAPPAR,
     *                A0CENT_KAPPAR,XK_A0C_KAPPAR,
     *                V0SORB_KAPPAR,XK_V0S_KAPPAR,
     *                R0SORB_KAPPAR,XK_R0S_KAPPAR,
     *                A0SORB_KAPPAR,XK_A0S_KAPPAR
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C       
C=======================================================================
C
C     This subroutine calculates the energy levels, densities... for
C     one single run with the parameter values desired for the user.
C
C     It is only activated if IFTEST=1 for the input file
C
C     The desired parameter values come from the input file, too
C       
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,9X,''Entering ONERUN_WSUNIV'',/)')
      END IF
C
C=======================================================================
C
      IFPROT=0
      IFNEUT=0
      IFBOTH=0
C
C=======================================================================
C
C     First, calculating the total weights (protons and neutrons)
C     that will be used as the normalizing constants of the \chi^2
C
      WEIGHT_PROTON=0.0
      WEIGHT_NEUTRS=0.0
C
      DO INUCLI=1,LDNUCL
         IF (ITAKNU(INUCLI).EQ.1) THEN
C_______________________________________________________________________
C
             IF (IF_SPE.EQ.1) THEN
C
                 DEGSUM_PROTON=0.0
C
                 DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                    DEGAUX=REAL(IDEGEX_PROTON(INUCLI,IEXPER))
                    DEGSUM_PROTON=DEGSUM_PROTON+DEGAUX
                 END DO
C
                 WEIGHT_PROTON=WEINUC_PROTON(INUCLI)
C
                 DEGSUM_NEUTRS=0.0
C
                 DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                    DEGAUX=REAL(IDEGEX_NEUTRS(INUCLI,IEXPER))
                    DEGSUM_NEUTRS=DEGSUM_NEUTRS+DEGAUX
                 END DO
C
                 WEIGHT_NEUTRS=WEINUC_NEUTRS(INUCLI)
C
             END IF
C_______________________________________________________________________
C
         END IF
      END DO
C       
C=======================================================================
C
      IMASIV_PRODUC=1
      IRANDO=0
      LDRAND=0
      IEVALU_PRINTG=1
      CHIGRD_PRINTG=999.
      CHISQU_MINIML=999.
C       
C=======================================================================
C
      DO IPARAM=1,NDPARS
         PARPOT_PRINTG(IPARAM)=PARPOT(IPARAM)
      END DO
C
      IF (NUCACT.LT.LDNUCL) RMSGLO_PRINTG=9.9999
C          
      RMSGLO_PROTON=0.
      RMSGLO_NEUTRS=0.
C
      RMSGLO_PROAUX=0.
      RMSGLO_NEUAUX=0.
C
      IDEG_P=0
      IDEG_N=0
C       
C=======================================================================
C
      DO INUCLI=1,LDNUCL
C
         IZ_FIX=NUMB_Z(INUCLI)
         IN_FIX=NUMB_N(INUCLI)
C
C=======================================================================     
C
C        Diagonalising the Hamiltonian for the single-run mode
C
         IF (LOGWRI.GT.4) THEN
             WRITE(LOGFIL,'(12x,''Entering WS_RUN from ONERUN with: '',
     *                          ''IZ_FIX= '',I3,'' and IN_FIX= '',I3)')
     *                            IZ_FIX,              IN_FIX
         END IF
C
         IDEFCN=0
                                                 I_MODE=0
                                                        I_FLAG=1
         CALL WS_UNI(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,I_FLAG,
     *                             CHISQU_PROTON,CHISQU_NEUTRS)
C
         VALCHI=CHISQU_PROTON/WEIGHT_PROTON
     *         +CHISQU_NEUTRS/WEIGHT_NEUTRS 
C
         IF (ITAKNU(INUCLI).EQ.1) CHISQU_MINIML=VALCHI
C_______________________________________________________________________
C     
         RMSTHE_PRONUC(INUCLI)=RMSTHE_PROTON
         LEVTHE_PRONUC(INUCLI)=LEVTHE_PROTON
         
         DO ITHEOR=1,LEVTHE_PROTON
            ENETHE_PRONUC(ITHEOR,INUCLI)=ENETHE_PROTON(ITHEOR)
            LABTHE_PRONUC(ITHEOR,INUCLI)=LABTHE_PROTON(ITHEOR)
         END DO
C_______________________________________________________________________
C         
         RMSTHE_NEUNUC(INUCLI)=RMSTHE_NEUTRS
         LEVTHE_NEUNUC(INUCLI)=LEVTHE_NEUTRS
         
         DO ITHEOR=1,LEVTHE_PROTON
            ENETHE_NEUNUC(ITHEOR,INUCLI)=ENETHE_NEUTRS(ITHEOR)
            LABTHE_NEUNUC(ITHEOR,INUCLI)=LABTHE_NEUTRS(ITHEOR)
         END DO
C_______________________________________________________________________
C
C        Calculating the TOTAL degenerancy of all the nuclei
C
         DO IEXPER=1,LEVEXP_PROTON(INUCLI)
            IDEG_P=IDEG_P+IDEGEX_PROTON(INUCLI,IEXPER)
         END DO
C
         DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
            IDEG_N=IDEG_N+IDEGEX_NEUTRS(INUCLI,IEXPER)
         END DO
C_______________________________________________________________________
C                  
         EABSAV_PRONUC(INUCLI)=EABSAV_PROTON
         EABSAV_NEUNUC(INUCLI)=EABSAV_NEUTRS
         
         ERRMAX_PRONUC(INUCLI)=ERRMAX_PROTON
         ERRMAX_NEUNUC(INUCLI)=ERRMAX_NEUTRS
         
         RMSVAL_PRONUC(INUCLI)=SQRT(CHIWEI_PROTON)
         RMSVAL_NEUNUC(INUCLI)=SQRT(CHIWEI_NEUTRS)
         
         RMSGLO_PROTON=RMSGLO_PROTON+CHIWEI_PROTON
         RMSGLO_NEUTRS=RMSGLO_NEUTRS+CHIWEI_NEUTRS

         RMSGLO_PROAUX=RMSGLO_PROAUX+CHIDEG_PROTON
         RMSGLO_NEUAUX=RMSGLO_NEUAUX+CHIDEG_NEUTRS
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_PROTON,0,-1
            DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
C
               ENERUP_PRONUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERUP_AUXPRO(LQNUMB,NWSNUM)
C
               ENERDN_PRONUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERDN_AUXPRO(LQNUMB,NWSNUM)
C
               DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
C
                  CMATUP_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATUP_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
C
                  CMATDN_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATDN_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
C
               END DO
C
            END DO
         END DO  
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_NEUTRS,0,-1
            DO NWSNUM=1,(NSHELL_NEUTRS-LQNUMB)/2+1
C
               ENERUP_NEUNUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERUP_AUXNEU(LQNUMB,NWSNUM)
C
               ENERDN_NEUNUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERDN_AUXNEU(LQNUMB,NWSNUM)
C
               DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
C
                  CMATUP_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATUP_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
C
                  CMATDN_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATDN_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
C
               END DO
C
            END DO
         END DO   
C_______________________________________________________________________
C          
      END DO !INUCLI
C_______________________________________________________________________
C      
      RMSGLO_PROTON=SQRT(RMSGLO_PROTON)
      RMSGLO_NEUTRS=SQRT(RMSGLO_NEUTRS)
C
      RMSGLO_PROAUX=SQRT(RMSGLO_PROAUX/IDEG_P)
      RMSGLO_NEUAUX=SQRT(RMSGLO_NEUAUX/IDEG_N)
C
C=======================================================================
C
      DO INUCLI=1,LDNUCL
C
         IZ_FIX=NUMB_Z(INUCLI)
         IN_FIX=NUMB_N(INUCLI)
C
C=======================================================================     
C                    Universal Woods-Saxon parameters
C=======================================================================     
C
         X_MASS=938.9059
         HBAR_C=197.3289
C
         V0CENT=-49.60            
C
         AKACEN=0.7
         AKASOR=0.7
C
         XKAPPA=0.860000
C
         R0CENT_PROTON=1.275
         R0CENT_NEUTRS=1.347
C
         R0SORB_PROTON=1.320
         R0SORB_NEUTRS=1.310
C
         V0SORB_PROTON=36.0 ! Unitless
         V0SORB_NEUTRS=35.0 ! Unitless
C
         R0COUL=1.275
C
C=======================================================================     
C
         AOSCIL=HBAR_C**2/HOMEGA(INUCLI)/X_MASS
         AOSCIL=SQRT(AOSCIL)
C
         A_MASS=IN_FIX+IZ_FIX
C
         RKACOU=R0COUL*A_MASS**(1./3.)
C
         VKASOR=1.0
C
C=======================================================================
C
         V0CENT_KAPPAR=V0CENT
         XK_V0C_KAPPAR=XKAPPA
         R0CENT_KAPPAR=0.0000
         XK_R0C_KAPPAR=0.0000
         A0CENT_KAPPAR=0.0000
         XK_A0C_KAPPAR=0.0000
C
         V0SORB_KAPPAR=0.0000
         XK_V0S_KAPPAR=0.0000
         R0SORB_KAPPAR=0.0000
         XK_R0S_KAPPAR=0.0000
         A0SORB_KAPPAR=0.0000
         XK_A0S_KAPPAR=0.0000
C
C=======================================================================
C
         VKACEN_PROTON=V0CENT*(1+XKAPPA*(IN_FIX-IZ_FIX)/A_MASS)
C
         RKACEN_PROTON=R0CENT_PROTON*A_MASS**(1./3.)
C
         RKASOR_PROTON=R0SORB_PROTON*A_MASS**(1./3.)
C
         V0UNIT=-0.25*V0SORB_PROTON*VKACEN_PROTON*(HBAR_C/X_MASS)**2
     *                             /((A_MASS-1)/A_MASS)**2
C
C=======================================================================
C
         AKACEN_PROTON=AKACEN
         VKASOR_PROTON=V0UNIT
         AKASOR_PROTON=AKASOR
C
C=======================================================================
C
         VKACEN_NEUTRS=V0CENT*(1-XKAPPA*(IN_FIX-IZ_FIX)/A_MASS)
C
         RKACEN_NEUTRS=R0CENT_NEUTRS*A_MASS**(1./3.)
C
         RKASOR_NEUTRS=R0SORB_NEUTRS*A_MASS**(1./3.)
C
         V0UNIT=-0.25*V0SORB_NEUTRS*VKACEN_NEUTRS*(HBAR_C/X_MASS)**2
     *                             /((A_MASS-1)/A_MASS)**2
C
C=======================================================================
C
         AKACEN_NEUTRS=AKACEN
         VKASOR_NEUTRS=V0UNIT
         AKASOR_NEUTRS=AKASOR
C
C=======================================================================
C
         DO LQNUMB=NSHELL_PROTON,0,-1
            DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
C
               ENERUP_AUXPRO(LQNUMB,NWSNUM)
     *        =
     *         ENERUP_PRONUC(LQNUMB,NWSNUM,INUCLI)
C
               ENERDN_AUXPRO(LQNUMB,NWSNUM)
     *        =
     *         ENERDN_PRONUC(LQNUMB,NWSNUM,INUCLI)
C
               DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
C
                  CMATUP_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATUP_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
                  CMATDN_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATDN_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
               END DO
C
            END DO
         END DO  
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_NEUTRS,0,-1
            DO NWSNUM=1,(NSHELL_NEUTRS-LQNUMB)/2+1
C
               ENERUP_AUXNEU(LQNUMB,NWSNUM)
     *        =
     *         ENERUP_NEUNUC(LQNUMB,NWSNUM,INUCLI)
C
               ENERDN_AUXNEU(LQNUMB,NWSNUM)
     *        =
     *         ENERDN_NEUNUC(LQNUMB,NWSNUM,INUCLI)
C
               DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
C
                  CMATUP_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATUP_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
                  CMATDN_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATDN_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
               END DO
C
            END DO
         END DO   
C_______________________________________________________________________
C 
         IFITED=3 ! WS UNIVERSAL single run
C_______________________________________________________________________
C             
         IF (IFDENS.EQ.0) THEN
C
             ISOSPI=1
             IFPROT=1
             IFNEUT=0
C
             ERRMAX_PRINTG=ERRMAX_PRONUC(INUCLI)
C            EABSAV_PRINTG=EABSAV_PRONUC(INUCLI)
             RMSVAL_PRINTG=RMSVAL_PRONUC(INUCLI)
             
             RMSEXP_PRINTG=RMSEXP_PROTON(INUCLI)
             RMSTHE_PRINTG=RMSTHE_PRONUC(INUCLI)
             LEVTHE_PRINTG=LEVTHE_PRONUC(INUCLI)
C
             DO ITHEOR=1,LEVTHE_PRINTG
                ENETHE_PRINTG(ITHEOR)=ENETHE_PRONUC(ITHEOR,INUCLI)
                LABTHE_PRINTG(ITHEOR)=LABTHE_PRONUC(ITHEOR,INUCLI)
             END DO
C
             CALL WRITIN_ENELEV(ISOSPI,IRANDO,LDRAND,IEVALU_PRINTG,
     *                                 PARPOT_PRINTG,CHISQU_MINIML,
     *                                 CHIGRD_PRINTG,ERRMAX_PRINTG,
     *                                 RMSVAL_PRINTG,RMSGLO_PROAUX,
     *                                 RMSEXP_PRINTG,RMSTHE_PRINTG,
     *                                 LEVTHE_PRINTG,ENETHE_PRINTG,
     *                                 LABTHE_PRINTG,INUCLI)
C_______________________________________________________________________
C         
             ISOSPI=0
             IFNEUT=1
             IFPROT=0
C
             ERRMAX_PRINTG=ERRMAX_NEUNUC(INUCLI)
C             EABSAV_PRINTG=EABSAV_NEUNUC(INUCLI)
             RMSVAL_PRINTG=RMSVAL_NEUNUC(INUCLI)
C
             RMSEXP_PRINTG=RMSEXP_NEUTRS(INUCLI)
             RMSTHE_PRINTG=RMSTHE_NEUNUC(INUCLI)
             LEVTHE_PRINTG=LEVTHE_NEUNUC(INUCLI)
C
             DO ITHEOR=1,LEVTHE_PRINTG
                ENETHE_PRINTG(ITHEOR)=ENETHE_NEUNUC(ITHEOR,INUCLI)
                LABTHE_PRINTG(ITHEOR)=LABTHE_NEUNUC(ITHEOR,INUCLI)
             END DO
C
             CALL WRITIN_ENELEV(ISOSPI,IRANDO,LDRAND,IEVALU_PRINTG,
     *                                 PARPOT_PRINTG,CHISQU_MINIML,
     *                                 CHIGRD_PRINTG,ERRMAX_PRINTG,
     *                                 RMSVAL_PRINTG,RMSGLO_NEUAUX,
     *                                 RMSEXP_PRINTG,RMSTHE_PRINTG,
     *                                 LEVTHE_PRINTG,ENETHE_PRINTG,
     *                                 LABTHE_PRINTG,INUCLI)
         END IF
C
      END DO  !INUCLI
C       
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,''Exiting ONERUN_WSUNIV'')')
      END IF
C       
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE ONERUN
C
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDMESH.f'
      INCLUDE   'MATDIM/ND_RHO.f'
      INCLUDE   'MATDIM/N_NOYX.f'
      INCLUDE   'MATDIM/NDIM_N.f'
      INCLUDE   'MATDIM/NDTITL.f'
C      
      EXTERNAL
     *         DENSIT,DENTHE_INTEGR,DENEXP,DENEXP_INTEGR,
     *         DENTHE_DENEXP
c
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1)
C
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6,
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,
     *          LABTHE_PRONUC*6,LABTHE_NEUNUC*6,
     *          LABTHE_PRINTG*6
      CHARACTER
     *          L_CURV_PROTON*6,L_CURV_NEUTRS*6
      CHARACTER
     *          CURNAM*020,L_CURV*100,CURLAB*100,MAIN_T*256,
     *          XTITLE*256,YTITLE*256,TITLES*012,
     *          TITLES_LATEXS*050,NUCNAM_TITLES*010
C
      DIMENSION
     *          PARPOT_PRINTG(1:NDPARS)
      DIMENSION
     *          RMSTHE_PRONUC(1:NDNUCL),
     *          LEVTHE_PRONUC(1:NDNUCL),
     *          ENETHE_PRONUC(1:NDSPEC,1:NDNUCL),
     *          LABTHE_PRONUC(1:NDSPEC,1:NDNUCL)
      DIMENSION
     *          RMSTHE_NEUNUC(1:NDNUCL),
     *          LEVTHE_NEUNUC(1:NDNUCL),
     *          ENETHE_NEUNUC(1:NDSPEC,1:NDNUCL),
     *          LABTHE_NEUNUC(1:NDSPEC,1:NDNUCL)
      DIMENSION
     *          ENETHE_PRINTG(1:NDSPEC),
     *          LABTHE_PRINTG(1:NDSPEC)
      DIMENSION
     *          EABSAV_PRONUC(1:NDNUCL),
     *          EABSAV_NEUNUC(1:NDNUCL),
     *          RMSVAL_PRONUC(1:NDNUCL),
     *          RMSVAL_NEUNUC(1:NDNUCL),
     *          ERRMAX_PRONUC(1:NDNUCL),
     *          ERRMAX_NEUNUC(1:NDNUCL)
      DIMENSION
     *          X_CURV_PROTON(1:NDMESH,1:NDSPEC),
     *          Y_CURV_PROTON(1:NDMESH,1:NDSPEC),
     *          L_CURV_PROTON(1:NDMESH,1:NDSPEC)
      DIMENSION
     *          X_CURV_NEUTRS(1:NDMESH,1:NDSPEC),
     *          Y_CURV_NEUTRS(1:NDMESH,1:NDSPEC),
     *          L_CURV_NEUTRS(1:NDMESH,1:NDSPEC)
      DIMENSION
     *          ND_MAX(1:NDSPEC),
     *          X_CURV(1:NDMESH,1:NDSPEC),
     *          Y_CURV(1:NDMESH,1:NDSPEC),
     *          L_CURV(1:NDMESH,1:NDSPEC)
      DIMENSION 
     *          ENERUP_PRONUC(0:NDIM_L,1:NDBASE,1:NDNUCL),
     *          ENERDN_PRONUC(0:NDIM_L,1:NDBASE,1:NDNUCL),
     *
     *          ENERUP_NEUNUC(0:NDIM_L,1:NDBASE,1:NDNUCL),
     *          ENERDN_NEUNUC(0:NDIM_L,1:NDBASE,1:NDNUCL)
      DIMENSION  
     *          CMATUP_PRONUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL),
     *          CMATDN_PRONUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL),
     *
     *          CMATUP_NEUNUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL),
     *          CMATDN_NEUNUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL)
C          
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL) 
      COMMON
     *       /EXPDEN/ LABELN(1:N_NOYX,1:2),
     *                R_MESH(1:ND_RHO,1:N_NOYX),
     *                RHOEXP(1:ND_RHO,1:N_NOYX)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                              LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                              LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR    
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS 
      COMMON
     *       /NUCWEI/ WEINUC_PROTON(1:NDNUCL),
     *                WEINUC_NEUTRS(1:NDNUCL),
     *                WEIRAD_PROTON(1:NDNUCL),
     *                WEIRAD_NEUTRS(1:NDNUCL) 
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI
      COMMON
     *       /ARGUMN/ IARG_R,IARG_Z
      COMMON
     *       /CHI_PN/ CHISQU_PROTON,CHISQU_NEUTRS
      COMMON
     *       /CHICHO/ VALCHI
     *       /DENSTR/ IFDENS
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /FITTED/ IFITED
     *       /MASSIV/ IMASIV_PRODUC
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /SIMUSE/ AOSCIL,RADCUT,INUCLI
      COMMON
     *       /CUTOFF/ RADIUS_CUTOFF(1:NDNUCL)
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C       
C=======================================================================
C
C     This subroutine calculates the energy levels, densities... for
C     one single run with the parameter values desired for the user.
C
C     It is only activated if IFTEST=1 for the input file
C
C     The desired parameter values come from the input file, too
C       
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,9X,''Entering ONERUN'',/)')
      END IF
C
C=======================================================================
C
      IFPROT=0
      IFNEUT=0
      IFBOTH=0
C
C=======================================================================
C
C     First, calculating the total weights (protons and neutrons)
C     that will be used as the normalizing constants of the \chi^2
C
      WEIGHT_PROTON=0.0
      WEIGHT_NEUTRS=0.0
C
      DO INUCLI=1,LDNUCL
         IF (ITAKNU(INUCLI).EQ.1) THEN
C_______________________________________________________________________
C
             IF (IF_SPE.EQ.1) THEN
C
                 DEGSUM_PROTON=0.0
C
                 DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                    DEGAUX=REAL(IDEGEX_PROTON(INUCLI,IEXPER))
                    DEGSUM_PROTON=DEGSUM_PROTON+DEGAUX
                 END DO
C
                 WEIGHT_PROTON=WEIGHT_PROTON+DEGSUM_PROTON
     *                                      *WEINUC_PROTON(INUCLI)
C
                 DEGSUM_NEUTRS=0.0
C
                 DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                    DEGAUX=REAL(IDEGEX_NEUTRS(INUCLI,IEXPER))
                    DEGSUM_NEUTRS=DEGSUM_NEUTRS+DEGAUX
                 END DO
C
                 WEIGHT_NEUTRS=WEIGHT_NEUTRS+DEGSUM_NEUTRS
     *                                      *WEINUC_NEUTRS(INUCLI)
C
             END IF
C_______________________________________________________________________
C
             IF (IF_RAD.EQ.1) THEN
C
                 WEIGHT_PROTON=WEIGHT_PROTON+WEIRAD_PROTON(INUCLI)
                 WEIGHT_NEUTRS=WEIGHT_NEUTRS+WEIRAD_NEUTRS(INUCLI)
C
             END IF
C_______________________________________________________________________
C
         END IF
      END DO
C       
C=======================================================================
C
      IMASIV_PRODUC=1
      IRANDO=0
      LDRAND=0
      IEVALU_PRINTG=1
      CHIGRD_PRINTG=999.
      CHISQU_MINIML=999.
C       
C=======================================================================
C
      DO IPARAM=1,NDPARS
         PARPOT_PRINTG(IPARAM)=PARPOT(IPARAM)
      END DO
C
      IF (NUCACT.LT.LDNUCL) RMSGLO_PRINTG=9.9999
C          
      RMSGLO_PROTON=0.
      RMSGLO_NEUTRS=0.
C
      RMSGLO_PROAUX=0.
      RMSGLO_NEUAUX=0.
C
      IDEG_P=0
      IDEG_N=0
C       
C=======================================================================
C
      DO INUCLI=1,LDNUCL
C
         IZ_FIX=NUMB_Z(INUCLI)
         IN_FIX=NUMB_N(INUCLI)
C
         WRITE(0,*)INUCLI,LDNUCL,IZ_FIX,IN_FIX
C
C=======================================================================     
C
C        Diagonalising the Hamiltonian for the single-run mode
C
         IF (LOGWRI.GT.4) THEN
             WRITE(LOGFIL,'(12x,''Entering WS_RUN from ONERUN with: '',
     *                          ''IZ_FIX= '',I3,'' and IN_FIX= '',I3)')
     *                            IZ_FIX,              IN_FIX
         END IF
C
         IDEFCN=0
                                                 I_MODE=0
                                                        I_FLAG=1
         CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,I_FLAG,
     *                             CHISQU_PROTON,CHISQU_NEUTRS)
C
         VALCHI=CHISQU_PROTON/WEIGHT_PROTON
     *         +CHISQU_NEUTRS/WEIGHT_NEUTRS 
C
         IF (ITAKNU(INUCLI).EQ.1) CHISQU_MINIML=VALCHI
C_______________________________________________________________________
C     
         RMSTHE_PRONUC(INUCLI)=RMSTHE_PROTON
         LEVTHE_PRONUC(INUCLI)=LEVTHE_PROTON
         
         DO ITHEOR=1,LEVTHE_PROTON
            ENETHE_PRONUC(ITHEOR,INUCLI)=ENETHE_PROTON(ITHEOR)
            LABTHE_PRONUC(ITHEOR,INUCLI)=LABTHE_PROTON(ITHEOR)
         END DO
C_______________________________________________________________________
C         
         RMSTHE_NEUNUC(INUCLI)=RMSTHE_NEUTRS
         LEVTHE_NEUNUC(INUCLI)=LEVTHE_NEUTRS
         
         DO ITHEOR=1,LEVTHE_PROTON
            ENETHE_NEUNUC(ITHEOR,INUCLI)=ENETHE_NEUTRS(ITHEOR)
            LABTHE_NEUNUC(ITHEOR,INUCLI)=LABTHE_NEUTRS(ITHEOR)
         END DO
C_______________________________________________________________________
C
C        Calculating the TOTAL degenerancy of all the nuclei
C
         DO IEXPER=1,LEVEXP_PROTON(INUCLI)
            IDEG_P=IDEG_P+IDEGEX_PROTON(INUCLI,IEXPER)
         END DO
C
         DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
            IDEG_N=IDEG_N+IDEGEX_NEUTRS(INUCLI,IEXPER)
         END DO
C_______________________________________________________________________
C                  
         EABSAV_PRONUC(INUCLI)=EABSAV_PROTON
         EABSAV_NEUNUC(INUCLI)=EABSAV_NEUTRS
         
         ERRMAX_PRONUC(INUCLI)=ERRMAX_PROTON
         ERRMAX_NEUNUC(INUCLI)=ERRMAX_NEUTRS
         
         RMSVAL_PRONUC(INUCLI)=SQRT(CHIWEI_PROTON)
         RMSVAL_NEUNUC(INUCLI)=SQRT(CHIWEI_NEUTRS)
         
         RMSGLO_PROTON=RMSGLO_PROTON+CHIWEI_PROTON
         RMSGLO_NEUTRS=RMSGLO_NEUTRS+CHIWEI_NEUTRS

         RMSGLO_PROAUX=RMSGLO_PROAUX+CHIDEG_PROTON
         RMSGLO_NEUAUX=RMSGLO_NEUAUX+CHIDEG_NEUTRS
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_PROTON,0,-1
            DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
C
               ENERUP_PRONUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERUP_AUXPRO(LQNUMB,NWSNUM)
C
               ENERDN_PRONUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERDN_AUXPRO(LQNUMB,NWSNUM)
C
               DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
C
                  CMATUP_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATUP_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
C
                  CMATDN_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATDN_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
C
               END DO
C
            END DO
         END DO  
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_NEUTRS,0,-1
            DO NWSNUM=1,(NSHELL_NEUTRS-LQNUMB)/2+1
C
               ENERUP_NEUNUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERUP_AUXNEU(LQNUMB,NWSNUM)
C
               ENERDN_NEUNUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERDN_AUXNEU(LQNUMB,NWSNUM)
C
               DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
C
                  CMATUP_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATUP_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
C
                  CMATDN_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATDN_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
C
               END DO
C
            END DO
         END DO   
C_______________________________________________________________________
C          
      END DO !INUCLI
C_______________________________________________________________________
C      
      RMSGLO_PROTON=SQRT(RMSGLO_PROTON)
      RMSGLO_NEUTRS=SQRT(RMSGLO_NEUTRS)
C
      RMSGLO_PROAUX=SQRT(RMSGLO_PROAUX/IDEG_P)
      RMSGLO_NEUAUX=SQRT(RMSGLO_NEUAUX/IDEG_N)
C
C=======================================================================
C
      DO INUCLI=1,LDNUCL
C
         IZ_FIX=NUMB_Z(INUCLI)
         IN_FIX=NUMB_N(INUCLI)
C
         CALL INTROD(INUCLI)
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_PROTON,0,-1
            DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
C
               ENERUP_AUXPRO(LQNUMB,NWSNUM)
     *        =
     *         ENERUP_PRONUC(LQNUMB,NWSNUM,INUCLI)
C
               ENERDN_AUXPRO(LQNUMB,NWSNUM)
     *        =
     *         ENERDN_PRONUC(LQNUMB,NWSNUM,INUCLI)
C
               DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
C
                  CMATUP_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATUP_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
                  CMATDN_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATDN_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
               END DO
C
            END DO
         END DO  
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_NEUTRS,0,-1
            DO NWSNUM=1,(NSHELL_NEUTRS-LQNUMB)/2+1
C
               ENERUP_AUXNEU(LQNUMB,NWSNUM)
     *        =
     *         ENERUP_NEUNUC(LQNUMB,NWSNUM,INUCLI)
C
               ENERDN_AUXNEU(LQNUMB,NWSNUM)
     *        =
     *         ENERDN_NEUNUC(LQNUMB,NWSNUM,INUCLI)
C
               DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
C
                  CMATUP_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATUP_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
                  CMATDN_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATDN_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
               END DO
C
            END DO
         END DO   
C_______________________________________________________________________
C 
         IFITED=2 ! single run
C_______________________________________________________________________
C             
         IF (IFDENS.EQ.0) THEN
C
             ISOSPI=1
             IFPROT=1
             IFNEUT=0
C
             ERRMAX_PRINTG=ERRMAX_PRONUC(INUCLI)
C            EABSAV_PRINTG=EABSAV_PRONUC(INUCLI)
             RMSVAL_PRINTG=RMSVAL_PRONUC(INUCLI)
             
             RMSEXP_PRINTG=RMSEXP_PROTON(INUCLI)
             RMSTHE_PRINTG=RMSTHE_PRONUC(INUCLI)
             LEVTHE_PRINTG=LEVTHE_PRONUC(INUCLI)
C
             DO ITHEOR=1,LEVTHE_PRINTG
                ENETHE_PRINTG(ITHEOR)=ENETHE_PRONUC(ITHEOR,INUCLI)
                LABTHE_PRINTG(ITHEOR)=LABTHE_PRONUC(ITHEOR,INUCLI)
             END DO
C
             CALL WRITIN_ENELEV(ISOSPI,IRANDO,LDRAND,IEVALU_PRINTG,
     *                                 PARPOT_PRINTG,CHISQU_MINIML,
     *                                 CHIGRD_PRINTG,ERRMAX_PRINTG,
     *                                 RMSVAL_PRINTG,RMSGLO_PROAUX,
     *                                 RMSEXP_PRINTG,RMSTHE_PRINTG,
     *                                 LEVTHE_PRINTG,ENETHE_PRINTG,
     *                                 LABTHE_PRINTG,INUCLI)
C_______________________________________________________________________
C         
             ISOSPI=0
             IFNEUT=1
             IFPROT=0
C
             ERRMAX_PRINTG=ERRMAX_NEUNUC(INUCLI)
C             EABSAV_PRINTG=EABSAV_NEUNUC(INUCLI)
             RMSVAL_PRINTG=RMSVAL_NEUNUC(INUCLI)
C
             RMSEXP_PRINTG=RMSEXP_NEUTRS(INUCLI)
             RMSTHE_PRINTG=RMSTHE_NEUNUC(INUCLI)
             LEVTHE_PRINTG=LEVTHE_NEUNUC(INUCLI)
C
             DO ITHEOR=1,LEVTHE_PRINTG
                ENETHE_PRINTG(ITHEOR)=ENETHE_NEUNUC(ITHEOR,INUCLI)
                LABTHE_PRINTG(ITHEOR)=LABTHE_NEUNUC(ITHEOR,INUCLI)
             END DO
C
             CALL WRITIN_ENELEV(ISOSPI,IRANDO,LDRAND,IEVALU_PRINTG,
     *                                 PARPOT_PRINTG,CHISQU_MINIML,
     *                                 CHIGRD_PRINTG,ERRMAX_PRINTG,
     *                                 RMSVAL_PRINTG,RMSGLO_NEUAUX,
     *                                 RMSEXP_PRINTG,RMSTHE_PRINTG,
     *                                 LEVTHE_PRINTG,ENETHE_PRINTG,
     *                                 LABTHE_PRINTG,INUCLI)
         END IF
C_______________________________________________________________________
C         
         IF (IFDENS.EQ.1) THEN
C
             ISOSPI=1
C
             ERRMAX_PRINTG=ERRMAX_PRONUC(INUCLI)
C             EABSAV_PRINTG=EABSAV_PRONUC(INUCLI)
             RMSVAL_PRINTG=RMSVAL_PRONUC(INUCLI)
C
             RMSEXP_PRINTG=RMSEXP_PROTON(INUCLI)
             RMSTHE_PRINTG=RMSTHE_PRONUC(INUCLI)
             LEVTHE_PRINTG=LEVTHE_PRONUC(INUCLI)
C
             DO ITHEOR=1,LEVTHE_PRINTG
                ENETHE_PRINTG(ITHEOR)=ENETHE_PRONUC(ITHEOR,INUCLI)
                LABTHE_PRINTG(ITHEOR)=LABTHE_PRONUC(ITHEOR,INUCLI)
             END DO
C
             CALL WRITIN_ENELEV(ISOSPI,IRANDO,LDRAND,IEVALU_PRINTG,
     *                                 PARPOT_PRINTG,CHISQU_MINIML,
     *                                 CHIGRD_PRINTG,ERRMAX_PRINTG,
     *                                 RMSVAL_PRINTG,RMSGLO_PROAUX,
     *                                 RMSEXP_PRINTG,RMSTHE_PRINTG,
     *                                 LEVTHE_PRINTG,ENETHE_PRINTG,
     *                                 LABTHE_PRINTG,INUCLI)
C_______________________________________________________________________
C     
             ISOSPI=0
C
             ERRMAX_PRINTG=ERRMAX_NEUNUC(INUCLI)
C             EABSAV_PRINTG=EABSAV_NEUNUC(INUCLI)
             RMSVAL_PRINTG=RMSVAL_NEUNUC(INUCLI)
C
             RMSEXP_PRINTG=RMSEXP_NEUTRS(INUCLI)
             RMSTHE_PRINTG=RMSTHE_NEUNUC(INUCLI)
             LEVTHE_PRINTG=LEVTHE_NEUNUC(INUCLI)
C
             DO ITHEOR=1,LEVTHE_PRINTG
                ENETHE_PRINTG(ITHEOR)=ENETHE_NEUNUC(ITHEOR,INUCLI)
                LABTHE_PRINTG(ITHEOR)=LABTHE_NEUNUC(ITHEOR,INUCLI)
             END DO
C
             CALL WRITIN_ENELEV(ISOSPI,IRANDO,LDRAND,IEVALU_PRINTG,
     *                                 PARPOT_PRINTG,CHISQU_MINIML,
     *                                 CHIGRD_PRINTG,ERRMAX_PRINTG,
     *                                 RMSVAL_PRINTG,RMSGLO_NEUAUX,
     *                                 RMSEXP_PRINTG,RMSTHE_PRINTG,
     *                                 LEVTHE_PRINTG,ENETHE_PRINTG,
     *                                 LABTHE_PRINTG,INUCLI)
         END IF
C
C=======================================================================
C
C        Now, preparing outputs for density-dependent functions
C
C=======================================================================
C
         ISPLIT=0
         CURNAM='Dens-'
C_______________________________________________________________________
C
C        Total Proton Densities: Theory vs. Experiment
C
         ISOSPI=1
C
         N_CURV=2
C                        
         DO I_CURV=1,N_CURV
            ND_MAX(I_CURV)=60
         END DO
C
         IARG_R=1
         IARG_Z=0
C                        
         AOSCIL=AOSCIL_PROTON(INUCLI)
         RADCUT=RADIUS_CUTOFF(INUCLI)
C
         IF (IF_PAI.EQ.0) CURLAB='$\\rho^{th}_{\\pi}(r)$'
         IF (IF_PAI.EQ.1) CURLAB='$\\rho^{pair}_{\\pi}(r)$'
C                        
         DO IPOINT=1,ND_MAX(N_CURV)
C           
            RARGUM=0.0001+(IPOINT-1)*0.2 
C           
            X_CURV(IPOINT,1)=RARGUM
            Y_CURV(IPOINT,1)=DENSIT(RARGUM)
            L_CURV(IPOINT,1)=CURLAB
C
            X_CURV(IPOINT,2)=RARGUM
            Y_CURV(IPOINT,2)=DENEXP(RARGUM)
            L_CURV(IPOINT,2)='$\\rho^{exp}_{\\pi}(r)$'
C                        
         END DO
C                     
         MAIN_T='Proton Density Profiles'
         XTITLE='r (fm)'
         YTITLE='Density (N/fm$^3$)'
         ISOSPI=1 
C                     
         CALL DENSIT_OUTPUT(CURNAM,N_CURV,ND_MAX,X_CURV,Y_CURV,L_CURV,
     *                      ISOSPI,IZ_FIX,IN_FIX,MAIN_T,XTITLE,YTITLE,
     *                                           ISPLIT,INUCLI,LDRAND) 
C_______________________________________________________________________
C
C        Total Neutron Density: Theory
C
         ISOSPI=0
C
         N_CURV=1
         ND_MAX(I_CURV)=60
C
         IARG_R=1
         IARG_Z=0
C
         AOSCIL=AOSCIL_NEUTRS(INUCLI)
         IF (IF_PAI.EQ.0) CURLAB='$\\rho^{th}_{\\nu}(r)$'
         IF (IF_PAI.EQ.1) CURLAB='$\\rho^{pair}_{\\nu}(r)$'
C                        
         DO IPOINT=1,ND_MAX(I_CURV)
C           
            RARGUM=0.0001+(IPOINT-1)*0.2 
C           
            X_CURV(IPOINT,1)=RARGUM
            Y_CURV(IPOINT,1)=DENSIT(RARGUM)
            L_CURV(IPOINT,1)=CURLAB
C                        
         END DO
C                     
         MAIN_T='Neutron Density Profile'
         XTITLE='r (fm)'
         YTITLE='Density (N/fm$^3$)'
         ISOSPI=0 
C                     
         CALL DENSIT_OUTPUT(CURNAM,N_CURV,ND_MAX,X_CURV,Y_CURV,L_CURV,
     *                      ISOSPI,IZ_FIX,IN_FIX,MAIN_T,XTITLE,YTITLE,
     *                                           ISPLIT,INUCLI,LDRAND)
C
C=======================================================================
C
C        Level densities summed one after the other
C        First protons, then neutrons
C_______________________________________________________________________
C
         ISPLIT=1                
         CURNAM='RhoS-'
         ND_MAX_AUXIL=60
C_______________________________________________________________________
C                    
         ISOSPI=1
C                     
         DO IPOINT=1,ND_MAX_AUXIL
C                        
            XPOINT=0.0001+(IPOINT-1)*0.2
C                        
            ZARGUM=(XPOINT/AOSCIL_PROTON(INUCLI))**2
C
            CALL RHONLJ_SUMMED(INUCLI,ISOSPI,ZARGUM,
     *                         IPOINT,N_CURV,Y_CURV,L_CURV)
C     
            DO I_CURV=1,N_CURV
C                           
               X_CURV(IPOINT,I_CURV)=XPOINT
               ND_MAX(I_CURV)=ND_MAX_AUXIL
C                           
            END DO
C     
         END DO
C                     
         WRITE(MAIN_T,'(''Calculated Proton Density Profiles'')')
         XTITLE='r (fm)'
         YTITLE='Density (N/fm$^3$)'
C                     
         CALL DENSIT_OUTPUT(CURNAM,N_CURV,ND_MAX,X_CURV,Y_CURV,L_CURV,
     *                      ISOSPI,IZ_FIX,IN_FIX,MAIN_T,XTITLE,YTITLE,
     *                                           ISPLIT,INUCLI,LDRAND)
C_______________________________________________________________________
C                     
         ISOSPI=0
C                     
         DO IPOINT=1,ND_MAX_AUXIL
C                        
            XPOINT=0.0001+(IPOINT-1)*0.2
C                        
            ZARGUM=(XPOINT/AOSCIL_NEUTRS(INUCLI))**2
C
            CALL RHONLJ_SUMMED(INUCLI,ISOSPI,ZARGUM,
     *                         IPOINT,N_CURV,Y_CURV,L_CURV)
C     
            DO I_CURV=1,N_CURV
C                           
               X_CURV(IPOINT,I_CURV)=XPOINT
               ND_MAX(I_CURV)=ND_MAX_AUXIL
C                           
            END DO
C     
         END DO
                     
         WRITE(MAIN_T,'(''Calculated Neutron Density Profiles'')')
         XTITLE='r (fm)'
         YTITLE='Density (N/fm$^3$)'
C                     
         CALL DENSIT_OUTPUT(CURNAM,N_CURV,ND_MAX,X_CURV,Y_CURV,L_CURV,
     *                      ISOSPI,IZ_FIX,IN_FIX,MAIN_T,XTITLE,YTITLE,
     *                                           ISPLIT,INUCLI,LDRAND)
C
C=======================================================================
C        
      END DO  !INUCLI
C       
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,''Exiting ONERUN'')')
      END IF
C       
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE SPENER_OFPARA(LDRAND)
C
      INCLUDE 'MATDIM/NDMESH.f'
      INCLUDE 'MATDIM/NDSPEC.f'
      INCLUDE 'MATDIM/NDPARS.f'
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDLEXP.f'
      INCLUDE 'MATDIM/NDIM_M.f'
      INCLUDE 'MATDIM/NDTITL.f'
      INCLUDE 'MATDIM/NDLAST.f'
C
      PARAMETER
     *          (NDMES2=NDMESH*NDMESH)
C
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6,VERSIO*3
      CHARACTER
     *          FILNAM*256,L_CURV*100,NUCNAM*05,TITLES*12,
     *          ISONAM*002,TEXLAM*020,TITPAR*13,FITNUC*02,
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          LABREF*6,LABTHE*6,LABEXP*6,LABTEX*11,L_CURV_AUXILI*100,
     *          L_CURV_AUXPRO*100,L_CURV_AUXNEU*100,
     *          LABREF_PROTON*6,LABREF_NEUTRS*6
      CHARACTER
     *          MAIN_T*256,XTITLE*256,YTITLE*256,PARNAM*8,TITMSH*8
C
      DIMENSION
     *          STPMSH(1:NDIM_M),
     *          XINITS(1:NDPARS),
     *          ARGMNT(1:NDPARS)
      DIMENSION
     *          TITMSH(1:NDPARS),
     *          TITPAR(1:NDPARS),
     *          PARPOT_PRINTI(1:NDPARS,1:NDMES2)
      DIMENSION
     *          NDPOIN(1:NDSPEC),
     *          X_CURV(1:NDMESH,1:NDSPEC),
     *          Y_CURV(1:NDMESH,1:NDSPEC),
     *          L_CURV(1:NDMESH,1:NDSPEC),
     *          ICOLOR(1:NDSPEC),
     *          ITHICK(1:NDSPEC)
      DIMENSION
     *          X_CURV_AUXILI(1:NDMESH,1:NDSPEC,1:NDNUCL),
     *          Y_CURV_AUXILI(1:NDMESH,1:NDSPEC,1:NDNUCL),
     *          L_CURV_AUXILI(1:NDMESH,1:NDSPEC,1:NDNUCL),
     *          ICOLOR_AUXILI(1:NDSPEC,1:NDNUCL),
     *          ITHICK_AUXILI(1:NDSPEC,1:NDNUCL)
      DIMENSION
     *          NDPOIN_PROTON(1:NDSPEC),
     *          X_CURV_AUXPRO(1:NDMESH,1:NDSPEC,1:NDNUCL),
     *          Y_CURV_AUXPRO(1:NDMESH,1:NDSPEC,1:NDNUCL),
     *          L_CURV_AUXPRO(1:NDMESH,1:NDSPEC,1:NDNUCL),
     *          ICOLOR_AUXPRO(1:NDSPEC,1:NDNUCL),
     *          ITHICK_AUXPRO(1:NDSPEC,1:NDNUCL)
      DIMENSION
     *          NDPOIN_NEUTRS(1:NDSPEC),
     *          X_CURV_AUXNEU(1:NDMESH,1:NDSPEC,1:NDNUCL),
     *          Y_CURV_AUXNEU(1:NDMESH,1:NDSPEC,1:NDNUCL),
     *          L_CURV_AUXNEU(1:NDMESH,1:NDSPEC,1:NDNUCL),
     *          ICOLOR_AUXNEU(1:NDSPEC,1:NDNUCL),
     *          ITHICK_AUXNEU(1:NDSPEC,1:NDNUCL)
      DIMENSION
     *          RMSVAL(1:NDSPEC,1:NDNUCL),
     *          RMSVAL_PROTON(1:NDSPEC,1:NDNUCL),
     *          RMSVAL_NEUTRS(1:NDSPEC,1:NDNUCL)
      DIMENSION
     *          LABREF(1:NDSPEC),
     *          LABREF_PROTON(1:NDSPEC),
     *          LABREF_NEUTRS(1:NDSPEC)
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /PARCOR/ IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /MESHIN/ I_MESH(1:NDPARS),
     *                XMIN_I(1:NDPARS),
     *                XMAX_I(1:NDPARS),
     *                MAXPAR(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /VLIMIT/ VMISTR(1:NDPARS),
     *                VMIMIN(1:NDPARS),
     *                VMIMAX(1:NDPARS),
     *                VMISTP(1:NDPARS)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)  
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /VERSIN/ VERSIO
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C       
C=======================================================================
C
C     This subroutine prepares all the input parapeters for WS_RUN
C     in order to be able to plot the single particle energies  as 
C     a function of O N E parameter, that the user has choosen via 
C     NAMELI. 
C
C     ATTENTION: this subroutine uses some vectors that are also used
C     in MESHIN_MAPING. This has been deliberately programmed.
C
C=======================================================================
C
C     IFTAKE .EQ. -1: parameter eliminated via parametric correlation
C     IFTAKE .EQ. +1: parameter entering to the minimization
C     IFTAKE .EQ. +4: parameter considered constant but printed anyway
C
C=======================================================================     
C
      WRITE(LOGFIL,'(/,''Entering to SPENER_OFPARA'',/)')
C
C=======================================================================     
C     Over which parameter the levels are going to be plotted
C=======================================================================
C
      ICOUNT=0
C
      DO IPARAM=1,NDPARS
         IF (I_MESH(IPARAM).EQ.1) THEN
C
             ICOUNT=ICOUNT+1
C
             STPMSH(IPARAM)=(XMAX_I(IPARAM)-XMIN_I(IPARAM))
     *                     /(MAXPAR(IPARAM)-1)
C
             MAXMSH=MAXPAR(IPARAM)
C
             INDEXI=IPARAM
C
             PARNAM=TITLES(IPARAM)(3:10)
             TITMSH(ICOUNT)=PARNAM
C
         END IF
      END DO
C
      IF (ICOUNT.NE.1) THEN
C
          WRITE(LSCREN,'(''ALARM from SPENER_OFPARA: '',
     *                   ''ICOUNT='',I2,''when it has to be '',
     *                   ''equal to 1!! - Change the input file '')')
     *                    ICOUNT
          STOP 'Stop - Change the input file in ISPE_P option'
C
      END IF
C
      ICMESH=ICOUNT
C
C=======================================================================
C         Over which parameters we are going to minimise --> ARGMNT(I)
C=======================================================================
C        
      ICOUNT_OFPARS=0
C
      IFPROT=0
      IFNEUT=0
      IFBOTH=0
C
      DO I=1,NDPARS
         IF (IFTAKE(I).EQ.1) THEN
C
             ICOUNT_OFPARS=ICOUNT_OFPARS+1
             ARGMNT(ICOUNT_OFPARS)=VMISTR(I)
             TITPAR(ICOUNT_OFPARS)=TITLES(I)(3:10)
C
             IF (I.LE.20 .AND. IFDENS.EQ.0) THEN
                 IFPROT=1
             END IF
             IF (I.GT.20 .AND. IFDENS.EQ.0) THEN
                 IFNEUT=1
             END IF
             IF (I.GE.51 .AND. IFDENS.EQ.0) THEN
                 IFPROT=0
                 IFNEUT=0
                 IFBOTH=1
             END IF
C
         END IF
      END DO
C
      IF (LOGWRI.GT.0) THEN
          IF (IFPROT.EQ.1) 
     *        WRITE(LOGFIL,'(9X,''SPENER_OFPARA for protons'',/)')
          IF (IFNEUT.EQ.1) 
     *        WRITE(LOGFIL,'(9X,''SPENER_OFPARA for neutrons'',/)')
      END IF
C
C=======================================================================
C
      IPRINT_PROTON=0
      IPRINT_NEUTRS=0
C
      IF ((IFDENS.EQ.0 .AND. IFNEUT.EQ.1) .OR.
     *    (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) .OR.
     *     IFDENS.EQ.1) THEN
           IPRINT_NEUTRS=1
      END IF
C
      IF ((IFDENS.EQ.0 .AND. IFPROT.EQ.1) .OR.
     *    (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) .OR.
     *     IFDENS.EQ.1) THEN
           IPRINT_PROTON=1
      END IF
C
C=======================================================================
C
      IF (ICOUNT_OFPARS.NE.0) GO TO 1 ! ==>> Minimization required
C
C=======================================================================
C
      IF (ICOUNT_OFPARS.EQ.0) THEN
C
          IFPROT=0
          IFNEUT=0
          IFBOTH=0
C
          DO I=1,NDPARS
             IF (I_MESH(I).EQ.1) THEN
C
                 IF (I.LE.20 .AND. IFDENS.EQ.0) THEN
                     IFPROT=1
                 END IF
                 IF (I.GT.20 .AND. IFDENS.EQ.0) THEN
                     IFNEUT=1
                 END IF
                 IF (I.GE.51 .AND. IFDENS.EQ.0) THEN
                     IFPROT=0
                     IFNEUT=0
                     IFBOTH=1
                 END IF
C
             END IF
          END DO
C
      END IF
C
      IF (LOGWRI.GT.0) THEN
          IF (IFPROT.EQ.1) 
     *        WRITE(LOGFIL,'(9X,''SPENER_OFPARA for protons'',/)')
          IF (IFNEUT.EQ.1) 
     *        WRITE(LOGFIL,'(9X,''SPENER_OFPARA for neutrons'',/)')
      END IF
C
C=======================================================================
C
      IPRINT_PROTON=0
      IPRINT_NEUTRS=0
C
      IF ((IFDENS.EQ.0 .AND. IFNEUT.EQ.1) .OR.
     *    (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) .OR.
     *     IFDENS.EQ.1) THEN
           IPRINT_NEUTRS=1
      END IF
C
      IF ((IFDENS.EQ.0 .AND. IFPROT.EQ.1) .OR.
     *    (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) .OR.
     *     IFDENS.EQ.1) THEN
           IPRINT_PROTON=1
      END IF
C
C=======================================================================
C
      IF (IPRINT_PROTON.EQ.1) THEN
          CONTINUE
      ELSE
          GO TO 3
      END IF
C
C=======================================================================
C
C     NO MINIMIZATION - PROTONS
C
      IF (LOGWRI.GT.0) 
     *    WRITE(LOGFIL,'(9x,''NO Minimization option'',/)')
C
      JPARAM=INDEXI
C
      DO INUCLI=1,LDNUCL
         IF (ITAKNU(INUCLI).EQ.1) THEN
C
             DO INDEX1=1,MAXMSH
C
                IF (LOGWRI.GT.0) THEN
                    WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *                             ''#  INDEX1= '',I6,T80,''#'',/,
     *                             ''#'',T80,''#'',/,80(''#''))')INDEX1
                END IF
C
                XINITS(JPARAM)=XMIN_I(JPARAM)+(INDEX1-1)*STPMSH(JPARAM)
                PARPOT(JPARAM)=XINITS(JPARAM)
C
                IDEFCN=0
                I_MODE=0
                I_FLAG=1
C
                CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,I_FLAG,
     *                                    CHISQU_PROTON,CHISQU_NEUTRS)
C
C               Updating the parameter vector for printing purposes
C
                DO KPARAM=1,NDPARS
                   PARPOT_PRINTI(KPARAM,INDEX1)=PARPOT(KPARAM)
                END DO
C
C               storing the rms value for protons
C
                RMSVAL(INDEX1,INUCLI)=SQRT(CHIWEI_PROTON)
C
C               Storing the values of the levels for each nucleus 
C               for the plotting output (depending on the reference,
C                                                         see below)
C
                NDCURV=LEVTHE_PROTON
C
C               Storing the reference order of the levels
C
                IF (INDEX1.EQ.1) THEN
                    DO IREFER=1,NDCURV
                       LABREF(IREFER)=LABTHE_PROTON(IREFER)
                    END DO
                END IF
C
                DO ICURVE=1,NDCURV
C
                   X_CURV(INDEX1,ICURVE)=XINITS(JPARAM)
C
                   DO ITHEOR=1,NDCURV
                      IF (LABTHE_PROTON(ITHEOR).EQ.LABREF(ICURVE))THEN
C
                          Y_CURV(INDEX1,ICURVE)
     *                   =ENETHE_PROTON(ITHEOR)
C
                          LABTHE=LABTHE_PROTON(ITHEOR)
                          CALL LATEXS_LABELS(LABTHE,LABTEX)
                          L_CURV(INDEX1,ICURVE)=LABTEX
C
                          LQNUMB=LWSSPH_PROTON(ITHEOR)
                          LPARIT=(-1)**LQNUMB
C
                          IF (LPARIT.EQ.+1) ICOLOR(ICURVE)=44
C
                          IF (LPARIT.EQ.-1) ICOLOR(ICURVE)=53
C
                          ITHICK(ICURVE)=4
C
                      END IF
                   END DO
C                   
                END DO !ICURVE
C
                DO I=1,NDCURV
                   NDPOIN(I)=MAXMSH
                END DO
C
             END DO !INDEX1
C
C            Looking the correspondance with the experiment
C
             IEXTRA=0
             DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                DO ITHEOR=1,NDCURV
C
                   LABEXP=LABEXP_PROTON(INUCLI,IEXPER)
                   CALL LATEXS_LABELS(LABEXP,LABTEX)
C
                   IF (LABTEX.EQ.L_CURV(1,ITHEOR)) THEN
C
                       DO IPOINT=1,NDPOIN(ITHEOR)-1
C
                          IF ((EXPEXP_PROTON(INUCLI,IEXPER)
     *                   .GE.  Y_CURV(IPOINT,ITHEOR))
     *                   .AND.(EXPEXP_PROTON(INUCLI,IEXPER)
     *                   .LT.  Y_CURV(IPOINT+1,ITHEOR)))
     *                    THEN
C
                             IEXTRA=IEXTRA+1
C
                             IF (IPOINT.EQ.1) THEN
                                 X_CURV(1,NDCURV+IEXTRA)
     *                          =X_CURV(IPOINT,ITHEOR)
                             ELSE
                                 X_CURV(1,NDCURV+IEXTRA)
     *                          =X_CURV(IPOINT-1,ITHEOR)
                             END IF
C
                             X_CURV(2,NDCURV+IEXTRA)
     *                      =X_CURV(IPOINT+1,ITHEOR)

C
                             Y_CURV(1,NDCURV+IEXTRA)
     *                      =EXPEXP_PROTON(INUCLI,IEXPER)
C
                             Y_CURV(2,NDCURV+IEXTRA)
     *                      =EXPEXP_PROTON(INUCLI,IEXPER)
C
                             L_CURV(1,NDCURV+IEXTRA)
     *                      =LABTEX
C
                             L_CURV(2,NDCURV+IEXTRA)
     *                      =LABTEX
C
                             NDPOIN(NDCURV+IEXTRA)=2
                             ITHICK(NDCURV+IEXTRA)=6
C
                             IF (ICOLOR(ITHEOR).EQ.44)
     *                           ICOLOR(NDCURV+IEXTRA)=71
C
                             IF (ICOLOR(ITHEOR).EQ.53)
     *                          ICOLOR(NDCURV+IEXTRA)=72
C
                          END IF
C
                          IF ((EXPEXP_PROTON(INUCLI,IEXPER)
     *                   .LE.  Y_CURV(IPOINT,ITHEOR))
     *                   .AND.(EXPEXP_PROTON(INUCLI,IEXPER)
     *                   .GT.  Y_CURV(IPOINT+1,ITHEOR)))
     *                    THEN
C
                             IEXTRA=IEXTRA+1
C
                             IF (IPOINT.EQ.1) THEN
                                 X_CURV(1,NDCURV+IEXTRA)
     *                          =X_CURV(IPOINT,ITHEOR)
                             ELSE
                                 X_CURV(1,NDCURV+IEXTRA)
     *                          =X_CURV(IPOINT-1,ITHEOR)
                             END IF
C
                             X_CURV(2,NDCURV+IEXTRA)
     *                      =X_CURV(IPOINT+1,ITHEOR)
C
                             Y_CURV(1,NDCURV+IEXTRA)
     *                      =EXPEXP_PROTON(INUCLI,IEXPER)
C
                             Y_CURV(2,NDCURV+IEXTRA)
     *                      =EXPEXP_PROTON(INUCLI,IEXPER)
C
                             L_CURV(1,NDCURV+IEXTRA)
     *                      =LABTEX
C
                             L_CURV(2,NDCURV+IEXTRA)
     *                      =LABTEX
C
                             NDPOIN(NDCURV+IEXTRA)=2
                             ITHICK(NDCURV+IEXTRA)=6
C
                             IF (ICOLOR(ITHEOR).EQ.44)
     *                           ICOLOR(NDCURV+IEXTRA)=71
C
                             IF (ICOLOR(ITHEOR).EQ.53)
     *                           ICOLOR(NDCURV+IEXTRA)=72
C
                          END IF
C
                       END DO !IPOINT=1,NDPOIN(ITHEOR)-1
C
                   END IF
C
                END DO
             END DO
C
             IF (IEXTRA.NE.LEVEXP_PROTON(INUCLI)) THEN
                 WRITE(0,'(''IEXTRA= '',I4,''LEVEXP= '',I4)')IEXTRA,
     *                                         LEVEXP_PROTON(INUCLI)
CID                 STOP 'IEXTRA.NE.LEVEXP_PROTON(INUCLI)'
             END IF
C
             NDCURV=NDCURV+IEXTRA   !LEVEXP_PROTON(INUCLI)
C
             ISOSPI=1
             IZ_FIX=NUMB_Z(INUCLI)
             IN_FIX=NUMB_N(INUCLI)
C
             MAIN_T='Energy Level Parametric Dependence'
             XTITLE='\\boldmath'//TITLES_LATEXS(JPARAM)
             YTITLE='Single Particle Energies (MeV)'
C
             IF (LOGWRI.GT.0) 
     *           WRITE(LOGFIL,'(9X,''Entering SPENER_PLOTIN '',
     *                                         ''for protons'')')
C
             CALL SPENER_PLOTIN(NDCURV,NDPOIN,X_CURV,Y_CURV,L_CURV,
     *                          MAIN_T,XTITLE,YTITLE,ICOLOR,ITHICK,
     *                          INUCLI,ISOSPI,IZ_FIX,IN_FIX,PARNAM,
     *                                 JPARAM,PARPOT_PRINTI,RMSVAL)
C
         END IF !ITAKNU(INUCLI).EQ.1
      END DO !INUCLI
C
C=======================================================================
C
   3  CONTINUE
C
      IF (IPRINT_NEUTRS.EQ.1) THEN
          CONTINUE   ! ==>> WE DO THE NEUTRONS
      ELSE
          GO TO 2    ! ==>> WE JUMP TO THE END
      END IF
C
C=======================================================================
C
C     NO MINIMIZATION - NEUTRONS
C
      IF (LOGWRI.GT.0) 
     *    WRITE(LOGFIL,'(9x,''NO Minimization option'',/)')
C
      JPARAM=INDEXI
C
      DO INUCLI=1,LDNUCL
         IF (ITAKNU(INUCLI).EQ.1) THEN
C
             DO INDEX1=1,MAXMSH
C
                IF (LOGWRI.GT.0) THEN
                    WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *                             ''#  INDEX1= '',I6,T80,''#'',/,
     *                             ''#'',T80,''#'',/,80(''#''))')INDEX1
                END IF
C
                XINITS(JPARAM)=XMIN_I(JPARAM)+(INDEX1-1)*STPMSH(JPARAM)
                PARPOT(JPARAM)=XINITS(JPARAM)
C
                IDEFCN=0
                I_MODE=0
                I_FLAG=1
C
                CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,I_FLAG,
     *                                    CHISQU_PROTON,CHISQU_NEUTRS)
C
C               Updating the parameter vector for printing purposes
C
                DO KPARAM=1,NDPARS
                   PARPOT_PRINTI(KPARAM,INDEX1)=PARPOT(KPARAM)
                END DO
C
                RMSVAL(INDEX1,INUCLI)=SQRT(CHIWEI_NEUTRS)
C
C               Storing the values of the levels for each nucleus 
C               for the plotting output (depending on the reference,
C                                                         see below)
C
                NDCURV=LEVTHE_NEUTRS
C
C               Storing the reference order of the levels
C
                IF (INDEX1.EQ.1) THEN
                    DO IREFER=1,NDCURV
                       LABREF(IREFER)=LABTHE_NEUTRS(IREFER)
                    END DO
                END IF
C
                DO ICURVE=1,NDCURV
C
                   X_CURV(INDEX1,ICURVE)=XINITS(JPARAM)
C
                   DO ITHEOR=1,NDCURV
                      IF (LABTHE_NEUTRS(ITHEOR).EQ.LABREF(ICURVE))THEN
C
                          Y_CURV(INDEX1,ICURVE)
     *                   =ENETHE_NEUTRS(ITHEOR)
C
                          LABTHE=LABTHE_NEUTRS(ITHEOR)
                          CALL LATEXS_LABELS(LABTHE,LABTEX)
                          L_CURV(INDEX1,ICURVE)=LABTEX
C
                          LQNUMB=LWSSPH_NEUTRS(ITHEOR)
                          LPARIT=(-1)**LQNUMB
C
                          IF (LPARIT.EQ.+1) ICOLOR(ICURVE)=44
C
                          IF (LPARIT.EQ.-1) ICOLOR(ICURVE)=53
C
                          ITHICK(ICURVE)=4
C
                      END IF
                   END DO
C                   
                END DO !ICURVE
C
                DO I=1,NDCURV
                   NDPOIN(I)=MAXMSH
                END DO
C
             END DO !INDEX1
C
C            Looking the correspondance with the experiment
C
             IEXTRA=0
             DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                DO ITHEOR=1,NDCURV
C
                   LABEXP=LABEXP_NEUTRS(INUCLI,IEXPER)
                   CALL LATEXS_LABELS(LABEXP,LABTEX)
C
                   IF (LABTEX.EQ.L_CURV(1,ITHEOR)) THEN
C
                       DO IPOINT=1,NDPOIN(ITHEOR)-1
C
                          IF ((EXPEXP_NEUTRS(INUCLI,IEXPER)
     *                   .GE.  Y_CURV(IPOINT,ITHEOR))
     *                   .AND.(EXPEXP_NEUTRS(INUCLI,IEXPER)
     *                   .LT.  Y_CURV(IPOINT+1,ITHEOR)))
     *                    THEN
C
                             IEXTRA=IEXTRA+1
C
                             IF (IPOINT.EQ.1) THEN
                                 X_CURV(1,NDCURV+IEXTRA)
     *                          =X_CURV(IPOINT,ITHEOR)
                             ELSE
                                 X_CURV(1,NDCURV+IEXTRA)
     *                          =X_CURV(IPOINT-1,ITHEOR)
                             END IF
C
                             X_CURV(2,NDCURV+IEXTRA)
     *                      =X_CURV(IPOINT+1,ITHEOR)
C
                             Y_CURV(1,NDCURV+IEXTRA)
     *                      =EXPEXP_NEUTRS(INUCLI,IEXPER)
C
                             Y_CURV(2,NDCURV+IEXTRA)
     *                      =EXPEXP_NEUTRS(INUCLI,IEXPER)
C
                             L_CURV(1,NDCURV+IEXTRA)
     *                      =LABTEX
C
                             L_CURV(2,NDCURV+IEXTRA)
     *                      =LABTEX
C
                             NDPOIN(NDCURV+IEXTRA)=2
                             ITHICK(NDCURV+IEXTRA)=6
C
                             IF (ICOLOR(ITHEOR).EQ.44)
     *                           ICOLOR(NDCURV+IEXTRA)=71
C
                             IF (ICOLOR(ITHEOR).EQ.53)
     *                          ICOLOR(NDCURV+IEXTRA)=72
C
                          END IF
C
                          IF ((EXPEXP_NEUTRS(INUCLI,IEXPER)
     *                   .LE.  Y_CURV(IPOINT,ITHEOR))
     *                   .AND.(EXPEXP_NEUTRS(INUCLI,IEXPER)
     *                   .GT.  Y_CURV(IPOINT+1,ITHEOR)))
     *                    THEN
C
                             IEXTRA=IEXTRA+1
C
                             IF (IPOINT.EQ.1) THEN
                                 X_CURV(1,NDCURV+IEXTRA)
     *                          =X_CURV(IPOINT,ITHEOR)
                             ELSE
                                 X_CURV(1,NDCURV+IEXTRA)
     *                          =X_CURV(IPOINT-1,ITHEOR)
                             END IF
C
                             X_CURV(2,NDCURV+IEXTRA)
     *                      =X_CURV(IPOINT+1,ITHEOR)
C
                             Y_CURV(1,NDCURV+IEXTRA)
     *                      =EXPEXP_NEUTRS(INUCLI,IEXPER)
C
                             Y_CURV(2,NDCURV+IEXTRA)
     *                      =EXPEXP_NEUTRS(INUCLI,IEXPER)
C
                             L_CURV(1,NDCURV+IEXTRA)
     *                      =LABTEX
C
                             L_CURV(2,NDCURV+IEXTRA)
     *                      =LABTEX
C
                             NDPOIN(NDCURV+IEXTRA)=2
                             ITHICK(NDCURV+IEXTRA)=6
C
                             IF (ICOLOR(ITHEOR).EQ.44)
     *                           ICOLOR(NDCURV+IEXTRA)=71
C
                             IF (ICOLOR(ITHEOR).EQ.53)
     *                           ICOLOR(NDCURV+IEXTRA)=72
C
                          END IF
C
                       END DO !IPOINT=1,NDPOIN(ITHEOR)-1
C
                   END IF
                END DO
             END DO
C
             IF (IEXTRA.NE.LEVEXP_NEUTRS(INUCLI)) THEN
                 WRITE(0,'(''IEXTRA= '',I4,''LEVEXP= '',I4)')IEXTRA,
     *                                         LEVEXP_NEUTRS(INUCLI)
CID                 STOP 'IEXTRA.NE.LEVEXP_NEUTRS(INUCLI)'
             END IF
C
             NDCURV=NDCURV+IEXTRA   !LEVEXP_NEUTRS(INUCLI)
C
             ISOSPI=0
             IZ_FIX=NUMB_Z(INUCLI)
             IN_FIX=NUMB_N(INUCLI)
C
             MAIN_T='Energy Level Parametric Dependence'
             XTITLE='\\boldmath'//TITLES_LATEXS(JPARAM)
             YTITLE='Single Particle Energies (MeV)'
C
             IF (LOGWRI.GT.0) 
     *           WRITE(LOGFIL,'(9X,''Entering SPENER_PLOTIN '',
     *                                         ''for neutrons'')')
C
             CALL SPENER_PLOTIN(NDCURV,NDPOIN,X_CURV,Y_CURV,L_CURV,
     *                          MAIN_T,XTITLE,YTITLE,ICOLOR,ITHICK,
     *                          INUCLI,ISOSPI,IZ_FIX,IN_FIX,PARNAM,
     *                                 JPARAM,PARPOT_PRINTI,RMSVAL)
C
         END IF !ITAKNU(INUCLI).EQ.1
      END DO !INUCLI
C
C=======================================================================
C
      IF (ICOUNT_OFPARS.EQ.0) GO TO 2 ! ==>> NO Minimization required
C                                               => we jump to the end
C
C=======================================================================
C
   1  CONTINUE
C
C=======================================================================
C
C     MINIMIZATION - PROTONS / NEUTRONS
C
      IF (LOGWRI.GT.0) 
     *    WRITE(LOGFIL,'(9x,''Minimization option'',/)')
C
      JPARAM=INDEXI
C
      NCOUNT_OFMESH=0
      NTOTAL_OFMESH=MAXMSH
C
      DO INDEX1=1,MAXMSH
C
         IF (LOGWRI.GT.0) THEN
             WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *                       ''#  INDEX1= '',I6,T80,''#'',/,
     *                       ''#'',T80,''#'',/,80(''#''))')INDEX1
         END IF
C
         XINITS(JPARAM)=XMIN_I(JPARAM)+(INDEX1-1)*STPMSH(JPARAM)
         PARPOT(JPARAM)=XINITS(JPARAM)
C
         NCOUNT_OFMESH=NCOUNT_OFMESH+1
C
         CALL LMMESH(NEWSED,ARGMNT,I_SEED,LDRAND,LEVNUM,
     *               NTOTAL_OFMESH,NCOUNT_OFMESH,TITMSH,
     *               ICMESH,ICOUNT_OFPARS,CHITOT_MINAUX,
     *                      CHISQU_PROAUX,CHISQU_NEUAUX,
     *                             PARPOT_PRINTI,NDLAST)
C
C        Updating the parameter vector        
C
         DO KPARAM=1,NDPARS
            PARPOT(KPARAM)=PARPOT_PRINTI(KPARAM,NCOUNT_OFMESH)
         END DO
C_______________________________________________________________________
C
C        Once we have the vector of parameters, we enter to WS_RUN
C        to calculate the S. P. Energy Levels that will be plotted
C
         WRITE(NOUTPT,'(/,''Entering to the final calculation'',/)')
C
         DO INUCLI=1,LDNUCL
CID            IF (ITAKNU(INUCLI).EQ.1) THEN
C
                IZ_FIX=NUMB_Z(INUCLI)
                IN_FIX=NUMB_N(INUCLI)
C
                IF (LOGWRI.GT.4) THEN
                    WRITE(LOGFIL,'(12X,''Entering WS_RUN from '',
     *                                 ''SPENER_OFPARA '',
     *                                 ''INUCLI='',I2)') INUCLI
                END IF
C
                I_MODE=0
                I_FLAG=1
C
                CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,
     *                      I_FLAG,CHISQU_PROTON,CHISQU_NEUTRS)
C
C               Storing the values of the levels for each nucleus 
C               for the plotting output (depending on the reference,
C                                                         see below)
C
                NDCURV_PROTON=LEVTHE_PROTON
                NDCURV_NEUTRS=LEVTHE_NEUTRS
C
                RMSVAL_PROTON(INDEX1,INUCLI)=SQRT(CHIWEI_PROTON)
                RMSVAL_NEUTRS(INDEX1,INUCLI)=SQRT(CHIWEI_NEUTRS)
C
C               Storing the reference order of the levels for protons
C
                IF (INDEX1.EQ.1) THEN
                    DO IREFER=1,NDCURV_PROTON
                       LABREF_PROTON(IREFER)=LABTHE_PROTON(IREFER)
                    END DO
                END IF
C
                DO ICURVE=1,NDCURV_PROTON
C
                   X_CURV_AUXPRO(INDEX1,ICURVE,INUCLI)=XINITS(JPARAM)
C
                   DO ITHEOR=1,NDCURV_PROTON
                      IF (LABTHE_PROTON(ITHEOR)
     *               .EQ. LABREF_PROTON(ICURVE))THEN
C
                          Y_CURV_AUXPRO(INDEX1,ICURVE,INUCLI)
     *                   =ENETHE_PROTON(ITHEOR)
C
                          LABTHE=LABTHE_PROTON(ITHEOR)
                          CALL LATEXS_LABELS(LABTHE,LABTEX)
                          L_CURV_AUXPRO(INDEX1,ICURVE,INUCLI)=LABTEX
C
                          LQNUMB=LWSSPH_PROTON(ITHEOR)
                          LPARIT=(-1)**LQNUMB
C
                          IF (LPARIT.EQ.+1) 
     *                        ICOLOR_AUXPRO(ICURVE,INUCLI)=44
C
                          IF (LPARIT.EQ.-1) 
     *                        ICOLOR_AUXPRO(ICURVE,INUCLI)=53
C
                          ITHICK_AUXPRO(ICURVE,INUCLI)=4
C
                      END IF
                   END DO
C                   
                END DO !ICURVE
C
                DO I=1,NDCURV_PROTON
                   NDPOIN_PROTON(I)=MAXMSH
                END DO
C
C               the same for neutrons
C
                IF (INDEX1.EQ.1) THEN
                    DO IREFER=1,NDCURV_NEUTRS
                       LABREF_NEUTRS(IREFER)=LABTHE_NEUTRS(IREFER)
                    END DO
                END IF
C
                DO ICURVE=1,NDCURV_NEUTRS
C
                   X_CURV_AUXNEU(INDEX1,ICURVE,INUCLI)=XINITS(JPARAM)
C
                   DO ITHEOR=1,NDCURV_NEUTRS
                      IF (LABTHE_NEUTRS(ITHEOR)
     *               .EQ. LABREF_NEUTRS(ICURVE))THEN
C
                          Y_CURV_AUXNEU(INDEX1,ICURVE,INUCLI)
     *                   =ENETHE_NEUTRS(ITHEOR)
C
                          LABTHE=LABTHE_NEUTRS(ITHEOR)
                          CALL LATEXS_LABELS(LABTHE,LABTEX)
                          L_CURV_AUXNEU(INDEX1,ICURVE,INUCLI)=LABTEX
C
                          LQNUMB=LWSSPH_NEUTRS(ITHEOR)
                          LPARIT=(-1)**LQNUMB
C
                          IF (LPARIT.EQ.+1)
     *                        ICOLOR_AUXNEU(ICURVE,INUCLI)=44
C
                          IF (LPARIT.EQ.-1)
     *                        ICOLOR_AUXNEU(ICURVE,INUCLI)=53
C
                          ITHICK_AUXNEU(ICURVE,INUCLI)=4
C
                      END IF
                   END DO
C
                END DO !ICURVE
C
                DO I=1,NDCURV_NEUTRS
                   NDPOIN_NEUTRS(I)=MAXMSH
                END DO
C
CID             END IF !ITAKNU(INUCLI).EQ.1
         END DO !INUCLI
C
      END DO !INDEX1
C
C=======================================================================
C
C     PRINTING PROTONS
C
      IF (IPRINT_PROTON.EQ.1) THEN
          CONTINUE
      ELSE
          GO TO 14
      END IF
C
      DO INUCLI=1,LDNUCL
CID         IF (ITAKNU(INUCLI).EQ.1) THEN
C
C            Looking the correspondance with the experiment
C
             NDCURV=NDCURV_PROTON
C
             IEXTRA=0
             DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                DO ITHEOR=1,NDCURV
C
                   LABEXP=LABEXP_PROTON(INUCLI,IEXPER)
                   CALL LATEXS_LABELS(LABEXP,LABTEX)
C
                   IF (LABTEX.EQ.L_CURV_AUXPRO(1,ITHEOR,INUCLI)) THEN
C
                       DO IPOINT=1,NDPOIN_PROTON(ITHEOR)-1
C
                          IF ((EXPEXP_PROTON(INUCLI,IEXPER)
     *                   .GE.  Y_CURV_AUXPRO(IPOINT,ITHEOR,INUCLI))
     *                   .AND.(EXPEXP_PROTON(INUCLI,IEXPER)
     *                   .LT.  Y_CURV_AUXPRO(IPOINT+1,ITHEOR,INUCLI)))
     *                    THEN
C
                             IEXTRA=IEXTRA+1
C
                             IF (IPOINT.EQ.1) THEN
                                 X_CURV_AUXPRO(1,NDCURV+IEXTRA,INUCLI)
     *                          =X_CURV_AUXPRO(IPOINT,ITHEOR,INUCLI)
                             ELSE
                                 X_CURV_AUXPRO(1,NDCURV+IEXTRA,INUCLI)
     *                          =X_CURV_AUXPRO(IPOINT-1,ITHEOR,INUCLI)
                             END IF
C
                             X_CURV_AUXPRO(2,NDCURV+IEXTRA,INUCLI)
     *                      =X_CURV_AUXPRO(IPOINT+1,ITHEOR,INUCLI)
C
                             Y_CURV_AUXPRO(1,NDCURV+IEXTRA,INUCLI)
     *                      =EXPEXP_PROTON(INUCLI,IEXPER)
C
                             Y_CURV_AUXPRO(2,NDCURV+IEXTRA,INUCLI)
     *                      =EXPEXP_PROTON(INUCLI,IEXPER)
C
                             L_CURV_AUXPRO(1,NDCURV+IEXTRA,INUCLI)
     *                      =LABTEX
C
                             L_CURV_AUXPRO(2,NDCURV+IEXTRA,INUCLI)
     *                      =LABTEX
C
                             NDPOIN_PROTON(NDCURV+IEXTRA)=2
                             ITHICK_AUXPRO(NDCURV+IEXTRA,INUCLI)=6
C
                             IF (ICOLOR_AUXPRO(ITHEOR,INUCLI).EQ.44)
     *                           ICOLOR_AUXPRO(NDCURV+IEXTRA,INUCLI)=71
C
                             IF (ICOLOR_AUXPRO(ITHEOR,INUCLI).EQ.53)
     *                          ICOLOR_AUXPRO(NDCURV+IEXTRA,INUCLI)=72
C
                          END IF
C
                          IF ((EXPEXP_PROTON(INUCLI,IEXPER)
     *                   .LE.  Y_CURV_AUXPRO(IPOINT,ITHEOR,INUCLI))
     *                   .AND.(EXPEXP_PROTON(INUCLI,IEXPER)
     *                   .GT.  Y_CURV_AUXPRO(IPOINT+1,ITHEOR,INUCLI)))
     *                    THEN
C
                             IEXTRA=IEXTRA+1
C
                             IF (IPOINT.EQ.1) THEN
                                 X_CURV_AUXPRO(1,NDCURV+IEXTRA,INUCLI)
     *                          =X_CURV_AUXPRO(IPOINT,ITHEOR,INUCLI)
                             ELSE
                                 X_CURV_AUXPRO(1,NDCURV+IEXTRA,INUCLI)
     *                          =X_CURV_AUXPRO(IPOINT-1,ITHEOR,INUCLI)
                             END IF
C
                             X_CURV_AUXPRO(2,NDCURV+IEXTRA,INUCLI)
     *                      =X_CURV_AUXPRO(IPOINT+1,ITHEOR,INUCLI)
C
                             Y_CURV_AUXPRO(1,NDCURV+IEXTRA,INUCLI)
     *                      =EXPEXP_PROTON(INUCLI,IEXPER)
C
                             Y_CURV_AUXPRO(2,NDCURV+IEXTRA,INUCLI)
     *                      =EXPEXP_PROTON(INUCLI,IEXPER)
C
                             L_CURV_AUXPRO(1,NDCURV+IEXTRA,INUCLI)
     *                      =LABTEX
C
                             L_CURV_AUXPRO(2,NDCURV+IEXTRA,INUCLI)
     *                      =LABTEX
C
                             NDPOIN_PROTON(NDCURV+IEXTRA)=2
                             ITHICK_AUXPRO(NDCURV+IEXTRA,INUCLI)=6
C
                             IF (ICOLOR_AUXPRO(ITHEOR,INUCLI).EQ.44)
     *                           ICOLOR_AUXPRO(NDCURV+IEXTRA,INUCLI)=71
C
                             IF (ICOLOR_AUXPRO(ITHEOR,INUCLI).EQ.53)
     *                          ICOLOR_AUXPRO(NDCURV+IEXTRA,INUCLI)=72
C
                          END IF
C
                       END DO !IPOINT=1,NDPOIN(ITHEOR)-1
C
                   END IF
C
                END DO
             END DO
C
             IF (IEXTRA.NE.LEVEXP_PROTON(INUCLI)) THEN
                 WRITE(0,'(''IEXTRA= '',I4,''LEVEXP_PROTON= '',I4)')
     *                                IEXTRA,LEVEXP_PROTON(INUCLI)
CID                 STOP 'IEXTRA.NE.LEVEXP_PROTON(INUCLI)'
             END IF
C
             NDCURV=NDCURV+IEXTRA   !LEVEXP_PROTON(INUCLI)
C_______________________________________________________________________
C
C            And now, printing the results for each nucleus
C
             DO ICURVE=1,NDCURV
                DO IPOINT=1,NDPOIN_PROTON(ICURVE)
C
                   X_CURV(IPOINT,ICURVE)
     *            =X_CURV_AUXPRO(IPOINT,ICURVE,INUCLI)
C
                   Y_CURV(IPOINT,ICURVE)
     *            =Y_CURV_AUXPRO(IPOINT,ICURVE,INUCLI)
C
                   L_CURV(IPOINT,ICURVE)
     *            =L_CURV_AUXPRO(IPOINT,ICURVE,INUCLI)
C
                END DO
C
                ICOLOR(ICURVE)=ICOLOR_AUXPRO(ICURVE,INUCLI)
                ITHICK(ICURVE)=ITHICK_AUXPRO(ICURVE,INUCLI)
C
             END DO
C
             ISOSPI=1
             IZ_FIX=NUMB_Z(INUCLI)
             IN_FIX=NUMB_N(INUCLI)
C
             MAIN_T='Energy Level Parametric Dependence'
             XTITLE='\\boldmath'//TITLES_LATEXS(JPARAM)
             YTITLE='Single Particle Energies (MeV)'
C
             CALL SPENER_PLOTIN(NDCURV,NDPOIN_PROTON,X_CURV,Y_CURV,
     *                          L_CURV,MAIN_T,XTITLE,YTITLE,ICOLOR,
     *                          ITHICK,INUCLI,ISOSPI,IZ_FIX,IN_FIX,
     *                                 PARNAM,JPARAM,PARPOT_PRINTI,
     *                                               RMSVAL_PROTON)
C
CID         END IF
      END DO
C
C=======================================================================
C
C     PRINTING NEUTRONS
C
  14  CONTINUE
C
      IF (IPRINT_NEUTRS.EQ.1) THEN
          CONTINUE
      ELSE
          GO TO 2
      END IF
C
      DO INUCLI=1,LDNUCL
CID         IF (ITAKNU(INUCLI).EQ.1) THEN
C
C            Looking the correspondance with the experiment
C
             NDCURV=NDCURV_NEUTRS
C
             IEXTRA=0
             DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                DO ITHEOR=1,NDCURV
C
                   LABEXP=LABEXP_NEUTRS(INUCLI,IEXPER)
                   CALL LATEXS_LABELS(LABEXP,LABTEX)
C
                   IF (LABTEX.EQ.L_CURV_AUXNEU(1,ITHEOR,INUCLI)) THEN
C
                       DO IPOINT=1,NDPOIN_NEUTRS(ITHEOR)-1
C
                          IF ((EXPEXP_NEUTRS(INUCLI,IEXPER)
     *                   .GE.  Y_CURV_AUXNEU(IPOINT,ITHEOR,INUCLI))
     *                   .AND.(EXPEXP_NEUTRS(INUCLI,IEXPER)
     *                   .LT.  Y_CURV_AUXNEU(IPOINT+1,ITHEOR,INUCLI)))
     *                    THEN
C
                             IEXTRA=IEXTRA+1
C
                             IF (IPOINT.EQ.1) THEN
                                 X_CURV_AUXNEU(1,NDCURV+IEXTRA,INUCLI)
     *                          =X_CURV_AUXNEU(IPOINT,ITHEOR,INUCLI)
                             ELSE
                                 X_CURV_AUXNEU(1,NDCURV+IEXTRA,INUCLI)
     *                          =X_CURV_AUXNEU(IPOINT-1,ITHEOR,INUCLI)
                             END IF
C
                             X_CURV_AUXNEU(2,NDCURV+IEXTRA,INUCLI)
     *                      =X_CURV_AUXNEU(IPOINT+1,ITHEOR,INUCLI)
C
                             Y_CURV_AUXNEU(1,NDCURV+IEXTRA,INUCLI)
     *                      =EXPEXP_NEUTRS(INUCLI,IEXPER)
C
                             Y_CURV_AUXNEU(2,NDCURV+IEXTRA,INUCLI)
     *                      =EXPEXP_NEUTRS(INUCLI,IEXPER)
C
                             L_CURV_AUXNEU(1,NDCURV+IEXTRA,INUCLI)
     *                      =LABTEX
C
                             L_CURV_AUXNEU(2,NDCURV+IEXTRA,INUCLI)
     *                      =LABTEX
C
                             NDPOIN(NDCURV+IEXTRA)=2
                             ITHICK_AUXNEU(NDCURV+IEXTRA,INUCLI)=6
C
                             IF (ICOLOR_AUXNEU(ITHEOR,INUCLI).EQ.44)
     *                           ICOLOR_AUXNEU(NDCURV+IEXTRA,INUCLI)=71
C
                             IF (ICOLOR_AUXNEU(ITHEOR,INUCLI).EQ.53)
     *                          ICOLOR_AUXNEU(NDCURV+IEXTRA,INUCLI)=72
C
                          END IF
C
                          IF ((EXPEXP_NEUTRS(INUCLI,IEXPER)
     *                   .LE.  Y_CURV_AUXNEU(IPOINT,ITHEOR,INUCLI))
     *                   .AND.(EXPEXP_NEUTRS(INUCLI,IEXPER)
     *                   .GT.  Y_CURV_AUXNEU(IPOINT+1,ITHEOR,INUCLI)))
     *                    THEN
C
                             IEXTRA=IEXTRA+1
C
                             IF (IPOINT.EQ.1) THEN
                                 X_CURV_AUXNEU(1,NDCURV+IEXTRA,INUCLI)
     *                          =X_CURV_AUXNEU(IPOINT,ITHEOR,INUCLI)
                             ELSE
                                 X_CURV_AUXNEU(1,NDCURV+IEXTRA,INUCLI)
     *                          =X_CURV_AUXNEU(IPOINT-1,ITHEOR,INUCLI)
                             END IF
C
                             X_CURV_AUXNEU(2,NDCURV+IEXTRA,INUCLI)
     *                      =X_CURV_AUXNEU(IPOINT+1,ITHEOR,INUCLI)
C
                             Y_CURV_AUXNEU(1,NDCURV+IEXTRA,INUCLI)
     *                      =EXPEXP_NEUTRS(INUCLI,IEXPER)
C
                             Y_CURV_AUXNEU(2,NDCURV+IEXTRA,INUCLI)
     *                      =EXPEXP_NEUTRS(INUCLI,IEXPER)
C
                             L_CURV_AUXNEU(1,NDCURV+IEXTRA,INUCLI)
     *                      =LABTEX
C
                             L_CURV_AUXNEU(2,NDCURV+IEXTRA,INUCLI)
     *                      =LABTEX
C
                             NDPOIN_NEUTRS(NDCURV+IEXTRA)=2
                             ITHICK_AUXNEU(NDCURV+IEXTRA,INUCLI)=6
C
                             IF (ICOLOR_AUXNEU(ITHEOR,INUCLI).EQ.44)
     *                           ICOLOR_AUXNEU(NDCURV+IEXTRA,INUCLI)=71
C
                             IF (ICOLOR_AUXNEU(ITHEOR,INUCLI).EQ.53)
     *                          ICOLOR_AUXNEU(NDCURV+IEXTRA,INUCLI)=72
C
                          END IF
C
                       END DO !IPOINT=1,NDPOIN(ITHEOR)-1
C
                   END IF
C
                END DO
             END DO
C
             IF (IEXTRA.NE.LEVEXP_NEUTRS(INUCLI)) THEN
                 WRITE(0,'(''IEXTRA= '',I4,''LEVEXP_NEUTRS= '',I4)')
     *                                IEXTRA,LEVEXP_NEUTRS(INUCLI)
CID                 STOP 'IEXTRA.NE.LEVEXP_NEUTRS(INUCLI)'
             END IF
C
             NDCURV=NDCURV+IEXTRA   !LEVEXP_NEUTRS(INUCLI)
C_______________________________________________________________________
C
C            And now, printing the results for each nucleus
C
             DO ICURVE=1,NDCURV
                DO IPOINT=1,NDPOIN_NEUTRS(ICURVE)
C
                   X_CURV(IPOINT,ICURVE)
     *            =X_CURV_AUXNEU(IPOINT,ICURVE,INUCLI)
C
                   Y_CURV(IPOINT,ICURVE)
     *            =Y_CURV_AUXNEU(IPOINT,ICURVE,INUCLI)
C
                   L_CURV(IPOINT,ICURVE)
     *            =L_CURV_AUXNEU(IPOINT,ICURVE,INUCLI)
C
                END DO
C
                ICOLOR(ICURVE)=ICOLOR_AUXNEU(ICURVE,INUCLI)
                ITHICK(ICURVE)=ITHICK_AUXNEU(ICURVE,INUCLI)
C
             END DO
C
             ISOSPI=0
             IZ_FIX=NUMB_Z(INUCLI)
             IN_FIX=NUMB_N(INUCLI)
C
             MAIN_T='Energy Level Parametric Dependence'
             XTITLE='\\boldmath'//TITLES_LATEXS(JPARAM)
             YTITLE='Single Particle Energies (MeV)'
C
             CALL SPENER_PLOTIN(NDCURV,NDPOIN_NEUTRS,X_CURV,Y_CURV,
     *                          L_CURV,MAIN_T,XTITLE,YTITLE,ICOLOR,
     *                          ITHICK,INUCLI,ISOSPI,IZ_FIX,IN_FIX,
     *                                 PARNAM,JPARAM,PARPOT_PRINTI,
     *                                               RMSVAL_NEUTRS)
C
CID         END IF
      END DO
C
C=======================================================================
C
   2  CONTINUE
C
C=======================================================================
C
      WRITE(LOGFIL,'(/,''Exiting SPENER_OFPARA'',/)')
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE SPENER_PLOTIN(NDCURV,NDPOIN,X_CURV,Y_CURV,L_CURV,
     *                         MAIN_T,XTITLE,YTITLE,ICOLOR,ITHICK,
     *                         INUCLI,ISOSPI,IZ_FIX,IN_FIX,PARNAM,
     *                         JPARAM,PARPOT_PRINTI,RMSVAL)
C
      INCLUDE 'MATDIM/NDMESH.f'
      INCLUDE 'MATDIM/NDSPEC.f'
      INCLUDE 'MATDIM/NDPARS.f'
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDCOLO.f'
      INCLUDE 'MATDIM/NDTITL.f'
C
      PARAMETER
     *         (NDMES2=NDMESH*NDMESH)
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6,VERSIO*3
      CHARACTER
     *          FILNAM*256,L_CURV*100,NUCNAM*06,TITLES*12,
     *          ISONAM*002,TEXLAM*020,TITPAR*13,FITNUC*02,
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010
      CHARACTER
     *          MAIN_T*256,XTITLE*256,YTITLE*256
      CHARACTER
     *          FILNAM_IFITED*14,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*02,PARNAM*8
      CHARACTER
     *          AUXTX1*30,AUXTX2*30,AUXTX3*30,AUXTX4*30,
     *          AUXTX5*30,AUXTX6*30
C
      DIMENSION
     *          NDPOIN(1:NDSPEC),
     *          X_CURV(1:NDMESH,1:NDSPEC),
     *          Y_CURV(1:NDMESH,1:NDSPEC),
     *          L_CURV(1:NDMESH,1:NDSPEC),
     *          ICOLOR(1:NDSPEC),
     *          ITHICK(1:NDSPEC)
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL)
      DIMENSION
     *          PARPOT_PRINTI(1:NDPARS,1:NDMES2),
     *          RMSVAL(1:NDSPEC,1:NDNUCL)
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /PARCOR/ IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /VERSIN/ VERSIO
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' /
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(/,''Entering SPENER_PLOTIN'')')
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(''INUCLI= '',I4)')INUCLI
      IF (LOGWRI.GT.0) 
     *    WRITE(LOGFIL,'(/,'' IZ= '',I3,'' IN= '',I3,/)') 
     *                  NUMB_Z(INUCLI),NUMB_N(INUCLI)
C
C=======================================================================
C
      WRITE(0,'(/,''Entering SPENER_PLOTIN'')')
      WRITE(0,'(''INUCLI= '',I4,'' ISOSPI= '',I2)')INUCLI,ISOSPI
      WRITE(0,'(/,'' IZ= '',I3,'' IN= '',I3,/)')
     *                  NUMB_Z(INUCLI),NUMB_N(INUCLI)
C
C=======================================================================
C
      YMINIM=+1.0E+10
      YMAXIM=-1.0E+10
      
      DO I_CURV=1,NDCURV
         DO IPOINT=1,NDPOIN(I_CURV)
            IF (Y_CURV(IPOINT,I_CURV).LT.YMINIM) THEN
                YMINIM=Y_CURV(IPOINT,I_CURV)
            END IF
            IF (Y_CURV(IPOINT,I_CURV).GT.YMAXIM) THEN
                YMAXIM=Y_CURV(IPOINT,I_CURV)
            END IF
         END DO
      END DO
C
C=======================================================================
C
      XMINIM=+1.0E+10
      XMAXIM=-1.0E+10
C
      DO I_CURV=1,NDCURV
         DO IPOINT=1,NDPOIN(I_CURV)
            IF (X_CURV(IPOINT,I_CURV).LT.XMINIM) THEN
                XMINIM=X_CURV(IPOINT,I_CURV)
            END IF
            IF (X_CURV(IPOINT,I_CURV).GT.XMAXIM) THEN
                XMAXIM=X_CURV(IPOINT,I_CURV)
            END IF
         END DO
      END DO
C
C=======================================================================
C
      NRESUL=60
C      
      IF (ISOSPI.EQ.1) ISONAM='-P'
      IF (ISOSPI.EQ.0) ISONAM='-N'
C
C=======================================================================
C 
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
C
      I1=3*KACTIV
C
      WRITE(FILNAM_NUCFIT,'(''_'',<NUCACT>(A2,''-''))')
     *                      (FITNUC_AUXILI(I),I=1,NUCACT)
C
C=======================================================================
C
      WRITE(NUCNAM,'(A6)') NUCSYM(INUCLI)
C
      J1=1
      J2=6
      IF (NUCNAM(1:1).EQ.' ') J1=2
      IF (NUCNAM(2:2).EQ.' ') J1=3
      IF (NUCNAM(3:3).EQ.' ') J1=4
C
      WRITE(0,*)INUCLI,NUCNAM(J1:J2)
C
C=======================================================================
C
      IF (IFDENS.EQ.0) THEN
          WRITE(FILNAM,'(''SPECurves/IFDENS-0/SPECur_'',A,A2,A,''_'',A8,
     *                  ''_IFDENS-'',I1,''_IFTENS-'',I1,''_IF-PAI-'',I1,
     *                  ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                  ''_IF-RHO-'',I1,''_IFDEEP-'',I1,
     *                  ''_IFPRON-'',I1,
     *                  ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                  ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                  ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                                   ''_'',A3,''.dat'')')
     *
     *               NUCNAM(J1:J2),ISONAM,FILNAM_NUCFIT(01:I1),PARNAM,
     *               IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,IF_RHO,
     *               IFDEEP,IFPRON,IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,
     *                                                  IFK_AS,VERSIO
      END IF
C
      WRITE(0,*)FILNAM
C
C=======================================================================
C
      IF (IFDENS.EQ.1 .AND. IFTENS.EQ.0) THEN
C
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                            IFPAR1,IFPAR2,IFPAR3,IFPAR4
C
          WRITE(FILNAM,'(''SPECurves/IFDENS-1_IFTENS-0/SPECur_'',
     *                                          A,A2,A,''_'',A8,
     *                  ''_IFDENS-'',I1,''_IFTENS-'',I1,''_IF-PAI-'',I1,
     *                  ''_IF-RAD-'',I1,''_IF-ORD-'',I1,''_IF-RHO-'',I1,
     *                  ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                  ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                  ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                  ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                                          A15,''_'',A3,''.dat'')')
     *
     *               NUCNAM(J1:J2),ISONAM,FILNAM_NUCFIT(01:I1),PARNAM,
     *               IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,IF_RHO,
     *               IFDEEP,IFPRON,IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,
     *                                           IFK_AS,TEXLAM,VERSIO
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.1 .AND. IFTENS.EQ.1) THEN
C
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                            IFPAR1,IFPAR2,IFPAR3,IFPAR4
C
          WRITE(FILNAM,'(''SPECurves/IFDENS-1_IFTENS-1/SPECur_'',
     *                                          A,A2,A,''_'',A8,
     *                  ''_IFDENS-'',I1,''_IFTENS-'',I1,''_IF-PAI-'',I1,
     *                  ''_ICENTT-'',I1,''_ISORBT-'',I1,''_ITENSR-'',I1,
     *                  ''_IF-RAD-'',I1,''_IF-ORD-'',I1,''_IF-RHO-'',I1,
     *                  ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                  ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                  ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                  ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                      A15,''_'',A3,''.dat'')')
     *
     *               NUCNAM(J1:J2),ISONAM,FILNAM_NUCFIT(01:I1),PARNAM,
     *               IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *               IF_RAD,IF_INV,IF_RHO,IFDEEP,IFPRON,
     *               IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                                           TEXLAM,VERSIO
      END IF
C
C=======================================================================
C
      OPEN(NRESUL,FILE=FILNAM,STATUS='UNKNOWN')
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<CODEVERSIO>> VERSIO'')')
C
      WRITE(NRESUL,'(16X,A3)') VERSIO
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<MAIN_TITLE>>'')')
C      
      WRITE(NRESUL,'(15X,A,/)') MAIN_T
C
C=======================================================================
C     
      WRITE(NRESUL,'(''<<NUCLIDINFO>>'',1X,''NUMB_Z'',2X,''NUMB_N'')')
C
      WRITE(NRESUL,'(15X,I3,6X,I3,/)') IZ_FIX,IN_FIX
C
      A_MASS=IZ_FIX+IN_FIX
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<NoNUCACTIV>>'',1X,''NUCACT'')')
C      
      WRITE(NRESUL,'(15X,I3,/)') NUCACT
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<EXPER_FILE>>'',1X,''IFDEEP'',2X
     *                                     ''IFPRON'')')
      
      WRITE(NRESUL,'(15X,2(I3,6X),/)') IFDEEP,IFPRON
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<POTEN_INFO>>'',1X,''ISOSPI'',2X,''IFDENS'',
     *                                  2X,''IFTENS'',2X,''IF_PAI'')')
C      
      WRITE(NRESUL,'(15X,4(I3,5X),/)') ISOSPI,IFDENS,IFTENS,IF_PAI
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<TENSR_INFO>>'',1X,''ICENTT'',2X
     *                                     ''ISORBT'',2X,''ITENSR'')')
C      
      WRITE(NRESUL,'(15X,3(I3,5X),/)') ICENTT,ISORBT,ITENSR
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<TAKEN_CHI2>> IF_SPE  IF_RAD  IF_GAP  '',
     *               ''IF_FER  IF_DEN  IF_RHO  IF_INV'')')
      WRITE(NRESUL,'(15X,7(I3,5X),/)')IF_SPE,IF_RAD,IF_GAP,IF_FER,
     *                                       IF_DEN,IF_RHO,IF_INV
C
C=======================================================================
C
C     IFTAKE .EQ. -1: parameter eliminated via parametric correlation
C     IFTAKE .EQ. +1: parameter entering to the minimization
C     IFTAKE .EQ. +4: parameter considered constant but printed anyway
C
      INFTOP=0
      WRITE(NRESUL,'(''<<PARAM_INFO>> '',A8,$)')TITLES(JPARAM)(3:10)
      DO KPARAM=1,NDPARS
         IF (IFTAKE(KPARAM).EQ.-1 .OR. IFTAKE(KPARAM).EQ.1
     *  .OR. IFTAKE(KPARAM).EQ.4) THEN
             INFTOP=INFTOP+1
             WRITE(NRESUL,'(2X,A8,$)')TITLES(KPARAM)(3:10)
         END IF
      END DO
      WRITE(NRESUL,'()')
C
      WRITE(NRESUL,'(15X,I8,2X,I8)')NDPOIN(1),INFTOP
      DO I=1,NDPOIN(1)
         WRITE(NRESUL,'(15X,F8.4,$)')PARPOT_PRINTI(JPARAM,I)
         DO KPARAM=1,NDPARS
            IF (IFTAKE(KPARAM).EQ.-1 .OR. IFTAKE(KPARAM).EQ.1
     *     .OR. IFTAKE(KPARAM).EQ.4) THEN
                WRITE(NRESUL,'(2X,F8.4,$)')PARPOT_PRINTI(KPARAM,I)
            END IF
         END DO
         WRITE(NRESUL,'()')
      END DO
C
      WRITE(NRESUL,'()')
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<PARAM_TITL>>'',/,14X,'' '',$)')
      DO KPARAM=1,NDPARS
         IF (IFTAKE(KPARAM).EQ.-1 .OR. IFTAKE(KPARAM).EQ.1
     *  .OR. IFTAKE(KPARAM).EQ.4) THEN
             WRITE(NRESUL,'(A50,''  '',$)')TITLES_LATEXS(KPARAM)
         END IF
      END DO
      WRITE(NRESUL,'()')
C
      WRITE(NRESUL,'()')
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<RMS_VALUES>>'')')
      WRITE(NRESUL,'(15X,I6)')NDPOIN(1)
      DO I=1,NDPOIN(1)
         WRITE(NRESUL,'(15X,F8.4,2X,F8.4)')
     *         PARPOT_PRINTI(JPARAM,I),RMSVAL(I,INUCLI)
      END DO
C
C=======================================================================
C      
      WRITE(NRESUL,'(''<<XAXIS_TEXT>>'',/,15x,A,/)') XTITLE
C      
      WRITE(NRESUL,'(''<<YAXIS_TEXT>>'',/,15x,A,/)') YTITLE
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<SIDE_TEXTS>>'')')
C
      AUXTX1=' '
      AUXTX2=' '
      AUXTX3=' '
      AUXTX4=' '
      AUXTX5=' '
      AUXTX6=' '
C
      IF (IFDENS.EQ.1) AUXTX1='${\\rm DENS}\\,\\vert\\,$'
      IF (IFTENS.EQ.1) AUXTX2='${\\rm TENS}\\,\\vert\\,$'
      IF (IF_PAI.EQ.1) AUXTX3='${\\rm PAIR}\\,\\vert\\,$'
      IF (IF_RAD.EQ.1) AUXTX4='${\\rm RADI}\\,\\vert\\,$'
      IF (IFDEEP.EQ.1) AUXTX5='${\\rm DEEP}\\,\\vert\\,$'
      IF (IFPRON.EQ.1) AUXTX6='${\\rm PRON}\\,\\vert\\,$'
C
      WRITE(NRESUL,'(15X,''~~~Id:'',6A)')AUXTX1,AUXTX2,AUXTX3,AUXTX4,
     *                                   AUXTX5,AUXTX6
C
      WRITE(NRESUL,'(15X,''Fitted: '',$)')
      DO KNUCLI=1,LDNUCL
         IF (ITAKNU(KNUCLI).EQ.1) THEN
             WRITE(NRESUL,'(A10,'','',$)') NUCNAM_LATEXS(KNUCLI)
         END IF
      END DO
      WRITE(NRESUL,'()')
C
      WRITE(NRESUL,'(15X,''Fixed: '',$)')
      DO KPARAM=1,NDPARS
         IF (IFTAKE(KPARAM).EQ.4) THEN
             WRITE(NRESUL,'(A,'' $='',F10.2,''$, '',$)') 
     *             TITLES_LATEXS(KPARAM),PARPOT_PRINTI(KPARAM,1)
         END IF
      END DO
      WRITE(NRESUL,'()')
C
C=======================================================================
C     
      WRITE(NRESUL,'(/,15X,30(''=''),/)')
          
      WRITE(NRESUL,'(''<<X_AX_PARAM>> XMINIM_FIG  XMAXIM_FIG  '',
     *                   ''X_STEP_FIG'')')
          
      WRITE(NRESUL,'(15X,3(F10.2,2X),/)')XMINIM,XMAXIM,(XMAXIM-XMINIM)
     
      WRITE(NRESUL,'(''<<Y_AX_PARAM>> YMINIM_FIG  YMAXIM_FIG  '',
     *                   ''Y_STEP_FIG'')')
          
      WRITE(NRESUL,'(15X,3(F10.2,2X),/)')
     *                         YMINIM,YMAXIM,(YMAXIM-YMINIM)
     
      WRITE(NRESUL,'(15X,30(''=''),/)')
C
C=======================================================================
C
      I_COLM=0
      I_LEFT=1
      I_RIGH=1
C
      WRITE(NRESUL,'(''<<WHATLEGEND>>'',1X,''COLM_LABEL'',2X,
     *               ''LEFT_LABEL'',2X,''RIGH_LABEL'')')
      WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5)')I_COLM,I_LEFT,I_RIGH
C
C=======================================================================
C      
      IFBULL=0
      IFHIST=0
      IFOVER=0
      ISPLIT=0
C      
      WRITE(NRESUL,'(/,''<<NO_OF_CURV>>'',1X,''NUMB_CURVE'',2X,
     *                 ''IF_SPLITIN'',2X,''IF_BULLETS'',2X,
     *                 ''IF_HISTOGS'',2X,''IF_OVERFITING'')')
      WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5,7X,I5,7X,I5)')NDCURV,ISPLIT,
     *                                         IFBULL,IFHIST,IFOVER
C
C=======================================================================
C
      ISTYLE=0
      I_TYPE=3
C
      DO I_CURV=1,NDCURV
C
         WRITE(NRESUL,'(''<<>>'')')
         WRITE(NRESUL,'(''<<CURVE_'',I4.4,''>>'',1X,
     *                  ''THICK_LINE'',2X,''STYLE_LINE'',2X,
     *                  ''COLOR_LINE'',2X,''TYPE_POINT'')')I_CURV
         WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5,7X,I5)')ITHICK(I_CURV),
     *                                             ISTYLE,
     *                                             ICOLOR(I_CURV),
     *                                             I_TYPE
         WRITE(NRESUL,'(15X,''NUMB_POINT'',/,15X,I5)')NDPOIN(I_CURV)
C
         DO IPOINT=1,NDPOIN(I_CURV)
C
            WRITE(NRESUL,'(15X,F10.4,4X,E12.4,4X,A100)') 
     *                           X_CURV(IPOINT,I_CURV),
     *                           Y_CURV(IPOINT,I_CURV),
     *                           L_CURV(IPOINT,I_CURV)
C
         END DO
C
      END DO
C
C=======================================================================
C      
      WRITE(NRESUL,'(/,''<<GO_GETTHEM>>'',/)')
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE FITTIN_MONTEC(I_SEED,NEWSED)
C
      INCLUDE 'MATDIM/NDSPEC.f'
      INCLUDE 'MATDIM/NDPARS.f'
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDLEXP.f'
      INCLUDE 'MATDIM/NDIM_M.f'
      INCLUDE 'MATDIM/MAXFEV.f'
      INCLUDE 'MATDIM/NDLAST.f'
      INCLUDE 'MATDIM/NDBINS.f'
      INCLUDE 'MATDIM/NDMONT.f'
      INCLUDE 'MATDIM/NDCOLO.f'
      INCLUDE 'MATDIM/NDTITL.f'
C
      PARAMETER 
     *         (NDCURV=NDSPEC,LENGTH=256,INMODE=1,NPRINT=-1,ND_RMS=2)
C
      CHARACTER
     *          LABPRO_PSEUDO*6,LABNEU_PSEUDO*6,
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6,
     *          LABEXP_PROREA*6,LABEXP_NEUREA*6,
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6
      CHARACTER
     *          LABVEC_PROTON*6,LABVEC_NEUTRS*6,
     *          LABREF_PROTON*6,LABREF_NEUTRS*6
      CHARACTER
     *          INPSYM*6,NUCSYM*6,TYPCHI*6
      CHARACTER
     *          FILNAM*256,FILNAM_ENDING*13,
     *          LABTHE_PRINTG*06,TEXLAM*20,
     *          FILNA2*256,FITNUC*2,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*30,FILNA3*256,VERSIO*3
      CHARACTER
     *          TITLES*12,TITLES_LATEXS*50,NUCNAM_LATEXS*10,LABELS*100,
     *          PARPOT_UNITSS*40,XUNITS*40
      CHARACTER
     *          FILPAR*300,PARNAM*8,FILRMS*300,FILSPE*300
      CHARACTER
     *          HISTIT*256,HX_TIT*256,HY_TIT*256,LABTIT*100,
     *          LABTIT_PARPOT*100,LABTIT_PROTON*100,LABTIT_NEUTRS*100
      CHARACTER
     *          SPELAB*6,CDUMMY*6,LABTHE*6,LABTEX*11
C
      DIMENSION
     *          LABREF_PROTON(1:NDSPEC),
     *          LABREF_NEUTRS(1:NDSPEC)
      DIMENSION
     *          ARGPAR(1:NDPARS),
     *          ARGPAR_TITLES(1:NDPARS),
     *          ARGPAR_LATEXS(1:NDPARS)
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL)
      DIMENSION
     *          LABELS(1:NDBINS,1:NDCURV),
     *          XHISTO(1:NDBINS,1:NDCURV),
     *          XHISTO_MINIMS(1:NDCURV),
     *          XHISTO_MAXIMS(1:NDCURV)
      DIMENSION
     *          PARPOT_MAXIMA(1:NDPARS),
     *          PARPOT_MINIMA(1:NDPARS)
      DIMENSION
     *          SPELAB(1:NDSPEC)
      DIMENSION
     *          BINSIZ(1:NDCURV),
     *          YHISTO_UNNORM(1:NDBINS,1:NDCURV),
     *          YHISTO_INTEGR(1:NDBINS,1:NDCURV),
     *          YHISTO_MAXIMS(1:NDBINS,1:NDCURV)
      DIMENSION
     *          XHISTO_PRINTI(1:NDBINS,1:NDCURV),
     *          YHISTO_PRINTI(1:NDBINS,1:NDCURV)
      DIMENSION
     *          YEXPEC(1:NDCURV),
     *          ICOLOR_HISTOG(1:NDCURV)
      DIMENSION
     *          LABTIT(1:ND_RMS),
     *          LABTIT_PARPOT(1:NDPARS),
     *          LABTIT_PROTON(1:NDSPEC),
     *          LABTIT_NEUTRS(1:NDSPEC)
      DIMENSION
     *          VECTOR_RMSVAL(1:ND_RMS),
     *          VECTOR_PARPOT(1:NDPARS),
     *          VECTOR_ENEPRO(1:NDSPEC),
     *          VECTOR_ENENEU(1:NDSPEC)
C
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)    
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /VLIMIT/ VMISTR(1:NDPARS),
     *                VMIMIN(1:NDPARS),
     *                VMIMAX(1:NDPARS),
     *                VMISTP(1:NDPARS)
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /CHIGRD/ CHISQU_GRDNRM,
     *                CHISQU_GRADIE(1:NDPARS)
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
     *       /FEVALS/ IFUNCT_EVALUS
      COMMON
     *       /STOPAR/ EPSLAS,LDLAST
     *       /MASSIV/ IMASIV_PRODUC
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /DENSTR/ IFDENS
     *       /TENSOR/ IFTENS
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /PSEUDO_ZN_NUM/ IZ_PSE(1:NDNUCL),
     *                       IN_PSE(1:NDNUCL)
      COMMON
     *       /PSEUDO_LEVELS/ LEVNEU_PSEUDO(1:NDNUCL),
     *                       LEVPRO_PSEUDO(1:NDNUCL)
      COMMON
     *       /PSEUDO_PROTON/ ENEPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LABPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       SIGPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       IDEPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LEVTAK_PROTON(1:NDLEXP,1:NDNUCL)
      COMMON
     *       /PSEUDO_NEUTRS/ ENENEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LABNEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       SIGNEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       IDENEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LEVTAK_NEUTRS(1:NDLEXP,1:NDNUCL)
      COMMON
     *       /SIGEXP_PRONEU/ SIGEXP_PROTON(1:NDLEXP,1:NDNUCL),
     *                       SIGEXP_NEUTRS(1:NDLEXP,1:NDNUCL)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /REALEX_PROTON/ EXPEXP_PROREA(1:NDNUCL,1:NDLEXP),
     *                       LABEXP_PROREA(1:NDNUCL,1:NDLEXP),
     *                       IDEGEX_PROREA(1:NDNUCL,1:NDLEXP),
     *                       LEVEXP_PROREA(1:NDNUCL)
      COMMON
     *       /REALEX_NEUTRS/ EXPEXP_NEUREA(1:NDNUCL,1:NDLEXP),
     *                       LABEXP_NEUREA(1:NDNUCL,1:NDLEXP),
     *                       IDEGEX_NEUREA(1:NDNUCL,1:NDLEXP),
     *                       LEVEXP_NEUREA(1:NDNUCL)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)  
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS
      COMMON  
     *       /VERSIN/ VERSIO
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /PARUNI/ PARPOT_UNITSS(1:NDTITL)
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
      COMMON
     *       /PRINAL/ IMTALK
      COMMON
     *       /OCCREC/ N_ACTU_PROTON,N_CORR_PROTON,
     *                N_ACTU_NEUTRS,N_CORR_NEUTRS
C
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' /
C
C=======================================================================
C
C     This subroutine does the minimization of the \chi^2 using the 
C     pseudo-experimental levels. Using the Monte-Carlo techniques, 
C     we give to these levels and error, normally distributed with 
C     the \sigma of our choice.
C
C     The mean and the sigma values of the gaussian over which the 
C     random numbers are generated are read from the input file:
C
C                          ws15_pseudo-exper.d
C
C     They depend on the nucleus, particle and energy level.
C____________________
C
C     BIG WARNING:
C
C     Since we did not want to complicate the minimization subroutines
C     of the rest of our code, we redifine the variables EXPEXP with
C     the pseudo-experimental levels. Anyway, the real experimental
C     values are kept in someother vectors under the common blocks:
C
C                   /REALEX_PROTON/ and /REALEX_NEUTRS/
C
C=======================================================================
C
C     First, reading the pseudo-experimental levels
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(''Entering READIN_PSEUDO from '',
     *                                ''FITTIN_MONTEC'')')
      CALL READIN_PSEUDO
C
C=======================================================================
C
C     Here the 'dangerous' part: transforming the real experimental
C     results to the pseudo-experimental
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(/,''Entering EX_TO_PSEUDO from '',
     *                                  ''FITTIN_MONTEC'')')
      CALL EX_TO_PSEUDO
C
      LEVACT_PROTON=0
      LEVACT_NEUTRS=0
      DO INUCLI=1,LDNUCL
         IF (ITAKNU(INUCLI).EQ.1) THEN
             LEVACT_PROTON=LEVACT_PROTON+LEVEXP_PROTON(INUCLI)
             LEVACT_NEUTRS=LEVACT_NEUTRS+LEVEXP_NEUTRS(INUCLI)
             SIGACT_PROTON=SIGEXP_PROTON(1,INUCLI)
             SIGACT_NEUTRS=SIGEXP_NEUTRS(1,INUCLI)
         END IF
      END DO
C
C=======================================================================
C
C     Identifying the parameters over we are going to minimize, 
C     creating the logfiles and counting how many contributions
C     we want to have to the \chi^2
C
C=======================================================================
C
      IFUNCT_EVALUS=0
C
      IFIRST=1
      IFPROT=0
      IFNEUT=0
      IFBOTH=0
      IACTIV=0
C
      DO IPARAM=1,NDPARS ! Fixed as NDPARS=48
C
         IF (IFTAKE(IPARAM).EQ.1) THEN
C
             IACTIV=IACTIV+1
             ARGPAR(IACTIV)=VMISTR(IPARAM)
C  
             IF (IPARAM.LE.20 .AND. IFDENS.EQ.0) THEN
                 IFPROT=1
                 LEVACT=LEVACT_PROTON
                 SIGACT=SIGACT_PROTON
             END IF
C
             IF (IPARAM.GT.20 .AND. IFDENS.EQ.0) THEN
                 IFNEUT=1
                 LEVACT=LEVACT_NEUTRS
                 SIGACT=SIGACT_NEUTRS
             END IF
C
             IF (IPARAM.GE.51 .AND. IFDENS.EQ.0) THEN
                 IFPROT=0
                 IFNEUT=0
                 IFBOTH=1
                 LEVACT=LEVACT_NEUTRS+LEVACT_PROTON
                 SIGACT=SIGACT_PROTON !SIGACT_NEUTRS
             END IF
C
         END IF
C
      END DO
C_______________________________________________________________________
C
      IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1).AND.(IFPROT.EQ.1)) THEN
C  
           IFPROT=0
           IFNEUT=0
           IFBOTH=1
C
          WRITE(0,'(/,''ALERT in LMMINI!! Density is NOT activated'',1X,
     *                ''and IFNEUT and IFPROT are equal to 1 !!!!'',/)')
C
C          STOP 'Chose proton OR neutron parameters, stop FROM LMMINI'
C
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(/,9X,''Number of active parameters '',
     *                        ''IACTIV='',I2)') IACTIV
C
          IF (IFPROT.EQ.1) THEN
              WRITE(LOGFIL,'(9X,''Minimisation for protons'')')
          END IF
C
          IF (IFNEUT.EQ.1) THEN
              WRITE(LOGFIL,'(9X,''Minimisation for neutrons'')')
          END IF
C
          IF (IFBOTH.EQ.1) THEN
              WRITE(LOGFIL,'(9X,''Minimisation for protons '',
     *                          ''and neutrons'')')
          END IF
C
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) FILNAM_ENDING='P'
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) FILNAM_ENDING='N'
      IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) FILNAM_ENDING='B'
C
      IF (IFDENS.EQ.1) THEN
C
          LEVACT=LEVACT_NEUTRS+LEVACT_PROTON
          SIGACT=SIGACT_PROTON !SIGACT_NEUTRS
C              
          FILNAM_ENDING='B'
C              
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                               IFPAR1,IFPAR2,IFPAR3,IFPAR4
C          
      END IF
C
C=======================================================================
C 
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
      
      I1=3*KACTIV-1
      
      WRITE(FILNAM_NUCFIT,'(<NUCACT>(A2,''-''))')
     *                     (FITNUC_AUXILI(I),I=1,NUCACT)
C
C=======================================================================
C     
      IF (IFDENS.EQ.0) THEN
C      
          WRITE(FILNAM,'(''LogMonte/IFDENS-0/'',A,''_'',A1,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACT-'',I2.2,''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,''_'',A3)')
     *
     *                      FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_RAD,IF_INV,IF_RHO,
     *                      IFDEEP,IFPRON,IFK_VC,IFK_VS,IFK_RC,
     *                      IFK_RS,IFK_AC,IFK_AS,LEVACT,SIGACT,
     *                      LDMONT,VERSIO
C          
          IF (NUCACT.GT.1 .AND. NUCACT.LT.LDNUCL) THEN
C              
              WRITE(FILNA2,'(''LogMonte/IFDENS-0/'',A,''_'',
     *                                      A1,''_Energies'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IF-RHO-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LEVACT-'',I2.2,''_SIGMAS-'',F5.3,
     *                       ''_LDMONT-'',I5.5,''_'',A3)')
     * 
     *                          FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                          IFDENS,IFTENS,IF_RAD,IF_INV,IF_RHO,
     *                          IFDEEP,IFPRON,IFK_VC,IFK_VS,IFK_RC,
     *                          IFK_RS,IFK_AC,IFK_AS,LEVACT,SIGACT,
     *                          LDMONT,VERSIO
             
              WRITE(FILNA3,'(''LogMonte/IFDENS-0/'',A,''_'',
     *                                         A1,''_Radii'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IF-RHO-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LEVACT-'',I2.2,''_SIGMAS-'',F5.3,
     *                       ''_LDMONT-'',I5.5,''_'',A3)')
     * 
     *                          FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                          IFDENS,IFTENS,IF_RAD,IF_INV,IF_RHO,
     *                          IFDEEP,IFPRON,IFK_VC,IFK_VS,IFK_RC,
     *                          IFK_RS,IFK_AC,IFK_AS,LEVACT,SIGACT,
     *                          LDMONT,VERSIO
C
              DO K=1,256
                 IF (FILNA2(K:K).EQ.'.') THEN
                     FILNA2(K:K)='_'
                 END IF
                 IF (FILNA2(K:K).EQ.' ') THEN
                     KLENG1=K-1
                     GO TO 1
                 END IF
              END DO
C
   1          CONTINUE
C
              FILNA2=FILNA2(1:KLENG1)//'.log'
C
              DO K=1,256
                 IF (FILNA3(K:K).EQ.'.') THEN
                     FILNA3(K:K)='_'
                 END IF
                 IF (FILNA3(K:K).EQ.' ') THEN
                     KLENG2=K-1
                     GO TO 2
                 END IF
              END DO
C
   2          CONTINUE
C
              FILNA3=FILNA3(1:KLENG2)//'.log'
C
              OPEN(LOGENE,FILE=FILNA2,STATUS='UNKNOWN',FORM='FORMATTED')
              OPEN(LOGRAD,FILE=FILNA3,STATUS='UNKNOWN',FORM='FORMATTED')
C
          END IF
C      
      END IF
C
C=======================================================================
C     
      IF (IFDENS.EQ.0) THEN
C      
          WRITE(FILNAM,'(''LogMonte/IFDENS-0/'',A,''_'',A1,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACT-'',I2.2,''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,''_'',A3)')
     *
     *                          FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                          IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                          IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                          LEVACT,SIGACT,LDMONT,VERSIO
C          
          IF (NUCACT.GT.1 .AND. NUCACT.LT.LDNUCL) THEN
C              
              WRITE(FILNA2,'(''LogMonte/IFDENS-0/'',A,''_'',
     *                                      A1,''_Energies'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IF-RHO-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LEVACT-'',I2.2,''_SIGMAS-'',F5.3,
     *                       ''_LDMONT-'',I5.5,''_'',A3)')
     * 
     *                          FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                          IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                          IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                          LEVACT,SIGACT,LDMONT,VERSIO
             
              WRITE(FILNA3,'(''LogMonte/IFDENS-0/'',A,''_'',
     *                                         A1,''_Radii'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IF-RHO-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LEVACT-'',I2.2,''_SIGMAS-'',F5.3,
     *                       ''_LDMONT-'',I5.5,''_'',A3)')
     * 
     *                          FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                          IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                          IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                          LEVACT,SIGACT,LDMONT,VERSIO
C
              DO K=1,256
                 IF (FILNA2(K:K).EQ.'.') THEN
                     FILNA2(K:K)='_'
                 END IF
                 IF (FILNA2(K:K).EQ.' ') THEN
                     KLENG1=K-1
                     GO TO 3
                 END IF
              END DO
C
   3          CONTINUE
C
              FILNA2=FILNA2(1:KLENG1)//'.log'
C
              DO K=1,256
                 IF (FILNA3(K:K).EQ.'.') THEN
                     FILNA3(K:K)='_'
                 END IF
                 IF (FILNA3(K:K).EQ.' ') THEN
                     KLENG2=K-1
                     GO TO 4
                 END IF
              END DO
C
   4          CONTINUE
C
              FILNA3=FILNA3(1:KLENG2)//'.log'
C
              OPEN(LOGENE,FILE=FILNA2,STATUS='UNKNOWN',FORM='FORMATTED')
              OPEN(LOGRAD,FILE=FILNA3,STATUS='UNKNOWN',FORM='FORMATTED')
C
          END IF
C
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.1) THEN
C
          WRITE(FILNAM,'(''LogMonte/IFDENS-1_IFTENS-'',I1,''/'',
     *                                        A,''_'',A1,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                      IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGACT,
     *                                    LDMONT,TEXLAM,VERSIO
C______________________________________________________________________
C
          IF (IFTENS.EQ.1) THEN ! IFDENS=1
C
              WRITE(FILNAM,'(''LogMonte/IFDENS-1_IFTENS-'',I1,''/'',
     *                                        A,''_'',A1,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGACT,
     *                                    LDMONT,TEXLAM,VERSIO
          END IF
C______________________________________________________________________
C
          IF (NUCACT.GT.1 .AND. NUCACT.LT.LDNUCL) THEN ! IFDENS=1
C
              WRITE(FILNA2,'(''LogMonte/IFDENS-1_IFTENS-'',I1,''/'',
     *                              A,''_'',A1,''_Energies'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                       ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGACT,
     *                                    LDMONT,TEXLAM,VERSIO
C______________________________________________________________________
C
              WRITE(FILNA3,'(''LogMonte/IFDENS-1_IFTENS-'',I1,''/'',
     *                                 A,''_'',A1,''_Radii'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                       ''_LDMONT-'',I5.5,A15,''_'',A3)')
     * 
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGACT,
     *                                    LDMONT,TEXLAM,VERSIO
C______________________________________________________________________
C
              IF (IFTENS.EQ.1) THEN ! IFDENS=1
C
                  WRITE(FILNA2,'(''LogMonte/IFDENS-1_IFTENS-'',I1,''/'',
     *                              A,''_'',A1,''_Energies'',
     *                           ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                           ''_IF-PAI-'',I1,
     *                           ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                           ''_ITENSR-'',I1,
     *                           ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                           ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                           ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                           ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                           ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                           ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                           ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGACT,
     *                                    LDMONT,TEXLAM,VERSIO
C
C______________________________________________________________________
C
                  WRITE(FILNA3,'(''LogMonte/IFDENS-1_IFTENS-'',I1,''/'',
     *                                 A,''_'',A1,''_Radii'',
     *                           ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                           ''_IF-PAI-'',I1,
     *                           ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                           ''_ITENSR-'',I1,
     *                           ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                           ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                           ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                           ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                           ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                           ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                           ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGACT,
     *                                    LDMONT,TEXLAM,VERSIO
C
              END IF
C
              DO K=1,256
                 IF (FILNA2(K:K).EQ.'.') THEN
                     FILNA2(K:K)='_'
                 END IF
                 IF (FILNA2(K:K).EQ.' ') THEN
                     KLENG1=K-1
                     GO TO 5
                 END IF
              END DO
C
   5          CONTINUE
C
              FILNA2=FILNA2(1:KLENG1)//'.log'
C
              DO K=1,256
                 IF (FILNA3(K:K).EQ.'.') THEN
                     FILNA3(K:K)='_'
                 END IF
                 IF (FILNA3(K:K).EQ.' ') THEN
                     KLENG2=K-1
                     GO TO 6
                 END IF
              END DO
C
   6          CONTINUE
C
              FILNA3=FILNA3(1:KLENG2)//'.log'
C
              OPEN(LOGENE,FILE=FILNA2,STATUS='UNKNOWN',FORM='FORMATTED')
              OPEN(LOGRAD,FILE=FILNA3,STATUS='UNKNOWN',FORM='FORMATTED')
C
          END IF
C
      END IF
C
C=======================================================================
C
      DO K=1,256
         IF (FILNAM(K:K).EQ.'.') THEN
             FILNAM(K:K)='_'
         END IF
         IF (FILNAM(K:K).EQ.' ') THEN
             KLENG3=K-1
             GO TO 7
         END IF
      END DO
   7  CONTINUE
C
      FILNAM=FILNAM(1:KLENG3)//'.log'
C
C=======================================================================
C
      OPEN(LOGAUX,FILE=FILNAM,STATUS='UNKNOWN',FORM='FORMATTED')
C
C=======================================================================
C
C     Defining the dimension of the vector-function to be minimised
C
      LEVNUM=0
C
      IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
          DO INUCLI=1,LDNUCL
C
             IF (ITAKNU(INUCLI).EQ.1) THEN
C
                 IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_PROTON(INUCLI)
     *                                         +LEVEXP_NEUTRS(INUCLI)
     
                 IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+2 ! Two radii for each 
C                                                       nucleus, (P+N)
C                                                              
                 IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+2 ! Two Gap Energies 
C                                                   for each nucleus
C                                                                (P+N)
C                                                     
                 IF (IF_FER.EQ.1) LEVNUM=LEVNUM+2 ! Two Fermi Energies 
C                                                   for  each  nucleus
C                                                                (P+N)
C
                 IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+4 ! Four densities for 
C                                                   each nucleus: 
C                                                   below and above the 
C                                                   shell closure (P+N)
                 IF (IF_RHO.EQ.1) THEN
C             
c                     NRHOEX=0
C             
c                     CALL COUNTI_RHOEXP(INUCLI,NRHOEX)
C             
c                     LEVNUM=LEVNUM+NRHOEX
C             
                 END IF
C            
             END IF
C        
          END DO ! of LDNUCL
C       
       END IF ! IFDENS=1
C
C=======================================================================
C       
       IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN 
C           
           DO INUCLI=1,LDNUCL
C        
              IF (ITAKNU(INUCLI).EQ.1) THEN
C         
                  IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_PROTON(INUCLI)
C     
                  IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+1 ! Proton radius
C                                                              
                  IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+1 ! Proton Gap energy
C                                                     
                  IF (IF_FER.EQ.1) LEVNUM=LEVNUM+1 ! Proton Fermi energy
C        
                  IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+2 ! Proton up and down 
C                                                    density energies
C
                  IF (IF_RHO.EQ.1) THEN
*C             
*                      NRHOEX=0
*C             
*                      CALL COUNTI_RHOEXP(INUCLI,NRHOEX)
*C             
*                      LEVNUM=LEVNUM+NRHOEX
C             
                  END IF
C            
              END IF
C        
           END DO
C       
       END IF
C
C=======================================================================
C       
       IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1)) THEN 
C
           DO INUCLI=1,LDNUCL
C
              IF (ITAKNU(INUCLI).EQ.1) THEN
C
                  IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_NEUTRS(INUCLI)
     
                  IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+1 ! Neutron radius
C                                                              
                  IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+1 ! Neutron Gap energy
C                                                     
                  IF (IF_FER.EQ.1) LEVNUM=LEVNUM+1 ! Neutron Fermi 
C                                                                energy
C
                  IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+2 ! Neutron up and 
C                                                    down density 
C                                                              energies
C                 IF (IF_RHO.EQ.1)
C                 IF (IF_INV.EQ.1)
            
              END IF
         
           END DO
       
       END IF       
C
C=======================================================================
C
       IF (LEVNUM.GT.NDIM_M) THEN
C
           WRITE(LSCREN,'(/,''LEVNUM= '',I4,''and NDIM_M= '',I4,
     *                  ''--> LEVNUM should be LT NDIM_M!!'',/)')
C
           STOP 'STOP in LMMINI: LEVNUM.GT.NDIM_M!!'
C
       END IF
C
C=======================================================================
C 
      IF (LOGWRI.GT.0) THEN
C 
          WRITE(LOGFIL,'(9X,''LEVNUM='',I2,'' including: '')') LEVNUM
C
          IF (IF_SPE.EQ.1) WRITE(LOGFIL,'(30X,''Single Particle'',
     *                                        '' Energies'')')
C
          IF (IF_RAD.EQ.1) WRITE(LOGFIL,'(30X,''RMS Radii'')')
C
          IF (IF_GAP.EQ.1) WRITE(LOGFIL,'(30X,''Gap Energy'')')   
C       
          IF (IF_FER.EQ.1) WRITE(LOGFIL,'(30X,''Fermi Energy'')')  
       
          IF (IF_DEN.EQ.1) WRITE(LOGFIL,'(''Densities below and '',
     *                                    ''above the shell closure'')') 
C         IF (IF_RHO.EQ.1)
C         IF (IF_INV.EQ.1)      
C 
      END IF
C
C=======================================================================
C
C     To avoid huge log/output files
C
      LOGWRI=0
      IMTALK=0
C
      WRITE(LOGFIL,'(/,''Setting LOGWRI=0 and IMTALK=0 to avoid '',
     *                 ''huge log/output files'')')
C
C=======================================================================
C
C     Opening the temporary files where we will store the results to
C     create the histograms. This is done to avoid the constructions
C     of huge matrices.
C
C
C     Opening files for the parameters
C
      NWRITE_PARAMS=1000
C
      DO IPARAM=1,NDPARS
         IF (IFTAKE(IPARAM).EQ.1) THEN
C
             NWRITE_PARAMS=NWRITE_PARAMS+1
             NRESUL=NWRITE_PARAMS
C
             PARNAM=TITLES(IPARAM)(3:10)
             CALL HISTOG_PARNAM(PARNAM,LEVACT,LEVACT_PROTON,
     *                          LEVACT_NEUTRS,SIGACT,FILPAR)
C
             WRITE(0,'(''Opening file: '',A)') FILPAR
C
             OPEN(UNIT=NWRITE_PARAMS,FILE=FILPAR,STATUS='UNKNOWN')
C
             LDCURV=1
C
             IF (IPARAM.LE.20) ISOSPI=1
             IF (IPARAM.GT.20) ISOSPI=0
             IF (IPARAM.GT.38) ISOSPI=2 !both particles
C
             YEXPEC=VMISTR(IPARAM)
C
             LENGT1=0
             DO K=50,1,-1
                IF (TITLES_LATEXS(IPARAM)(K:K).NE.' ') THEN
                    LENGT1=K
                    GO TO 8
                END IF
             END DO
   8         CONTINUE
C
             LENGT2=0
             DO K=40,1,-1
                IF (PARPOT_UNITSS(IPARAM)(K:K).NE.' ') THEN
                    LENGT2=K
                    GO TO 9
                END IF
             END DO
   9         CONTINUE
C
             HISTIT='Parameter Distribution'
             HX_TIT='\\boldmath'//TITLES_LATEXS(IPARAM)(1:LENGT1)//
     *                      ' ('//PARPOT_UNITSS(IPARAM)(1:LENGT2)//')'
             HY_TIT='Probability Distribution'
             XUNITS=PARPOT_UNITSS(IPARAM)
C
             CALL PLOTINFOPRINT(NRESUL,HISTIT,HX_TIT,HY_TIT,
     *                          LEVACT_PROTON,LEVACT_NEUTRS,
     *                          SIGACT_PROTON,SIGACT_NEUTRS,
     *                                 LDCURV,YEXPEC,XUNITS)
C
         END IF
      END DO
C
C     Opening files for rms
C
      IPRINT_PROTON=0
      IPRINT_NEUTRS=0
C
      IF ((IFDENS.EQ.0 .AND. IFPROT.EQ.1) .OR.
     *    (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) .OR.
     *     IFDENS.EQ.1) THEN
C
          NWRITE_RMSPRO=2001
          NRESUL=NWRITE_RMSPRO
          ISOSPI=1
          CALL HISTOG_RMSNAM(ISOSPI,LEVACT,LEVACT_PROTON,
     *                       LEVACT_NEUTRS,SIGACT,FILRMS)
C
          WRITE(0,'(''Opening file: '',A)') FILRMS
C
          OPEN(UNIT=NWRITE_RMSPRO,FILE=FILRMS,STATUS='UNKNOWN')
C
          LDCURV=1
C
          YEXPEC=0.0
C
          HISTIT='\\boldmath$\\chi$ Distribution'
          HX_TIT='\\boldmath${\\rm rms}_p$ (MeV)'
          HY_TIT='Probability Distribution'
          XUNITS='MeV'
C
          CALL PLOTINFOPRINT(NRESUL,HISTIT,HX_TIT,HY_TIT,
     *                       LEVACT_PROTON,LEVACT_NEUTRS,
     *                       SIGACT_PROTON,SIGACT_NEUTRS,
     *                              LDCURV,YEXPEC,XUNITS)
C
          IPRINT_PROTON=1
C
      END IF
C
      IF ((IFDENS.EQ.0 .AND. IFNEUT.EQ.1) .OR.
     *    (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) .OR.
     *     IFDENS.EQ.1) THEN
C
          NWRITE_RMSNEU=2000
          NRESUL=NWRITE_RMSNEU
          ISOSPI=0
          CALL HISTOG_RMSNAM(ISOSPI,LEVACT,LEVACT_PROTON,
     *                       LEVACT_NEUTRS,SIGACT,FILRMS)
C
          WRITE(0,'(''Opening file: '',A)') FILRMS
C
          OPEN(UNIT=NWRITE_RMSNEU,FILE=FILRMS,STATUS='UNKNOWN')
C
          LDCURV=1
C
          YEXPEC=0.0
C
          HISTIT='\\boldmath$\\chi$ Distribution'
          HX_TIT='\\boldmath${\\rm rms}_p$ (MeV)'
          HY_TIT='Probability Distribution'
          XUNITS='MeV'
C
          CALL PLOTINFOPRINT(NRESUL,HISTIT,HX_TIT,HY_TIT,
     *                       LEVACT_PROTON,LEVACT_NEUTRS,
     *                       SIGACT_PROTON,SIGACT_NEUTRS,
     *                              LDCURV,YEXPEC,XUNITS)
C
          IPRINT_NEUTRS=1
C
      END IF
C
C     Opening files for the spe
C
      IF ((IFDENS.EQ.0 .AND. IFPROT.EQ.1) .OR.
     *    (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) .OR.
     *     IFDENS.EQ.1) THEN
C
          NWRITE_ENEPRO=3001
          NRESUL=NWRITE_ENEPRO
C
          ISOSPI=1
          CALL HISTOG_SPENAM(ISOSPI,LEVACT,LEVACT_PROTON,
     *                       LEVACT_NEUTRS,SIGACT,FILSPE)
C
          WRITE(0,'(''Opening file: '',A)') FILSPE
C
          OPEN(UNIT=NRESUL,FILE=FILSPE,STATUS='UNKNOWN')
C
          LDCURV=(NSHELL_PROTON+1)*(NSHELL_PROTON/2+1)
C
          YEXPEC=99.9999
C
          WRITE(HISTIT,'(''Uncertainty Distributions for '',
     *                   ''\\boldmath$N_p= '',i3,
     *                   ''$'')')LEVACT_PROTON
          HX_TIT='\\boldmath${\\rm Energy (MeV)}$'
          HY_TIT='Proton Histograms'
          XUNITS='MeV'
C
          CALL PLOTINFOPRINT(NRESUL,HISTIT,HX_TIT,HY_TIT,
     *                       LEVACT_PROTON,LEVACT_NEUTRS,
     *                       SIGACT_PROTON,SIGACT_NEUTRS,
     *                              LDCURV,YEXPEC,XUNITS)
C
      END IF
C
      IF ((IFDENS.EQ.0 .AND. IFNEUT.EQ.1) .OR.
     *    (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) .OR.
     *     IFDENS.EQ.1) THEN
C
          NWRITE_ENENEU=3000
          NRESUL=NWRITE_ENENEU
C
          ISOSPI=0
          CALL HISTOG_SPENAM(ISOSPI,LEVACT,LEVACT_PROTON,
     *                       LEVACT_NEUTRS,SIGACT,FILSPE)
C
          OPEN(UNIT=NRESUL,FILE=FILSPE,STATUS='UNKNOWN')
C
          WRITE(0,'(''Opening file: '',A)') FILSPE
C
          LDCURV=(NSHELL_NEUTRS+1)*(NSHELL_NEUTRS/2+1)
C
          YEXPEC=99.9999
C
          WRITE(HISTIT,'(''Uncertainty Distributions for '',
     *                   ''\\boldmath$N_n= '',i3,
     *                   ''$'')')LEVACT_NEUTRS
          HX_TIT='\\boldmath${\\rm Energy (MeV)}$'
          HY_TIT='Neutron Histograms'
          XUNITS='MeV'
C
          CALL PLOTINFOPRINT(NRESUL,HISTIT,HX_TIT,HY_TIT,
     *                       LEVACT_PROTON,LEVACT_NEUTRS,
     *                       SIGACT_PROTON,SIGACT_NEUTRS,
     *                              LDCURV,YEXPEC,XUNITS)
C
      END IF
C
C=======================================================================
C
C     Initializing the maxima and the minima for the parameters,
C     rms and s.p.e.
C
      DO IPARAM=1,NDPARS
         PARPOT_MAXIMA(IPARAM)=-1.0E+10
         PARPOT_MINIMA(IPARAM)=+1.0E+10
      END DO
C
      RMSVAL_PROMAX=-1.0E+10
      RMSVAL_PROMIN=+1.0E+10
C
      RMSVAL_NEUMAX=-1.0E+10
      RMSVAL_NEUMIN=+1.0E+10
C
      ENETHE_PROMAX=-1.0E+10
      ENETHE_PROMIN=+1.0E+10
C
      ENETHE_NEUMAX=-1.0E+10
      ENETHE_NEUMIN=+1.0E+10
C
C=======================================================================
C
C     Beginning the real calculations: generating the random numbers
C     for the noise for the psuedo-experimental levels and minimizing
C     the \chi^2
C
      INSEED=0!7893
      CALL ZBQLINI(INSEED)
C
      IERROR_PROTON=0  !To count how many times we did not get the
      IERROR_NEUTRS=0  !corresponding particle number
C
      DO IMONTE=1,LDMONT
C_______________________________________________________________________
C
C        Randomly generating the noise for the pseudo-levels
C
         DO INUCLI=1,LDNUCL
            IF (ITAKNU(INUCLI).EQ.1) THEN
C
                IEXPER=0
                DO I=1,LEVPRO_PSEUDO(INUCLI)          !Protons
C
                   IF (LEVTAK_PROTON(I,INUCLI).EQ.1) THEN
C
                       IEXPER=IEXPER+1
C
                       GAUSIG=SIGPRO_PSEUDO(I,INUCLI)
                       GAUSMU=ENEPRO_PSEUDO(I,INUCLI)
C
                       RANDOM=ZBQLNOR(GAUSMU,GAUSIG)
                       EXPEXP_PROTON(INUCLI,IEXPER)=RANDOM
C
                    END IF
C
                END DO
C
                IEXPER=0
                DO I=1,LEVNEU_PSEUDO(INUCLI)         !Neutrons
C
                   IF (LEVTAK_NEUTRS(I,INUCLI).EQ.1) THEN
C
                       IEXPER=IEXPER+1
C
                       GAUSIG=SIGNEU_PSEUDO(I,INUCLI)
                       GAUSMU=ENENEU_PSEUDO(I,INUCLI)
C
                       RANDOM=ZBQLNOR(GAUSMU,GAUSIG)
                       EXPEXP_NEUTRS(INUCLI,IEXPER)=RANDOM
C
                   END IF
C
                END DO
C
            END IF
         END DO
C_______________________________________________________________________
C
C        Calling the minimization subroutine
C
 100     CONTINUE
C
         CALL LMMINI_MONTEC(IMONTE,LDMONT,IACTIV,ARGPAR,
     *                      LEVNUM,NDLAST,NEWSED,I_SEED)
C_______________________________________________________________________
C
C        Checking if we arrived to the correct particle number.
C        If not, we repeat the iteration -->> GO TO 100
C
         IF (IPRINT_PROTON.EQ.1) THEN
             IF (N_ACTU_PROTON.NE.N_CORR_PROTON) THEN
C
                 WRITE(LOGAUX,'()')
                 WRITE(000000,'()')
                 DO I=1,3
                    WRITE(LOGAUX,'(''PROTON PARTICLE NUMBER NOT '',
     *                             ''SATISFIED - WE REPEAT THIS '',
     *                             ''ITERATION'')')
                    WRITE(000000,'(''PROTON PARTICLE NUMBER NOT '',
     *                             ''SATISFIED - WE REPEAT THIS '',
     *                             ''ITERATION'')')
                 END DO
C
                 IERROR_PROTON=IERROR_PROTON+1
C
                 WRITE(LOGAUX,'()')
                 WRITE(000000,'()')
                 DO I=1,3
                    WRITE(LOGAUX,'(''It already happened for '',
     *                             ''IERROR_PROTON= '',i6,'' times'')')
     *                               IERROR_PROTON
                    WRITE(000000,'(''It already happened for '',
     *                             ''IERROR_PROTON= '',i6,'' times'')')
     *                               IERROR_PROTON
                 END DO
                 WRITE(LOGAUX,'()')
                 WRITE(000000,'()')
C
                 I_SEED=NEWSED
C
                 GO TO 100
C
             END IF
         END IF
C
         IF (IPRINT_NEUTRS.EQ.1) THEN
             IF (N_ACTU_PROTON.NE.N_CORR_PROTON) THEN
C
                 WRITE(LOGAUX,'()')
                 WRITE(000000,'()')
                 DO I=1,3
                    WRITE(LOGAUX,'(/,''NEUTRON PARTICLE NUMBER NOT '',
     *                               ''SATISFIED - WE REPEAT THIS '',
     *                               ''ITERATION'',/)')
                    WRITE(000000,'(/,''NEUTRON PARTICLE NUMBER NOT '',
     *                               ''SATISFIED - WE REPEAT THIS '',
     *                               ''ITERATION'',/)')
                 END DO
C
                 IERROR_NEUTRS=IERROR_NEUTRS+1
C
                 WRITE(LOGAUX,'()')
                 WRITE(000000,'()')
                 DO I=1,3
                    WRITE(LOGAUX,'(''It already happened for '',
     *                             ''IERROR_NEUTRS= '',i6,'' times'')')
     *                               IERROR_NEUTRS
                    WRITE(LOGAUX,'(''It already happened for '',
     *                             ''IERROR_NEUTRS= '',i6,'' times'')')
     *                               IERROR_NEUTRS
                 END DO
                 WRITE(LOGAUX,'()')
                 WRITE(000000,'()')
C
                 I_SEED=NEWSED
C
                 GO TO 100
C
             END IF
         END IF
C_______________________________________________________________________
C
C        Calculating the s.p.e. and rms values after each minimization
C
         DO INUCLI=1,LDNUCL
            IF (ITAKNU(INUCLI).EQ.1) THEN
C
                I_FLAG=1
                I_MODE=0
C
                CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,
     *                      I_FLAG,CHISQU_PROTON,CHISQU_NEUTRS)
C
                LTPROT=LEVTHE_PROTON
                LTNEUT=LEVTHE_NEUTRS
C_______________________________________________________________________
C
C               Printing the rms values at each IMONTE
C
                IF (IPRINT_PROTON.EQ.1) THEN
                    LDCURV=1
                    LABTIT(LDCURV)='${\\rm rms}_p$'
                    VECTOR_RMSVAL(LDCURV)=SQRT(CHIWEI_PROTON)
C
                    CALL PLOTCURVPRINT(NWRITE_RMSPRO,ND_RMS,LDCURV,
     *                                 IMONTE,LABTIT,VECTOR_RMSVAL)
                END IF
C
                IF (IPRINT_NEUTRS.EQ.1) THEN
                    LDCURV=1
                    LABTIT(LDCURV)='${\\rm rms}_n$'
                    VECTOR_RMSVAL(LDCURV)=SQRT(CHIWEI_NEUTRS)
C
                    CALL PLOTCURVPRINT(NWRITE_RMSNEU,ND_RMS,LDCURV,
     *                                 IMONTE,LABTIT,VECTOR_RMSVAL)
                END IF
C
C               MAX - MIN for rms proton
C
                IF (SQRT(CHIWEI_PROTON).LT.RMSVAL_PROMIN) THEN
                    RMSVAL_PROMIN=SQRT(CHIWEI_PROTON)
                END IF
C
                IF (SQRT(CHIWEI_PROTON).GT.RMSVAL_PROMAX) THEN
                    RMSVAL_PROMAX=SQRT(CHIWEI_PROTON)
                END IF
C
C               MAX - MIN for rms neutrons
C
                IF (SQRT(CHIWEI_NEUTRS).LT.RMSVAL_NEUMIN) THEN
                    RMSVAL_NEUMIN=SQRT(CHIWEI_NEUTRS)
                END IF
C
                IF (SQRT(CHIWEI_NEUTRS).GT.RMSVAL_NEUMAX) THEN
                    RMSVAL_NEUMAX=SQRT(CHIWEI_NEUTRS)
                END IF
C_______________________________________________________________________
C
C               Storing the reference label
C
                IF (IMONTE.EQ.1) THEN
C
                    DO IREFER=1,LTPROT
                       LABREF_PROTON(IREFER)=LABTHE_PROTON(IREFER)
                    END DO
C
                    DO IREFER=1,LTNEUT
                       LABREF_NEUTRS(IREFER)=LABTHE_NEUTRS(IREFER)
                    END DO
C
                END IF
C
C               Printing the results for each IMONTE (=restart)
C
                IF (IPRINT_PROTON.EQ.1) THEN
C
                    LDCURV=LTPROT
C
                    DO IREFER=1,LTPROT
C
                       LABTIT_PROTON(IREFER)=LABREF_PROTON(IREFER)
C
                       DO ITHEOR=1,LTPROT
                          IF (LABTHE_PROTON(ITHEOR)
     *                   .EQ. LABREF_PROTON(IREFER))THEN
C
                              VECTOR_ENEPRO(IREFER)
     *                       =ENETHE_PROTON(ITHEOR)
C
                              IF (ENETHE_PROTON(ITHEOR)
     *                       .LT. ENETHE_PROMIN) THEN
                                  ENETHE_PROMIN
     *                           =ENETHE_PROTON(ITHEOR)
                              END IF
C
                              IF (ENETHE_PROTON(ITHEOR)
     *                       .GT. ENETHE_PROMAX) THEN
                                  ENETHE_PROMAX
     *                           =ENETHE_PROTON(ITHEOR)
                              END IF
C
                          END IF
                       END DO
                    END DO
C
                    CALL PLOTCURVPRINT(NWRITE_ENEPRO,NDSPEC,LDCURV,
     *                                        IMONTE,LABTIT_PROTON,
     *                                               VECTOR_ENEPRO)
C
                END IF
C
                IF (IPRINT_NEUTRS.EQ.1) THEN
C
                    LDCURV=LTNEUT
C
                    DO IREFER=1,LTNEUT
C
                       LABTIT_NEUTRS(IREFER)=LABREF_NEUTRS(IREFER)
C
                       DO ITHEOR=1,LTNEUT
                          IF (LABTHE_NEUTRS(ITHEOR)
     *                   .EQ. LABREF_NEUTRS(IREFER)) THEN
C
                              VECTOR_ENENEU(IREFER)
     *                       =ENETHE_NEUTRS(ITHEOR)
C
                              IF (ENETHE_NEUTRS(ITHEOR)
     *                       .LT. ENETHE_NEUMIN) THEN
                                  ENETHE_NEUMIN
     *                           =ENETHE_NEUTRS(ITHEOR)
                              END IF
C
                              IF (ENETHE_NEUTRS(ITHEOR)
     *                       .GT. ENETHE_NEUMAX) THEN
                                  ENETHE_NEUMAX
     *                           =ENETHE_NEUTRS(ITHEOR)
                              END IF
C
                          END IF
                       END DO
                    END DO
C
                    CALL PLOTCURVPRINT(NWRITE_ENENEU,NDSPEC,LDCURV,
     *                                        IMONTE,LABTIT_NEUTRS,
     *                                               VECTOR_ENENEU)
C
                END IF
C
            END IF !ITAKNU
         END DO !INUCLI
C_______________________________________________________________________
C
C        Looking for the parameter extrems
C
         DO IPARAM=1,NDPARS
            IF (PARPOT_MAXIMA(IPARAM).LT.PARPOT(IPARAM)) THEN
                PARPOT_MAXIMA(IPARAM)=PARPOT(IPARAM)
            END IF
            IF (PARPOT_MINIMA(IPARAM).GT.PARPOT(IPARAM)) THEN
                PARPOT_MINIMA(IPARAM)=PARPOT(IPARAM)
            END IF
         END DO
C
C        Printing the parameters at each IMONTE
C
         NWRITE_PARAMS=1000
C
         DO IPARAM=1,NDPARS
            IF (IFTAKE(IPARAM).EQ.1) THEN
C
                NWRITE_PARAMS=NWRITE_PARAMS+1
                LDCURV=1
C
                LABTIT_PARPOT(LDCURV)=TITLES_LATEXS(IPARAM)
                VECTOR_PARPOT(LDCURV)=PARPOT(IPARAM)
C
                CALL PLOTCURVPRINT(NWRITE_PARAMS,NDPARS,LDCURV,
     *                                    IMONTE,LABTIT_PARPOT,
     *                                           VECTOR_PARPOT)
C
            END IF
         END DO
C
         I_SEED=NEWSED
C_______________________________________________________________________
C
      END DO !IMONTE
C
C=======================================================================
C=======================================================================
C
C     Printing RMS and SPE max and min values
C
      YMINIM=1.0
      YMAXIM=REAL(LDMONT)
C
      IF (IPRINT_PROTON.EQ.1) THEN
C
          CALL PLOTEXTRPRINT(NWRITE_RMSPRO,RMSVAL_PROMIN,
     *                       RMSVAL_PROMAX,YMINIM,YMAXIM)
C
          CALL PLOTEXTRPRINT(NWRITE_ENEPRO,ENETHE_PROMIN,
     *                       ENETHE_PROMAX,YMINIM,YMAXIM)
C
      END IF
C
      IF (IPRINT_NEUTRS.EQ.1) THEN
C
          CALL PLOTEXTRPRINT(NWRITE_RMSNEU,RMSVAL_NEUMIN,
     *                       RMSVAL_NEUMAX,YMINIM,YMAXIM)
C
          CALL PLOTEXTRPRINT(NWRITE_ENENEU,ENETHE_NEUMIN,
     *                       ENETHE_NEUMAX,YMINIM,YMAXIM)
C
      END IF
C
C     And now the parameters
C
      NWRITE_PARAMS=1000
C
      DO IPARAM=1,NDPARS
         IF (IFTAKE(IPARAM).EQ.1) THEN
C
             NWRITE_PARAMS=NWRITE_PARAMS+1
C
             XMAXIM=PARPOT_MAXIMA(IPARAM)
             XMINIM=PARPOT_MINIMA(IPARAM)
C
             CALL PLOTEXTRPRINT(NWRITE_PARAMS,XMINIM,XMAXIM,
     *                                        YMINIM,YMAXIM)
C
         END IF
      END DO
C
C=======================================================================
C
      CLOSE(NWRITE_PARAMS)
      CLOSE(NWRITE_ENENEU)
      CLOSE(NWRITE_ENEPRO)
      CLOSE(NWRITE_RMSNEU)
      CLOSE(NWRITE_RMSPRO)
C
C=======================================================================
C=======================================================================
C=======================================================================
C=======================================================================
C
      REWIND LOGPRO
   10 CONTINUE
      READ (LOGPRO,'(A120)',END=11) STRING
      IF (LOGWRI.GT.4) WRITE(NpUNIT,'(A80)'        ) STRING
C
      GO TO 10
C
   11 CONTINUE  ! Ready with the copy for the protons      
C      
C=======================================================================
C 
      REWIND LOGNEU    
   20 CONTINUE
      READ (LOGNEU,'(A120)',END=21) STRING
      IF (LOGWRI.GT.4) WRITE(NnUNIT,'(A80)'        ) STRING
C      
      GO TO 20
C
   21 CONTINUE  ! Ready with the copy for the neutrons     
C
C=======================================================================      
C=======================================================================
C
      WRITE(LOGFIL,'(/,9X,''Exting FITTIN_MONTEC'')')
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE EX_TO_PSEUDO
C
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDLEXP.f'
C
      CHARACTER
     *          NUCSYM*6,INPSYM*6
      CHARACTER
     *          LABPRO_PSEUDO*6,LABNEU_PSEUDO*6,
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6,
     *          LABEXP_PROREA*6,LABEXP_NEUREA*6
C
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /PSEUDO_ZN_NUM/ IZ_PSE(1:NDNUCL),
     *                       IN_PSE(1:NDNUCL)
      COMMON
     *       /PSEUDO_LEVELS/ LEVNEU_PSEUDO(1:NDNUCL),
     *                       LEVPRO_PSEUDO(1:NDNUCL)
      COMMON
     *       /PSEUDO_PROTON/ ENEPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LABPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       SIGPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       IDEPRO_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LEVTAK_PROTON(1:NDLEXP,1:NDNUCL)
      COMMON
     *       /PSEUDO_NEUTRS/ ENENEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LABNEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       SIGNEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       IDENEU_PSEUDO(1:NDLEXP,1:NDNUCL),
     *                       LEVTAK_NEUTRS(1:NDLEXP,1:NDNUCL)
      COMMON
     *       /SIGEXP_PRONEU/ SIGEXP_PROTON(1:NDLEXP,1:NDNUCL),
     *                       SIGEXP_NEUTRS(1:NDLEXP,1:NDNUCL)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /REALEX_PROTON/ EXPEXP_PROREA(1:NDNUCL,1:NDLEXP),
     *                       LABEXP_PROREA(1:NDNUCL,1:NDLEXP),
     *                       IDEGEX_PROREA(1:NDNUCL,1:NDLEXP),
     *                       LEVEXP_PROREA(1:NDNUCL)
      COMMON
     *       /REALEX_NEUTRS/ EXPEXP_NEUREA(1:NDNUCL,1:NDLEXP),
     *                       LABEXP_NEUREA(1:NDNUCL,1:NDLEXP),
     *                       IDEGEX_NEUREA(1:NDNUCL,1:NDLEXP),
     *                       LEVEXP_NEUREA(1:NDNUCL)
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C
C     This subroutine transforms the real experimental single particle
C     energy values to the pseudo-experimental ones. It is called from
C     FITTIN_MONTEC.
C
C=======================================================================
C
      WRITE(LOGFIL,'(/,''Entering EX_TO_PSEUDO'')')
C
C=======================================================================
C
C     First, we store the real-experimental values 
C
      DO I=1,LDNUCL
C
         LEVEXP_PROREA(I)=LEVEXP_PROTON(I)
         DO J=1,LEVEXP_PROTON(I)
            EXPEXP_PROREA(I,J)=EXPEXP_PROTON(I,J)
            LABEXP_PROREA(I,J)=LABEXP_PROTON(I,J)
            IDEGEX_PROREA(I,J)=IDEGEX_PROTON(I,J)
         END DO
C
         LEVEXP_NEUREA(I)=LEVEXP_NEUTRS(I)
         DO J=1,LEVEXP_NEUTRS(I)
            EXPEXP_NEUREA(I,J)=EXPEXP_NEUTRS(I,J)
            LABEXP_NEUREA(I,J)=LABEXP_NEUTRS(I,J)
            IDEGEX_NEUREA(I,J)=IDEGEX_NEUTRS(I,J)
         END DO
C
      END DO
C
C=======================================================================
C
      DO I=1,LDNUCL
C
         IF (NUMB_Z(I).NE.IZ_PSE(I) .OR. NUMB_N(I).NE.IN_PSE(I)) THEN
             WRITE(LOGFIL,'(''WARNING in EX_TO_PSEUDO - not the same'',
     *                      ''nucleus: NUMB_Z= '',i3,'' and IZ_PSE= '',
     *                       I3,'' and NUMB_N= '',I3,'' and IN_PSE= '',
     *                       i3)')NUMB_Z(I),IZ_PSE(I),NUMB_N(I),
     *                                                IN_PSE(I)
             STOP 'STOP in EX_TO_PSEUDO: Wrong nucleus order'
         END IF
C
         IEXPER=0
         DO J=1,LEVPRO_PSEUDO(I)
            IF (LEVTAK_PROTON(J,I).EQ.1) THEN
                IEXPER=IEXPER+1
                EXPEXP_PROTON(I,IEXPER)=ENEPRO_PSEUDO(J,I)
                LABEXP_PROTON(I,IEXPER)=LABPRO_PSEUDO(J,I)
                IDEGEX_PROTON(I,IEXPER)=IDEPRO_PSEUDO(J,I)
                SIGEXP_PROTON(IEXPER,I)=SIGPRO_PSEUDO(J,I)
            END IF
         END DO
         LEVEXP_PROTON(I)=IEXPER
C
         IEXPER=0
         DO J=1,LEVNEU_PSEUDO(I)
            IF (LEVTAK_NEUTRS(J,I).EQ.1) THEN 
                IEXPER=IEXPER+1
                EXPEXP_NEUTRS(I,IEXPER)=ENENEU_PSEUDO(J,I)
                LABEXP_NEUTRS(I,IEXPER)=LABNEU_PSEUDO(J,I)
                IDEGEX_NEUTRS(I,IEXPER)=IDENEU_PSEUDO(J,I)
                SIGEXP_NEUTRS(IEXPER,I)=SIGNEU_PSEUDO(J,I)
            END IF
         END DO
         LEVEXP_NEUTRS(I)=IEXPER
C
         IF (LOGWRI.GT.0) THEN
             WRITE(LOGFIL,'(/,''For INUCLI= '',I1,'' we have '',
     *                        ''LEVEXP_PROTON= '',I3,'' and '',
     *                        ''LEVEXP_NEUTRS= '',I3,/)')
     *                        I,LEVEXP_PROTON(I),LEVEXP_NEUTRS(I)
         END IF
C
      END DO
C
C=======================================================================
C
      WRITE(LOGFIL,'(/,''We are working with the following '',
     *                                     ''pseudo-levels:'',/)')
C
      WRITE(LOGFIL,'(9X,''Protons:'',/)')
      DO INUCLI=1,LDNUCL
         IF (ITAKNU(INUCLI).EQ.1) THEN
C
             DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                WRITE(LOGFIL,'(15X,2I4,F15.3,3X,A6,3X,I4,F15.4)')
     *                            INUCLI,IEXPER,
     *                            EXPEXP_PROTON(INUCLI,IEXPER),
     *                            LABEXP_PROTON(INUCLI,IEXPER),
     *                            IDEGEX_PROTON(INUCLI,IEXPER),
     *                            SIGEXP_PROTON(IEXPER,INUCLI)
             END DO
C
             WRITE(LOGFIL,'()')
C
         END IF
      END DO
C
      WRITE(LOGFIL,'(9X,''Neutrons:'',/)')
      DO INUCLI=1,LDNUCL
         IF (ITAKNU(INUCLI).EQ.1) THEN
C
             DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                WRITE(LOGFIL,'(15X,2I4,F15.3,3X,A6,3X,I4,F15.4)')
     *                            INUCLI,IEXPER,
     *                            EXPEXP_NEUTRS(INUCLI,IEXPER),
     *                            LABEXP_NEUTRS(INUCLI,IEXPER),
     *                            IDEGEX_NEUTRS(INUCLI,IEXPER),
     *                            SIGEXP_NEUTRS(IEXPER,INUCLI)
             END DO
C
             WRITE(LOGFIL,'()')
C
         END IF
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(''Exiting EX_TO_PSEUDO'')')
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE HISTOG_PARNAM(PARNAM,LEVACT,LEVACT_PROTON,
     *                         LEVACT_NEUTRS,SIGMAS,FILPAR)
C
      INCLUDE 'MATDIM/NDNUCL.f'
C
      CHARACTER
     *          PARNAM*8,FILPAR*300,VERSIO*3,TYPCHI*6,
     *          NUCSYM*6,INPSYM*6,FITNUC*2,
     *          FITNUC_AUXILI*2,FILNAM_NUCFIT*30,TEXLAM*20
C
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL)
C
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
       COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /VERSIN/ VERSIO
C
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' /
C
C=======================================================================
C
      IF (IFDENS.EQ.1) THEN
         WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                               IFPAR1,IFPAR2,IFPAR3,IFPAR4    
      END IF
C
C=======================================================================
C 
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
      
      I1=3*KACTIV-1
      
      WRITE(FILNAM_NUCFIT,'(<NUCACT>(A2,''-''))')
     *                     (FITNUC_AUXILI(I),I=1,NUCACT)
C
C=======================================================================
C
      CALL SYSTEM('mkdir -pv ParHists/IFDENS-0')
      CALL SYSTEM('mkdir -pv ParHists/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv ParHists/IFDENS-1_IFTENS-1')
C
C=======================================================================
C     
      IF (IFDENS.EQ.0) THEN
C      
          WRITE(FILPAR,'(''ParHists/IFDENS-0/'',A8,''_'',A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACT-'',I2.2,''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,''_'',A3)')
     *
     *                          PARNAM,FILNAM_NUCFIT(1:I1),
     *                          IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                          IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                          LEVACT,SIGMAS,LDMONT,VERSIO
C      
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.1) THEN
C      
          WRITE(FILPAR,'(''ParHists/IFDENS-1_IFTENS-'',I1,''/'',
     *                                        A8,''_'',A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,PARNAM,FILNAM_NUCFIT(1:I1),
     *                      IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                      IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGMAS,
     *                                    LDMONT,TEXLAM,VERSIO
C______________________________________________________________________
C
          IF (IFTENS.EQ.1) THEN ! IFDENS=1
C
              WRITE(FILPAR,'(''ParHists/IFDENS-1_IFTENS-'',I1,''/'',
     *                                        A8,''_'',A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,PARNAM,FILNAM_NUCFIT(1:I1),
     *                      IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGMAS,
     *                                    LDMONT,TEXLAM,VERSIO
          END IF
C
      END IF
C
      DO K=1,300
         IF (FILPAR(K:K).EQ.'.') THEN
             FILPAR(K:K)='_'
         END IF
         IF (FILPAR(K:K).EQ.' ') THEN
             KLENGT=K-1
             GO TO 1
         END IF
      END DO
C
   1  CONTINUE
C
      FILPAR=FILPAR(1:KLENGT)//'.dat'
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE HISTOG_RMSNAM(ISOSPI,LEVACT,LEVACT_PROTON,
     *                         LEVACT_NEUTRS,SIGMAS,FILRMS)
C
      INCLUDE 'MATDIM/NDNUCL.f'
C
      CHARACTER
     *          FILISO*1,FILRMS*300,VERSIO*3,TYPCHI*6,
     *          FITNUC*2,FITNUC_AUXILI*2,FILNAM_NUCFIT*30,TEXLAM*20
      CHARACTER
     *          NUCSYM*6,INPSYM*6
C
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL)
C
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /VERSIN/ VERSIO
C
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' /
C
C=======================================================================
C
      IF (ISOSPI.EQ.1) FILISO='P'
      IF (ISOSPI.EQ.0) FILISO='N'
C
C=======================================================================
C
      IF (IFDENS.EQ.1) THEN
         WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                               IFPAR1,IFPAR2,IFPAR3,IFPAR4    
      END IF
C
C=======================================================================
C 
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
      
      I1=3*KACTIV-1
      
      WRITE(FILNAM_NUCFIT,'(<NUCACT>(A2,''-''))')
     *                     (FITNUC_AUXILI(I),I=1,NUCACT)
C
C=======================================================================
C
      CALL SYSTEM('mkdir -pv RMSHists/IFDENS-0')
      CALL SYSTEM('mkdir -pv RMSHists/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv RMSHists/IFDENS-1_IFTENS-1')
C
C=======================================================================
C
      IF (IFDENS.EQ.0) THEN
C      
          WRITE(FILRMS,'(''RMSHists/IFDENS-0/RMS-'',A1,''_'',A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACT-'',I2.2,''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,''_'',A3)')
     *
     *                          FILISO,FILNAM_NUCFIT(1:I1),
     *                          IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                          IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                          LEVACT,SIGMAS,LDMONT,VERSIO
C
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.1) THEN
C      
          WRITE(FILRMS,'(''RMSHists/IFDENS-1_IFTENS-'',I1,''/RMS-'',
     *                                        A1,''_'',A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,FILISO,FILNAM_NUCFIT(1:I1),
     *                      IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                      IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGMAS,
     *                                    LDMONT,TEXLAM,VERSIO
C______________________________________________________________________
C
          IF (IFTENS.EQ.1) THEN ! IFDENS=1
C
              WRITE(FILRMS,'(''RMSHists/IFDENS-1_IFTENS-'',I1,''/RMS-'',
     *                                        A1,''_'',A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,FILISO,FILNAM_NUCFIT(1:I1),
     *                      IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGMAS,
     *                                    LDMONT,TEXLAM,VERSIO
          END IF
C
      END IF
C
      DO K=1,300
         IF (FILRMS(K:K).EQ.'.') THEN
             FILRMS(K:K)='_'
         END IF
         IF (FILRMS(K:K).EQ.' ') THEN
             KLENGT=K-1
             GO TO 1
         END IF
      END DO
C
   1  CONTINUE
C
      FILRMS=FILRMS(1:KLENGT)//'.dat'
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE HISTOG_SPENAM(ISOSPI,LEVACT,LEVACT_PROTON,
     *                         LEVACT_NEUTRS,SIGMAS,FILSPE)
C
      INCLUDE 'MATDIM/NDNUCL.f'
C
      CHARACTER
     *          FILISO*1,FILSPE*300,VERSIO*3,TYPCHI*6,
     *          FITNUC*2,FITNUC_AUXILI*2,FILNAM_NUCFIT*30,TEXLAM*20
      CHARACTER
     *          NUCSYM*6,INPSYM*6
C
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL)
C
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /VERSIN/ VERSIO
C
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' /
C
C=======================================================================
C
      IF (ISOSPI.EQ.1) FILISO='P'
      IF (ISOSPI.EQ.0) FILISO='N'
C
C=======================================================================
C
      IF (IFDENS.EQ.1) THEN
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                               IFPAR1,IFPAR2,IFPAR3,IFPAR4
      END IF
C
C=======================================================================
C
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
          END IF
      END DO

      I1=3*KACTIV-1

      WRITE(FILNAM_NUCFIT,'(<NUCACT>(A2,''-''))')
     *                     (FITNUC_AUXILI(I),I=1,NUCACT)
C
C=======================================================================
C
      CALL SYSTEM('mkdir -pv SPEHists/IFDENS-0')
      CALL SYSTEM('mkdir -pv SPEHists/IFDENS-1_IFTENS-0')
      CALL SYSTEM('mkdir -pv SPEHists/IFDENS-1_IFTENS-1')
C
C=======================================================================
C
      IF (IFDENS.EQ.0) THEN
C
          WRITE(FILSPE,'(''SPEHists/IFDENS-0/SPE-'',A1,''_'',A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACT-'',I2.2,''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,''_'',A3)')
     *
     *                          FILISO,FILNAM_NUCFIT(1:I1),
     *                          IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                          IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                          LEVACT,SIGMAS,LDMONT,VERSIO
C
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.1) THEN
C
          WRITE(FILSPE,'(''SPEHists/IFDENS-1_IFTENS-'',I1,''/SPE-'',
     *                                        A1,''_'',A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,FILISO,FILNAM_NUCFIT(1:I1),
     *                      IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                      IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGMAS,
     *                                    LDMONT,TEXLAM,VERSIO
C______________________________________________________________________
C
          IF (IFTENS.EQ.1) THEN ! IFDENS=1
C
              WRITE(FILSPE,'(''SPEHists/IFDENS-1_IFTENS-'',I1,''/SPE-'',
     *                                        A1,''_'',A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LEVACp-'',I2.2,''_LEVACn-'',I2.2,
     *                                     ''_SIGMAS-'',F5.3,
     *                   ''_LDMONT-'',I5.5,A15,''_'',A3)')
     *
     *                      IFTENS,FILISO,FILNAM_NUCFIT(1:I1),
     *                      IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                      LEVACT_PROTON,LEVACT_NEUTRS,SIGMAS,
     *                                    LDMONT,TEXLAM,VERSIO
          END IF
C
      END IF
C
      DO K=1,300
         IF (FILSPE(K:K).EQ.'.') THEN
             FILSPE(K:K)='_'
         END IF
         IF (FILSPE(K:K).EQ.' ') THEN
             KLENGT=K-1
             GO TO 1
         END IF
      END DO
C
   1  CONTINUE
C
      FILSPE=FILSPE(1:KLENGT)//'.dat'
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE SPENER_MONTEC
C
      INCLUDE 'MATDIM/NDMESH.f'
      INCLUDE 'MATDIM/NDSPEC.f'
      INCLUDE 'MATDIM/NDPARS.f'
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDLEXP.f'
      INCLUDE 'MATDIM/NDIM_M.f'
      INCLUDE 'MATDIM/NDTITL.f'
      INCLUDE 'MATDIM/NDLAST.f'
      INCLUDE 'MATDIM/NDBINS.f'
      INCLUDE 'MATDIM/NDMONT.f'
      INCLUDE 'MATDIM/NDCOLO.f'
C
      PARAMETER
     *          (NDMES2=NDMESH*NDMESH)
C
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6,VERSIO*3,FILNAM*256
      CHARACTER
     *          TITLES*12,TITLES_LATEXS*050,NUCNAM_LATEXS*010
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          LABREF*6,LABTHE*6,LABEXP*6,LABTEX*11,LABELS*100
      CHARACTER
     *          LABREF_PROTON*6,LABREF_NEUTRS*6
      CHARACTER
     *          HISTIT*256,HX_TIT*256,HY_TIT*256
C
      DIMENSION
     *          ARGMNT(1:NDPARS)
      DIMENSION
     *          SPEVEC_PROTON(1:NDMONT,1:NDSPEC),
     *          SPEVEC_NEUTRS(1:NDMONT,1:NDSPEC)
      DIMENSION
     *          LABREF_PROTON(1:NDSPEC),
     *          LABREF_NEUTRS(1:NDSPEC)
      DIMENSION
     *          LABELS(1:NDBINS,1:NDSPEC),
     *          XHISTO(1:NDBINS,1:NDSPEC),
     *          XHISTO_MINIMS(1:NDSPEC),
     *          XHISTO_MAXIMS(1:NDSPEC)
      DIMENSION
     *          BINSIZ(1:NDSPEC)
      DIMENSION
     *          YHISTO_UNNORM(1:NDBINS,1:NDSPEC),
     *          YHISTO_INTEGR(1:NDBINS,1:NDSPEC),
     *          YHISTO_MAXIMS(1:NDBINS,1:NDSPEC)
      DIMENSION
     *          YEXPEC(1:NDSPEC),
     *          ICOLOR_HISTOG(1:NDSPEC)
C      
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /PARCOR/ IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS

      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /VLIMIT/ VMISTR(1:NDPARS),
     *                VMIMIN(1:NDPARS),
     *                VMIMAX(1:NDPARS),
     *                VMISTP(1:NDPARS)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)  
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /GAUSSI/ PARPOT_XMEANS(1:NDPARS),
     *                PARPOT_SIGMAS(1:NDPARS)
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /ATTRIB/ ISTYLE,I_TYPE,ICOLOR(1:NDCOLO),ITHICK(1:NDCOLO)
      COMMON
     *       /VERSIN/ VERSIO
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C
C     This subroutine creates the histograms of the SPE levels .
C     It uses Monte-Carlo random generator to create LDMONT random
C     restarts. 
C
C     The random numbers are choosen using PARPOT_XMEANS
C     and PARPOT_SIGMAS distributed in a Gaussian Distribution.
C
C=======================================================================
C
                   INSEED=0!7893
      CALL ZBQLINI(INSEED)
C
      DO INUCLI=1,LDNUCL
         IF (ITAKNU(INUCLI).EQ.1) THEN
C
             IZ_FIX=NUMB_Z(INUCLI)
             IN_FIX=NUMB_N(INUCLI)
C
             CALL LOGMOC_CREATN(INUCLI,FILNAM)
             LOGMOC=44
             OPEN(UNIT=LOGMOC,FILE=FILNAM,STATUS='UNKNOWN')
C
             WRITE(LOGMOC,'(''  IMONTE'',$)')
             DO IPARAM=1,NDPARS
                IF (IFTAKE(IPARAM).EQ.1) THEN
                    WRITE(LOGMOC,'(3X,A8,$)')TITLES(IPARAM)(3:10)
                END IF
             END DO
             WRITE(LOGMOC,'(3X,''RMSVAL_p'',3x,''RMSVAL_n'')')
C
             DO IMONTE=1,LDMONT
C
                IF (LOGWRI.GT.0) THEN
                    WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *                             ''#  IMONTE= '',I6,T80,''#'',/,
     *                             ''#'',T80,''#'',/,80(''#''))')IMONTE
                END IF
C
                IACTIV=0
                DO IPARAM=1,NDPARS
C
                   IF (IFTAKE(IPARAM).EQ.1) THEN
C
                       IACTIV=IACTIV+1
C
                       GAUSIG=PARPOT_SIGMAS(IPARAM)
                       GAUSMU=PARPOT_XMEANS(IPARAM)
C
                       RANDOM=ZBQLNOR(GAUSMU,GAUSIG)
                       ARGMNT(IACTIV)=RANDOM
                       PARPOT(IPARAM)=RANDOM
C
                   END IF
C
                END DO !IPARAM
C
                WRITE(LOGMOC,'(I8,$)')IMONTE
                IACTIV=0
                DO IPARAM=1,NDPARS
                   IF (IFTAKE(IPARAM).EQ.1) THEN
                       IACTIV=IACTIV+1
                       WRITE(LOGMOC,'(3X,F8.4,$)')PARPOT(IPARAM)
                   END IF
                END DO
                WRITE(LOGMOC,'()')
C
C               Being sure that the random numbers have physical sense
C
                CALL VERIFY(ARGMNT,IABORT)
C
                IACTIV=0
                DO IPARAM=1,NDPARS
                   IF (IFTAKE(IPARAM).EQ.1) THEN
                       IACTIV=IACTIV+1
                       PARPOT(IPARAM)=ARGMNT(IACTIV)
                   END IF
                END DO
C
                WRITE(LOGMOC,'(I8,$)')IMONTE
                DO IPARAM=1,NDPARS
                   IF (IFTAKE(IPARAM).EQ.1) THEN
                       WRITE(LOGMOC,'(3X,F8.4,$)')PARPOT(IPARAM)
                   END IF
                END DO
C
C               Levels Calculation
C
                IDEFCN=0
                I_MODE=0
                I_FLAG=1
C
                CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,
     *                      I_FLAG,CHISQU_PROTON,CHISQU_NEUTRS)
C
                WRITE(LOGMOC,'(3X,F8.4,3X,F8.4)')SQRT(CHIWEI_PROTON),
     *                                           SQRT(CHIWEI_NEUTRS)
C
                LTPROT=LEVTHE_PROTON
                LTNEUT=LEVTHE_NEUTRS
C
C               Storing the reference label
C
                IF (IMONTE.EQ.1) THEN
                    DO IREFER=1,LTPROT
                       LABREF_PROTON(IREFER)=LABTHE_PROTON(IREFER)
                    END DO
                    DO IREFER=1,LTNEUT
                       LABREF_NEUTRS(IREFER)=LABTHE_NEUTRS(IREFER)
                    END DO
                END IF
C
C               Storing the results for each IMONTE (=restart)
C
                DO ITHEOR=1,LTPROT
                   DO IREFER=1,LTPROT
                      IF (LABTHE_PROTON(ITHEOR)
     *               .EQ. LABREF_PROTON(IREFER))THEN
                          SPEVEC_PROTON(IMONTE,ITHEOR)
     *                   =ENETHE_PROTON(ITHEOR)
                      END IF  
                   END DO       
                END DO
C
                DO ITHEOR=1,LTNEUT
                   DO IREFER=1,LTNEUT
                      IF (LABTHE_NEUTRS(ITHEOR)
     *               .EQ. LABREF_NEUTRS(IREFER)) THEN
                          SPEVEC_NEUTRS(IMONTE,ITHEOR)
     *                   =ENETHE_NEUTRS(ITHEOR)
                      END IF
                   END DO
                END DO
C 
             END DO !IMONTE
C_______________________________________________________________________
C
C            Once we have the LDMONT different results, 
C            we construct the histograms
C_______________________________________________________________________
C
C            Protons
C
             ISOSPI=1
C
             CALL HISTOG_FABRIC(LTPROT,SPEVEC_PROTON,LDHIST,BINSIZ,
     *                          XHISTO,XHISTO_MINIMS,XHISTO_MAXIMS,
     *                                 YHISTO_UNNORM,YHISTO_INTEGR,
     *                                               YHISTO_MAXIMS)
C
             DO ITHEOR=1,LTPROT
                DO IHISTO=1,LDHIST
                   LABTHE=LABREF_PROTON(ITHEOR)
                   CALL LATEXS_LABELS(LABTHE,LABTEX)
                   LABELS(IHISTO,ITHEOR)=LABTEX
                END DO
             END DO
C
C            Identifying the EXPECTED values (for plotting purposes)
C
             II=0
             DO ITHEOR=1,LTPROT
                YEXPEC(ITHEOR)=999.0
                ICOLOR_HISTOG(ITHEOR)=70
                DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                   IF (LABREF_PROTON(ITHEOR)
     *            .EQ. LABEXP_PROTON(INUCLI,IEXPER)) THEN
                       YEXPEC(ITHEOR)=EXPEXP_PROTON(INUCLI,IEXPER)
                       II=II+1
                       ICOLOR_HISTOG(ITHEOR)=ICOLOR(II)
                   END IF
                END DO
             END DO
C
             HISTIT='Proton Energy Distributions'
             HX_TIT='Energy (MeV)'
             HY_TIT='Probability Distribution'
C
             CALL HISTOG_PRINTI(LTPROT,LDHIST,XHISTO,YHISTO_MAXIMS,
     *                          XHISTO_MINIMS,XHISTO_MAXIMS,YEXPEC,
     *                          HISTIT,HX_TIT,HY_TIT,LABELS,INUCLI,
     *                                               ICOLOR_HISTOG)
C_______________________________________________________________________
C
C            Neutrons
C
             ISOSPI=0
C
             CALL HISTOG_FABRIC(LTNEUT,SPEVEC_NEUTRS,LDHIST,BINSIZ,
     *                          XHISTO,XHISTO_MINIMS,XHISTO_MAXIMS,
     *                                 YHISTO_UNNORM,YHISTO_INTEGR,
     *                                               YHISTO_MAXIMS)
C
             DO ITHEOR=1,LTNEUT
                DO IHISTO=1,LDHIST
                   LABTHE=LABREF_NEUTRS(ITHEOR)
                   CALL LATEXS_LABELS(LABTHE,LABTEX)
                   LABELS(IHISTO,ITHEOR)=LABTEX
                END DO
             END DO
C
C            Identifying the EXPECTED values (for plotting purposes)
C
             II=0
             DO ITHEOR=1,LTNEUT
                YEXPEC(ITHEOR)=999.0
                ICOLOR_HISTOG(ITHEOR)=70
                DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                   IF (LABREF_NEUTRS(ITHEOR)
     *            .EQ. LABEXP_NEUTRS(INUCLI,IEXPER)) THEN
                       YEXPEC(ITHEOR)=EXPEXP_NEUTRS(INUCLI,IEXPER)
                       II=II+1
                       ICOLOR_HISTOG(ITHEOR)=ICOLOR(II)
                   END IF
                END DO
             END DO
C
             HISTIT='Neutron Energy Distributions'
             HX_TIT='Energy (MeV)'
             HY_TIT='Probability Distribution'
C
             CALL HISTOG_PRINTI(LTNEUT,LDHIST,XHISTO,YHISTO_MAXIMS,
     *                          XHISTO_MINIMS,XHISTO_MAXIMS,YEXPEC,
     *                          HISTIT,HX_TIT,HY_TIT,LABELS,INUCLI,
     *                                               ICOLOR_HISTOG)
C
         END IF !ITAKNU
      END DO !INUCLI
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE LOGMOC_CREATN(INUCLI,FILNAM)
C
      INCLUDE 'MATDIM/NDNUCL.f'
C
      CHARACTER
     *          FILNAM*256,NUCSYM*6,TYPCHI*6,TEXLAM*20,NUCNAM*6,
     *                                                 VERSIO*3
C      
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /PARCOR/ IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS
      COMMON
     *       /VERSIN/ VERSIO
C
C=======================================================================
C
      WRITE(NUCNAM,'(A6)') NUCSYM(INUCLI)
C
      J1=1
      J2=6
      IF (NUCNAM(1:1).EQ.' ') J1=2
      IF (NUCNAM(2:2).EQ.' ') J1=3
      IF (NUCNAM(3:3).EQ.' ') J1=4
C
C=======================================================================
C
      IF (IFDENS.EQ.0) THEN
          WRITE(FILNAM,'(''LogFMont/IFDENS-0/SPE-MC_'',A,
     *                  ''_IFDENS-'',I1,''_IFTENS-'',I1,''_IF-PAI-'',I1,
     *                  ''_IF-RAD-'',I1,''_IF-ORD-'',I1,''_IFDEEP-'',I1,
     *                  ''_IFPRON-'',I1,
     *                  ''_IFCORR-'',I1,''_IFRCVC-'',I1,''_IFRCAC-'',I1,
     *                  ''_IFVCAC-'',I1,''_IFRSVS-'',I1,''_IFRSAS-'',I1,
     *                  ''_IFVSAS-'',I1,
     *                  ''_'',A3,''.log'')')
     *
     *               NUCNAM(J1:J2),IFDENS,IFTENS,IF_PAI,
     *               IF_RAD,IF_INV,IFDEEP,IFPRON,IFCORR,IFRCVC,
     *               IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS,VERSIO
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.1 .AND. IFTENS.EQ.0) THEN
C
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                            IFPAR1,IFPAR2,IFPAR3,IFPAR4
C
          WRITE(FILNAM,'(''LogFMont/IFDENS-1_IFTENS-0/SPE-MC_'',A,
     *                  ''_IFDENS-'',I1,''_IFTENS-'',I1,''_IF-PAI-'',I1,
     *                  ''_IF-RAD-'',I1,''_IF-ORD-'',I1,''_IFDEEP-'',I1,
     *                  ''_IFPRON-'',I1,
     *                  ''_IFCORR-'',I1,''_IFRCVC-'',I1,''_IFRCAC-'',I1,
     *                  ''_IFVCAC-'',I1,''_IFRSVS-'',I1,''_IFRSAS-'',I1,
     *                  ''_IFVSAS-'',I1,
     *                  A15,''_'',A3,''.log'')')
     *
     *               NUCNAM(J1:J2),
     *               IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,IFDEEP,IFPRON,
     *               IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS,
     *                                                  TEXLAM,VERSIO
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.1 .AND. IFTENS.EQ.1) THEN
C
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                            IFPAR1,IFPAR2,IFPAR3,IFPAR4
C
          WRITE(FILNAM,'(''LogFMont/IFDENS-1_IFTENS-0/SPE-MC_'',A,
     *                  ''_IFDENS-'',I1,''_IFTENS-'',I1,''_IF-PAI-'',I1,
     *                  ''_ICENTT-'',I1,''_ISORBT-'',I1,''_ITENSR-'',I1,
     *                  ''_IF-RAD-'',I1,''_IF-ORD-'',I1,''_IFDEEP-'',I1,
     *                  ''_IFPRON-'',I1,
     *                  ''_IFCORR-'',I1,''_IFRCVC-'',I1,''_IFRCAC-'',I1,
     *                  ''_IFVCAC-'',I1,''_IFRSVS-'',I1,''_IFRSAS-'',I1,
     *                  ''_IFVSAS-'',I1,
     *                  A15,''_'',A3,''.log'')')
     *
     *               NUCNAM(J1:J2),
     *               IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *               IF_RAD,IF_INV,IFDEEP,IFPRON,IFCORR,IFRCVC,
     *               IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS,TEXLAM,VERSIO
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE HISTOG_FABRIC(LDCURV,SPEVEC,LDHIST,BINSIZ,XHISTO,
     *                                XHISTO_MINIMS,XHISTO_MAXIMS,
     *                                YHISTO_UNNORM,YHISTO_INTEGR,
     *                                              YHISTO_MAXIMS)
C
      INCLUDE 'MATDIM/NDSPEC.f'
      INCLUDE 'MATDIM/NDMONT.f'
      INCLUDE 'MATDIM/NDBINS.f'
C
      DIMENSION
     *          SPEVEC(1:NDMONT,1:NDSPEC)
      DIMENSION
     *          XAUXIL_HISTOG(1:NDBINS,1:NDSPEC),
     *          YAUXIL_HISTOG(1:NDBINS,1:NDSPEC)
      DIMENSION
     *          XHISTO(1:NDBINS,1:NDSPEC),
     *          XHISTO_MINIMS(1:NDSPEC),
     *          XHISTO_MAXIMS(1:NDSPEC)
      DIMENSION
     *          YHISTO_UNNORM(1:NDBINS,1:NDSPEC),
     *          YHISTO_INTEGR(1:NDBINS,1:NDSPEC),
     *          YHISTO_MAXIMS(1:NDBINS,1:NDSPEC)
      DIMENSION
     *          BINSIZ(1:NDSPEC)
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(''Entering to HISTOG_FABRIC'')')
      END IF
C
C=======================================================================
C
      DO K=1,NDBINS
         DO J=1,LDCURV
            YHISTO_UNNORM(K,J)=0.0
            YHISTO_INTEGR(K,J)=0.0
            YHISTO_MAXIMS(K,J)=0.0
            YAUXIL_HISTOG(K,J)=0.0
        END DO
      END DO
C
C=======================================================================
C
      DO J=1,LDCURV
C
         XMINIM=+1.0E+10
         XMAXIM=-1.0E+10
C
         DO I=1,LDMONT
C
            IF (XMINIM.GT.SPEVEC(I,J)) THEN
                XMINIM=SPEVEC(I,J)
            END IF
C
            IF (XMAXIM.LT.SPEVEC(I,J)) THEN
                XMAXIM=SPEVEC(I,J)
            END IF
C
         END DO
C_______________________________________________________________________
C
C                                        Defining the bins
         XHISTO_MINIMS(J)=XMINIM
         XHISTO_MAXIMS(J)=XMAXIM
C
         BINSIZ(J)=(XMAXIM-XMINIM)/LDBINS         
C
         DO K=1,LDBINS+1
            XAUXIL_HISTOG(K,J)=XMINIM+(K-1)*BINSIZ(J) !histogram X-axis
         END DO
C_______________________________________________________________________
C
C                                        Begining to count
         DO K=1,LDBINS+1   
            DO I=1,LDMONT
C         
               IF (SPEVEC(I,J).LT.XAUXIL_HISTOG(K+1,J).AND.
     *             SPEVEC(I,J).GE.XAUXIL_HISTOG( K ,J)) THEN
C     
                   YAUXIL_HISTOG(K,J)=YAUXIL_HISTOG(K,J)+1.0
C                   
               END IF
C         
            END DO     
         END DO
C
      END DO  !J=1,LDCURV
C
C=======================================================================
C
C     Beautifying the histograms: arraging x-axis and normalizations
C
      Y_MAXI=-1.0E+10
      DO J=1,LDCURV
C
         K=1
         XHISTO(K,J)=XHISTO_MINIMS(J)-BINSIZ(J)
         YHISTO_UNNORM(K,J)=0.0000
C
         K=K+1
         XHISTO(K,J)=XHISTO_MINIMS(J)
         YHISTO_UNNORM(K,J)=0.0000
C
         DO I=1,LDBINS
C
            K=K+1
            XHISTO(K,J)=XHISTO_MINIMS(J)+(I-1)*BINSIZ(J)
            YHISTO_UNNORM(K,J)=YAUXIL_HISTOG(I,J)
C
            K=K+1
            XHISTO(K,J)=XHISTO_MINIMS(J)+I*BINSIZ(J)
            YHISTO_UNNORM(K,J)=YAUXIL_HISTOG(I,J)
C
         END DO
C
         K=K+1
         XHISTO(K,J)=XHISTO_MINIMS(J)+LDBINS*BINSIZ(J)
         YHISTO_UNNORM(K,J)=0.0000
C
         K=K+1
         XHISTO(K,J)=XHISTO_MINIMS(J)+(LDBINS+1)*BINSIZ(J)
         YHISTO_UNNORM(K,J)=0.0000
C
         LDHIST=K
C
         IF (LDHIST.GT.NDBINS) THEN
C
             WRITE(LOGFIL,'(/,''Actual No. of bins, LDHIST='',I5,1x,
     *                        ''exceeds the limit NDBINS='',I5,/)')
     *                                     LDHIST,NDBINS
C
             WRITE(000000,'(/,''Actual No. of bins, LDHIST='',I5,1x,
     *                        ''exceeds the limit NDBINS='',I5,/)')
     *                                     LDHIST,NDBINS
C
             STOP 'Actual number of bins out of allowed limit'
C
         END IF 
C_______________________________________________________________________
C
C                                  Normalization 1: Integral ->> Area
C
         XINTEG=0.0
         DO K=1,LDHIST,2
            XINTEG=XINTEG+YHISTO_UNNORM(K,J)*BINSIZ(J)
         END DO
C
         DO K=1,LDHIST
            YHISTO_INTEGR(K,J)=YHISTO_UNNORM(K,J)/XINTEG
         END DO
C_______________________________________________________________________
C
C                                  Normalization 2: Histog. maxim
C
         DO K=1,LDHIST
            IF (Y_MAXI.LT.YHISTO_UNNORM(K,J)) THEN
                Y_MAXI=YHISTO_UNNORM(K,J)
            END IF
         END DO
C
      END DO
C
      DO J=1,LDCURV
         DO K=1,LDHIST
            YHISTO_MAXIMS(K,J)=YHISTO_UNNORM(K,J)/Y_MAXI
         END DO
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(''Exiting HISTOG_FABRIC'')')
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE HISTOG2FABRIC(N_READ,NDCURV,LDCURV,LDHIST,
     *                         XHISTO_MAXIMS,XHISTO_MINIMS,
     *                         BINSIZ,XHISTO,YHISTO_UNNORM,
     *                         YHISTO_INTEGR,YHISTO_MAXIMS)
C
      INCLUDE 'MATDIM/NDBINS.f'
C
      DIMENSION
     *          VECTOR(1:NDCURV)
      DIMENSION
     *          XAUXIL_HISTOG(1:NDBINS,1:NDCURV),
     *          YAUXIL_HISTOG(1:NDBINS,1:NDCURV)
      DIMENSION
     *          XHISTO(1:NDBINS,1:NDCURV),
     *          XHISTO_MINIMS(1:NDCURV),
     *          XHISTO_MAXIMS(1:NDCURV)
      DIMENSION
     *          YHISTO_UNNORM(1:NDBINS,1:NDCURV),
     *          YHISTO_INTEGR(1:NDBINS,1:NDCURV),
     *          YHISTO_MAXIMS(1:NDBINS,1:NDCURV)
      DIMENSION
     *          BINSIZ(1:NDCURV)
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C
C=======================================================================
C
C     This subroutine creates the histograms reading the data from
C     temporary files. As input we have to give the maxima and the
C     minima so that the subroutine can compute the bin sizes.
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(''Entering to HISTOG2FABRIC'')')
      END IF
C
C=======================================================================
C
C     Initializing the necessary quantities
C
      DO K=1,NDBINS
         DO J=1,LDCURV
            YHISTO_UNNORM(K,J)=0.0
            YHISTO_INTEGR(K,J)=0.0
            YHISTO_MAXIMS(K,J)=0.0
            YAUXIL_HISTOG(K,J)=0.0
         END DO
      END DO
C
C=======================================================================
C
C     Creating the size of the bins
C
      DO ICURVE=1,LDCURV
C
         BINSIZ(ICURVE)=(XHISTO_MAXIMS(ICURVE)-XHISTO_MINIMS(ICURVE))
     *                 /LDBINS
C
         DO K_BINS=1,LDBINS+1
            XAUXIL_HISTOG(K_BINS,ICURVE)=XHISTO_MINIMS(ICURVE)
     *                                  +(K_BINS-1)*BINSIZ(ICURVE)
         END DO
C
      END DO
C
C=======================================================================
C
C     Reading the file and counting
C
      DO IMONTE=1,LDMONT
C
         READ(N_READ,*)JDUMMY,(VECTOR(I),I=1,LDCURV)
C
         DO ICURVE=1,LDCURV
            DO K_BINS=1,LDBINS
C
               IF (VECTOR(ICURVE).LT.XAUXIL_HISTOG(K_BINS+1,ICURVE)
     *        .AND.VECTOR(ICURVE).GE.XAUXIL_HISTOG(K_BINS,ICURVE)) THEN
C
                   YAUXIL_HISTOG(K_BINS,ICURVE)
     *            =YAUXIL_HISTOG(K_BINS,ICURVE)+1.0
C
               END IF
C
            END DO
         END DO
C
      END DO
C
C=======================================================================
C
C     Beautifying the histograms(I): arraging x-axis
C
      DO ICURVE=1,LDCURV
C
         K=1
         XHISTO(K,ICURVE)=XHISTO_MINIMS(ICURVE)-BINSIZ(ICURVE)
         YHISTO_UNNORM(K,ICURVE)=0.0000
C
         K=K+1
         XHISTO(K,ICURVE)=XHISTO_MINIMS(ICURVE)
         YHISTO_UNNORM(K,ICURVE)=0.0000
C
         DO I=1,LDBINS
C
            K=K+1
            XHISTO(K,ICURVE)=XHISTO_MINIMS(ICURVE)+(I-1)*BINSIZ(ICURVE)
            YHISTO_UNNORM(K,ICURVE)=YAUXIL_HISTOG(I,ICURVE)
C
            K=K+1
            XHISTO(K,ICURVE)=XHISTO_MINIMS(ICURVE)+I*BINSIZ(ICURVE)
            YHISTO_UNNORM(K,ICURVE)=YAUXIL_HISTOG(I,ICURVE)
C
         END DO
C
         K=K+1
         XHISTO(K,ICURVE)=XHISTO_MINIMS(ICURVE)+LDBINS*BINSIZ(ICURVE)
         YHISTO_UNNORM(K,ICURVE)=0.0000
C
         K=K+1
         XHISTO(K,ICURVE)=XHISTO_MINIMS(ICURVE)+(LDBINS+1)
     *                                         *BINSIZ(ICURVE)
         YHISTO_UNNORM(K,ICURVE)=0.0000
C
         LDHIST=K
C_______________________________________________________________________
C
         IF (LDHIST.GT.NDBINS) THEN
C
             WRITE(LOGFIL,'(/,''Actual No. of bins, LDHIST='',I5,1x,
     *                        ''exceeds the limit NDBINS='',I5,/)')
     *                                     LDHIST,NDBINS
C
             WRITE(000000,'(/,''Actual No. of bins, LDHIST='',I5,1x,
     *                        ''exceeds the limit NDBINS='',I5,/)')
     *                                     LDHIST,NDBINS
C
             STOP
     *      'HISTOG2FRABRIC: Actual number of bins out of allowed limit'
C
         END IF
C
      END DO
C
C=======================================================================
C
C     Beautifying the histograms (II): normalizations
C
C                                  Normalization 1: Integral ->> Area
C
      DO ICURVE=1,LDCURV
C
         XINTEG=0.0
         DO K_BINS=1,LDHIST,2
            XINTEG=XINTEG+YHISTO_UNNORM(K_BINS,ICURVE)*BINSIZ(ICURVE)
         END DO
C
         DO K_BINS=1,LDHIST
            YHISTO_INTEGR(K_BINS,ICURVE)=YHISTO_UNNORM(K_BINS,ICURVE)
     *                                  /XINTEG
         END DO
C
      END DO
C
C                                  Normalization 2: Histog. maxim
C
      Y_MAXI=-1.0E+10
      DO ICURVE=1,LDCURV
         DO K_BINS=1,LDHIST
            IF (Y_MAXI.LT.YHISTO_UNNORM(K_BINS,ICURVE)) THEN
                Y_MAXI=YHISTO_UNNORM(K_BINS,ICURVE)
            END IF
         END DO
      END DO
C
      DO ICURVE=1,LDCURV
         DO K_BINS=1,LDHIST
            YHISTO_MAXIMS(K_BINS,ICURVE)=YHISTO_UNNORM(K_BINS,ICURVE)
     *                                  /Y_MAXI
         END DO
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(''Exiting HISTOG2FABRIC'')')
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE HISTOG_PRINTI(LDCURV,LDHIST,XHISTO,YHISTO,
     *                         XHISTO_MINIMS,XHISTO_MAXIMS,YEXPEC,
     *                         HISTIT,HX_TIT,HY_TIT,LABELS,INUCLI,
     *                                              ICOLOR_HISTOG)
C
      INCLUDE 'MATDIM/NDMESH.f'
      INCLUDE 'MATDIM/NDSPEC.f'
      INCLUDE 'MATDIM/NDPARS.f'
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDCOLO.f'
      INCLUDE 'MATDIM/NDTITL.f'
      INCLUDE 'MATDIM/NDBINS.f'
C
      PARAMETER
     *         (NDMES2=NDMESH*NDMESH)
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6,VERSIO*3
      CHARACTER
     *          FILNAM*256,LABELS*100,NUCNAM*06,TITLES*12,
     *          ISONAM*002,TEXLAM*020,TITPAR*13,FITNUC*02,
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010
      CHARACTER
     *          HISTIT*256,HX_TIT*256,HY_TIT*256
      CHARACTER
     *          FILNAM_IFITED*14,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*02,PARNAM*8
      CHARACTER
     *          AUXTX1*30,AUXTX2*30,AUXTX3*30,AUXTX4*30,
     *          AUXTX5*30,AUXTX6*30
C
      DIMENSION
     *          XHISTO(1:NDBINS,1:NDSPEC),
     *          YHISTO(1:NDBINS,1:NDSPEC),
     *          LABELS(1:NDBINS,1:NDSPEC)
      DIMENSION
     *          XHISTO_MINIMS(1:NDSPEC),
     *          XHISTO_MAXIMS(1:NDSPEC)
      DIMENSION
     *          YEXPEC(1:NDSPEC),
     *          YHISTO_MAXIMS(1:NDSPEC),
     *          XPOSIT_YMAXIM(1:NDSPEC)
      DIMENSION
     *          ICOLOR_HISTOG(1:NDSPEC)
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL)
      DIMENSION
     *          PARPOT_PRINTI(1:NDPARS,1:NDMES2),
     *          RMSVAL(1:NDSPEC,1:NDNUCL)      
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /PARCOR/ IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /VERSIN/ VERSIO
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /GAUSSI/ PARPOT_XMEANS(1:NDPARS),
     *                PARPOT_SIGMAS(1:NDPARS)
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)

      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' /
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(/,''Entering HISTOG_PRINTI'')')
C
      IF (LOGWRI.GT.0) 
     *    WRITE(LOGFIL,'(/,'' IZ= '',I3,'' IN= '',I3,/)') 
     *                        IZ_FIX,IN_FIX
C
C=======================================================================
C
      NRESUL=60
C      
      IF (ISOSPI.EQ.1) ISONAM='-P'
      IF (ISOSPI.EQ.0) ISONAM='-N'
C
C=======================================================================
C 
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
      
      I1=3*KACTIV
      
      WRITE(FILNAM_NUCFIT,'(''_'',<NUCACT>(A2,''-''))')
     *                      (FITNUC_AUXILI(I),I=1,NUCACT)
C
C=======================================================================
C
      WRITE(NUCNAM,'(A6)') NUCSYM(INUCLI)
      
      J1=1
      J2=6
      IF (NUCNAM(1:1).EQ.' ') J1=2
      IF (NUCNAM(2:2).EQ.' ') J1=3
      IF (NUCNAM(3:3).EQ.' ') J1=4
C
C=======================================================================
C
      IF (IFDENS.EQ.0) THEN
          WRITE(FILNAM,'(''SPEMontC/IFDENS-0/SPE-MC_'',A,A2,
     *                  ''_IFDENS-'',I1,''_IFTENS-'',I1,''_IF-PAI-'',I1,
     *                  ''_IF-RAD-'',I1,''_IF-ORD-'',I1,''_IFDEEP-'',I1,
     *                  ''_IFPRON-'',I1,
     *                  ''_IFCORR-'',I1,''_IFRCVC-'',I1,''_IFRCAC-'',I1,
     *                  ''_IFVCAC-'',I1,''_IFRSVS-'',I1,''_IFRSAS-'',I1,
     *                  ''_IFVSAS-'',I1,
     *                  ''_'',A3,''.dat'')')
     *
     *               NUCNAM(J1:J2),ISONAM,IFDENS,IFTENS,IF_PAI,
     *               IF_RAD,IF_INV,IFDEEP,IFPRON,IFCORR,IFRCVC,
     *               IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS,VERSIO
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.1 .AND. IFTENS.EQ.0) THEN
C
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                            IFPAR1,IFPAR2,IFPAR3,IFPAR4
C
          WRITE(FILNAM,'(''SPEMontC/IFDENS-1_IFTENS-0/SPE-MC_'',A,A2,
     *                  ''_IFDENS-'',I1,''_IFTENS-'',I1,''_IF-PAI-'',I1,
     *                  ''_IF-RAD-'',I1,''_IF-ORD-'',I1,''_IFDEEP-'',I1,
     *                  ''_IFPRON-'',I1,
     *                  ''_IFCORR-'',I1,''_IFRCVC-'',I1,''_IFRCAC-'',I1,
     *                  ''_IFVCAC-'',I1,''_IFRSVS-'',I1,''_IFRSAS-'',I1,
     *                  ''_IFVSAS-'',I1,
     *                  A15,''_'',A3,''.dat'')')
     *
     *               NUCNAM(J1:J2),ISONAM,
     *               IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,IFDEEP,IFPRON,
     *               IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS,
     *                                                  TEXLAM,VERSIO
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.1 .AND. IFTENS.EQ.1) THEN
C
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                            IFPAR1,IFPAR2,IFPAR3,IFPAR4
C
          WRITE(FILNAM,'(''SPEMontC/IFDENS-1_IFTENS-0/SPE-MC_'',A,A2,
     *                  ''_IFDENS-'',I1,''_IFTENS-'',I1,''_IF-PAI-'',I1,
     *                  ''_ICENTT-'',I1,''_ISORBT-'',I1,''_ITENSR-'',I1,
     *                  ''_IF-RAD-'',I1,''_IF-ORD-'',I1,''_IFDEEP-'',I1,
     *                  ''_IFPRON-'',I1,
     *                  ''_IFCORR-'',I1,''_IFRCVC-'',I1,''_IFRCAC-'',I1,
     *                  ''_IFVCAC-'',I1,''_IFRSVS-'',I1,''_IFRSAS-'',I1,
     *                  ''_IFVSAS-'',I1,
     *                  A15,''_'',A3,''.dat'')')
     *
     *               NUCNAM(J1:J2),ISONAM,
     *               IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *               IF_RAD,IF_INV,IFDEEP,IFPRON,IFCORR,IFRCVC,
     *               IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS,TEXLAM,VERSIO
      END IF
C
C=======================================================================
C
      OPEN(NRESUL,FILE=FILNAM,STATUS='UNKNOWN')
C
C=======================================================================
C
      XMINIM=+1.0E+10
      XMAXIM=-1.0E+10
C
      DO ICURVE=1,LDCURV
         IF (XHISTO_MINIMS(ICURVE).LT.XMINIM) THEN
             XMINIM=XHISTO_MINIMS(ICURVE)
         END IF
         IF (XHISTO_MAXIMS(ICURVE).GT.XMAXIM) THEN
             XMAXIM=XHISTO_MAXIMS(ICURVE)
         END IF
      END DO
C
      YMINIM=+1.0E+10
      YMAXIM=-1.0E+10
C
      DO ICURVE=1,LDCURV
         DO IPOINT=1,LDHIST
            IF (YHISTO(IPOINT,ICURVE).LT.YMINIM) THEN
                YMINIM=YHISTO(IPOINT,ICURVE)
            END IF
            IF (YHISTO(IPOINT,ICURVE).GT.YMAXIM) THEN
                YMAXIM=YHISTO(IPOINT,ICURVE)
            END IF
         END DO
      END DO
C
C=======================================================================
C
      DO ICURVE=1,LDCURV
         YHISTO_MAXIMS(ICURVE)=-1.0E+10
         DO IPOINT=1,LDHIST
            IF (YHISTO(IPOINT,ICURVE).GT.YHISTO_MAXIMS(ICURVE)) THEN
                YHISTO_MAXIMS(ICURVE)=YHISTO(IPOINT,ICURVE)
                XPOSIT_YMAXIM(ICURVE)=XHISTO(IPOINT,ICURVE)
            END IF
         END DO
      END DO
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<CODEVERSIO>> VERSIO'')')
C
      WRITE(NRESUL,'(16X,A3)') VERSIO
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<MAIN_TITLE>>'')')
C      
      WRITE(NRESUL,'(15X,A,/)') HISTIT
C
C=======================================================================
C     
      WRITE(NRESUL,'(''<<NUCLIDINFO>>'',1X,''NUMB_Z'',2X,''NUMB_N'')')
C
      WRITE(NRESUL,'(15X,I3,6X,I3,/)') IZ_FIX,IN_FIX
C
      A_MASS=IZ_FIX+IN_FIX
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<NoNUCACTIV>>'',1X,''NUCACT'')')
C      
      WRITE(NRESUL,'(15X,I3,/)') NUCACT
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<EXPER_FILE>>'',1X,''IFDEEP'',2X
     *                                     ''IFPRON'')')
      
      WRITE(NRESUL,'(15X,2(I3,6X),/)') IFDEEP,IFPRON
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<POTEN_INFO>>'',1X,''ISOSPI'',2X,''IFDENS'',
     *                                  2X,''IFTENS'',2X,''IF_PAI'')')
C      
      WRITE(NRESUL,'(15X,4(I3,5X),/)') ISOSPI,IFDENS,IFTENS,IF_PAI
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<TENSR_INFO>>'',1X,''ICENTT'',2X
     *                                     ''ISORBT'',2X,''ITENSR'')')
C      
      WRITE(NRESUL,'(15X,3(I3,5X),/)') ICENTT,ISORBT,ITENSR
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<TAKEN_CHI2>> IF_SPE  IF_RAD  IF_GAP  '',
     *               ''IF_FER  IF_DEN  IF_RHO  IF_INV'')')
      WRITE(NRESUL,'(15X,7(I3,5X),/)')IF_SPE,IF_RAD,IF_GAP,IF_FER,
     *                                       IF_DEN,IF_RHO,IF_INV
C
C=======================================================================
C      
      WRITE(NRESUL,'(''<<XAXIS_TEXT>>'',/,15x,A,/)') HX_TIT
C      
      WRITE(NRESUL,'(''<<YAXIS_TEXT>>'',/,15x,A,/)') HY_TIT
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<SIDE_TEXTS>>'')')
C
      AUXTX1=' '
      AUXTX2=' '
      AUXTX3=' '
      AUXTX4=' '
      AUXTX5=' '
      AUXTX6=' '
C
      IF (IFDENS.EQ.1) AUXTX1='${\\rm DENS}\\,\\vert\\,$'
      IF (IFTENS.EQ.1) AUXTX2='${\\rm TENS}\\,\\vert\\,$'
      IF (IF_PAI.EQ.1) AUXTX3='${\\rm PAIR}\\,\\vert\\,$'
      IF (IF_RAD.EQ.1) AUXTX4='${\\rm RADI}\\,\\vert\\,$'
      IF (IFDEEP.EQ.1) AUXTX5='${\\rm DEEP}\\,\\vert\\,$'
      IF (IFPRON.EQ.1) AUXTX6='${\\rm PRON}\\,\\vert\\,$'
C
      WRITE(NRESUL,'(15X,''~~~Id: $\\rm LDMONT= '',I6,
     *                           ''\\,\\vert\\,$'',6A)')
     *            LDMONT,AUXTX1,AUXTX2,AUXTX3,AUXTX4,AUXTX5,AUXTX6
C
      IF (ISOSPI.EQ.1) THEN
          WRITE(NRESUL,'(15X,''~~~$\\sigma_{V_c}= '',f6.4,
     *                       ''\\,\\vert\\,$'',
     *                       '' $\\sigma_{r_c}= '',f6.4,
     *                       ''\\,\\vert\\,$'',
     *                       '' $\\sigma_{a_c}= '',f6.4,''$'')')
     *       PARPOT_SIGMAS(1),PARPOT_SIGMAS(2),PARPOT_SIGMAS(3)
          WRITE(NRESUL,'(15X,''~~~$\\sigma_{\\lambda_{so}}= '',f6.4,
     *                       ''\\,\\vert\\,$'',
     *                       '' $\\sigma_{r_{so}}= '',f6.4,
     *                       ''\\,\\vert\\,$'',
     *                       '' $\\sigma_{a_{so}}= '',f6.4,''$'')')
     *       PARPOT_SIGMAS(4),PARPOT_SIGMAS(5),PARPOT_SIGMAS(6)
      END IF
C
      IF (ISOSPI.EQ.0) THEN
          WRITE(NRESUL,'(15X,''~~~$\\sigma_{V_c}= '',f6.4,
     *                       ''\\,\\vert\\,$'',
     *                       '' $\\sigma_{r_c}= '',f6.4,
     *                       ''\\,\\vert\\,$'',
     *                       '' $\\sigma_{a_c}= '',f6.4,''$'')')
     *       PARPOT_SIGMAS(21),PARPOT_SIGMAS(22),PARPOT_SIGMAS(23)
          WRITE(NRESUL,'(15X,''~~~$\\sigma_{\\lambda_{so}}= '',f6.4,
     *                       ''\\,\\vert\\,$'',
     *                       '' $\\sigma_{r_{so}}= '',f6.4,
     *                       ''\\,\\vert\\,$'',
     *                       '' $\\sigma_{a_{so}}= '',f6.4,''$'')')
     *       PARPOT_SIGMAS(24),PARPOT_SIGMAS(25),PARPOT_SIGMAS(26)
      END IF
C
C=======================================================================
C     
      WRITE(NRESUL,'(/,15X,30(''=''),/)')
          
      WRITE(NRESUL,'(''<<X_AX_PARAM>> XMINIM_FIG  XMAXIM_FIG  '',
     *                   ''X_STEP_FIG'')')
          
      WRITE(NRESUL,'(15X,3(F10.2,2X),/)')XMINIM,XMAXIM,(XMAXIM-XMINIM)
     
      WRITE(NRESUL,'(''<<Y_AX_PARAM>> YMINIM_FIG  YMAXIM_FIG  '',
     *                   ''Y_STEP_FIG'')')
          
      WRITE(NRESUL,'(15X,3(F10.2,2X),/)')
     *                         YMINIM,YMAXIM,(YMAXIM-YMINIM)
     
      WRITE(NRESUL,'(15X,30(''=''),/)')
C
C=======================================================================
C
      I_COLM=0
      I_LEFT=0
      I_RIGH=0
C
      WRITE(NRESUL,'(''<<WHATLEGEND>>'',1X,''COLM_LABEL'',2X,
     *               ''LEFT_LABEL'',2X,''RIGH_LABEL'')')
      WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5)')I_COLM,I_LEFT,I_RIGH
C
C=======================================================================
C      
      IFBULL=0
      IFHIST=1
      IFOVER=0
C      
      WRITE(NRESUL,'(/,''<<NO_OF_CURV>>'',1X,''NUMB_CURVE'',2X,
     *                 ''IF_BULLETS'',2X,
     *                 ''IF_HISTOGS'',2X,''IF_OVERFITING'')')
      WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5,7X,I5,7X,I5)')LDCURV,
     *                                         IFBULL,IFHIST,IFOVER
C
C=======================================================================
C
      ISTYLE=0
      I_TYPE=3
      ITHICK=3
C      ICOLOR=70
C
      DO I_CURV=1,LDCURV
C
         WRITE(NRESUL,'(''<<>>'')')
         WRITE(NRESUL,'(''<<CURVE_'',I4.4,''>>'',1X,
     *                  ''THICK_LINE'',2X,''STYLE_LINE'',2X,
     *                  ''COLOR_LINE'',2X,''TYPE_POINT'')')I_CURV
         WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5,7X,I5)')ITHICK,ISTYLE,
     *                                      ICOLOR_HISTOG(I_CURV),
     *                                                    I_TYPE
         WRITE(NRESUL,'(15X,''NUMB_POINT'',2X,''YXPECTED_V'',
     *                   2X,''XPOSI_YMAX'')')
         WRITE(NRESUL,'(15X,I10,2X,F10.4,2X,F10.4)')
     *                      LDHIST,YEXPEC(I_CURV),XPOSIT_YMAXIM(I_CURV)
C
         DO IPOINT=1,LDHIST
C
            WRITE(NRESUL,'(15X,F10.4,4X,E12.4,4X,A100)') 
     *                           XHISTO(IPOINT,I_CURV),
     *                           YHISTO(IPOINT,I_CURV),
     *                           LABELS(IPOINT,I_CURV)
C
         END DO
C
      END DO
C
C=======================================================================
C      
      WRITE(NRESUL,'(/,''<<GO_GETTHEM>>'',/)')
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE HISTOG2PRINTI(NDCURV,LDCURV,LDHIST,
     *                         XHISTO,YHISTO,LABELS,
     *                         YEXPEC,HISTIT,HX_TIT,
     *                         HY_TIT,ICOLOR_HISTOG,
     *                                       NRESUL)
C
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDPARS.f'
      INCLUDE 'MATDIM/NDCOLO.f'
      INCLUDE 'MATDIM/NDTITL.f'
      INCLUDE 'MATDIM/NDBINS.f'
C
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6,VERSIO*3
      CHARACTER
     *          FILNAM*256,LABELS*100,NUCNAM*05,TITLES*12,
     *          ISONAM*002,TEXLAM*020,TITPAR*13,FITNUC*02,
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010
      CHARACTER
     *          HISTIT*256,HX_TIT*256,HY_TIT*256
      CHARACTER
     *          FILNAM_IFITED*14,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*02,PARNAM*8
      CHARACTER
     *          AUXTX1*30,AUXTX2*30,AUXTX3*30,AUXTX4*30,
     *          AUXTX5*30,AUXTX6*30
C
      DIMENSION
     *          XHISTO(1:NDBINS,1:NDCURV),
     *          YHISTO(1:NDBINS,1:NDCURV),
     *          LABELS(1:NDBINS,1:NDCURV)
      DIMENSION
     *          XHISTO_MINIMS(1:NDCURV),
     *          XHISTO_MAXIMS(1:NDCURV)
      DIMENSION
     *          YEXPEC(1:NDCURV),
     *          YHISTO_MAXIMS(1:NDCURV),
     *          XPOSIT_YMAXIM(1:NDCURV)
      DIMENSION
     *          ICOLOR_HISTOG(1:NDCURV)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /PARCOR/ IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)

      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /VERSIN/ VERSIO
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /GAUSSI/ PARPOT_XMEANS(1:NDPARS),
     *                PARPOT_SIGMAS(1:NDPARS)
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)

      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(/,''Entering HISTOG2PRINTI'')')
C
C=======================================================================
C
      XMINIM=+1.0E+10
      XMAXIM=-1.0E+10
C
      DO ICURVE=1,LDCURV
         DO IPOINT=1,LDHIST
             IF (XHISTO(IPOINT,ICURVE).LT.XMINIM) THEN
                 XMINIM=XHISTO(IPOINT,ICURVE)
             END IF
             IF (XHISTO(IPOINT,ICURVE).GT.XMAXIM) THEN
                 XMAXIM=XHISTO(IPOINT,ICURVE)
             END IF
          END DO
      END DO
C
      YMINIM=+1.0E+10
      YMAXIM=-1.0E+10
C
      DO ICURVE=1,LDCURV
         DO IPOINT=1,LDHIST
            IF (YHISTO(IPOINT,ICURVE).LT.YMINIM) THEN
                YMINIM=YHISTO(IPOINT,ICURVE)
            END IF
            IF (YHISTO(IPOINT,ICURVE).GT.YMAXIM) THEN
                YMAXIM=YHISTO(IPOINT,ICURVE)
            END IF
         END DO
      END DO
C
C=======================================================================
C
      DO ICURVE=1,LDCURV
         YHISTO_MAXIMS(ICURVE)=-1.0E+10
         DO IPOINT=1,LDHIST
            IF (YHISTO(IPOINT,ICURVE).GT.YHISTO_MAXIMS(ICURVE)) THEN
                YHISTO_MAXIMS(ICURVE)=YHISTO(IPOINT,ICURVE)
                XPOSIT_YMAXIM(ICURVE)=XHISTO(IPOINT,ICURVE)
            END IF
         END DO
      END DO
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<CODEVERSIO>> VERSIO'')')
C
      WRITE(NRESUL,'(16X,A3)') VERSIO
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<MAIN_TITLE>>'')')
C      
      WRITE(NRESUL,'(15X,A,/)') HISTIT
C
C=======================================================================
C     
      WRITE(NRESUL,'(''<<NUCLIDINFO>>'',1X,''NUMB_Z'',2X,''NUMB_N'')')
C
      WRITE(NRESUL,'(15X,I3,6X,I3,/)') IZ_FIX,IN_FIX
C
      A_MASS=IZ_FIX+IN_FIX
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<NoNUCACTIV>>'',1X,''NUCACT'')')
C      
      WRITE(NRESUL,'(15X,I3,/)') NUCACT
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<EXPER_FILE>>'',1X,''IFDEEP'',2X
     *                                     ''IFPRON'')')
      
      WRITE(NRESUL,'(15X,2(I3,6X),/)') IFDEEP,IFPRON
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<POTEN_INFO>>'',1X,''ISOSPI'',2X,''IFDENS'',
     *                                  2X,''IFTENS'',2X,''IF_PAI'')')
C      
      WRITE(NRESUL,'(15X,4(I3,5X),/)') ISOSPI,IFDENS,IFTENS,IF_PAI
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<TENSR_INFO>>'',1X,''ICENTT'',2X
     *                                     ''ISORBT'',2X,''ITENSR'')')
C      
      WRITE(NRESUL,'(15X,3(I3,5X),/)') ICENTT,ISORBT,ITENSR
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<TAKEN_CHI2>> IF_SPE  IF_RAD  IF_GAP  '',
     *               ''IF_FER  IF_DEN  IF_RHO  IF_INV'')')
      WRITE(NRESUL,'(15X,7(I3,5X),/)')IF_SPE,IF_RAD,IF_GAP,IF_FER,
     *                                       IF_DEN,IF_RHO,IF_INV
C
C=======================================================================
C      
      WRITE(NRESUL,'(''<<XAXIS_TEXT>>'',/,15x,A,/)') HX_TIT
C      
      WRITE(NRESUL,'(''<<YAXIS_TEXT>>'',/,15x,A,/)') HY_TIT
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<SIDE_TEXTS>>'')')
C
      AUXTX1=' '
      AUXTX2=' '
      AUXTX3=' '
      AUXTX4=' '
      AUXTX5=' '
      AUXTX6=' '
C
      IF (IFDENS.EQ.1) AUXTX1='${\\rm DENS}\\,\\vert\\,$'
      IF (IFTENS.EQ.1) AUXTX2='${\\rm TENS}\\,\\vert\\,$'
      IF (IF_PAI.EQ.1) AUXTX3='${\\rm PAIR}\\,\\vert\\,$'
      IF (IF_RAD.EQ.1) AUXTX4='${\\rm RADI}\\,\\vert\\,$'
      IF (IFDEEP.EQ.1) AUXTX5='${\\rm DEEP}\\,\\vert\\,$'
      IF (IFPRON.EQ.1) AUXTX6='${\\rm PRON}\\,\\vert\\,$'
C
      WRITE(NRESUL,'(15X,''~~~Id: $\\rm LDMONT= '',I6,
     *                           ''\\,\\vert\\,$'',6A)')
     *            LDMONT,AUXTX1,AUXTX2,AUXTX3,AUXTX4,AUXTX5,AUXTX6
C
      WRITE(NRESUL,'(15X,''~~~Fitted: '',$)')
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             WRITE(NRESUL,'(2X,A10,$)') NUCNAM_LATEXS(JNUCLI)
         END IF
      END DO
      WRITE(NRESUL,'()')
C
C=======================================================================
C     
      WRITE(NRESUL,'(/,15X,30(''=''),/)')
          
      WRITE(NRESUL,'(''<<X_AX_PARAM>> XMINIM_FIG  XMAXIM_FIG  '',
     *                   ''X_STEP_FIG'')')
          
      WRITE(NRESUL,'(15X,3(F10.2,2X),/)')XMINIM,XMAXIM,(XMAXIM-XMINIM)
     
      WRITE(NRESUL,'(''<<Y_AX_PARAM>> YMINIM_FIG  YMAXIM_FIG  '',
     *                   ''Y_STEP_FIG'')')
          
      WRITE(NRESUL,'(15X,3(F10.2,2X),/)')
     *                         YMINIM,YMAXIM,(YMAXIM-YMINIM)
     
      WRITE(NRESUL,'(15X,30(''=''),/)')
C
C=======================================================================
C
      I_COLM=0
      I_LEFT=0
      I_RIGH=0
C
      WRITE(NRESUL,'(''<<WHATLEGEND>>'',1X,''COLM_LABEL'',2X,
     *               ''LEFT_LABEL'',2X,''RIGH_LABEL'')')
      WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5)')I_COLM,I_LEFT,I_RIGH
C
C=======================================================================
C      
      IFBULL=0
      IFHIST=1
      IFOVER=0
C      
      WRITE(NRESUL,'(/,''<<NO_OF_CURV>>'',1X,''NUMB_CURVE'',2X,
     *                 ''IF_BULLETS'',2X,
     *                 ''IF_HISTOGS'',2X,''IF_OVERFITING'')')
      WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5,7X,I5,7X,I5)')LDCURV,
     *                                         IFBULL,IFHIST,IFOVER
C
C=======================================================================
C
      ISTYLE=0
      I_TYPE=3
      ITHICK=3
C      ICOLOR=70
C
      DO I_CURV=1,LDCURV
C
         WRITE(NRESUL,'(''<<>>'')')
         WRITE(NRESUL,'(''<<CURVE_'',I4.4,''>>'',1X,
     *                  ''THICK_LINE'',2X,''STYLE_LINE'',2X,
     *                  ''COLOR_LINE'',2X,''TYPE_POINT'')')I_CURV
         WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5,7X,I5)')ITHICK,ISTYLE,
     *                                      ICOLOR_HISTOG(I_CURV),
     *                                                    I_TYPE
         WRITE(NRESUL,'(15X,''NUMB_POINT'',2X,''YXPECTED_V'',
     *                   2X,''XPOSI_YMAX'')')
         WRITE(NRESUL,'(15X,I10,2X,F10.4,2X,F10.4)')
     *                      LDHIST,YEXPEC(I_CURV),XPOSIT_YMAXIM(I_CURV)
C
         DO IPOINT=1,LDHIST
C
            WRITE(NRESUL,'(15X,F10.4,4X,E12.4,4X,A100)') 
     *                           XHISTO(IPOINT,I_CURV),
     *                           YHISTO(IPOINT,I_CURV)/YMAXIM,
     *                           LABELS(IPOINT,I_CURV)
C
         END DO

C
      END DO
C
C=======================================================================
C      
      WRITE(NRESUL,'(/,''<<GO_GETTHEM>>'',/)')
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE PLOTINFOPRINT(NRESUL,HISTIT,HX_TIT,HY_TIT,
     *                         LEVACT_PROTON,LEVACT_NEUTRS,
     *                         SIGACT_PROTON,SIGACT_NEUTRS,
     *                                LDCURV,YEXPEC,XUNITS)
C
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDPARS.f'
      INCLUDE 'MATDIM/NDCOLO.f'
      INCLUDE 'MATDIM/NDTITL.f'
      INCLUDE 'MATDIM/NDBINS.f'
C
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6,VERSIO*3
      CHARACTER
     *          FILNAM*256,LABELS*100,NUCNAM*05,TITLES*12,
     *          ISONAM*002,TEXLAM*020,TITPAR*13,FITNUC*02,
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010,XUNITS*40
      CHARACTER
     *          HISTIT*256,HX_TIT*256,HY_TIT*256
      CHARACTER
     *          FILNAM_IFITED*14,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*02,PARNAM*8
      CHARACTER
     *          AUXTX1*30,AUXTX2*30,AUXTX3*30,AUXTX4*30,
     *          AUXTX5*30,AUXTX6*30
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /PARCOR/ IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /VLIMIT/ VMISTR(1:NDPARS),
     *                VMIMIN(1:NDPARS),
     *                VMIMAX(1:NDPARS),
     *                VMISTP(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /FACCOU/ COUFAC
      COMMON
     *       /VERSIN/ VERSIO
      COMMON
     *       /MONTEC/ IFPSEU,IFPARA,LDMONT,LDBINS
      COMMON
     *       /GAUSSI/ PARPOT_XMEANS(1:NDPARS),
     *                PARPOT_SIGMAS(1:NDPARS)
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<CODEVERSIO>> VERSIO'')')
C
      WRITE(NRESUL,'(16X,A3)') VERSIO
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<MAIN_TITLE>>'')')
C
      WRITE(NRESUL,'(15X,A,/)') HISTIT
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<NUCLIDINFO>>'',1X,''NUMB_Z'',2X,''NUMB_N'')')
C
      WRITE(NRESUL,'(15X,I3,6X,I3,/)') IZ_FIX,IN_FIX
C
      A_MASS=IZ_FIX+IN_FIX
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<NoNUCACTIV>>'',1X,''NUCACT'')')
C
      WRITE(NRESUL,'(15X,I3,/)') NUCACT
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<EXPER_FILE>>'',1X,''IFDEEP'',2X
     *                                     ''IFPRON'')')

      WRITE(NRESUL,'(15X,2(I3,6X),/)') IFDEEP,IFPRON
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<POTEN_INFO>>'',1X,''ISOSPI'',2X,''IFDENS'',
     *                                  2X,''IFTENS'',2X,''IF_PAI'')')
C
      WRITE(NRESUL,'(15X,4(I3,5X),/)') ISOSPI,IFDENS,IFTENS,IF_PAI
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<TENSR_INFO>>'',1X,''ICENTT'',2X
     *                                     ''ISORBT'',2X,''ITENSR'')')
C
      WRITE(NRESUL,'(15X,3(I3,5X),/)') ICENTT,ISORBT,ITENSR
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<TAKEN_CHI2>> IF_SPE  IF_RAD  IF_GAP  '',
     *               ''IF_FER  IF_DEN  IF_RHO  IF_INV'')')
      WRITE(NRESUL,'(15X,7(I3,5X),/)')IF_SPE,IF_RAD,IF_GAP,IF_FER,
     *                                       IF_DEN,IF_RHO,IF_INV
C
C=======================================================================
C
      IF (ISOSPI.EQ.1) THEN
          WRITE(NRESUL,'(''<<COULOMBFAC>> COUFAC'')')
          WRITE(NRESUL,'(15X,F8.2,/)')COUFAC
      END IF
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<XAXIS_TEXT>>'',/,15x,A,/)') HX_TIT
C
      WRITE(NRESUL,'(''<<YAXIS_TEXT>>'',/,15x,A,/)') HY_TIT
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<SIDE_TEXTS>>'')')
C
      AUXTX1=' '
      AUXTX2=' '
      AUXTX3=' '
      AUXTX4=' '
      AUXTX5=' '
      AUXTX6=' '
C
      IF (IFDENS.EQ.1) AUXTX1='{\\rm DENS}\\,\\vert\\,'
      IF (IFTENS.EQ.1) AUXTX2='{\\rm TENS}\\,\\vert\\,'
      IF (IF_PAI.EQ.1) AUXTX3='{\\rm PAIR}\\,\\vert\\,'
      IF (IF_RAD.EQ.1) AUXTX4='{\\rm RADI}\\,\\vert\\,'
      IF (IFDEEP.EQ.1) AUXTX5='{\\rm DEEP}\\,\\vert\\,'
      IF (IFPRON.EQ.1) AUXTX6='{\\rm PRON}\\,\\vert\\,'
C
      IF (ISOSPI.EQ.1) THEN
C
          WRITE(NRESUL,'(15X,''~~~Id: $ N_{MC}= '',I6,
     *                       '',\\,N_p= '',i3,'',\\,\\sigma_p= '',f5.3,
     *                       '',\\,f_c= '',f6.2,
     *                       ''\\,\\vert\\,'',6A,''$'')')
     *            LDMONT,LEVACT_PROTON,SIGACT_PROTON,COUFAC,
     *            AUXTX1,AUXTX2,AUXTX3,AUXTX4,AUXTX5,AUXTX6
C
          WRITE(NRESUL,'(15X,''~~~Fitted: '',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(2X,A10,$)') NUCNAM_LATEXS(JNUCLI)
             END IF
          END DO
          WRITE(NRESUL,'()')
C
          IF (IFDENS.EQ.0) THEN
C
              WRITE(NRESUL,'(15X,''~~~$ V_p^c= '',f8.2,
     *                                           ''\\,{\\rm MeV},'',
     *                             ''\\,r_p^c= '',f8.2,
     *                                           ''\\,{\\rm fm},'',
     *                             ''\\,a_p^c= '',f8.2,
     *                                           ''\\,{\\rm fm}$'')')
     *                                  VMISTR(1),VMISTR(2),VMISTR(3)
              WRITE(NRESUL,'(15X,''~~~$ \\lambda_p^{so}= '',f8.2,
     *                           ''\\,{\\rm MeV\\,fm^2/\\hbar^2},'',
     *                           ''\\,r_p^{so}= '',f8.2,
     *                           ''\\,{\\rm fm},'',
     *                           ''\\,a_p^{so}= '',f8.2,
     *                           ''\\,{\\rm fm}$'')')
     *                                 VMISTR(4),VMISTR(5),VMISTR(6)
C
          END IF
C
          IF (IFDENS.EQ.1) THEN
C
              WRITE(NRESUL,'(15X,''~~~$ V_p^c= '',f8.2,
     *                                           ''\\,{\\rm MeV},'',
     *                             ''\\,r_p^c= '',f8.2,
     *                                           ''\\,{\\rm fm},'',
     *                             ''\\,a_p^c= '',f8.2,
     *                                           ''\\,{\\rm fm}$'')')
     *                                  VMISTR(1),VMISTR(2),VMISTR(3)
              WRITE(NRESUL,'(15X,''~~~$ \\lambda^{\\pi\\pi}= '',f10.2,
     *                           ''\\,{\\rm MeV\\,fm^5/\\hbar^2},'',
     *                           ''\\,\\lambda^{\\pi\\nu}= '',f10.2,
     *                           ''\\,{\\rm MeV\\,fm^5/\\hbar^2}$'')')
     *                                 VMISTR(39),VMISTR(40)
C
          END IF
C
      END IF
C
      IF (ISOSPI.EQ.0) THEN
C
          WRITE(NRESUL,'(15X,''~~~Id: $ N_{MC}= '',I6,
     *                       '',\\,N_n= '',i3,'',\\,\\sigma_n= '',f5.3,
     *                           ''\\,\\vert\\,'',6A,''$'')')
     *            LDMONT,LEVACT_NEUTRS,SIGACT_NEUTRS,
     *            AUXTX1,AUXTX2,AUXTX3,AUXTX4,AUXTX5,AUXTX6
C
          WRITE(NRESUL,'(15X,''~~~Fitted: '',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(2X,A10,$)') NUCNAM_LATEXS(JNUCLI)
             END IF
          END DO
          WRITE(NRESUL,'()')
C
          IF (IFDENS.EQ.0) THEN
C
              WRITE(NRESUL,'(15X,''~~~$ V_n^c= '',f8.2,
     *                                           ''\\,{\\rm MeV},'',
     *                             ''\\,r_n^c= '',f8.2,
     *                                           ''\\,{\\rm fm},'',
     *                             ''\\,a_n^c= '',f8.2,
     *                                           ''\\,{\\rm fm}$'')')
     *                                VMISTR(21),VMISTR(22),VMISTR(23)
              WRITE(NRESUL,'(15X,''~~~$ \\lambda_n^{so}= '',f8.2,
     *                           ''\\,{\\rm MeV\\,fm^2/\\hbar^2},'',
     *                           ''\\,r_n^{so}= '',f8.2,
     *                           ''\\,{\\rm fm},'',
     *                           ''\\,a_n^{so}= '',f8.2,
     *                           ''\\,{\\rm fm}$'')')
     *                                 VMISTR(24),VMISTR(25),VMISTR(26)
C
          END IF
C
          IF (IFDENS.EQ.1) THEN
C
              WRITE(NRESUL,'(15X,''~~~$ V_n^c= '',f8.2,
     *                                           ''\\,{\\rm MeV},'',
     *                             ''\\,r_n^c= '',f8.2,
     *                                           ''\\,{\\rm fm},'',
     *                             ''\\,a_n^c= '',f8.2,
     *                                           ''\\,{\\rm fm}$'')')
     *                                 VMISTR(21),VMISTR(22),VMISTR(23)
              WRITE(NRESUL,'(15X,''~~~$ \\lambda^{\\nu\\nu}= '',f10.2,
     *                           ''\\,{\\rm MeV\\,fm^5/\\hbar^2},'',
     *                           ''\\,\\lambda^{\\nu\\pi}= '',f10.2,
     *                           ''\\,{\\rm MeV\\,fm^5/\\hbar^2}$'')')
     *                                 VMISTR(42),VMISTR(41)
C
          END IF
C
      END IF
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<VALUE_UNIT>>'')')
      WRITE(NRESUL,'(15X,A)') XUNITS
C
C=======================================================================
C
      IFBULL=0
      IFHIST=1
      IFOVER=0
C
      ITHICK=4
      ISTYLE=0
      ICOLOR=44
      I_TYPE=3
C
      XPOSIT_YMAXIM=99.9999
C
      WRITE(NRESUL,'(/,''<<NO_OF_CURV>>'',1X,''NUMB_CURVE'',2X,
     *                 ''IF_BULLETS'',2X,
     *                 ''IF_HISTOGS'',2X,''IF_OVERFITING'')')
      WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5,7X,I5,7X,I5)')LDCURV,
     *                                         IFBULL,IFHIST,IFOVER
      WRITE(NRESUL,'(''<<>>'')')
      WRITE(NRESUL,'(''<<CURVE_0000>>'',1X,
     *                  ''THICK_LINE'',2X,''STYLE_LINE'',2X,
     *                  ''COLOR_LINE'',2X,''TYPE_POINT'')')
      WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5,7X,I5)')ITHICK,ISTYLE,
     *                                          ICOLOR,I_TYPE
      WRITE(NRESUL,'(15X,''NUMB_POINT'',2X,''YXPECTED_V'',
     *                   2X,''XPOSI_YMAX'')')
      WRITE(NRESUL,'(15X,I10,2X,F10.4,2X,F10.4)')
     *                      LDMONT,YEXPEC,XPOSIT_YMAXIM
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE PLOTCURVPRINT(NRESUL,NDCURV,LDCURV,IMONTE,
     *                                LABELS,VECTOR_OFDATA)
C
      CHARACTER
     *          LABELS*100
      DIMENSION
     *          LABELS(1:NDCURV)
      DIMENSION
     *          VECTOR_OFDATA(1:NDCURV)
C
C=======================================================================
C
      IF (IMONTE.EQ.1) THEN
          WRITE(NRESUL,'(21X,<LDCURV>(12X,I6.6))')(I,I=1,LDCURV)
          WRITE(NRESUL,'(15X,''IMONTE'',$)')
          DO I=1,LDCURV
             LENGTH=0
             DO J=100,1,-1
                IF (LABELS(I)(J:J).NE.' ') THEN
                    LENGTH=J
                    GO TO 1
                END IF
             END DO
   1         CONTINUE
             IF (LENGTH.EQ.5) LENGTH=LENGTH+1
             WRITE(NRESUL,'(12X,A,$)')LABELS(I)(1:LENGTH)
          END DO
          WRITE(NRESUL,'()')
      END IF
C
      WRITE(NRESUL,'(15X,I6,<LDCURV>(3X,F15.8))')IMONTE,
     *                 (VECTOR_OFDATA(I),I=1,LDCURV)
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE PLOTEXTRPRINT(NRESUL,XMINIM,XMAXIM,YMINIM,YMAXIM)
C
C=======================================================================
C
      WRITE(NRESUL,'()')
C
      WRITE(NRESUL,'(''<<X_AX_PARAM>> XMINIM_FIG  XMAXIM_FIG  '',
     *                   ''X_STEP_FIG'')')
C
      WRITE(NRESUL,'(15X,3(F10.2,2X),/)')XMINIM,XMAXIM,(XMAXIM-XMINIM)
C
      WRITE(NRESUL,'(''<<Y_AX_PARAM>> YMINIM_FIG  YMAXIM_FIG  '',
     *                   ''Y_STEP_FIG'')')
C
      WRITE(NRESUL,'(15X,3(F10.2,2X),/)')
     *                         YMINIM,YMAXIM,(YMAXIM-YMINIM)
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<GO_GETTHEM>>'',/)')
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE SELECT_VSODEN
C
      INCLUDE 'MATDIM/NDPARS.f'
C
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
C=======================================================================
C
C     This SUBROUTINE "corrects" the values of the SO-Potential
C     lambda's depending on the IFLAMB block from the NAME-LIST
C
C
C  spin-orbit and tensor concerned
C
C=======================================================================
C      
      IF (IFDENS.EQ.0) THEN
          IF (LOGWRI.GT.5) THEN
              WRITE(LOGFIL,'(15X,''Exiting  SELECT_VSODEN at '',
     *                           ''IFDENS=0'')')
          END IF
          RETURN
      END IF
C
C=======================================================================
C 
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(18x,''Lambdas before modification:'',
     *               '' PARPOT(39)= '',F10.4,'' PARPOT(40)= '',F10.4,
     *               '' PARPOT(41)= '',F10.4,'' PARPOT(42)= '',F10.4)') 
     *                  PARPOT(39),PARPOT(40),PARPOT(41),PARPOT(42) 
          WRITE(LOGFIL,'(46X,'' ALAMPP    = '',F10.4,
     *                       '' ALAMPN    = '',F10.4,
     *                       '' ALAMNP    = '',F10.4,
     *                       '' ALAMNN    = '',F10.4,/)')
     *                  ALAMPP,ALAMPN,ALAMNP,ALAMNN  
      END IF
C
C=======================================================================
C     
      IF (IFPAR1.EQ.1.AND.IFPAR2.EQ.-1) THEN
          PARPOT(40)=PARPOT(39)
          ALAMPN=ALAMPP
      END IF
C      
      IF (IFPAR1.EQ.1.AND.IFPAR3.EQ.-1) THEN
          PARPOT(41)=PARPOT(39)
          ALAMNP=ALAMPP
      END IF
C      
      IF (IFPAR1.EQ.1.AND.IFPAR4.EQ.-1) THEN
          PARPOT(42)=PARPOT(39)
          ALAMNN=ALAMPP
      END IF
C_______________________________________________________________________
C     
      IF (IFPAR2.EQ.2.AND.IFPAR3.EQ.-2) THEN
          PARPOT(41)=PARPOT(40)
          ALAMNP=ALAMPN
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(18x,''Lambdas after modification:'',
     *               '' PARPOT(39)= '',F10.4,'' PARPOT(40)= '',F10.4,
     *               '' PARPOT(41)= '',F10.4,'' PARPOT(42)= '',F10.4)') 
     *                  PARPOT(39),PARPOT(40),PARPOT(41),PARPOT(42) 
          WRITE(LOGFIL,'(45X,'' ALAMPP    = '',F10.4,
     *                       '' ALAMPN    = '',F10.4,
     *                       '' ALAMNP    = '',F10.4,
     *                       '' ALAMNN    = '',F10.4)')
     *                  ALAMPP,ALAMPN,ALAMNP,ALAMNN 
      END IF
C
C=======================================================================
C      
      IF (IFTENS.EQ.0) THEN
          IF (LOGWRI.GT.5) THEN
              WRITE(LOGFIL,'(15X,''Exiting  SELECT_VSODEN at '',
     *                           ''IFTENS=0'')')
          END IF
          RETURN
      END IF
C
C=======================================================================
C 
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(18x,''Lambdas before modification:'',
     *               '' PARPOT(43)= '',F10.4,'' PARPOT(44)= '',F10.4,
     *               '' PARPOT(45)= '',F10.4,'' PARPOT(46)= '',F10.4)') 
     *                  PARPOT(43),PARPOT(44),PARPOT(45),PARPOT(46) 
          WRITE(LOGFIL,'(46X,'' TLAMPP    = '',F10.4,
     *                       '' TLAMPN    = '',F10.4,
     *                       '' TLAMNP    = '',F10.4,
     *                       '' TLAMNN    = '',F10.4,/)')
     *                  TLAMPP,TLAMPN,TLAMNP,TLAMNN 
      END IF
C
C=======================================================================
C     
      IF (IFPAR5.EQ.1.AND.IFPAR6.EQ.-1) THEN
          PARPOT(44)=PARPOT(43)
          TLAMPN=TLAMPP
      END IF
C      
      IF (IFPAR5.EQ.1.AND.IFPAR7.EQ.-1) THEN
          PARPOT(45)=PARPOT(43)
          TLAMNP=TLAMPP
      END IF
C      
      IF (IFPAR5.EQ.1.AND.IFPAR8.EQ.-1) THEN
          PARPOT(46)=PARPOT(43)
          TLAMNN=TLAMPP
      END IF
C_______________________________________________________________________
C      
      IF (IFPAR6.EQ.2.AND.IFPAR7.EQ.-2) THEN
          PARPOT(45)=PARPOT(44)
          TLAMNP=TLAMPN
      END IF
C_______________________________________________________________________
C
      IF (IFPAR5.EQ.3.AND.IFPAR6.EQ.-3) THEN
          PARPOT(44)=-PARPOT(43)
          TLAMPN=-TLAMPP
      END IF
C      
      IF (IFPAR5.EQ.3.AND.IFPAR7.EQ.-3) THEN
          PARPOT(45)=-PARPOT(43)
          TLAMNP=-TLAMPP
      END IF
C      
      IF (IFPAR5.EQ.3.AND.IFPAR8.EQ.-3) THEN
          PARPOT(46)=PARPOT(43)
          TLAMNN=TLAMPP
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(18x,''Lambdas after modification:'',
     *               '' PARPOT(43)= '',F10.4,'' PARPOT(44)= '',F10.4,
     *               '' PARPOT(45)= '',F10.4,'' PARPOT(46)= '',F10.4)') 
     *                  PARPOT(43),PARPOT(44),PARPOT(45),PARPOT(46) 
          WRITE(LOGFIL,'(46X,'' TLAMPP    = '',F10.4,
     *                       '' TLAMPN    = '',F10.4,
     *                       '' TLAMNP    = '',F10.4,
     *                       '' TLAMNN    = '',F10.4,/)')
     *                  TLAMPP,TLAMPN,TLAMNP,TLAMNN
      END IF
C
C=======================================================================
C 
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(18x,''Lambdas before modification:'',
     *               '' PARPOT(47)= '',F10.4,'' PARPOT(48)= '',F10.4,
     *               '' PARPOT(49)= '',F10.4,'' PARPOT(50)= '',F10.4)') 
     *                  PARPOT(47),PARPOT(48),PARPOT(49),PARPOT(50) 
          WRITE(LOGFIL,'(46X,'' CLAMPP    = '',F10.4,
     *                       '' CLAMPN    = '',F10.4,
     *                       '' CLAMNP    = '',F10.4,
     *                       '' CLAMNN    = '',F10.4,/)')
     *                  CLAMPP,CLAMPN,CLAMNP,CLAMNN
      END IF
C
C=======================================================================
C     
      IF (IFPA09.EQ.1.AND.IFPA10.EQ.-1) THEN
          PARPOT(48)=PARPOT(47)
          CLAMPN=CLAMPP
      END IF
C      
      IF (IFPA09.EQ.1.AND.IFPA11.EQ.-1) THEN
          PARPOT(49)=PARPOT(47)
          CLAMNP=CLAMPP
      END IF
C      
      IF (IFPA09.EQ.1.AND.IFPA12.EQ.-1) THEN
          PARPOT(50)=PARPOT(47)
          CLAMNN=CLAMPP
      END IF
C_______________________________________________________________________
C      
      IF (IFPA10.EQ.2.AND.IFPA11.EQ.-2) THEN
          PARPOT(49)=PARPOT(48)
          CLAMNP=CLAMPN
      END IF
C_______________________________________________________________________
C
      IF (IFPA09.EQ.3.AND.IFPA10.EQ.-3) THEN
          PARPOT(48)=-PARPOT(47)
          CLAMPN=-CLAMPP
      END IF
C      
      IF (IFPA09.EQ.3.AND.IFPA11.EQ.-3) THEN
          PARPOT(49)=-PARPOT(47)
          CLAMNP=-CLAMPP
      END IF
C      
      IF (IFPA09.EQ.3.AND.IFPA12.EQ.-3) THEN
          PARPOT(50)=PARPOT(47)
          CLAMNN=CLAMPP
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(18x,''Lambdas before modification:'',
     *               '' PARPOT(47)= '',F10.4,'' PARPOT(48)= '',F10.4,
     *               '' PARPOT(49)= '',F10.4,'' PARPOT(50)= '',F10.4)') 
     *                  PARPOT(47),PARPOT(48),PARPOT(49),PARPOT(50) 
          WRITE(LOGFIL,'(46X,'' CLAMPP    = '',F10.4,
     *                       '' CLAMPN    = '',F10.4,
     *                       '' CLAMNP    = '',F10.4,
     *                       '' CLAMNN    = '',F10.4,/)')
     *                  CLAMPP,CLAMPN,CLAMNP,CLAMNN 
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(18X,''Exiting SELECT_VSODEN, normal exit'')')
      END IF
C
C=======================================================================
C      
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE SPHLAB(IZ_FIX,IN_FIX,EFERMI_PROTON,EFERMI_NEUTRS)
C      
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDRAUS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDMAIN.f'
C      
      PARAMETER
     *         (NDORBI=NDMAIN,NDJTOT=2*NDORBI+1) 
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,LBSHEL*6
      CHARACTER
     *          LABPRO_REMOVE*6,LABNEU_REMOVE*6,
     *          REMOVE_PROTON*3,REMOVE_NEUTRS*3
C
      DIMENSION
     *          LBSHEL(0:NDMAIN,0:NDORBI,1:NDJTOT)
C
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS          
      COMMON
     *       /REMLAB/ REMOVE_PROTON,REMOVE_NEUTRS
      COMMON
     *       /OUTLAB/ LABPRO_REMOVE(1:NDRAUS),
     *                LABNEU_REMOVE(1:NDRAUS)
      COMMON
     *       /OUTIND/ INDPRO_LETOUT(1:NDRAUS),
     *                INDNEU_LETOUT(1:NDRAUS)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /DEGENE/ IDGLEV_PROTON(1:NDSPEC),
     *                ICUMUL_PROTON(0:NDSPEC),
     *                IDGLEV_NEUTRS(1:NDSPEC),
     *                ICUMUL_NEUTRS(0:NDSPEC)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS) 
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /ACTIVE/ IACTIV,IwMODE
      COMMON
     *       /ENEPRI/ ENEMAX
C_______________________________________________________________________
C
      DATA !      n  L  J
     *     LBSHEL(00,00,01) / '1s1/2 ' /   ! Shell no. 0
      DATA
     *     LBSHEL(01,01,03) / '1p3/2 ' /, 
     *     LBSHEL(01,01,01) / '1p1/2 ' /   ! Shell no. 1
      DATA
     *     LBSHEL(02,00,01) / '2s1/2 ' /, 
     *     LBSHEL(02,02,05) / '1d5/2 ' /, 
     *     LBSHEL(02,02,03) / '1d3/2 ' /   ! Shell no. 2
      DATA
     *     LBSHEL(03,01,03) / '2p3/2 ' /, 
     *     LBSHEL(03,01,01) / '2p1/2 ' /, 
     *     LBSHEL(03,03,07) / '1f7/2 ' /, 
     *     LBSHEL(03,03,05) / '1f5/2 ' /   ! Shell no. 3
      DATA
     *     LBSHEL(04,00,01) / '3s1/2 ' /, 
     *     LBSHEL(04,02,05) / '2d5/2 ' /, 
     *     LBSHEL(04,02,03) / '2d3/2 ' /, 
     *     LBSHEL(04,04,09) / '1g9/2 ' /, 
     *     LBSHEL(04,04,07) / '1g7/2 ' /   ! Shell no. 4
      DATA
     *     LBSHEL(05,01,03) / '3p3/2 ' /, 
     *     LBSHEL(05,01,01) / '3p1/2 ' /, 
     *     LBSHEL(05,03,07) / '2f7/2 ' /, 
     *     LBSHEL(05,03,05) / '2f5/2 ' /, 
     *     LBSHEL(05,05,11) / '1h11/2' /, 
     *     LBSHEL(05,05,09) / '1h9/2 ' /   ! Shell no. 5
      DATA
     *     LBSHEL(06,00,01) / '4s1/2 ' /, 
     *     LBSHEL(06,02,05) / '3d5/2 ' /, 
     *     LBSHEL(06,02,03) / '3d3/2 ' /, 
     *     LBSHEL(06,04,09) / '2g9/2 ' /, 
     *     LBSHEL(06,04,07) / '2g7/2 ' /, 
     *     LBSHEL(06,06,13) / '1i13/2' /, 
     *     LBSHEL(06,06,11) / '1i11/2' /   ! Shell no. 6
      DATA
     *     LBSHEL(07,01,03) / '4p3/2 ' /, 
     *     LBSHEL(07,01,01) / '4p1/2 ' /, 
     *     LBSHEL(07,03,07) / '3f7/2 ' /, 
     *     LBSHEL(07,03,05) / '3f5/2 ' /, 
     *     LBSHEL(07,05,11) / '2h11/2' /, 
     *     LBSHEL(07,05,09) / '2h9/2 ' /, 
     *     LBSHEL(07,07,15) / '1j15/2' /, 
     *     LBSHEL(07,07,13) / '1j13/2' /   ! Shell no. 7
      DATA
     *     LBSHEL(08,00,01) / '5s1/2 ' /, 
     *     LBSHEL(08,02,05) / '4d5/2 ' /, 
     *     LBSHEL(08,02,03) / '4d3/2 ' /, 
     *     LBSHEL(08,04,09) / '3g9/2 ' /, 
     *     LBSHEL(08,04,07) / '3g7/2 ' /, 
     *     LBSHEL(08,06,13) / '2i13/2' /, 
     *     LBSHEL(08,06,11) / '2i11/2' /, 
     *     LBSHEL(08,08,17) / '1k17/2' /, 
     *     LBSHEL(08,08,15) / '1k15/2' /   ! Shell no. 8
      DATA
     *     LBSHEL(09,01,03) / '5p3/2 ' /, 
     *     LBSHEL(09,01,01) / '5p1/2 ' /, 
     *     LBSHEL(09,03,07) / '4f7/2 ' /, 
     *     LBSHEL(09,03,05) / '4f5/2 ' /, 
     *     LBSHEL(09,05,11) / '3h11/2' /, 
     *     LBSHEL(09,05,09) / '3h9/2 ' /, 
     *     LBSHEL(09,07,15) / '2j15/2' /, 
     *     LBSHEL(09,07,13) / '2j13/2' /, 
     *     LBSHEL(09,09,19) / '1l19/2' /, 
     *     LBSHEL(09,09,17) / '1l17/2' /   ! Shell no. 9
      DATA
     *     LBSHEL(10,00,01) / '6s1/2 ' /, 
     *     LBSHEL(10,02,05) / '5d5/2 ' /, 
     *     LBSHEL(10,02,03) / '5d3/2 ' /, 
     *     LBSHEL(10,04,09) / '4g9/2 ' /, 
     *     LBSHEL(10,04,07) / '4g7/2 ' /, 
     *     LBSHEL(10,06,13) / '3i13/2' /, 
     *     LBSHEL(10,06,11) / '3i11/2' /, 
     *     LBSHEL(10,08,17) / '2k17/2' /, 
     *     LBSHEL(10,08,15) / '2k15/2' /, 
     *     LBSHEL(10,10,21) / '1m21/2' /, 
     *     LBSHEL(10,10,19) / '1m19/2' /   ! Shell no.10
      DATA
     *     LBSHEL(11,01,03) / '6p3/2 ' /, 
     *     LBSHEL(11,01,01) / '6p1/2 ' /, 
     *     LBSHEL(11,03,07) / '5f7/2 ' /, 
     *     LBSHEL(11,03,05) / '5f5/2 ' /, 
     *     LBSHEL(11,05,11) / '4h11/2' /, 
     *     LBSHEL(11,05,09) / '4h9/2 ' /, 
     *     LBSHEL(11,07,15) / '3j15/2' /, 
     *     LBSHEL(11,07,13) / '3j13/2' /, 
     *     LBSHEL(11,09,19) / '2l19/2' /, 
     *     LBSHEL(11,09,17) / '2l17/2' /, 
     *     LBSHEL(11,11,23) / '1n23/2' /, 
     *     LBSHEL(11,11,21) / '1n21/2' /   ! Shell no.11
      DATA
     *     LBSHEL(12,00,01) / '7s1/2 ' /, 
     *     LBSHEL(12,02,05) / '6d5/2 ' /, 
     *     LBSHEL(12,02,03) / '6d3/2 ' /, 
     *     LBSHEL(12,04,09) / '5g9/2 ' /, 
     *     LBSHEL(12,04,07) / '5g7/2 ' /, 
     *     LBSHEL(12,06,13) / '4i13/2' /, 
     *     LBSHEL(12,06,11) / '4i11/2' /, 
     *     LBSHEL(12,08,17) / '3k17/2' /, 
     *     LBSHEL(12,08,15) / '3k15/2' /, 
     *     LBSHEL(12,10,21) / '2m21/2' /, 
     *     LBSHEL(12,10,19) / '2m19/2' /, 
     *     LBSHEL(12,12,25) / '2o25/2' /, 
     *     LBSHEL(12,12,23) / '2o23/2' /   ! Shell no.12
      DATA
     *     LBSHEL(13,01,03) / '7p3/2 ' /, 
     *     LBSHEL(13,01,01) / '7p1/2 ' /, 
     *     LBSHEL(13,03,07) / '6f7/2 ' /, 
     *     LBSHEL(13,03,05) / '6f5/2 ' /, 
     *     LBSHEL(13,05,11) / '5h11/2' /, 
     *     LBSHEL(13,05,09) / '5h9/2 ' /, 
     *     LBSHEL(13,07,15) / '4j15/2' /, 
     *     LBSHEL(13,07,13) / '4j13/2' /, 
     *     LBSHEL(13,09,19) / '3l19/2' /, 
     *     LBSHEL(13,09,17) / '3l17/2' /, 
     *     LBSHEL(13,11,23) / '2n23/2' /, 
     *     LBSHEL(13,11,21) / '2n21/2' /, 
     *     LBSHEL(13,13,27) / '1r27/2' /, 
     *     LBSHEL(13,13,25) / '1r25/2' /   ! Shell no.13
      DATA
     *     LBSHEL(14,00,01) / '8s1/2 ' /, 
     *     LBSHEL(14,02,05) / '7d5/2 ' /, 
     *     LBSHEL(14,02,03) / '7d3/2 ' /, 
     *     LBSHEL(14,04,09) / '6g9/2 ' /, 
     *     LBSHEL(14,04,07) / '6g7/2 ' /, 
     *     LBSHEL(14,06,13) / '5i13/2' /, 
     *     LBSHEL(14,06,11) / '5i11/2' /, 
     *     LBSHEL(14,08,17) / '4k17/2' /, 
     *     LBSHEL(14,08,15) / '4k15/2' /, 
     *     LBSHEL(14,10,21) / '3m21/2' /, 
     *     LBSHEL(14,10,19) / '3m19/2' /, 
     *     LBSHEL(14,12,25) / '2o25/2' /, 
     *     LBSHEL(14,12,23) / '2o23/2' /,
     *     LBSHEL(14,14,29) / '1q29/2' /, 
     *     LBSHEL(14,14,27) / '1q27/2' /   ! Shell no.14
      DATA
     *     LBSHEL(15,01,03) / '8p3/2 ' /, 
     *     LBSHEL(15,01,01) / '8p1/2 ' /, 
     *     LBSHEL(15,03,07) / '7f7/2 ' /, 
     *     LBSHEL(15,03,05) / '7f5/2 ' /, 
     *     LBSHEL(15,05,11) / '6h11/2' /, 
     *     LBSHEL(15,05,09) / '6h9/2 ' /, 
     *     LBSHEL(15,07,15) / '5j15/2' /, 
     *     LBSHEL(15,07,13) / '5j13/2' /, 
     *     LBSHEL(15,09,19) / '4l19/2' /, 
     *     LBSHEL(15,09,17) / '4l17/2' /, 
     *     LBSHEL(15,11,23) / '3n23/2' /, 
     *     LBSHEL(15,11,21) / '3n21/2' /, 
     *     LBSHEL(15,13,27) / '2r27/2' /, 
     *     LBSHEL(15,13,25) / '2r25/2' /, 
     *     LBSHEL(15,15,31) / '1t31/2' /, 
     *     LBSHEL(15,15,29) / '1t29/2' /   ! Shell no.15
      DATA
     *     LBSHEL(16,00,01) / '9s1/2 ' /, 
     *     LBSHEL(16,02,05) / '8d5/2 ' /, 
     *     LBSHEL(16,02,03) / '8d3/2 ' /, 
     *     LBSHEL(16,04,09) / '7g9/2 ' /, 
     *     LBSHEL(16,04,07) / '7g7/2 ' /, 
     *     LBSHEL(16,06,13) / '6i13/2' /, 
     *     LBSHEL(16,06,11) / '6i11/2' /, 
     *     LBSHEL(16,08,17) / '5k17/2' /, 
     *     LBSHEL(16,08,15) / '5k15/2' /, 
     *     LBSHEL(16,10,21) / '4m21/2' /, 
     *     LBSHEL(16,10,19) / '4m19/2' /, 
     *     LBSHEL(16,12,25) / '3o25/2' /, 
     *     LBSHEL(16,12,23) / '3o23/2' /,
     *     LBSHEL(16,14,29) / '2q29/2' /, 
     *     LBSHEL(16,14,27) / '2q27/2' /,
     *     LBSHEL(16,16,33) / '1u33/2' /, 
     *     LBSHEL(16,16,31) / '1u31/2' /   ! Shell no.16
      DATA
     *     LBSHEL(17,01,03) / '9p3/2 ' /, 
     *     LBSHEL(17,01,01) / '9p1/2 ' /, 
     *     LBSHEL(17,03,07) / '8f7/2 ' /, 
     *     LBSHEL(17,03,05) / '8f5/2 ' /, 
     *     LBSHEL(17,05,11) / '7h11/2' /, 
     *     LBSHEL(17,05,09) / '7h9/2 ' /, 
     *     LBSHEL(17,07,15) / '6j15/2' /, 
     *     LBSHEL(17,07,13) / '6j13/2' /, 
     *     LBSHEL(17,09,19) / '5l19/2' /, 
     *     LBSHEL(17,09,17) / '5l17/2' /, 
     *     LBSHEL(17,11,23) / '4n23/2' /, 
     *     LBSHEL(17,11,21) / '4n21/2' /, 
     *     LBSHEL(17,13,27) / '3r27/2' /, 
     *     LBSHEL(17,13,25) / '3r25/2' /, 
     *     LBSHEL(17,15,31) / '2t31/2' /, 
     *     LBSHEL(17,15,29) / '2t29/2' /, 
     *     LBSHEL(17,17,35) / '1v35/2' /, 
     *     LBSHEL(17,17,33) / '1v33/2' /   ! Shell no.17
      DATA
     *     LBSHEL(18,00,01) / '10s1/2' /, 
     *     LBSHEL(18,02,05) / '9d5/2 ' /, 
     *     LBSHEL(18,02,03) / '9d3/2 ' /, 
     *     LBSHEL(18,04,09) / '8g9/2 ' /, 
     *     LBSHEL(18,04,07) / '8g7/2 ' /, 
     *     LBSHEL(18,06,13) / '7i13/2' /, 
     *     LBSHEL(18,06,11) / '7i11/2' /, 
     *     LBSHEL(18,08,17) / '6k17/2' /, 
     *     LBSHEL(18,08,15) / '6k15/2' /, 
     *     LBSHEL(18,10,21) / '5m21/2' /, 
     *     LBSHEL(18,10,19) / '5m19/2' /, 
     *     LBSHEL(18,12,25) / '4o25/2' /, 
     *     LBSHEL(18,12,23) / '4o23/2' /,
     *     LBSHEL(18,14,29) / '3q29/2' /, 
     *     LBSHEL(18,14,27) / '3q27/2' /,
     *     LBSHEL(18,16,33) / '2u33/2' /, 
     *     LBSHEL(18,16,31) / '2u31/2' /,
     *     LBSHEL(18,18,37) / '1w39/2' /, 
     *     LBSHEL(18,18,35) / '1w37/2' /   ! Shell no.18
      DATA
     *     LBSHEL(19,01,03) / '10p3/2' /, 
     *     LBSHEL(19,01,01) / '10p1/2' /, 
     *     LBSHEL(19,03,07) / '9f7/2 ' /, 
     *     LBSHEL(19,03,05) / '9f5/2 ' /, 
     *     LBSHEL(19,05,11) / '8h11/2' /, 
     *     LBSHEL(19,05,09) / '8h9/2 ' /, 
     *     LBSHEL(19,07,15) / '7j15/2' /, 
     *     LBSHEL(19,07,13) / '7j13/2' /, 
     *     LBSHEL(19,09,19) / '6l19/2' /, 
     *     LBSHEL(19,09,17) / '6l17/2' /, 
     *     LBSHEL(19,11,23) / '5n23/2' /, 
     *     LBSHEL(19,11,21) / '5n21/2' /, 
     *     LBSHEL(19,13,27) / '4r27/2' /, 
     *     LBSHEL(19,13,25) / '4r25/2' /, 
     *     LBSHEL(19,15,31) / '3t31/2' /, 
     *     LBSHEL(19,15,29) / '3t29/2' /, 
     *     LBSHEL(19,17,35) / '2v35/2' /, 
     *     LBSHEL(19,17,33) / '2v33/2' /, 
     *     LBSHEL(19,19,39) / '1x39/2' /, 
     *     LBSHEL(19,19,37) / '1x37/2' /   ! Shell no.19
      DATA
     *     LBSHEL(20,00,01) / '11s1/2' /, 
     *     LBSHEL(20,02,05) / '10d5/2' /, 
     *     LBSHEL(20,02,03) / '10d3/2' /, 
     *     LBSHEL(20,04,09) / '9g9/2 ' /, 
     *     LBSHEL(20,04,07) / '9g7/2 ' /, 
     *     LBSHEL(20,06,13) / '8i13/2' /, 
     *     LBSHEL(20,06,11) / '8i11/2' /, 
     *     LBSHEL(20,08,17) / '7k17/2' /, 
     *     LBSHEL(20,08,15) / '7k15/2' /, 
     *     LBSHEL(20,10,21) / '6m21/2' /, 
     *     LBSHEL(20,10,19) / '6m19/2' /, 
     *     LBSHEL(20,12,25) / '5o25/2' /, 
     *     LBSHEL(20,12,23) / '5o23/2' /,
     *     LBSHEL(20,14,29) / '4q29/2' /, 
     *     LBSHEL(20,14,27) / '4q27/2' /,
     *     LBSHEL(20,16,33) / '3u33/2' /, 
     *     LBSHEL(20,16,31) / '3u31/2' /,
     *     LBSHEL(20,18,37) / '2w39/2' /, 
     *     LBSHEL(20,18,35) / '2w37/2' /,
     *     LBSHEL(20,20,41) / '1y43/2' /, 
     *     LBSHEL(20,20,39) / '1y41/2' /   ! Shell no.20
C
C=======================================================================
C
C     This subroutine prepares the spherical labels e.g. for the
C     plotting system and for the chi^2  minimisation and prints
C     the corresponding table. 
C
C     Here we identify the  'spherical multiplets'   by a direct 
C     identification of the L and J quantum numbers. 
C
C     Called from WSSTAN and HAMMAT
C
C=======================================================================
C
      IF (IwMODE.EQ.1) RETURN ! No global table print when doing 
C                                                   the gradient
C=======================================================================
C
      IF (IwMODE.EQ.2 .AND. LOGWRI.GT.4) THEN
C
          WRITE(IRESUL,'(/,27x,''The very final Result Table'',/)')
C
          WRITE(LOGPRO,'(/,''IDEFCN='',I3,'' IRANDO='',I3)')
     *                       IDEFCN,         IRANDO
          WRITE(LOGNEU,'(/,''IDEFCN='',I3,'' IRANDO='',I3)')
     *                       IDEFCN,         IRANDO
C
          IF (REMOVE_PROTON.EQ.'YES') THEN
              WRITE(LOGPRO,'(/,''The following experimental proton ''
     *                         ''levels  were not included in the fit'',
     *                                                              /)')
C
              DO I=1,NDRAUS
                 IF (ISCREN.EQ.1.AND.INDPRO_LETOUT(I).EQ.1) THEN
                     WRITE(LOGPRO,'(''Removed proton '',a6,'' level'')')
     *                     LABPRO_REMOVE(I)                            
                 END IF
              END DO
          END IF
C
          IF (REMOVE_NEUTRS.EQ.'YES') THEN
              WRITE(LOGNEU,'(/,''The following experimental neutron '',
     *                         ''levels were not included in the fit:'',
     *                                                              /)')
              DO I=1,NDRAUS
                 IF (INDNEU_LETOUT(I).EQ.1) THEN
                     WRITE(LOGNEU,'(''Removed neutron '',a6,
     *                                          '' level'')')
     *                     LABNEU_REMOVE(I)                            
                 END IF
              END DO
          END IF
C
      END IF
C
C=======================================================================
C
      V0CENT_PROTON=PARPOT( 1)
      R0CENT_PROTON=PARPOT( 2)
      A0CENT_PROTON=PARPOT( 3)
      V0SORB_PROTON=PARPOT( 4)
      R0SORB_PROTON=PARPOT( 5)
      A0SORB_PROTON=PARPOT( 6)
      V0EFFM_PROTON=PARPOT( 7)
      R0EFFM_PROTON=PARPOT( 8)
      A0EFFM_PROTON=PARPOT( 9)
      R0COUL       =PARPOT(10)
     
      XK_V0C_PROTON=PARPOT(11)
      XK_R0C_PROTON=PARPOT(12)
      XK_A0C_PROTON=PARPOT(13)
      XK_LAM_PROTON=PARPOT(14)
      XK_RSO_PROTON=PARPOT(15)
      XK_ASO_PROTON=PARPOT(16)
      XK_LEF_PROTON=PARPOT(17)
      XK_REF_PROTON=PARPOT(18)
      XK_AEF_PROTON=PARPOT(19)
      XK_COU	   =PARPOT(20)
     
      V0CENT_NEUTRS=PARPOT(21)
      R0CENT_NEUTRS=PARPOT(22)
      A0CENT_NEUTRS=PARPOT(23)
      V0SORB_NEUTRS=PARPOT(24)
      R0SORB_NEUTRS=PARPOT(25)
      A0SORB_NEUTRS=PARPOT(26)
      V0EFFM_NEUTRS=PARPOT(27)
      R0EFFM_NEUTRS=PARPOT(28)
      A0EFFM_NEUTRS=PARPOT(29)
     
      XK_V0C_NEUTRS=PARPOT(30)
      XK_R0C_NEUTRS=PARPOT(31)
      XK_A0C_NEUTRS=PARPOT(32)
      XK_LAM_NEUTRS=PARPOT(33)
      XK_RSO_NEUTRS=PARPOT(34)
      XK_ASO_NEUTRS=PARPOT(35)
      XK_LEF_NEUTRS=PARPOT(36)
      XK_REF_NEUTRS=PARPOT(37)
      XK_AEF_NEUTRS=PARPOT(38)
     
      ALAMPP       =PARPOT(39)
      ALAMPN       =PARPOT(40)
      ALAMNP       =PARPOT(41)
      ALAMNN       =PARPOT(42)

      TLAMPP       =PARPOT(43)
      TLAMPN       =PARPOT(44)
      TLAMNP       =PARPOT(45)
      TLAMNN       =PARPOT(46)
      
      CLAMPP       =PARPOT(47)
      CLAMPN       =PARPOT(48)
      CLAMNP       =PARPOT(49)
      CLAMNN       =PARPOT(50)

      IF (LDSING_PROTON.GT.NDSPEC) THEN
          STOP 'LDSING_PROTON.GT.NDSPEC in SPHLAB'
      END IF
C
C=======================================================================
C
      N_PART=IZ_FIX
C
C=======================================================================
C
      ICUMUL_PROTON(0)=0
C
      DO JSTATE=1,LDSING_PROTON
C
         INDEXN=LWSSPH_PROTON(JSTATE)
     *         +NWSSPH_PROTON(JSTATE)
     *         +NWSSPH_PROTON(JSTATE)
         INDEXL=LWSSPH_PROTON(JSTATE)
         INDEXJ=JWSSPH_PROTON(JSTATE)
C
         LABTHE_PROTON(JSTATE)=LBSHEL(INDEXN,INDEXL,INDEXJ)
         IDGLEV_PROTON(JSTATE)=JWSSPH_PROTON(JSTATE)+1
C
         ICUMUL_PROTON(JSTATE)=ICUMUL_PROTON(JSTATE-1)
     *                        +IDGLEV_PROTON(JSTATE) 
C
         IF (ICUMUL_PROTON(JSTATE).EQ.N_PART) THEN
             EFERMI_PROTON=ENETHE_PROTON(JSTATE)+1.0e-8
         END IF
C
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
C
          WRITE(IRESUL,'(/,80(''#''),/,''#'',78X,''#'',/,
     *               ''#   Central Potential:    V0CENT='',F8.4,
     *               ''   A0CENT='',F8.4,''  R0CENT='',F8.4,
     *               ''   #'',/,''#'',T62,''R0COUL='',F8.4,
     *               ''   #'')')
     *               V0CENT_PROTON,A0CENT_PROTON,R0CENT_PROTON,R0COUL
          WRITE(IRESUL,'(''#                         VKACEN='',F8.4,
     *               ''   AKACEN='',F8.4,''  RKACEN='',F8.4,
     *               ''   #'',/,''#'',T62,''RKACOU='',F8.4,
     *               ''   #'')')
     *               VKACEN_PROTON,AKACEN_PROTON,RKACEN_PROTON,
     *                                                  RKACOU
          WRITE(IRESUL,'(''#   S-Orbit Potential:    V0SORB='',F8.4,
     *               ''   A0SORB='',F8.4,''  R0SORB='',F8.4,
     *               ''   #'',78X,''#'')')
     *               V0SORB_PROTON,A0SORB_PROTON,R0SORB_PROTON
          WRITE(IRESUL,'(''#                         VKASOR='',F8.4,
     *               ''   AKASOR='',F8.4,''  RKASOR='',F8.4,
     *               ''   #'',/,''#'',78X,''#'',/,80(''#''))')
     *               VKASOR_PROTON,AKASOR_PROTON,RKASOR_PROTON

          WRITE(IRESUL,'(/,80(''#''),/,''#'',78X,''#'',/,
     *        ''#   Proton  Spherical Woods-Saxon Spectrum'',
     *        '' (LDSING='',I3,'')'',T63,
     *        ''Z='',I3,''   N='',I3,''    #'')') 
     *         LDSING_PROTON,IZ_FIX,IN_FIX
C
          WRITE(IRESUL,'(  ''#'',78X,''#'',/,80(''#''),             /,
     *            ''#'',78X,''#'',/,
     *            ''#   No)     Energy     State   Occup   '',
     *            ''    No)     Energy     State   Occup    #'',/,
     *            ''#'',78X,''#'')')
      END IF
C
C=======================================================================
C
      IF (IwMODE.EQ.2 .AND. LOGWRI.GT.4) THEN
C
          WRITE(LOGPRO,'(/,80(''#''),/,''#'',78X,''#'',/,
     *               ''#   Central Potential:     V0CENT='',F8.4,
     *               ''    A0CENT='',F6.4,''   R0CENT='',F6.4,
     *               ''    #'',/,''#'',T63,''R0COUL='',F6.4,
     *               ''    #'',/,
     *               ''#   S-Orbit Potential:     V0SORB='',F8.4,
     *               ''    A0SORB='',F6.4,''   R0SORB='',F6.4,
     *               ''    #'',/,''#'',78X,''#'',/,80(''#''))')
     *               V0CENT_PROTON,A0CENT_PROTON,R0CENT_PROTON,R0COUL,
     *               V0SORB_PROTON,A0SORB_PROTON,R0SORB_PROTON
C
          WRITE(LOGPRO,'(/,80(''#''),/,''#'',78X,''#'',/,
     *        ''#   Proton  Spherical Woods-Saxon Spectrum'',
     *        '' (LDSING='',I3,'')'',T63,
     *        ''Z='',I3,''   N='',I3,''    #'')') 
     *         LDSING_PROTON,IZ_FIX,IN_FIX
C
          WRITE(LOGPRO,'(  ''#'',78X,''#'',/,80(''#''),             /,
     *            ''#'',78X,''#'',/,
     *            ''#   No)     Energy     State   Occup   '',
     *            ''    No)     Energy     State   Occup    #'',/,
     *            ''#'',78X,''#'')')
      END IF
C
C=======================================================================
C
      DO ISTATE=1,LDSING_PROTON
         IF (ENETHE_PROTON(ISTATE).GT.ENEMAX) GO TO 1
      END DO
C
   1  CONTINUE
C   
      LDLINE=(ISTATE-1)/2
C
      DO LINE=1,LDLINE
C
         LINE_1=LINE
         LINE_2=LDLINE+LINE
C
         ICUM_1=ICUMUL_PROTON(LINE_1)
C
         ICUM_2=ICUMUL_PROTON(LINE_2)
C
         IF (LOGWRI.GT.4)
     *       WRITE(IRESUL,'(''#  '', I3,'')'',F12.5,4X,A6,I6,'' '',
     *                  ''      '',I3,'')'',F12.5,4X,A6,I6,'' '',
     *                                                 ''    #'')')
     *                LINE_1,ENETHE_PROTON(LINE_1),
     *                       LABTHE_PROTON(LINE_1),ICUM_1,
     *                LINE_2,ENETHE_PROTON(LINE_2),
     *                       LABTHE_PROTON(LINE_2),ICUM_2
C
         IF (IwMODE.EQ.2 .AND. LOGWRI.GT.4) THEN
C
             WRITE(LOGPRO,'(''#  '', I3,'')'',F12.5,4X,A6,I6,'' '',
     *                      ''      '',I3,'')'',F12.5,4X,A6,I6,'' '',
     *                                                   ''    #'')')
     *            LINE_1,ENETHE_PROTON(LINE_1),
     *                   LABTHE_PROTON(LINE_1),ICUM_1,
     *            LINE_2,ENETHE_PROTON(LINE_2),
     *                   LABTHE_PROTON(LINE_2),ICUM_2
         END IF
C
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.4) WRITE(IRESUL,'(''#'',78X,''#'',/,80(''#''))')
C
      IF (IwMODE.EQ.2  .AND. LOGWRI.GT.4) THEN
          WRITE(LOGPRO,'(''#'',78X,''#'',/,80(''#''))')
      END IF
C
C=======================================================================
C=======================================================================
C     Repeating the same algorithm for the neutrons
C=======================================================================
C=======================================================================
C
      N_PART=IN_FIX
C
C=======================================================================
C
      ICUMUL_NEUTRS(0)=0
C
      DO JSTATE=1,LDSING_NEUTRS
C
         INDEXN=LWSSPH_NEUTRS(JSTATE)
     *         +NWSSPH_NEUTRS(JSTATE)
     *         +NWSSPH_NEUTRS(JSTATE)
         INDEXL=LWSSPH_NEUTRS(JSTATE)
         INDEXJ=JWSSPH_NEUTRS(JSTATE)
C
         LABTHE_NEUTRS(JSTATE)=LBSHEL(INDEXN,INDEXL,INDEXJ)
         IDGLEV_NEUTRS(JSTATE)=JWSSPH_NEUTRS(JSTATE)+1
C
         ICUMUL_NEUTRS(JSTATE)=ICUMUL_NEUTRS(JSTATE-1)
     *                        +IDGLEV_NEUTRS(JSTATE) 
C @@@
         IF (ICUMUL_NEUTRS(JSTATE).EQ.N_PART) THEN
             EFERMI_NEUTRS=ENETHE_NEUTRS(JSTATE)+1.0e-8
         END IF
C
      END DO
C
      IF (LOGWRI.GT.4) THEN
C
          WRITE(IRESUL,'(/,80(''#''),/,''#'',78X,''#'',/,
     *               ''#   Central Potential:    V0CENT='',F8.4,
     *               ''   A0CENT='',F8.4,''  R0CENT='',F8.4,
     *               ''   #'',78X,''#'')')
     *               V0CENT_NEUTRS,A0CENT_NEUTRS,R0CENT_NEUTRS
          WRITE(IRESUL,'(''#                         VKACEN='',F8.4,
     *               ''   AKACEN='',F8.4,''  RKACEN='',F8.4,
     *               ''   #'',78X,''#'')')
     *               VKACEN_NEUTRS,AKACEN_NEUTRS,RKACEN_NEUTRS
          WRITE(IRESUL,'(''#   S-Orbit Potential:    V0SORB='',F8.4,
     *               ''   A0SORB='',F8.4,''  R0SORB='',F8.4,
     *               ''   #'',78X,''#'')')
     *               V0SORB_NEUTRS,A0SORB_NEUTRS,R0SORB_NEUTRS
          WRITE(IRESUL,'(''#                         VKASOR='',F8.4,
     *               ''   AKASOR='',F8.4,''  RKASOR='',F8.4,
     *               ''   #'',/,''#'',78X,''#'',/,80(''#''))')
     *               VKASOR_NEUTRS,AKASOR_NEUTRS,RKASOR_NEUTRS
C
          WRITE(IRESUL,'(/,80(''#''),/,''#'',78X,''#'',/,
     *        ''#   Neutron Spherical Woods-Saxon Spectrum '',
     *        '' (LDSING='',I3,'')'',T63,
     *        ''Z='',I3,''   N='',I3,''    #'')') 
     *          LDSING_NEUTRS,IZ_FIX,IN_FIX
C
          WRITE(IRESUL,'(  ''#'',78X,''#'',/,80(''#''),             /,
     *            ''#'',78X,''#'',/,
     *            ''#   No)     Energy     State   Occup   '',
     *            ''    No)     Energy     State   Occup    #'',/,
     *            ''#'',78X,''#'')')
      END IF
C
      IF (IwMODE.EQ.2 .AND. LOGWRI.GT.4) THEN
C
          WRITE(LOGNEU,'(/,80(''#''),/,''#'',78X,''#'',/,
     *               ''#   Central Potential:     V0CENT='',F8.4,
     *               ''    A0CENT='',F6.4,''   R0CENT='',F6.4,
     *               ''    #'',/,''#'',78X,''#'',/,
     *               ''#   S-Orbit Potential:     V0SORB='',F8.4,
     *               ''    A0SORB='',F6.4,''   R0SORB='',F6.4,
     *               ''    #'',/,''#'',78X,''#'',/,80(''#''))')
     *               V0CENT_NEUTRS,A0CENT_NEUTRS,R0CENT_NEUTRS,
     *               V0SORB_NEUTRS,A0SORB_NEUTRS,R0SORB_NEUTRS
C
          WRITE(LOGNEU,'(/,80(''#''),/,''#'',78X,''#'',/,
     *               ''#   Neutron Spherical Woods-Saxon Spectrum '',
     *               '' (LDSING='',I3,'')'',T63,
     *               ''Z='',I3,''   N='',I3,''    #'')') 
     *               LDSING_NEUTRS,IZ_FIX,IN_FIX
C
          WRITE(LOGNEU,'(  ''#'',78X,''#'',/,80(''#''),             /,
     *            ''#'',78X,''#'',/,
     *            ''#   No)     Energy     State   Occup   '',
     *            ''    No)     Energy     State   Occup    #'',/,
     *            ''#'',78X,''#'')')
      END IF
C
C=======================================================================
C
      DO ISTATE=1,LDSING_NEUTRS
         IF (ENETHE_NEUTRS(ISTATE).GT.ENEMAX) GO TO 2
      END DO
C
   2  CONTINUE
C   
      LDLINE=(ISTATE-1)/2
C
      DO LINE=1,LDLINE
C
         LINE_1=LINE
         LINE_2=LDLINE+LINE
C
         ICUM_1=ICUMUL_NEUTRS(LINE_1)
C
         ICUM_2=ICUMUL_NEUTRS(LINE_2)
C
         IF (LOGWRI.GT.4)
     *       WRITE(IRESUL,'(''#  '', I3,'')'',F12.5,4X,A6,I6,'' '',
     *                  ''      '',I3,'')'',F12.5,4X,A6,I6,'' '',
     *                                                 ''    #'')')
     *         LINE_1,ENETHE_NEUTRS(LINE_1),
     *                LABTHE_NEUTRS(LINE_1),ICUM_1,
     *         LINE_2,ENETHE_NEUTRS(LINE_2),
     *                LABTHE_NEUTRS(LINE_2),ICUM_2
C
          IF (IwMODE.EQ.2 .AND. LOGWRI.GT.4) THEN
C
              WRITE(LOGNEU,'(''#  '', I3,'')'',F12.5,4X,A6,I6,'' '',
     *                       ''      '',I3,'')'',F12.5,4X,A6,I6,'' '',
     *                                                    ''    #'')')
     *              LINE_1,ENETHE_NEUTRS(LINE_1),
     *                     LABTHE_NEUTRS(LINE_1),ICUM_1,
     *              LINE_2,ENETHE_NEUTRS(LINE_2),
     *                     LABTHE_NEUTRS(LINE_2),ICUM_2
          END IF
C
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.4) WRITE(IRESUL,'(''#'',78X,''#'',/,80(''#''))')
C
      IF (IwMODE.EQ.2 .AND. LOGWRI.GT.4) THEN
          WRITE(LOGNEU,'(''#'',78X,''#'',/,80(''#''))')
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE READEG(IDEGEN,LBSPHE)
      CHARACTER
     *          LBSPHE*6
C
C=======================================================================
C     This subroutine defines  the level degeneracies
C     using for this purpose the spectroscopic labels
C=======================================================================
C
      IF (LBSPHE(4:4).EQ.'/') THEN
          READ(LBSPHE(3:3),'(I1)') JDEGEN
      END IF
C
      IF (LBSPHE(5:5).EQ.'/') THEN
          READ(LBSPHE(3:4),'(I2)') JDEGEN
      END IF
C
      IDEGEN=JDEGEN+1
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE PRTNG(INUCLI,ISOSPI)  
          
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NITERA.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDIM_N.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      
      PARAMETER
     *         (NDIM_L=NDIM_N)
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,LABTHE*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6,LABEXP*6
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC),
     *          ENETHE(1:NDSPEC),
     *          EXPEXP(1:NDSPEC),
     *          LABTHE(1:NDSPEC),
     *          LABEXP(1:NDSPEC),
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
C
C=======================================================================
C     
      
      OPEN(70,FILE='Eth_vs_Eexp.d',STATUS='UNKNOWN')
      
      WRITE(70,'(/,''LDSING'',7X,''n'',4X,''L'',4X,''J'',3X,
     *             ''LEVEL'',4X,''Y?'',9X,
     *             ''E_THEO'',8X,''E_EXPE'',/)')
C
C=======================================================================
C
      IF (ISOSPI.EQ.1) THEN
        
        LDSING=LDSING_PROTON
        LEVEXP=LEVEXP_PROTON(INUCLI)
        
        DO I=1,LDSING
            
            NWSSPH(I)=NWSSPH_PROTON(I)
            LWSSPH(I)=LWSSPH_PROTON(I)
            JWSSPH(I)=JWSSPH_PROTON(I)
            
            ENETHE(I)=ENETHE_PROTON(I)
            LABTHE(I)=LABTHE_PROTON(I)
            
            LABORD(NWSSPH(I),LWSSPH(I),JWSSPH(I))=
     *      LABORD_PROTON(INUCLI,NWSSPH(I),LWSSPH(I),JWSSPH(I))
            
        END DO
        
        DO I=1,LEVEXP
            
            EXPEXP(I)=EXPEXP_PROTON(INUCLI,I)
            LABEXP(I)=LABEXP_PROTON(INUCLI,I)
            
        END DO
     
      ELSEIF (ISOSPI.EQ.0) THEN
      
        LDSING=LDSING_NEUTRS
        LEVEXP=LEVEXP_NEUTRS(INUCLI)
        
        DO I=1,LDSING
            
            NWSSPH(I)=NWSSPH_NEUTRS(I)
            LWSSPH(I)=LWSSPH_NEUTRS(I)
            JWSSPH(I)=JWSSPH_NEUTRS(I)
            
            ENETHE(I)=ENETHE_NEUTRS(I)
            LABTHE(I)=LABTHE_NEUTRS(I)
            
            LABORD(NWSSPH(I),LWSSPH(I),JWSSPH(I))=
     *      LABORD_NEUTRS(INUCLI,NWSSPH(I),LWSSPH(I),JWSSPH(I))
            
        END DO
       
        DO I=1,LEVEXP
            
            EXPEXP(I)=EXPEXP_PROTON(INUCLI,I)
            LABEXP(I)=LABEXP_PROTON(INUCLI,I)
            
         END DO
       
      END IF
C
C=======================================================================
C      
      DO I=1,LDSING
        
        IF (LABORD(NWSSPH(I),LWSSPH(I),JWSSPH(I)).EQ.1) THEN 
        
         DO J=1,LEVEXP
C      
          IF (LABEXP(J).EQ.LABTHE(I)) THEN
      
           WRITE(70,'(I3,6X,3I5,3x,a6,3x,''Y'',3X,2F14.6)')
     *       I,NWSSPH(I),LWSSPH(I),JWSSPH(I),LABTHE(I),
     *                              ENETHE(I),EXPEXP(J)
          
           GO TO 3
          
          END IF
          
          END DO
           
           WRITE(70,'(I3,6X,3I5,3x,a6,3x,''Y'',3X,F14.6)')
     *       I,NWSSPH(I),LWSSPH(I),JWSSPH(I),LABTHE(I),
     *                                        ENETHE(I)
        
        ELSE
        
         DO J=1,LEVEXP
C      
          IF (LABEXP(J).EQ.LABTHE(I)) THEN
        
           WRITE(70,'(I3,6X,3I5,3x,a6,3x,''N'',3X,2F14.6)')
     *       I,NWSSPH(I),LWSSPH(I),JWSSPH(I),LABTHE(I),
     *                             ENETHE(I),EXPEXP(J)
           GO TO 3
          
          END IF
         
         END DO
         
         WRITE(70,'(I3,6X,3I5,3x,a6,3x,''N'',3X,F14.6)')
     *       I,NWSSPH(I),LWSSPH(I),JWSSPH(I),LABTHE(I),
     *                                        ENETHE(I)
          
        END IF
        
   3    CONTINUE     
      
      END DO
      
      CLOSE(70)
      
      RETURN
      END    
C     
C=======================================================================
C=======================================================================
C 
C FILE NAME = wspher06_potnts_15.f ! Keep this symbol: $ident@string$
C
C=======================================================================
C=======================================================================
C                MATRIX ELEMENTS, POTENTIALS, HAMILTONIANS
C=======================================================================
C=======================================================================
C
      SUBROUTINE INTROD(INUCLI)
      
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
C
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /KAPPAR/ V0CENT_KAPPAR,XK_V0C_KAPPAR,
     *                R0CENT_KAPPAR,XK_R0C_KAPPAR,
     *                A0CENT_KAPPAR,XK_A0C_KAPPAR,
     *                V0SORB_KAPPAR,XK_V0S_KAPPAR,
     *                R0SORB_KAPPAR,XK_R0S_KAPPAR,
     *                A0SORB_KAPPAR,XK_A0S_KAPPAR
      COMMON
     *       /HBAR_V/ HBAR_C
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)      
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
     *       /DENSTR/ IFDENS
     *       /TENSOR/ IFTENS
      COMMON
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON
     *       /CTSHIF/ V0SHIF_PROTON(1:NDNUCL),
     *                V0SHIF_NEUTRS(1:NDNUCL)
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
     *       /MASSIV/ IMASIV_PRODUCC
      COMMON
     *       /PARCOR/ IFCORR,IFRCVC,IFRCAC,IFVCAC,IFRSVS,IFRSAS,IFVSAS
      COMMON
     *       /FACCOU/ COUFAC
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
      DATA
     *     XMASSP /938.27231 /,! Units: MeV/c**2; ERROR: (+/-)0.00028
     *     XMASSN /939.56563 / ! Units: MeV/c**2; ERROR: (+/-)0.00028
C
C=======================================================================
C     Introducing all the constant constants
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(/,9X,''Entering INTROD'')')
      END IF
C
C=======================================================================
C
      V0CENT_PROTON=PARPOT( 1)
      R0CENT_PROTON=PARPOT( 2)
      A0CENT_PROTON=PARPOT( 3)
      V0SORB_PROTON=PARPOT( 4)
      R0SORB_PROTON=PARPOT( 5)
      A0SORB_PROTON=PARPOT( 6)
      V0EFFM_PROTON=PARPOT( 7)
      R0EFFM_PROTON=PARPOT( 8)
      A0EFFM_PROTON=PARPOT( 9)
      R0COUL       =PARPOT(10)
     
      XK_V0C_PROTON=PARPOT(11)
      XK_R0C_PROTON=PARPOT(12)
      XK_A0C_PROTON=PARPOT(13)
      XK_LAM_PROTON=PARPOT(14)
      XK_RSO_PROTON=PARPOT(15)
      XK_ASO_PROTON=PARPOT(16)
      XK_LEF_PROTON=PARPOT(17)
      XK_REF_PROTON=PARPOT(18)
      XK_AEF_PROTON=PARPOT(19)
      XK_COU	   =PARPOT(20)
     
      V0CENT_NEUTRS=PARPOT(21)
      R0CENT_NEUTRS=PARPOT(22)
      A0CENT_NEUTRS=PARPOT(23)
      V0SORB_NEUTRS=PARPOT(24)
      R0SORB_NEUTRS=PARPOT(25)
      A0SORB_NEUTRS=PARPOT(26)
      V0EFFM_NEUTRS=PARPOT(27)
      R0EFFM_NEUTRS=PARPOT(28)
      A0EFFM_NEUTRS=PARPOT(29)
     
      XK_V0C_NEUTRS=PARPOT(30)
      XK_R0C_NEUTRS=PARPOT(31)
      XK_A0C_NEUTRS=PARPOT(32)
      XK_LAM_NEUTRS=PARPOT(33)
      XK_RSO_NEUTRS=PARPOT(34)
      XK_ASO_NEUTRS=PARPOT(35)
      XK_LEF_NEUTRS=PARPOT(36)
      XK_REF_NEUTRS=PARPOT(37)
      XK_AEF_NEUTRS=PARPOT(38)
C
C     For one single run we optionally apply 
C     the shift to the central potential
C
      IF (IFTEST.EQ.1) THEN
          V0CENT_PROTON=V0CENT_PROTON+V0SHIF_PROTON(INUCLI)
          V0CENT_NEUTRS=V0CENT_NEUTRS+V0SHIF_NEUTRS(INUCLI)
      END IF
C      
C=======================================================================
C=======================================================================
C     Spin-orbit potential with density dependence
C=======================================================================
C=======================================================================
C     
      ALAMPP=PARPOT(39)
      ALAMPN=PARPOT(40)
      ALAMNP=PARPOT(41)
      ALAMNN=PARPOT(42)
C      
C=======================================================================
C=======================================================================
C     Spin-orbit TENSOR Potential
C=======================================================================
C=======================================================================
C  
      TLAMPP=PARPOT(43)
      TLAMPN=PARPOT(44)
      TLAMNP=PARPOT(45)
      TLAMNN=PARPOT(46)
C      
C=======================================================================
C=======================================================================
C     Central TENSOR Potential
C=======================================================================
C=======================================================================
C      
      CLAMPP=PARPOT(47)
      CLAMPN=PARPOT(48)
      CLAMNP=PARPOT(49)
      CLAMNN=PARPOT(50)
C      
C=======================================================================
C=======================================================================
C     KAPpa PARametrization = KAPPAR
C=======================================================================
C=======================================================================
C      
      V0CENT_KAPPAR=PARPOT(51)
      XK_V0C_KAPPAR=PARPOT(52)
      R0CENT_KAPPAR=PARPOT(53)
      XK_R0C_KAPPAR=PARPOT(54)
      A0CENT_KAPPAR=PARPOT(55)
      XK_A0C_KAPPAR=PARPOT(56)
C
      V0SORB_KAPPAR=PARPOT(57)
      XK_V0S_KAPPAR=PARPOT(58)
      R0SORB_KAPPAR=PARPOT(59)
      XK_R0S_KAPPAR=PARPOT(60)
      A0SORB_KAPPAR=PARPOT(61)
      XK_A0S_KAPPAR=PARPOT(62)
C
C=======================================================================
C=======================================================================
C 
      A_MASS=IZ_FIX+IN_FIX
C
C=======================================================================
C=======================================================================
C         Proton part
C=======================================================================
C=======================================================================
C
      ISOSPI=1
C
      SIGISO=(IN_FIX-IZ_FIX)/A_MASS
C
C-----------------------------------------------------------------------      
C
      IF (IFK_VC.EQ.1) THEN
          VKACEN_PROTON=V0CENT_KAPPAR*(1+SIGISO*XK_V0C_KAPPAR)
      ELSE
          VKACEN_PROTON=V0CENT_PROTON
          V0CENT_KAPPAR=0.0
          XK_V0C_KAPPAR=0.0
      END IF
C
      IF (IFK_RC.EQ.1) THEN
          RKACEN_PROTON=
     *    R0CENT_KAPPAR*(1+SIGISO*XK_R0C_KAPPAR)*A_MASS**(1./3.)
      ELSE
          RKACEN_PROTON=R0CENT_PROTON*A_MASS**(1./3.)
          R0CENT_KAPPAR=0.0
          XK_R0C_KAPPAR=0.0
      END IF 
C     
      IF (IFK_AC.EQ.1) THEN
          AKACEN_PROTON=A0CENT_KAPPAR*(1+SIGISO*XK_A0C_KAPPAR)
      ELSE
          AKACEN_PROTON=A0CENT_PROTON
          A0CENT_KAPPAR=0.0
          XK_A0C_KAPPAR=0.0
      END IF
C     
      R0COUL=R0CENT_PROTON
      RKACOU=COUFAC*R0COUL*(1+SIGISO*XK_COU)*A_MASS**(1./3.)
C
C-----------------------------------------------------------------------      
C
      IF (IFK_VS.EQ.1) THEN
          VKASOR_PROTON=V0SORB_KAPPAR*(1+SIGISO*XK_V0S_KAPPAR)
      ELSE
          VKASOR_PROTON=V0SORB_PROTON
          V0SORB_KAPPAR=0.0
          XK_V0S_KAPPAR=0.0
      END IF
C
      IF (IFK_RS.EQ.1) THEN
          RKASOR_PROTON=
     *    R0SORB_KAPPAR*(1+SIGISO*XK_R0S_KAPPAR)*A_MASS**(1./3.)
      ELSE
          RKASOR_PROTON=R0SORB_PROTON*A_MASS**(1./3.)
          R0SORB_KAPPAR=0.0
          XK_R0S_KAPPAR=0.0
      END IF 
C     
      IF (IFK_AS.EQ.1) THEN
          AKASOR_PROTON=A0SORB_KAPPAR*(1+SIGISO*XK_A0S_KAPPAR)
      ELSE
          AKASOR_PROTON=A0SORB_PROTON
          A0SORB_KAPPAR=0.0
          XK_A0S_KAPPAR=0.0
      END IF
C
C-----------------------------------------------------------------------      
C
      RKAEFM_PROTON=
     *R0EFFM_PROTON*(1-SIGISO*XK_REF_PROTON)*A_MASS**(1./3.)
C     
      AKAEFM_PROTON=A0EFFM_PROTON*(1-SIGISO*XK_AEF_PROTON)
      VKAEFM_PROTON=V0EFFM_PROTON*(1-SIGISO*XK_LEF_PROTON) 
C      
C=======================================================================
C
      IF (IFCORR.EQ.1 .AND. IFRCVC.EQ.1) THEN
C
          VKACEN_PROTON=V0CENT_PROTON
C
          R0CENT_PROTON=R0CV0C(VKACEN_PROTON)
          RKACEN_PROTON=R0CENT_PROTON*A_MASS**(1./3.)
C
          AKACEN_PROTON=A0CENT_PROTON
              
          R0COUL=R0CENT_PROTON
          RKACOU=COUFAC*R0COUL*(1+SIGISO*XK_COU)*A_MASS**(1./3.)
C
      END IF
C      
C=======================================================================
C=======================================================================
C         Neutron part
C=======================================================================
C=======================================================================
C
      ISOSPI=0
C
      SIGISO=(IN_FIX-IZ_FIX)/A_MASS
C
C-----------------------------------------------------------------------      
C
      IF (IFK_VC.EQ.1) THEN
          VKACEN_NEUTRS=V0CENT_KAPPAR*(1-SIGISO*XK_V0C_KAPPAR)
      ELSE
          VKACEN_NEUTRS=V0CENT_NEUTRS
          V0CENT_KAPPAR=0.0
          XK_V0C_KAPPAR=0.0
      END IF
C
      IF (IFK_RC.EQ.1) THEN
          RKACEN_NEUTRS=
     *    R0CENT_KAPPAR*(1-SIGISO*XK_R0C_KAPPAR)*A_MASS**(1./3.)
      ELSE
          RKACEN_NEUTRS=R0CENT_NEUTRS*A_MASS**(1./3.)
          R0CENT_KAPPAR=0.0
          XK_R0C_KAPPAR=0.0
      END IF
C
      IF (IFK_AC.EQ.1) THEN
          AKACEN_NEUTRS=A0CENT_KAPPAR*(1-SIGISO*XK_A0C_KAPPAR)
      ELSE
          AKACEN_NEUTRS=A0CENT_NEUTRS
          A0CENT_KAPPAR=0.0
          XK_A0C_KAPPAR=0.0
      END IF
C
C-----------------------------------------------------------------------      
C
      IF (IFK_VS.EQ.1) THEN
          VKASOR_NEUTRS=V0SORB_KAPPAR*(1-SIGISO*XK_V0S_KAPPAR)
      ELSE
          VKASOR_NEUTRS=V0SORB_NEUTRS
          V0SORB_KAPPAR=0.0
          XK_V0S_KAPPAR=0.0
      END IF
C
      IF (IFK_RS.EQ.1) THEN
          RKASOR_NEUTRS=
     *    R0SORB_KAPPAR*(1-SIGISO*XK_R0S_KAPPAR)*A_MASS**(1./3.)
      ELSE
          RKASOR_NEUTRS=R0SORB_NEUTRS*A_MASS**(1./3.)
          R0SORB_KAPPAR=0.0
          XK_R0S_KAPPAR=0.0
      END IF
C
      IF (IFK_AS.EQ.1) THEN
          AKASOR_NEUTRS=A0SORB_KAPPAR*(1-SIGISO*XK_A0S_KAPPAR)
      ELSE
          AKASOR_NEUTRS=A0SORB_NEUTRS
          A0SORB_KAPPAR=0.0
          XK_A0S_KAPPAR=0.0
      END IF
C
C-----------------------------------------------------------------------      
C
      RKAEFM_NEUTRS=
     *R0EFFM_NEUTRS*(1-SIGISO*XK_REF_NEUTRS)*A_MASS**(1./3.)
C     
      AKAEFM_NEUTRS=A0EFFM_NEUTRS*(1-SIGISO*XK_AEF_NEUTRS)
      VKAEFM_NEUTRS=V0EFFM_NEUTRS*(1-SIGISO*XK_LEF_NEUTRS)
C
C=======================================================================
C
      IF (IFCORR.EQ.1 .AND. IFRCVC.EQ.1) THEN
C
          VKACEN_NEUTRS=V0CENT_NEUTRS
C
          R0CENT_NEUTRS=R0CV0C(VKACEN_NEUTRS)
          RKACEN_NEUTRS=R0CENT_NEUTRS*A_MASS**(1./3.)
C
          AKACEN_NEUTRS=A0CENT_NEUTRS
C
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *           ''#'',27X,''P A R A M E T E R S '',T80,''#'',/,
     *           ''#'',T80,''#'',/,
     *           ''#'',20X,''IZ_FIX='',I3,10X,''IN_FIX='',I3,
     *                                           T80,''#'',/,
     *           ''#'',T80,''#'',/,80(''#''))')IZ_FIX,IN_FIX
      
          WRITE(NOUTPT,'(/,80(''#''),/,''#'',''  Protons'',T80,''#'',/,
     *            ''#  VKACEN  VKASOR    '',
     *            ''RKACEN  RKASOR    '',
     *            ''AKACEN  AKASOR    RKACOU'',T80,''#'',/,
     *            ''#'',2F8.3,2X,2F8.4,2X,2F8.4,2X,F8.4,T80,''#'',/,
     *            ''#'',T80,''#'',/,80(''#''))')
     *
     *            VKACEN_PROTON,VKASOR_PROTON, 
     *            RKACEN_PROTON,RKASOR_PROTON,
     *            AKACEN_PROTON,AKASOR_PROTON,RKACOU
C
          WRITE(NOUTPT,'(/,80(''#''),/,''#'',''  Neutrons'',T80,''#'',/,
     *            ''#  VKACEN  VKASOR    '',
     *            ''RKACEN  RKASOR    '',
     *            ''AKACEN  AKASOR'',T80,''#'',/,
     *            ''#'',2F8.3,2X,2F8.4,2X,2F8.4,T80,''#'',/,
     *            ''#'',T80,''#'',/,80(''#''))')
     *
     *            VKACEN_NEUTRS,VKASOR_NEUTRS,
     *            RKACEN_NEUTRS,RKASOR_NEUTRS,
     *            AKACEN_NEUTRS,AKASOR_NEUTRS
C
          WRITE(NOUTPT,'(/,80(''#''),/,''#'',''  Kappa '',
     *            ''Parametrisation'',T80,''#'',/,
     *            ''#  V0CENT  XK_V0C    '',
     *            ''R0CENT  XK_R0C    '',
     *            ''A0CENT  XK_R0C'',T80,''#'',/,
     *            ''#'',2F8.3,2X,2F8.4,2X,2F8.4,T80,''#'',/,
     *            ''#'',T80,''#'',/,
     *            ''#  V0SORB  XK_LAM    '',
     *            ''R0SORB  XK_RSO    '',
     *            ''A0SORB  XK_ASO'',T80,''#'',/,
     *            ''#'',2F8.3,2X,2F8.4,2X,2F8.4,T80,''#'',/,
     *            ''#'',T80,''#'',/,''#'',T64,''R0COUL  XK_COU  #'',/,
     *            ''#'',T64,F6.4,F8.3,''  #'',/,
     *            ''#'',T80,''#'',/,80(''#''))')
     *
     *            V0CENT_KAPPAR,XK_V0C_KAPPAR,
     *            R0CENT_KAPPAR,XK_R0C_KAPPAR,
     *            A0CENT_KAPPAR,XK_A0C_KAPPAR,
     *            V0SORB_KAPPAR,XK_V0S_KAPPAR,
     *            R0SORB_KAPPAR,XK_R0S_KAPPAR,
     *            A0SORB_KAPPAR,XK_A0S_KAPPAR,R0COUL,XK_COU
C
          WRITE(NOUTPT,'(/,80(''#''),/,''#'',''  No-Kappa Protons'',
     *                                                    T80,''#'',/,
     *            ''#  V0CENT  V0SORB    '',
     *            ''R0CENT  R0SORB    '',
     *            ''A0CENT  A0SORB'',T80,''#'',/,
     *            ''#'',2F8.3,2X,2F8.4,2X,2F8.4,T80,''#'',/,
     *            ''#'',T80,''#'',/,''#'',T64,''R0COUL'',T80,''#'',/,
     *            ''#'',T64,F6.4,T80,''#'',/,
     *            ''#'',T80,''#'',/,80(''#''))')
     *
     *            V0CENT_PROTON,V0SORB_PROTON,
     *            R0CENT_PROTON,R0SORB_PROTON,
     *            A0CENT_PROTON,A0SORB_PROTON,R0COUL
C
          WRITE(NOUTPT,'(/,80(''#''),/,''#'',''  No-Kappa Neutron'',
     *                                                    T80,''#'',/,
     *            ''#  V0CENT  V0SORB    '',
     *            ''R0CENT  R0SORB    '',
     *            ''A0CENT  A0SORB'',T80,''#'',/,
     *            ''#'',2F8.3,2X,2F8.4,2X,2F8.4,T80,''#'',/,
     *            ''#'',T80,''#'',/,80(''#''))')
     *
     *            V0CENT_NEUTRS,V0SORB_NEUTRS,
     *            R0CENT_NEUTRS,R0SORB_NEUTRS,
     *            A0CENT_NEUTRS,A0SORB_NEUTRS
C
          IF (IFDENS.EQ.1)
     *        WRITE(NOUTPT,'(/,80(''#''),/,''#'',
     *            ''  Lambdas'',T80,''#'',/,
     *            ''#'',9X,''ALAMPP    ALAMPN    ALAMNP    ALAMNN'',
     *                                                     T80,''#'',/,
     *            ''#'',7X,4(F8.4,2X),T80,''#'',/,
     *            ''#'',T80,''#'',/,
     *            ''#'',9X,''TLAMPP    TLAMPN    TLAMNP    TLAMNN'',
     *                                                     T80,''#'',/,
     *            ''#'',7X,4(F8.4,2X),T80,''#'',/,
     *            ''#'',T80,''#'',/,
     *            ''#'',9X,''CLAMPP    CLAMPN    CLAMNP    CLAMNN'',
     *                                                     T80,''#'',/,
     *            ''#'',7X,4(F8.4,2X),T80,''#'',/,
     *            ''#'',T80,''#'',/,
     *            ''#'',T80,''#'',/,80(''#''))')
     *
     *            ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *            TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *            CLAMPP,CLAMPN,CLAMNP,CLAMNN
C
      END IF
C
C=======================================================================
C
      PARPOT( 1)=V0CENT_PROTON
      PARPOT( 2)=R0CENT_PROTON
      PARPOT( 3)=A0CENT_PROTON
      PARPOT( 4)=V0SORB_PROTON
      PARPOT( 5)=R0SORB_PROTON
      PARPOT( 6)=A0SORB_PROTON
      PARPOT( 7)=V0EFFM_PROTON
      PARPOT( 8)=R0EFFM_PROTON
      PARPOT( 9)=A0EFFM_PROTON
      PARPOT(10)=R0COUL
     
      PARPOT(11)=XK_V0C_PROTON
      PARPOT(12)=XK_R0C_PROTON
      PARPOT(13)=XK_A0C_PROTON
      PARPOT(14)=XK_LAM_PROTON
      PARPOT(15)=XK_RSO_PROTON
      PARPOT(16)=XK_ASO_PROTON
      PARPOT(17)=XK_LEF_PROTON
      PARPOT(18)=XK_REF_PROTON
      PARPOT(19)=XK_AEF_PROTON
      PARPOT(20)=XK_COU
     
      PARPOT(21)=V0CENT_NEUTRS
      PARPOT(22)=R0CENT_NEUTRS
      PARPOT(23)=A0CENT_NEUTRS
      PARPOT(24)=V0SORB_NEUTRS
      PARPOT(25)=R0SORB_NEUTRS
      PARPOT(26)=A0SORB_NEUTRS
      PARPOT(27)=V0EFFM_NEUTRS
      PARPOT(28)=R0EFFM_NEUTRS
      PARPOT(29)=A0EFFM_NEUTRS
     
      PARPOT(30)=XK_V0C_NEUTRS
      PARPOT(31)=XK_R0C_NEUTRS
      PARPOT(32)=XK_A0C_NEUTRS
      PARPOT(33)=XK_LAM_NEUTRS
      PARPOT(34)=XK_RSO_NEUTRS
      PARPOT(35)=XK_ASO_NEUTRS
      PARPOT(36)=XK_LEF_NEUTRS
      PARPOT(37)=XK_REF_NEUTRS
      PARPOT(38)=XK_AEF_NEUTRS
     
      PARPOT(39)=ALAMPP
      PARPOT(40)=ALAMPN
      PARPOT(41)=ALAMNP
      PARPOT(42)=ALAMNN

      PARPOT(43)=TLAMPP
      PARPOT(44)=TLAMPN
      PARPOT(45)=TLAMNP
      PARPOT(46)=TLAMNN
         
      PARPOT(47)=CLAMPP
      PARPOT(48)=CLAMPN
      PARPOT(49)=CLAMNP
      PARPOT(50)=CLAMNN
C
      PARPOT(51)=V0CENT_KAPPAR
      PARPOT(52)=XK_V0C_KAPPAR
      PARPOT(53)=R0CENT_KAPPAR
      PARPOT(54)=XK_R0C_KAPPAR
      PARPOT(55)=A0CENT_KAPPAR
      PARPOT(56)=XK_A0C_KAPPAR
C
      PARPOT(57)=V0SORB_KAPPAR
      PARPOT(58)=XK_V0S_KAPPAR
      PARPOT(59)=R0SORB_KAPPAR
      PARPOT(60)=XK_R0S_KAPPAR
      PARPOT(61)=A0SORB_KAPPAR
      PARPOT(62)=XK_A0S_KAPPAR
C
C=======================================================================
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Exiting INTROD'')')
c      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      FUNCTION R0CV0C(VARGUM)
C
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
C
C=======================================================================
C     Parabolic parametric correlation between r_o^c and V_o^c
C=======================================================================
C
      IF (IZ_FIX.EQ.82 .AND. IN_FIX.EQ.126) THEN
          IF (ISOSPI.EQ.1) THEN
              ACOEFF=0.00023262
              BCOEFF=0.04561273
              CCOEFF=3.16142711
          ELSE
              ACOEFF=0.00020081
              BCOEFF=0.03822447
              CCOEFF=2.63782567
          END IF
      END IF
C
      R0CV0C=ACOEFF*VARGUM**2 + BCOEFF*VARGUM + CCOEFF
C
C=======================================================================
C
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE INTROD_KAPPAS(INUCLI)
      
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
C
      CHARACTER
     *          NUCSYM*6,INPSYM*6
C
      COMMON
     *       /HBAR_V/ HBAR_C
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /KAPPAS/ V0CENK,XKAPPA_V0CENK,R0CENK,XKAPPA_R0CENK,
     *                                     A0CENK,XKAPPA_A0CENK,
     *                V0SORK,XKAPPA_V0SORK,R0SORK,XKAPPA_R0SORK,
     *                                     A0SORK,XKAPPA_A0SORK
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON
     *       /CTSHIF/ V0SHIF_PROTON(1:NDNUCL),
     *                V0SHIF_NEUTRS(1:NDNUCL)
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C
      WRITE(LOGFIL,'(''Entering INTROD_KAPPAS with IZ_FIX= '',I3,
     *               '' and IN_FIX= '',I3)') IZ_FIX,IN_FIX
C
C=======================================================================
C
C     Initializing things
C
      V0CENK=0.
      XKAPPA_V0CENK=0.
C
      R0CENK=0.
      XKAPPA_R0CENK=0.
C
      A0CENK=0.
      XKAPPA_A0CENK=0.
C_______________________________________________________________________
C
      V0SORK=0.
      XKAPPA_V0SORK=0.
C
      R0SORK=0.
      XKAPPA_R0SORK=0.
C
      A0SORK=0.
      XKAPPA_A0SORK=0.
C
C=======================================================================
C
      IZ_FIX=NUMB_Z(INUCLI)
      IN_FIX=NUMB_N(INUCLI)
      A_FIXX=IZ_FIX+IN_FIX
      FRACTN=(IN_FIX-IZ_FIX)/A_FIXX
C
C=======================================================================
C
C     Identifying the nucleus over which we have minimized 
C     in order to calculate V_o and kappa from it.
C
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             IZ_AUX=NUMB_Z(JNUCLI)
             IN_AUX=NUMB_N(JNUCLI)
             A_AUXX=IZ_AUX+IN_AUX
         END IF
      END DO
C
C=======================================================================
C
      WRITE(LOGFIL,'(''IZ_AUX= '',I3,'' and IN_AUX= '',I3)') 
     *                 IZ_AUX,              IN_AUX
C
C=======================================================================
C=======================================================================
C
C     Introducing the "kappa" variant to the CENTRAL potential
C     parameters
C
C     As they come from the minimization
C
      V_PROT=PARPOT(01)
      V_NEUT=PARPOT(21)
C
      R_PROT=PARPOT(02)
      R_NEUT=PARPOT(22)
C
      A_PROT=PARPOT(03)
      A_NEUT=PARPOT(23)
C
C=======================================================================
C
      XKAPPA_V0CENK= (V_PROT-V_NEUT)*A_AUXX
     *             /((V_PROT+V_NEUT)*(IN_AUX-IZ_AUX))
C
      V0CENK=0.500*(V_PROT+V_NEUT)
C_______________________________________________________________________
C
C
      VKACEN_PROTON=V0CENK*(1+XKAPPA_V0CENK*FRACTN)
C
      VKACEN_NEUTRS=V0CENK*(1-XKAPPA_V0CENK*FRACTN)
C
      IF (IZ_AUX.EQ.IN_AUX) THEN
          XKAPPA_V0CENK=0.0
          VKACEN_PROTON=V_PROT
          VKACEN_NEUTRS=V_NEUT
      END IF
C
C=======================================================================
C
      IF (IFK_RC.EQ.1) THEN
C
          IF (R_PROT.GT.R_NEUT) THEN
C
              XKAPPA_R0CENK= (R_PROT-R_NEUT)*(IN_AUX+IZ_AUX)
     *                     /((R_PROT+R_NEUT)*(IN_AUX-IZ_AUX))
C
              R0CENK=0.500*(R_NEUT+R_PROT)
C_______________________________________________________________________
C
              RKACEN_PROTON=R0CENK*(1+XKAPPA_R0CENK*FRACTN)
     *                            *A_FIXX**(1./3.)
C
              RKACEN_NEUTRS=R0CENK*(1-XKAPPA_R0CENK*FRACTN)
     *                            *A_FIXX**(1./3.)
C
          ELSE
C
              XKAPPA_R0CENK= (R_NEUT-R_PROT)*(IN_AUX+IZ_AUX)
     *                     /((R_PROT+R_NEUT)*(IN_AUX-IZ_AUX))
C
              R0CENK=0.500*(R_NEUT+R_PROT)
C_______________________________________________________________________
C
              RKACEN_PROTON=R0CENK*(1-XKAPPA_R0CENK*FRACTN)
     *                            *A_FIXX**(1./3.)
C
              RKACEN_NEUTRS=R0CENK*(1+XKAPPA_R0CENK*FRACTN)
     *                            *A_FIXX**(1./3.)
C
          END IF
C
          IF (IZ_AUX.EQ.IN_AUX) THEN
              XKAPPA_R0CENK=0.0
              RKACEN_PROTON=R_PROT
              RKACEN_NEUTRS=R_NEUT
          END IF
C
      END IF
C
C=======================================================================
C
      IF (IFK_AC.EQ.1) THEN
C
          IF (A_PROT.GT.A_NEUT) THEN
C
              XKAPPA_A0CENK=(A_PROT-A_NEUT)*(IN_AUX+IZ_AUX)
     *                    /((A_PROT+A_NEUT)*(IN_AUX-IZ_AUX))
C
              A0CENK=0.500*(A_NEUT+A_PROT)
C_______________________________________________________________________
C
              AKACEN_PROTON=A0CENK*(1+XKAPPA_A0CENK*FRACTN)
C
              AKACEN_NEUTRS=A0CENK*(1-XKAPPA_A0CENK*FRACTN)
C
          ELSE
C
              XKAPPA_A0CENK= (A_NEUT-A_PROT)*(IN_AUX+IZ_AUX)
     *                     /((A_PROT+A_NEUT)*(IN_AUX-IZ_AUX))
C
              A0CENK=0.500*(A_NEUT+A_PROT)
C_______________________________________________________________________
C
              AKACEN_PROTON=A0CENK*(1-XKAPPA_A0CENK*FRACTN)
C
              AKACEN_NEUTRS=A0CENK*(1+XKAPPA_A0CENK*FRACTN)
C
          END IF
C
          IF (IZ_AUX.EQ.IN_AUX) THEN
              XKAPPA_A0CENK=0.0
              AKACEN_PROTON=A_PROT
              AKACEN_NEUTRS=A_NEUT
          END IF
C
      END IF
C
C=======================================================================
C
      WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *           ''#'',27X,''PARAMETERS WITH KAPPAS'',T80,''#'',/,
     *           ''#'',T80,''#'',/,
     *           ''#'',25X,''IZ_FIX= '',I3,4X,''IN_FIX= '',I3,4X,/,
     *           ''#'',T80,''#'',/,80(''#''))') IZ_FIX,IN_FIX
C_______________________________________________________________________
C      
      WRITE(NOUTPT,'(/,80(''#''),/,''#'',''  Protons - Central'',
     *             T80,''#'',/,''#  '',17X,''V0CENT  XKAP_V  VKACEN'',
     *                        3X,''R0CENT  XKAP_R  RKACEN'',T80,''#'',/,
     *               ''#  '',15x,3f8.3,1x,3F8.3,T80,''#'',/,
     *             ''#'',T80,''#'',/,
     *             ''#'',44X,''A0CENT  XKAP_A  AKACEN'',T80,''#'',/,
     *             ''#'',42x,3F8.3,T80,''#'',/,
     *             ''#'',T80,''#'',/,80(''#''))')
     *
     *            V0CENK,XKAPPA_V0CENK,VKACEN_PROTON,
     *            R0CENK,XKAPPA_R0CENK,RKACEN_PROTON,
     *            A0CENK,XKAPPA_A0CENK,AKACEN_PROTON
C
      WRITE(NOUTPT,'(/,80(''#''),/,''#'',''  Neutron - Central'',
     *             T80,''#'',/,''#  '',17X,''V0CENT  XKAP_V  VKACEN'',
     *                        3X,''R0CENT  XKAP_R  RKACEN'',T80,''#'',/,
     *               ''#  '',15x,3f8.3,1x,3F8.3,T80,''#'',/,
     *             ''#'',T80,''#'',/,
     *             ''#'',44X,''A0CENT  XKAP_A  AKACEN'',T80,''#'',/,
     *             ''#'',42x,3F8.3,T80,''#'',/,
     *             ''#'',T80,''#'',/,80(''#''))')
     *
     *            V0CENK,XKAPPA_V0CENK,VKACEN_NEUTRS,
     *            R0CENK,XKAPPA_R0CENK,RKACEN_NEUTRS,
     *            A0CENK,XKAPPA_A0CENK,AKACEN_NEUTRS
C
C=======================================================================
C=======================================================================
C
C     Introducing the "kappa" variant to the SPIN-ORBIT potential
C     parameters (Pure Woods-Saxon)
C
C     As they come from the minimization
C
      V_PROT=PARPOT(04)
      V_NEUT=PARPOT(24)
C
      R_PROT=PARPOT(05)
      R_NEUT=PARPOT(25)
C
      A_PROT=PARPOT(06)
      A_NEUT=PARPOT(26)
C
C=======================================================================
C
      XKAPPA_V0SORK= (V_PROT-V_NEUT)*(IN_AUX+IZ_AUX)
     *             /((V_PROT+V_NEUT)*(IN_AUX-IZ_AUX))
C
      V0SORK=0.500*(V_NEUT+V_PROT)
C_______________________________________________________________________
C
C     Protons
C
      VKASOR_PROTON=V0SORK*(1+XKAPPA_V0SORK*FRACTN)
C
C     Neutrons
C
      VKASOR_NEUTRS=V0SORK*(1-XKAPPA_V0SORK*FRACTN)
C
      IF (IZ_AUX.EQ.IN_AUX) THEN
          XKAPPA_V0SORK=0.0
          VKASOR_PROTON=V_PROT
          VKASOR_NEUTRS=V_NEUT
      END IF
C
C=======================================================================
C
      IF (IFK_RS.EQ.1) THEN
C
          IF (R_PROT.GT.R_NEUT) THEN
C
              XKAPPA_R0SORK= (R_PROT-R_NEUT)*(IN_AUX+IZ_AUX)
     *                     /((R_PROT+R_NEUT)*(IN_AUX-IZ_AUX))
C
              R0SORK=0.500*(R_NEUT+R_PROT)
C_______________________________________________________________________
C
              RKASOR_PROTON=R0SORK*(1+XKAPPA_R0SORK*FRACTN)
     *                            *A_FIXX**(1./3.)
C
              RKASOR_NEUTRS=R0SORK*(1-XKAPPA_R0SORK*FRACTN)
     *                            *A_FIXX**(1./3.)
C
          ELSE
C
              XKAPPA_R0SORK= (R_NEUT-R_PROT)*(IN_AUX+IZ_AUX)
     *                     /((R_PROT+R_NEUT)*(IN_AUX-IZ_AUX))
C
              R0SORK=0.500*(R_NEUT+R_PROT)
C_______________________________________________________________________
C
              RKASOR_PROTON=R0SORK*(1-XKAPPA_R0SORK*FRACTN)
     *                            *A_FIXX**(1./3.)
C
              RKASOR_NEUTRS=R0SORK*(1+XKAPPA_R0SORK*FRACTN)
     *                            *A_FIXX**(1./3.)
C
          END IF
C
          IF (IZ_AUX.EQ.IN_AUX) THEN
              XKAPPA_R0SORK=0.0
              RKASOR_PROTON=R_PROT
              RKASOR_NEUTRS=R_NEUT
          END IF
C
      END IF
C
C=======================================================================
C
      IF (IFK_AS.EQ.1) THEN
C
          IF (A_PROT.GT.A_NEUT) THEN
C
              XKAPPA_A0SORK= (A_PROT-A_NEUT)*(IN_AUX+IZ_AUX)
     *                     /((A_PROT+A_NEUT)*(IN_AUX-IZ_AUX))
C
              A0SORK=0.500*(A_NEUT+A_PROT)
C_______________________________________________________________________
C
              AKASOR_PROTON=A0SORK*(1+XKAPPA_A0SORK*FRACTN)
C
              AKASOR_NEUTRS=A0SORK*(1-XKAPPA_A0SORK*FRACTN)
C
          ELSE
C
              XKAPPA_A0SORK= (A_NEUT-A_PROT)*(IN_AUX+IZ_AUX)
     *                     /((A_PROT+A_NEUT)*(IN_AUX-IZ_AUX))
C
              A0SORK=0.500*(A_NEUT+A_PROT)
C_______________________________________________________________________
C
              AKASOR_PROTON=A0SORK*(1-XKAPPA_A0SORK*FRACTN)
C
              AKASOR_NEUTRS=A0SORK*(1+XKAPPA_A0SORK*FRACTN)
C
          END IF
C
          IF (IZ_AUX.EQ.IN_AUX) THEN
              XKAPPA_A0SORK=0.0
              AKASOR_PROTON=A_PROT
              AKASOR_NEUTRS=A_NEUT
          END IF
C
      END IF
C
C=======================================================================
C      
      WRITE(NOUTPT,'(/,80(''#''),/,''#'',''  Protons - Central'',
     *             T80,''#'',/,''#  '',17X,''V0SORB  XKAP_V  VKASOR'',
     *                        3X,''R0SORB  XKAP_R  RKASOR'',T80,''#'',/,
     *               ''#  '',15x,3f8.3,1x,3F8.3,T80,''#'',/,
     *             ''#'',T80,''#'',/,
     *             ''#'',44X,''A0SORB  XKAP_A  AKASOR'',T80,''#'',/,
     *             ''#'',42x,3F8.3,T80,''#'',/,
     *             ''#'',T80,''#'',/,80(''#''))')
     *
     *            V0SORK,XKAPPA_V0SORK,VKASOR_PROTON,
     *            R0SORK,XKAPPA_R0SORK,RKASOR_PROTON,
     *            A0SORK,XKAPPA_A0SORK,AKASOR_PROTON
C
      WRITE(NOUTPT,'(/,80(''#''),/,''#'',''  Neutron - Central'',
     *             T80,''#'',/,''#  '',17X,''V0SORB  XKAP_V  VKASOR'',
     *                        3X,''R0SORB  XKAP_R  RKASOR'',T80,''#'',/,
     *               ''#  '',15x,3f8.3,1x,3F8.3,T80,''#'',/,
     *             ''#'',T80,''#'',/,
     *             ''#'',44X,''A0SORB  XKAP_A  AKASOR'',T80,''#'',/,
     *             ''#'',42x,3F8.3,T80,''#'',/,
     *             ''#'',T80,''#'',/,80(''#''))')
     *
     *            V0SORK,XKAPPA_V0SORK,VKASOR_NEUTRS,
     *            R0SORK,XKAPPA_R0SORK,RKASOR_NEUTRS,
     *            A0SORK,XKAPPA_A0SORK,AKASOR_NEUTRS
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      FUNCTION VCENTR(INUCLI,ZARGUM,IPOINT,LQNUMB)
C      
      INCLUDE    'MATDIM/NDNUCL.f'
C
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *        /HBAR_V/ HBAR_C
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)      
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /VPROEF/ V0EFFC
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
C
      DATA
     *        ALFCON / 137.03602 /     
C
C=======================================================================
C
C      IF (LOGWRI.GT.0) THEN
C          WRITE(LOGFIL,'(/,9X,''Entering VCENTR'')')
C      END IF
C
C=======================================================================
C      
      IF (ISOSPI.EQ.1) THEN
          AOSCIL=AOSCIL_PROTON(INUCLI)
	      VKACEN=VKACEN_PROTON
	      RKACEN=RKACEN_PROTON
	      AKACEN=AKACEN_PROTON
      END IF
C
      IF (ISOSPI.EQ.0) THEN
          AOSCIL=AOSCIL_NEUTRS(INUCLI)
	      VKACEN=VKACEN_NEUTRS
	      RKACEN=RKACEN_NEUTRS
	      AKACEN=AKACEN_NEUTRS
      END IF
C
C=======================================================================
C
      RADIUS=AOSCIL*SQRT(ZARGUM) ! Radius in Fermi
C
C=======================================================================
C
      VCENWS=VKACEN/(1.0+EXP((RADIUS-RKACEN)/AKACEN))
C
C=======================================================================
C
C     Analytical exression for the Coulomb potential of the uniformly
C                                                      charged sphere
      V_COUL=0.0
C
      IF (ISOSPI.EQ.1) THEN
C            
          IF (RADIUS.LE.RKACOU) THEN
C            
              V_COUL=HBAR_C*(IZ_FIX-1)/ALFCON/RKACOU
     *              *(1.500-0.5000000*(RADIUS/RKACOU)**2)   
          ELSE
              V_COUL=HBAR_C*(IZ_FIX-1)/(ALFCON*RADIUS)
C            
          END IF
C          
          V0EFFC=VKACEN+HBAR_C*(IZ_FIX-1)/ALFCON/RKACOU*1.500
C
      END IF
C
C=======================================================================
C @@@
C     The tensor contribution to the central potential, cf. Dx Eq.y
C
      VCTENS=0.0
C      
      IF (IFTENS.EQ.1 .AND. ICENTT.EQ.1) THEN
C
          SPIN_J_PROTON=SPIN_J(INUCLI,1,ZARGUM,IPOINT,LQNUMB)
          SPIN_J_NEUTRS=SPIN_J(INUCLI,0,ZARGUM,IPOINT,LQNUMB)
C          
          IF (ISOSPI.EQ.1) THEN
C              
              VCTENS=CLAMPP*SPIN_J_PROTON+CLAMPN*SPIN_J_NEUTRS
C              
          END IF
C          
          IF (ISOSPI.EQ.0) THEN
C              
              VCTENS=CLAMNP*SPIN_J_PROTON+CLAMNN*SPIN_J_NEUTRS
C              
          END IF
C          
      END IF
C
C=======================================================================    
C
      VCENTR=VCENWS+V_COUL+VCTENS
C
C=======================================================================
C
C      IF (LOGWRI.GT.0) THEN
C          WRITE(LOGFIL,'(/,9X,''Exiting VCENTR'')')
C      END IF
C
C=======================================================================
C
      RETURN
      END      
C
C=======================================================================
C=======================================================================
C
      FUNCTION V_SORB(INUCLI,ZARGUM)
C
      INCLUDE    'MATDIM/NDNUCL.f'
C
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)      
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI  
C
C=======================================================================
C     Spherical spin-orbit Woods-Saxon form-factor;
C     the argument denoted ZARGUM is dimensionless
C=======================================================================
C
C      IF (LOGWRI.GT.0) THEN
C          WRITE(LOGFIL,'(/,9X,''Exiting V_SORB'')')
C      END IF
C
C=======================================================================
C
      IF (ISOSPI.EQ.1) THEN
C
          AOSCIL=AOSCIL_PROTON(INUCLI)
	  VKASOR=VKASOR_PROTON
          AKASOR=AKASOR_PROTON
          RKASOR=RKASOR_PROTON
          V0UNIT=V0UNIT_PROTON
C
      END IF
C
      IF (ISOSPI.EQ.0) THEN
C
          AOSCIL=AOSCIL_NEUTRS(INUCLI)
          VKASOR=VKASOR_NEUTRS
          AKASOR=AKASOR_NEUTRS
          RKASOR=RKASOR_NEUTRS
          V0UNIT=V0UNIT_NEUTRS
C
      END IF
C
C=======================================================================
C      
      RADIUS=AOSCIL*SQRT(ZARGUM) ! Radius in Fermis
C      WRITE(0,*)'RADIUS',RADIUS,AOSCIL,ZARGUM,INUCLI
C
C=======================================================================
C      
      V_SORB=-VKASOR/AKASOR*EXP((RADIUS-RKASOR)/AKASOR)
     *              /(1.000+EXP((RADIUS-RKASOR)/AKASOR))**2
     *              /RADIUS
C
C=======================================================================
C
C      IF (LOGWRI.GT.0) THEN
C          WRITE(LOGFIL,'(/,9X,''Exiting V_SORB'')')
C      END IF
C
C=======================================================================
C
      RETURN
      END         
C      
C=======================================================================
C=======================================================================
C
      FUNCTION V_SORB_DENSIT(INUCLI,ZARGUM,IPOINT,LQNUMB)
          
      INCLUDE 'MATDIM/NDNUCL.f'
C      
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI  
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /DENSIF/ ITRNUM
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)
C      
C=======================================================================
C     This FUNCTION computes the density dependent spin-orbit potential 
C     taking into account the spin-J current (optional: IFTENS=1)
C                                ===>> Eq.(5.1.39) of MFV_14D.pdf
C=======================================================================
C      
C      IF (LOGWRI.GT.0) THEN
C          WRITE(0,'(/,9X,''Entering V_SORB_DENSIT'')')
C      END IF
C
C=======================================================================
C
      CALL CPUTIM('V_SORB',1)
C
C=======================================================================
C     
      IF (ISOSPI.EQ.1) THEN ! Protons
C          
          VSOAUX=DENSIT_GRADNT(INUCLI,1,ZARGUM,IPOINT,LQNUMB)*ALAMPP
     *          +DENSIT_GRADNT(INUCLI,0,ZARGUM,IPOINT,LQNUMB)*ALAMPN
C     
          IF (IFTENS.EQ.1 .AND. ISORBT.EQ.1) THEN
C              
              VSOAUX=VSOAUX
     *              +SPINJR(INUCLI,1,ZARGUM,IPOINT,LQNUMB)*TLAMPP
     *              +SPINJR(INUCLI,0,ZARGUM,IPOINT,LQNUMB)*TLAMPN
C     
          END IF
C      
      END IF
C      
      IF (ISOSPI.EQ.0) THEN ! Neutrons
C       
          VSOAUX=DENSIT_GRADNT(INUCLI,1,ZARGUM,IPOINT,LQNUMB)*ALAMNP
     *          +DENSIT_GRADNT(INUCLI,0,ZARGUM,IPOINT,LQNUMB)*ALAMNN
     
          IF (IFTENS.EQ.1 .AND. ISORBT.EQ.1) THEN
C              
              VSOAUX=VSOAUX
     *              +SPINJR(INUCLI,1,ZARGUM,IPOINT,LQNUMB)*TLAMNP
     *              +SPINJR(INUCLI,0,ZARGUM,IPOINT,LQNUMB)*TLAMNN
C     
          END IF
     
      END IF
C      
      V_SORB_DENSIT=VSOAUX
C
C=======================================================================
C      
C      IF (LOGWRI.GT.0) THEN
C          WRITE(0,'(/,9X,''Exiting V_SORB_DENSIT'')')
C      END IF
C
C=======================================================================
C 
      CALL CPUTIM('V_SORB',0)
C
C=======================================================================
C      
      RETURN
      END	     
C      
C=======================================================================
C=======================================================================
C
      FUNCTION DENSIT(XARGUM)
C      
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDIM_N.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1) 
      REAL*16
     *          QARGUM,QFLAGN,QDFLAG,QNORNL
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          DENSIT_VECTOR(1:NDGAUS,0:NDIM_L),
     *          DENAUX_TEST_L(0:NDIM_L)
      DIMENSION
     *          QFLAGN(0:NDIM_N,0:NDIM_L),
     *          QDFLAG(0:NDIM_N,0:NDIM_L),
     *          XFLAGN(0:NDIM_N,0:NDIM_L),
     *          XDFLAG(0:NDIM_N,0:NDIM_L)
C
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)   
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /NMLCNT/ XNORNL(0:NDIM_N,0:NDIM_L)
      COMMON
     *       /POLDEN/ 
     *        XPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *        XDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
       COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /ARGUMN/ IARG_R,IARG_Z
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
      COMMON
     *       /SIMUSE/ AOSCIL,RADCUT,INUCLI
C
C=======================================================================   
C  
C       This FUNCTION calculates the TOTAL DENSITY FUNCTION D1. Eq.(4.7.14)
C          
C          It is prepared to distinct between neutrons and protons
C
C=======================================================================     
C
C             It is mainly used for plotting purposes
C
C=======================================================================     
C
C      WRITE(0,'(''Entering DENSIT with INUCLI= '',I3,''ISOSPI= '',I3)')
C     *                                 INUCLI,ISOSPI
C
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================    
C      
      IF (ISOSPI.EQ.1) THEN
C        
          N_PART=IZ_FIX
          NSHELL=NSHELL_PROTON
          LDSING=LDSING_PROTON
C        
          AOSCIL=AOSCIL_PROTON(INUCLI)
          
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_PROTON(INUCLI)
              DELTA2=DELT_2(INUCLI,1)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,1)
          END IF
C        
          DO INDEXX=1,LDSING
C          
             LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
C          
          END DO
C        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
C             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
         END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI.EQ.0) THEN
C        
          N_PART=IN_FIX
          NSHELL=NSHELL_NEUTRS
          LDSING=LDSING_NEUTRS
C        
          AOSCIL=AOSCIL_NEUTRS(INUCLI)
          
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_NEUTRS(INUCLI)
              DELTA2=DELT_2(INUCLI,2)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,2)
          END IF
C        
          DO INDEXX=1,LDSING
C          
             LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
C          
          END DO
C        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
C             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
     
C
             END DO
         END DO                  
C
      END IF
C
C=======================================================================     
C
C       Calculating the polynomials in the desired ZARGUM point
C
C=======================================================================
C
C     IARG_R and IARG_Z are used in order to choose if we want to 
C     integrate over small r or over z.
C
C     IARG_R=1 - the integration will be done over r
C
C     IARG_Z=1 - the integration will be done over z
C
C=======================================================================
C
      IF (IARG_Z.EQ.1) ZARGUM=XARGUM
      IF (IARG_R.EQ.1) ZARGUM=(XARGUM/AOSCIL)**2
C
      KIND_L=1
      NORDER=NSHELL/2
      LORDER=NSHELL
C      
      QARGUM=QEXT(ZARGUM)    !passing the argument to real*16
C      
      CALL LAGUER(QARGUM,QFLAGN,QDFLAG,NORDER,LORDER,KIND_L,
     *                                        NDIM_L,NDIM_N)
C     
      DO NAUXIL=0,NORDER
        DO LAUXIL=0,LORDER
            XFLAGN(NAUXIL,LAUXIL)=REAL(QFLAGN(NAUXIL,LAUXIL))
            XDFLAG(NAUXIL,LAUXIL)=REAL(QDFLAG(NAUXIL,LAUXIL))
        END DO
      END DO
C
C=======================================================================     
C
C                   Calculating the DENSITY Eq.(4.7.14)
C
C=======================================================================        
C      
      PINUMB=4.0*ATAN(1.0)
      FACTOR=1.0/(PINUMB*(AOSCIL**3)) ! multiplied by 2/a 
C                                             from N_{n1,l}*N_{n2,l}
C
C  Here we calculate J_UP block
C      
      DEN_UP=0.0
C
      TESTV2=0.0
C      
      DO LQPRIM=NSHELL,0,-1
C          
         JNUMUP=2*LQPRIM+1
C
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
        
            ENERGY=ENERUP(LQPRIM,NWSNUM)
           
            IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 1
           
            IF (IF_PAI.EQ.0
     *          .AND.LABORD(NWSNUM-1,LQPRIM,JNUMUP).EQ.0) GO TO 1
     
            DNL_UP=0.0
C            
            DO N1NUMB=0,(NSHELL-LQPRIM)/2
C                
               DO N2NUMB=0,(NSHELL-LQPRIM)/2
C                  
                  CFACT1=(LQPRIM+1)*CMATUP(LQPRIM,N1NUMB+1,NWSNUM)
     *                             *CMATUP(LQPRIM,N2NUMB+1,NWSNUM)
C    
                  POLPOL=XNORNL(N1NUMB,LQPRIM)*XFLAGN(N1NUMB,LQPRIM)
     *                  *XNORNL(N2NUMB,LQPRIM)*XFLAGN(N2NUMB,LQPRIM)
C                
                  DNL_UP=DNL_UP+ZARGUM**LQPRIM*EXP(-ZARGUM)
     *                         *POLPOL*CFACT1
C                  
               END DO !N2NUMB
C              
            END DO !N1NUMB
C
                IF (IF_PAI.EQ.1) THEN
                    V2_PUP=V2PAIR(ENERGY,XLAMBD,DELTA2)
                    DEN_UP=DEN_UP+DNL_UP*V2_PUP
                    TESTV2=TESTV2+V2_PUP*(JNUMUP+1)
                ELSE
                    DEN_UP=DEN_UP+DNL_UP
                END IF
C
   1         CONTINUE
C            
         END DO !NWSNUM
C        
      END DO !LQPRIM
C
C  Here we calculate J_DOWN block
C
      DEN_DW=0.0

      DO LQPRIM=NSHELL,0,-1
C
         JNUMDW=2*LQPRIM-1     
C          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
            
            ENERGY=ENERDN(LQPRIM,NWSNUM)
           
            IF (JNUMDW.GE.0) THEN
                
                IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 2
           
                IF (IF_PAI.EQ.0
     *             .AND.LABORD(NWSNUM-1,LQPRIM,JNUMDW).EQ.0) GO TO 2
            
                DNL_DW=0.0
C            
                DO N1NUMB=0,(NSHELL-LQPRIM)/2
C                
                   DO N2NUMB=0,(NSHELL-LQPRIM)/2
C
                      CFACT2=(LQPRIM  )*CMATDN(LQPRIM,N1NUMB+1,NWSNUM)
     *                                 *CMATDN(LQPRIM,N2NUMB+1,NWSNUM)
C    
                      POLPOL=XNORNL(N1NUMB,LQPRIM)*XFLAGN(N1NUMB,LQPRIM)
     *                      *XNORNL(N2NUMB,LQPRIM)*XFLAGN(N2NUMB,LQPRIM)
C                
                      DNL_DW=DNL_DW+ZARGUM**LQPRIM*EXP(-ZARGUM)
     *                             *POLPOL*CFACT2
C                  
                   END DO !N2NUMB
C              
                END DO !N1NUMB
               
                IF (IF_PAI.EQ.1) THEN
                    V2_PDW=V2PAIR(ENERGY,XLAMBD,DELTA2)
                    DEN_DW=DEN_DW+DNL_DW*V2_PDW
                    TESTV2=TESTV2+V2_PDW*(JNUMDW+1)
                ELSE
                    DEN_DW=DEN_DW+DNL_DW
                END IF             
                                                
            END IF  !JNUMDW.GE.0
           
   2        CONTINUE            
      
         END DO !NWSNUM
C        
      END DO !LQPRIM
C      
      DENSIT=(DEN_UP+DEN_DW)*FACTOR
C
C=======================================================================
C     
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      FUNCTION DENSIT_LAGUER(INUCLI,ISOSPI_AUXILI,ZARGUM,IPOINT,LQNUMB)
C      
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDIM_N.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1) 
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          DENSIT_VECTOR(1:NDGAUS,0:NDIM_L),
     *          DENAUX_TEST_L(0:NDIM_L)
C
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)   
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /POLPOL/ XPOLYN(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *                XDPOLY(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      COMMON
     *       /POLDEN/ 
     *        XPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *        XDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
       COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
C
C=======================================================================   
C  
C       This FUNCTION calculates the TOTAL DENSITY FUNCTION Eq.(4.7.14)
C       at LAGUERRE NODES
C          
C          It is prepared to distinct between netrons and protons 
C
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================    
C     
      IF (ISOSPI_AUXILI.EQ.1) THEN
C        
          N_PART=IZ_FIX
          NSHELL=NSHELL_PROTON
          LDSING=LDSING_PROTON
C        
          AOSCIL=AOSCIL_PROTON(INUCLI)
          
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_PROTON(INUCLI)
              DELTA2=DELT_2(INUCLI,1)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,1)
          END IF
C        
          DO INDEXX=1,LDSING
C          
             LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
C          
          END DO
C        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
C             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
          END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI_AUXILI.EQ.0) THEN
        
          N_PART=IN_FIX
          NSHELL=NSHELL_NEUTRS
          LDSING=LDSING_NEUTRS
        
          AOSCIL=AOSCIL_NEUTRS(INUCLI)
          
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_NEUTRS(INUCLI)
              DELTA2=DELT_2(INUCLI,2)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,2)
          END IF
        
          DO INDEXX=1,LDSING
          
             LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
          
          END DO
        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
          END DO                  
C
      END IF
C
C=======================================================================     
C
C                   Calculating the DENSITY Eq.(4.7.14)
C
C=======================================================================        
C      
      PINUMB=4.0*ATAN(1.0)
      FACTOR=1.0/(PINUMB*(AOSCIL**3)) ! multiplied by 2/a 
C                                             from N_{n1,l}*N_{n2,l}
C
C  Here we calculate J_UP block
C      
      DEN_UP=0.0
C
C      DO LQPRIM=NSHELL,0,-1
C          
        JNUMUP=2*LQNUMB+1
        
         DO NWSNUM=1,(NSHELL-LQNUMB)/2+1
        
            ENERGY=ENERUP(LQNUMB,NWSNUM)
           
            IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 1
           
            IF (IF_PAI.EQ.0
     *          .AND.LABORD(NWSNUM-1,LQNUMB,JNUMUP).EQ.0) GO TO 1
     
                 DNL_UP=0.0
            
                 DO N1NUMB=0,(NSHELL-LQNUMB)/2
                
                    DO N2NUMB=0,(NSHELL-LQNUMB)/2
                  
                       CFACT1=(LQNUMB+1)*CMATUP(LQNUMB,N1NUMB+1,NWSNUM)
     *                                  *CMATUP(LQNUMB,N2NUMB+1,NWSNUM)
               
                      POLPOL=XPOLYN(IPOINT,N1NUMB,LQNUMB)
     *                      *XPOLYN(IPOINT,N2NUMB,LQNUMB)
    
C              POLPOL=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
C     *              *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
                
                      DNL_UP=DNL_UP+POLPOL*CFACT1
CID     *                             *ZARGUM**LQNUMB*EXP(-ZARGUM)
                  
                   END DO !N2NUMB
              
                END DO !N1NUMB
          
                IF (IF_PAI.EQ.1) THEN
                    V2_PUP=V2PAIR(ENERGY,XLAMBD,DELTA2)
                    DEN_UP=DEN_UP+DNL_UP*V2_PUP
                ELSE
                    DEN_UP=DEN_UP+DNL_UP
                END IF
              
   1         CONTINUE
            
        END DO !NWSNUM
        
C      END DO !LQPRIM
C
C  Here we calculate J_DOWN block
C
      DEN_DW=0.0
C      DO LQPRIM=NSHELL,0,-1

        JNUMDW=2*LQNUMB-1          
                              
        DO NWSNUM=1,(NSHELL-LQNUMB)/2+1
            
           ENERGY=ENERDN(LQNUMB,NWSNUM)
           
           IF (JNUMDW.GE.0) THEN
                
               IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 2
           
               IF (IF_PAI.EQ.0
     *             .AND.LABORD(NWSNUM-1,LQNUMB,JNUMDW).EQ.0) GO TO 2
            
                    DNL_DW=0.0
            
                    DO N1NUMB=0,(NSHELL-LQNUMB)/2
                
                       DO N2NUMB=0,(NSHELL-LQNUMB)/2
    
                          CFACT2=(LQNUMB)
     *                          *CMATDN(LQNUMB,N1NUMB+1,NWSNUM)
     *                          *CMATDN(LQNUMB,N2NUMB+1,NWSNUM)
               
                          POLPOL=XPOLYN(IPOINT,N1NUMB,LQNUMB)
     *                          *XPOLYN(IPOINT,N2NUMB,LQNUMB)
    
C              POLPOL=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
C     *              *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
                
                          DNL_DW=DNL_DW+POLPOL*CFACT2
CID     *                          *ZARGUM**LQNUMB*EXP(-ZARGUM)
                  
                  END DO !N2NUMB
              
               END DO !N1NUMB
               
               IF (IF_PAI.EQ.1) THEN
                   V2_PDW=V2PAIR(ENERGY,XLAMBD,DELTA2)
                   DEN_DW=DEN_DW+DNL_DW*V2_PDW
               ELSE
                   DEN_DW=DEN_DW+DNL_DW
               END IF             
                                                
           END IF  !JNUMDW.GE.0
           
   2       CONTINUE            
      
        END DO !NWSNUM
        
C      END DO !LQPRIM
      
      DENSIT_LAGUER=(DEN_UP+DEN_DW)!*FACTOR
C
C=======================================================================
C     
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      FUNCTION DENSIT_STATES(INUCLI,ISOSPI_AUXILI,ZARGUM,IPOINT,
     *                                     LQNUMB,NWSNUM,JQNUMB)
C      
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDIM_N.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1) 
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          DENSIT_VECTOR(1:NDGAUS,0:NDIM_L),
     *          DENAUX_TEST_L(0:NDIM_L)
C
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)   
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /POLPOL/ XPOLYN(1:NDGAUS,0:NDIM_N,0:NDIM_L), 
     *                XDPOLY(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      COMMON
     *       /POLDEN/ 
     *        XPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *        XDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /V2_COE/ V2_PUP_VECTOR(0:NDIM_L,1:NDBASE),
     *                V2_PDW_VECTOR(0:NDIM_L,1:NDBASE),
     *                DUP_LN(0:NDIM_L,1:NDBASE),
     *                DDW_LN(0:NDIM_L,1:NDBASE),
     *                ENERGY,XLAMBD,DELTA2
      COMMON
     *       /V2COEF/ VCOEUP_PROTON(0:NDIM_L,1:NDBASE),
     *                VCOEDN_PROTON(0:NDIM_L,1:NDBASE),
     *
     *                VCOEUP_NEUTRS(0:NDIM_L,1:NDBASE),
     *                VCOEDN_NEUTRS(0:NDIM_L,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
       COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
C
C=======================================================================   
C  
C       This FUNCTION calculates the PARTIAL DENSITY FUNCTION
C        Eq.(4.7.14) at the LAGUERRE NODES.
C          
C          It is prepared to distinct between neutrons and protons 
C
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================    
C     
      IF (ISOSPI_AUXILI.EQ.1) THEN
C        
          N_PART=IZ_FIX
          NSHELL=NSHELL_PROTON
          LDSING=LDSING_PROTON
C        
          AOSCIL=AOSCIL_PROTON(INUCLI)
          
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_PROTON(INUCLI)
              DELTA2=DELT_2(INUCLI,1)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,1)
          END IF
C        
          DO INDEXX=1,LDSING
C          
             LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
C          
          END DO
C        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
C             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
          END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI_AUXILI.EQ.0) THEN
        
          N_PART=IN_FIX
          NSHELL=NSHELL_NEUTRS
          LDSING=LDSING_NEUTRS
        
          AOSCIL=AOSCIL_NEUTRS(INUCLI)
          
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_NEUTRS(INUCLI)
              DELTA2=DELT_2(INUCLI,2)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,2)
          END IF
        
          DO INDEXX=1,LDSING
          
             LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
          
          END DO
        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
          END DO                  
C
      END IF
C
C=======================================================================     
C
C                   Calculating the DENSITY Eq.(4.7.14)
C
C=======================================================================        
C      
      PINUMB=4.0*ATAN(1.0)
      FACTOR=1.0/(PINUMB*(AOSCIL**3)) ! multiplied by 2/a 
C                                             from N_{n1,l}*N_{n2,l}

      DENAUX=0.0
      
      V2_PUP_VECTOR(LQNUMB,NWSNUM)=0.0
      V2_PDW_VECTOR(LQNUMB,NWSNUM)=0.0

C
C  Here we calculate J_UP block
C      
      DEN_UP=0.0
      
      V2_SUM=0.0
C
C      DO LQPRIM=NSHELL,0,-1
C          
        JNUMUP=2*LQNUMB+1
        
C         DO NWSNUM=1,(NSHELL-LQNUMB)/2+1
        
        IF (JQNUMB.EQ.JNUMUP) THEN
            
            ENERGY=ENERUP(LQNUMB,NWSNUM)
           
            IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 1
           
            IF (IF_PAI.EQ.0
     *          .AND.LABORD(NWSNUM-1,LQNUMB,JNUMUP).EQ.0) GO TO 1
     
                 DNL_UP=0.0
            
                 DO N1NUMB=0,(NSHELL-LQNUMB)/2
                
                    DO N2NUMB=0,(NSHELL-LQNUMB)/2
                  
                       CFACT1=(LQNUMB+1)*CMATUP(LQNUMB,N1NUMB+1,NWSNUM)
     *                                  *CMATUP(LQNUMB,N2NUMB+1,NWSNUM)
               
                      POLPOL=XPOLYN(IPOINT,N1NUMB,LQNUMB)
     *                      *XPOLYN(IPOINT,N2NUMB,LQNUMB)
    
C              POLPOL=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
C     *              *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
                
                      DNL_UP=DNL_UP+POLPOL*CFACT1
CID     *                             *ZARGUM**LQNUMB*EXP(-ZARGUM)
                  
                   END DO !N2NUMB
              
                END DO !N1NUMB
          
                IF (IF_PAI.EQ.1) THEN
                    
                    V2_PUP=V2PAIR(ENERGY,XLAMBD,DELTA2)
                    V2_PUP_VECTOR(LQNUMB,NWSNUM)=V2_PUP
                    
                    DEN_UP=DEN_UP+DNL_UP*V2_PUP
                    DUP_LN(LQNUMB,NWSNUM)=DNL_UP
                    
                    V2_SUM=V2_SUM+V2_PUP
                    
                ELSE
                    DEN_UP=DEN_UP+DNL_UP
                END IF
              
   1         CONTINUE
   
        DENAUX=DEN_UP
   
        END IF 
            
C        END DO !NWSNUM
        
C      END DO !LQPRIM
C      
C
C  Here we calculate J_DOWN block
C
      DEN_DW=0.0
C      DO LQPRIM=NSHELL,0,-1

        JNUMDW=2*LQNUMB-1          
                              
C        DO NWSNUM=1,(NSHELL-LQNUMB)/2+1
            
           ENERGY=ENERDN(LQNUMB,NWSNUM)
           
           IF (JNUMDW.EQ.JQNUMB.AND.JNUMDW.GE.0) THEN
                
               IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 2
           
               IF (IF_PAI.EQ.0
     *             .AND.LABORD(NWSNUM-1,LQNUMB,JNUMDW).EQ.0) GO TO 2
            
                    DNL_DW=0.0
            
                    DO N1NUMB=0,(NSHELL-LQNUMB)/2
                
                       DO N2NUMB=0,(NSHELL-LQNUMB)/2
    
                          CFACT2=(LQNUMB)
     *                          *CMATDN(LQNUMB,N1NUMB+1,NWSNUM)
     *                          *CMATDN(LQNUMB,N2NUMB+1,NWSNUM)
               
                          POLPOL=XPOLYN(IPOINT,N1NUMB,LQNUMB)
     *                          *XPOLYN(IPOINT,N2NUMB,LQNUMB)
    
C              POLPOL=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
C     *              *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
                
                          DNL_DW=DNL_DW+POLPOL*CFACT2
CID     *                          *ZARGUM**LQNUMB*EXP(-ZARGUM)
                  
                  END DO !N2NUMB
              
               END DO !N1NUMB
               
               IF (IF_PAI.EQ.1) THEN
                   
                   V2_PDW=V2PAIR(ENERGY,XLAMBD,DELTA2)
                   V2_PDW_VECTOR(LQNUMB,NWSNUM)=V2_PDW
                   
                   DEN_DW=DEN_DW+DNL_DW*V2_PDW
                   DDW_LN(LQNUMB,NWSNUM)=DNL_DW
                   
                   V2_SUM=V2_SUM+V2_PDW
                   
               ELSE
                   DEN_DW=DEN_DW+DNL_DW
               END IF   
               
               DENAUX=DEN_DW
                                                
           END IF  !JNUMDW.GE.0
           
   2       CONTINUE            
      
C        END DO !NWSNUM
        
C      END DO !LQPRIM
      
      DENSIT_STATES=DENAUX!*FACTOR
C
C=======================================================================
C     
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      FUNCTION DENSIT_GRADNT(INUCLI,ISOSPI_AUXILI,ZARGUM,IPOINT,LQNUMB)
C          
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDIM_N.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1) 
C      
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          DENDER(1:NDGAUS,0:NDIM_N,0:NDIM_N,0:NDIM_L),
     *          AUXILI(1:NDGAUS)
C
      COMMON
     *       /POLDEN/ 
     *        XPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *        XDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)    
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /NMLCNT/ XNORNL(0:NDIM_N,0:NDIM_L)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
       COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /DENSIF/ ITRNUM
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI      
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
      COMMON
     *       /CNTCNT/ ICOUNT_DENGRD,ICOUNT_FUNMIN,ICOUNT_HAMMAT,
     *                ICOUNT_EXPTHE,ICOUNT_CHOICE,ICOUNT_DIAMAT
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
C=======================================================================   
C
       CALL CPUTIM('DENGRD',1)
C       
       ICOUNT_DENGRD=ICOUNT_DENGRD+1
C
C=======================================================================   
C  
CID        This FUNCTION calculates the GRADIENT OF THE DENSITY 
C               Eq.(4.7.21)=(1/r)*(drho/dr) from MFV12.pdf
C
C=======================================================================     
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Entering DENSIT_GRADNT'',/,
c     *                   9X,/,9X,''ISOSPI_AUXILI='',I1)')ISOSPI_AUXILI
c      END IF
C
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================  
C    
      IF (ISOSPI_AUXILI.EQ.1) THEN
C        
          N_PART=IZ_FIX
          NSHELL=NSHELL_PROTON
          LDSING=LDSING_PROTON
C        
          AOSCIL=AOSCIL_PROTON(INUCLI)
          
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_PROTON(INUCLI)
              DELTA2=DELT_2(INUCLI,1)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,1)
          END IF
C        
          DO INDEXX=1,LDSING
C          
             LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
C          
          END DO
          
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	         NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
C             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          

             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
         END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI_AUXILI.EQ.0) THEN
        
        N_PART=IN_FIX
        NSHELL=NSHELL_NEUTRS
        LDSING=LDSING_NEUTRS
        
        AOSCIL=AOSCIL_NEUTRS(INUCLI)
        
        IF (IF_PAI.EQ.1) THEN
            XLAMBD=XLAMBD_NEUTRS(INUCLI)
            DELTA2=DELT_2(INUCLI,2)
            ENEMAX=ENEMAX_BCSPAI(INUCLI,2)
        END IF
        
        DO INDEXX=1,LDSING
          
          LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
          NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
          JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
          
        END DO
C
        DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
             NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C     
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
     
C
             END DO
        END DO                  
C
      END IF
C
C=======================================================================     
C
C                 Calculating the DENSITY GRADIENT Eq.(4.7.21)
C
C=======================================================================        
C   
      PINUMB=4.*ATAN(1.0)
      FACTOR=2./(PINUMB*AOSCIL**5)
C
C  Here we calculate J_UP block
C      
      DEN_UP=0.0
      TESTV2=0.0
      
      DO LQPRIM=NSHELL,0,-1 
         
         JNUMUP=2*LQPRIM+1  
          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
            
            ENERGY=ENERUP(LQPRIM,NWSNUM)
            
            IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 1
           
            IF (IF_PAI.EQ.0
     *          .AND.LABORD(NWSNUM-1,LQPRIM,JNUMUP).EQ.0) GO TO 1
                
                DNL_UP=0.0
                
                DO N1NUMB=0,(NSHELL-LQPRIM)/2
                
                   DO N2NUMB=0,(NSHELL-LQPRIM)/2
                                         
                      CFACT1=(LQPRIM+1)*CMATUP(LQPRIM,N1NUMB+1,NWSNUM)
     *                                 *CMATUP(LQPRIM,N2NUMB+1,NWSNUM)
              
                      POLPOL=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
     *                      *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
     
                      POLDER=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
     *                      *XDPOLY_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
     
                      DERPOL=XDPOLY_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
     *                      *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
              
                      ZLTLAG=(LQPRIM-ZARGUM)*POLPOL
     *                      +ZARGUM*(POLDER+DERPOL)
                
                      DNL_UP=DNL_UP+EXP(-ZARGUM)*ZARGUM**(LQPRIM-1)
     *                             *CFACT1*ZLTLAG
     
                  END DO !N2NUMB
              
               END DO !N1NUMB
               
               IF (IF_PAI.EQ.1) THEN
                   
                   V2_PUP=V2PAIR(ENERGY,XLAMBD,DELTA2)
                   DEN_UP=DEN_UP+DNL_UP*V2_PUP
                   
                   TESTV2=TESTV2+V2_PUP*(JNUMUP+1)   
                   
               ELSE
                   DEN_UP=DEN_UP+DNL_UP
               END IF
              
   1         CONTINUE
           
         END DO !NWSNUM
      
      END DO !LQPRIM
C
C  Here we calculate J_DOWN block
C
      DEN_DW=0.0
      
      DO LQPRIM=NSHELL,0,-1 
          
         JNUMDW=2*LQPRIM-1
          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
             
            ENERGY=ENERDN(LQPRIM,NWSNUM)
           
            IF (JNUMDW.GE.0) THEN
                
                IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 2
           
                IF (IF_PAI.EQ.0
     *              .AND.LABORD(NWSNUM-1,LQPRIM,JNUMDW).EQ.0) GO TO 2
                    
                    DNL_DW=0.0
                    
                    DO N1NUMB=0,(NSHELL-LQPRIM)/2
                
                       DO N2NUMB=0,(NSHELL-LQPRIM)/2
    
                          CFACT2=(LQPRIM)
     *                          *CMATDN(LQPRIM,N1NUMB+1,NWSNUM)
     *                          *CMATDN(LQPRIM,N2NUMB+1,NWSNUM)
              
                          POLPOL=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,
     *                                                       LQNUMB) 
     *                          *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,
     *                                                       LQNUMB) 
     
                          POLDER=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,
     *                                                       LQNUMB)  
     *                          *XDPOLY_DENSIT(IPOINT,N2NUMB,LQPRIM,
     *                                                       LQNUMB) 
     
                          DERPOL=XDPOLY_DENSIT(IPOINT,N1NUMB,LQPRIM,
     *                                                       LQNUMB) 
     *                          *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,
     *                                                       LQNUMB) 
              
                          ZLTLAG=(LQPRIM-ZARGUM)*POLPOL
     *                          +ZARGUM*(POLDER+DERPOL)
     
                          DNL_DW=DNL_DW+EXP(-ZARGUM)*ZARGUM**(LQPRIM-1)
     *                                 *CFACT2*ZLTLAG
                
                       END DO !N2NUMB
              
                    END DO !N1NUMB
                    
                    IF (IF_PAI.EQ.1) THEN
                        
                        V2_PDW=V2PAIR(ENERGY,XLAMBD,DELTA2)
                        DEN_DW=DEN_DW+DNL_DW*V2_PDW
                        
                        TESTV2=TESTV2+V2_PDW*(JNUMDW+1) 
                        
                   ELSE
                        DEN_DW=DEN_DW+DNL_DW
                   END IF

            END IF
            
   2        CONTINUE 
                
         END DO !NWSNUM
      
      END DO !LQPRIM
C
C=======================================================================     
C      
      DENSIT_GRADNT=(DEN_UP+DEN_DW)*FACTOR
C
C=======================================================================     
C
      IF (IF_PAI.EQ.1) THEN
          IF (ABS(TESTV2-N_PART).GT.1.E-4) THEN
              WRITE(LOGFIL,'(''ITRNUM= '',I2)')ITRNUM
              WRITE(LOGFIL,'(''ISOSPI_AUXILI='',I2)')ISOSPI_AUXILI
              WRITE(LOGFIL,'(''In DENSIT_GRADNT: TESTV2='',F20.13)')
     *                                           TESTV2
              WRITE(LOGFIL,'(18X,''N_PART='',I6)')N_PART
     
              IF (ISCREN.GE.5) THEN
                  WRITE(LSCREN,'(''ITRNUM= '',I2)')ITRNUM
                  WRITE(LSCREN,'(''ISOSPI_AUXILI='',I2)')ISOSPI_AUXILI
                  WRITE(LSCREN,'(''In DENSIT_GRADNT: TESTV2='',F20.13)')
     *                                          TESTV2
                  WRITE(LSCREN,'(18X,''N_PART='',I6)')N_PART
              END IF
     
C              STOP 'Stop in DENSIT_GRADNT: TESTV2 not correct!'
          END IF
      END IF
C
C=======================================================================     
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Exiting DENSIT_GRADNT'')')
c      END IF
C
C=======================================================================
C
      CALL CPUTIM('DENGRD',0)
C
C=======================================================================
C      
      RETURN
      END

C      
C=======================================================================
C=======================================================================
C
      FUNCTION DENGRD_PLOTIN(INUCLI,ISOSPI_AUXILI,ZARGUM)
C          
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDIM_N.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1) 
C      
      REAL*16
     *          QARGUM,QFLAGN,QDFLAG,QNORNL
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          DENDER(1:NDGAUS,0:NDIM_N,0:NDIM_N,0:NDIM_L),
     *          AUXILI(1:NDGAUS)
      DIMENSION
     *          QFLAGN(0:NDIM_N,0:NDIM_L),
     *          QDFLAG(0:NDIM_N,0:NDIM_L),
     *          XFLAGN(0:NDIM_N,0:NDIM_L),
     *          XDFLAG(0:NDIM_N,0:NDIM_L)
C
      COMMON
     *       /POLDEN/ 
     *        XPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *        XDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)    
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /NMLCNT/ XNORNL(0:NDIM_N,0:NDIM_L)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
       COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /DENSIF/ ITRNUM
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI      
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
      COMMON
     *       /CNTCNT/ ICOUNT_DENGRD,ICOUNT_FUNMIN,ICOUNT_HAMMAT,
     *                ICOUNT_EXPTHE,ICOUNT_CHOICE,ICOUNT_DIAMAT
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
C=======================================================================   
C
       CALL CPUTIM('DENGRD',1)
C       
       ICOUNT_DENGRD=ICOUNT_DENGRD+1
C
C=======================================================================   
C  
CID        This FUNCTION calculates the GRADIENT OF THE DENSITY 
C               Eq.(4.7.21)=(1/r)*(drho/dr) from MFV12.pdf
C
C=======================================================================     
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Entering DENSIT_GRADNT'',/,
c     *                   9X,/,9X,''ISOSPI_AUXILI='',I1)')ISOSPI_AUXILI
c      END IF
C
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================  
C    
      IF (ISOSPI_AUXILI.EQ.1) THEN
C        
          N_PART=IZ_FIX
          NSHELL=NSHELL_PROTON
          LDSING=LDSING_PROTON
C        
          AOSCIL=AOSCIL_PROTON(INUCLI)
          
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_PROTON(INUCLI)
              DELTA2=DELT_2(INUCLI,1)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,1)
          END IF
C        
          DO INDEXX=1,LDSING
C          
             LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
C          
          END DO
          
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
C             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          

             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
         END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI_AUXILI.EQ.0) THEN
        
        N_PART=IN_FIX
        NSHELL=NSHELL_NEUTRS
        LDSING=LDSING_NEUTRS
        
        AOSCIL=AOSCIL_NEUTRS(INUCLI)
        
        IF (IF_PAI.EQ.1) THEN
            XLAMBD=XLAMBD_NEUTRS(INUCLI)
            DELTA2=DELT_2(INUCLI,2)
            ENEMAX=ENEMAX_BCSPAI(INUCLI,2)
        END IF
        
        DO INDEXX=1,LDSING
          
          LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
          NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
          JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
          
        END DO
C
        DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C     
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
     
C
             END DO
        END DO                  
C
      END IF
C
C=======================================================================     
C
C       Calculating the polynomials in the desired ZARGUM point
C
C=======================================================================          
C      
      KIND_L=1
      NORDER=NSHELL/2
      LORDER=NSHELL
      
      QARGUM=QEXT(ZARGUM)    !passing the argument to quadruple precision
      
      CALL LAGUER(QARGUM,QFLAGN,QDFLAG,NORDER,LORDER,KIND_L,
     *                                        NDIM_L,NDIM_N)
     
      DO NAUXIL=0,NORDER
        DO LAUXIL=0,LORDER
            XFLAGN(NAUXIL,LAUXIL)=REAL(QFLAGN(NAUXIL,LAUXIL))
            XDFLAG(NAUXIL,LAUXIL)=REAL(QDFLAG(NAUXIL,LAUXIL))
        END DO
      END DO
C
C=======================================================================     
C
C                 Calculating the DENSITY GRADIENT Eq.(4.7.21)
C
C=======================================================================        
C   
      PINUMB=4.*ATAN(1.0)
      FACTOR=2./(PINUMB*AOSCIL**5)
C
C  Here we calculate J_UP block
C      
      DEN_UP=0.0
      TESTV2=0.0
      
      DO LQPRIM=NSHELL,0,-1 
         
         JNUMUP=2*LQPRIM+1  
          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
            
            ENERGY=ENERUP(LQPRIM,NWSNUM)
            
            IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 1
           
            IF (IF_PAI.EQ.0
     *          .AND.LABORD(NWSNUM-1,LQPRIM,JNUMUP).EQ.0) GO TO 1
                
                DNL_UP=0.0
                
                DO N1NUMB=0,(NSHELL-LQPRIM)/2
                
                   DO N2NUMB=0,(NSHELL-LQPRIM)/2
                                         
                      CFACT1=(LQPRIM+1)*CMATUP(LQPRIM,N1NUMB+1,NWSNUM)
     *                                 *CMATUP(LQPRIM,N2NUMB+1,NWSNUM)
              
                      POLPOL=XNORNL(N1NUMB,LQPRIM)*XFLAGN(N1NUMB,LQPRIM)
     *                      *XNORNL(N2NUMB,LQPRIM)*XFLAGN(N2NUMB,LQPRIM)
     
                      POLDER=XNORNL(N1NUMB,LQPRIM)*XFLAGN(N1NUMB,LQPRIM)
     *                      *XNORNL(N2NUMB,LQPRIM)*XDFLAG(N2NUMB,LQPRIM)
     
                      DERPOL=XNORNL(N1NUMB,LQPRIM)*XDFLAG(N1NUMB,LQPRIM)
     *                      *XNORNL(N2NUMB,LQPRIM)*XFLAGN(N2NUMB,LQPRIM)
              
                      ZLTLAG=(LQPRIM-ZARGUM)*POLPOL
     *                      +ZARGUM*(POLDER+DERPOL)
                
                      DNL_UP=DNL_UP+EXP(-ZARGUM)*ZARGUM**(LQPRIM-1)
     *                             *CFACT1*ZLTLAG
     
                  END DO !N2NUMB
              
               END DO !N1NUMB
               
               IF (IF_PAI.EQ.1) THEN
                   
                   V2_PUP=V2PAIR(ENERGY,XLAMBD,DELTA2)
                   DEN_UP=DEN_UP+DNL_UP*V2_PUP
                   
                   TESTV2=TESTV2+V2_PUP*(JNUMUP+1)   
                   
               ELSE
                   DEN_UP=DEN_UP+DNL_UP
               END IF
              
   1         CONTINUE
           
         END DO !NWSNUM
      
      END DO !LQPRIM
C
C  Here we calculate J_DOWN block
C
      DEN_DW=0.0
      
      DO LQPRIM=NSHELL,0,-1 
          
         JNUMDW=2*LQPRIM-1
          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
             
            ENERGY=ENERDN(LQPRIM,NWSNUM)
           
            IF (JNUMDW.GE.0) THEN
                
                IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 2
           
                IF (IF_PAI.EQ.0
     *              .AND.LABORD(NWSNUM-1,LQPRIM,JNUMDW).EQ.0) GO TO 2
                    
                    DNL_DW=0.0
                    
                    DO N1NUMB=0,(NSHELL-LQPRIM)/2
                
                       DO N2NUMB=0,(NSHELL-LQPRIM)/2
    
                          CFACT2=(LQPRIM)
     *                          *CMATDN(LQPRIM,N1NUMB+1,NWSNUM)
     *                          *CMATDN(LQPRIM,N2NUMB+1,NWSNUM)
              
                          POLPOL=
     *                    XNORNL(N1NUMB,LQPRIM)*XFLAGN(N1NUMB,LQPRIM)
     *                   *XNORNL(N2NUMB,LQPRIM)*XFLAGN(N2NUMB,LQPRIM)
     
                          POLDER=
     *                    XNORNL(N1NUMB,LQPRIM)*XFLAGN(N1NUMB,LQPRIM)
     *                   *XNORNL(N2NUMB,LQPRIM)*XDFLAG(N2NUMB,LQPRIM)
     
                          DERPOL=
     *                    XNORNL(N1NUMB,LQPRIM)*XDFLAG(N1NUMB,LQPRIM)
     *                   *XNORNL(N2NUMB,LQPRIM)*XFLAGN(N2NUMB,LQPRIM)
              
                          ZLTLAG=(LQPRIM-ZARGUM)*POLPOL
     *                          +ZARGUM*(POLDER+DERPOL)
     
                          DNL_DW=DNL_DW+EXP(-ZARGUM)*ZARGUM**(LQPRIM-1)
     *                                 *CFACT2*ZLTLAG
                
                       END DO !N2NUMB
              
                    END DO !N1NUMB
                    
                    IF (IF_PAI.EQ.1) THEN
                        
                        V2_PDW=V2PAIR(ENERGY,XLAMBD,DELTA2)
                        DEN_DW=DEN_DW+DNL_DW*V2_PDW
                        
                        TESTV2=TESTV2+V2_PDW*(JNUMDW+1) 
                        
                   ELSE
                        DEN_DW=DEN_DW+DNL_DW
                   END IF

            END IF
            
   2        CONTINUE 
                
         END DO !NWSNUM
      
      END DO !LQPRIM
C
C=======================================================================     
C      
      DENGRD_PLOTIN=(DEN_UP+DEN_DW)*FACTOR
C
C=======================================================================     
C
      IF (IF_PAI.EQ.1) THEN
          IF (ABS(TESTV2-N_PART).GT.1.E-4) THEN
              WRITE(LOGFIL,'(''ITRNUM= '',I2)')ITRNUM
              WRITE(LOGFIL,'(''ISOSPI_AUXILI='',I2)')ISOSPI_AUXILI
              WRITE(LOGFIL,'(''In DENSIT_GRADNT: TESTV2='',F20.13)')
     *                                           TESTV2
              WRITE(LOGFIL,'(18X,''N_PART='',I6)')N_PART
     
              IF (ISCREN.GE.5) THEN
                  WRITE(LSCREN,'(''ITRNUM= '',I2)')ITRNUM
                  WRITE(LSCREN,'(''ISOSPI_AUXILI='',I2)')ISOSPI_AUXILI
                  WRITE(LSCREN,'(''In DENSIT_GRADNT: TESTV2='',F20.13)')
     *                                          TESTV2
                  WRITE(LSCREN,'(18X,''N_PART='',I6)')N_PART
              END IF
     
C              STOP 'Stop in DENSIT_GRADNT: TESTV2 not correct!'
          END IF
      END IF
C
C=======================================================================     
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Exiting DENSIT_GRADNT'')')
c      END IF
C
C=======================================================================
C
      CALL CPUTIM('DENGRD',0)
C
C=======================================================================
C      
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      FUNCTION SPINJR(INUCLI,ISOSPI_AUXILI,ZARGUM,IPOINT,LQNUMB)
C          
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDIM_N.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1) 
C      
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          DENDER(1:NDGAUS,0:NDIM_N,0:NDIM_N,0:NDIM_L),
     *          AUXILI(1:NDGAUS)
C
      COMMON
     *       /POLDEN/ 
     *        XPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *        XDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)    
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /NMLCNT/ XNORNL(0:NDIM_N,0:NDIM_L)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
       COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
      COMMON
     *       /DENSIF/ ITRNUM
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
C=======================================================================   
C
       CALL CPUTIM('SPINJR',1)
C
C=======================================================================   
C  
CID  This FUNCTION calculates the SPIN CURRENT J(r) over r: (1/r)*J(r)
C
C=======================================================================     
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Entering SPINJR'',/,
c     *                   9X,/,9X,''ISOSPI_AUXILI='',I1)')ISOSPI_AUXILI
c      END IF
C
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================    
C
c      WRITE(0,*)'ENTERING IN THE DENSITY FUNCTION'      
                  
      IF (ISOSPI_AUXILI.EQ.1) THEN
        
          N_PART=IZ_FIX
          NSHELL=NSHELL_PROTON
          LDSING=LDSING_PROTON
        
          AOSCIL=AOSCIL_PROTON(INUCLI)
      
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_PROTON(INUCLI)
              DELTA2=DELT_2(INUCLI,1)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,1)
          END IF
        
          DO INDEXX=1,LDSING
          
             LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
          
          END DO
        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          

             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
         END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI_AUXILI.EQ.0) THEN
        
          N_PART=IN_FIX
          NSHELL=NSHELL_NEUTRS
          LDSING=LDSING_NEUTRS
        
          AOSCIL=AOSCIL_NEUTRS(INUCLI)
C
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_NEUTRS(INUCLI)
              DELTA2=DELT_2(INUCLI,2)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,2)
          END IF
        
          DO INDEXX=1,LDSING
          
             LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
          
          END DO
        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C     
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
     
C
             END DO
         END DO                  
C
      END IF
C
C=======================================================================     
C
C                     Calculating J(r)/r
C
C=======================================================================        
C   
      PINUMB=4.*ATAN(1.0)
      FACTOR=1./(PINUMB*AOSCIL**5)
C
C  Here we calculate J_UP block
C       
      TESTV2=0.0
      XJR_UP=0.0
      
      DO LQPRIM=NSHELL,0,-1 
         
         JNUMUP=2*LQPRIM+1
          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
             
            ENERGY=ENERUP(LQPRIM,NWSNUM)
            
            IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 1
           
            IF (IF_PAI.EQ.0
     *          .AND.LABORD(NWSNUM-1,LQPRIM,JNUMUP).EQ.0) GO TO 1
            
            XNL_UP=0.0
            
            DO N1NUMB=0,(NSHELL-LQPRIM)/2
                
               DO N2NUMB=0,(NSHELL-LQPRIM)/2
                  
                  CFACT1=LQPRIM*(LQPRIM+1)
     *                  *CMATUP(LQPRIM,N1NUMB+1,NWSNUM)
     *                  *CMATUP(LQPRIM,N2NUMB+1,NWSNUM)
              
                  POLPOL=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
     *                  *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
                
                  XNL_UP=XNL_UP+EXP(-ZARGUM)*ZARGUM**(LQPRIM-1)
     *                         *CFACT1*POLPOL
                  
               END DO !N2NUMB
              
            END DO !N1NUMB
            
            IF (IF_PAI.EQ.1) THEN
                V2_PUP=V2PAIR(ENERGY,XLAMBD,DELTA2)
                XJR_UP=XJR_UP+XNL_UP*V2_PUP  
                TESTV2=TESTV2+V2_PUP*(JNUMUP+1)   
            ELSE
                XJR_UP=XJR_UP+XNL_UP
            END IF
            
   1        CONTINUE
            
         END DO !NWSNUM
      
      END DO !LQPRIM
C
C  Here we calculate J_DOWN block
C      
      XJR_DW=0.0
      
      DO LQPRIM=NSHELL,0,-1 
         
         JNUMDW=2*LQPRIM-1
          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
             
            ENERGY=ENERDN(LQPRIM,NWSNUM)
            
            IF (JNUMDW.GE.0) THEN
                
                IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 2
           
                IF (IF_PAI.EQ.0
     *              .AND.LABORD(NWSNUM-1,LQPRIM,JNUMDW).EQ.0) GO TO 2
                    
                XNL_DW=0.0
            
                DO N1NUMB=0,(NSHELL-LQPRIM)/2
                
                   DO N2NUMB=0,(NSHELL-LQPRIM)/2
    
                      CFACT2=(-LQPRIM)*(LQPRIM+1)
     *                      *CMATDN(LQPRIM,N1NUMB+1,NWSNUM)
     *                      *CMATDN(LQPRIM,N2NUMB+1,NWSNUM)
              
                      POLPOL=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
     *                      *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
                
                      XNL_DW=XNL_DW+EXP(-ZARGUM)*ZARGUM**(LQPRIM-1)
     *                             *CFACT2*POLPOL
                
                   END DO !N2NUMB
              
                END DO !N1NUMB
                
                IF (IF_PAI.EQ.1) THEN
                    V2_PDW=V2PAIR(ENERGY,XLAMBD,DELTA2)
                    XJR_DW=XJR_DW+XNL_DW*V2_PDW
                    TESTV2=TESTV2+V2_PDW*(JNUMDW+1) 
                ELSE
                    XJR_DW=XJR_DW+XNL_DW
                END IF

            END IF
            
   2        CONTINUE 
            
        END DO !NWSNUM
      
      END DO !LQPRIM
      
      SPINJR=(XJR_UP+XJR_DW)*FACTOR
C
C=======================================================================     
C
      IF (IF_PAI.EQ.1) THEN
          IF (ABS(TESTV2-N_PART).GT.1.E-4) THEN
              WRITE(LOGFIL,'(''ITRNUM= '',I2)')ITRNUM
              WRITE(LOGFIL,'(''ISOSPI_AUXILI='',I2)')ISOSPI_AUXILI
              WRITE(LOGFIL,'(''In SPINJR: TESTV2='',F20.13)')TESTV2
              WRITE(LOGFIL,'(11X,''N_PART='',I6)')N_PART
     
              IF (ISCREN.GE.5) THEN
                  WRITE(0,'(''ITRNUM= '',I2)')ITRNUM
                  WRITE(0,'(''ISOSPI_AUXILI='',I2)')ISOSPI_AUXILI
                  WRITE(0,'(''In SPINJR: TESTV2='',F20.13)')TESTV2
                  WRITE(0,'(11X,''N_PART='',I6)')N_PART
              END IF
     
C              STOP 'Stop in DENSIT_GRADNT: TESTV2 not correct!'
          END IF
      END IF
C
C=======================================================================     
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Exiting SPINJR'')')
c      END IF
C
C=======================================================================
C
      CALL CPUTIM('SPINJR',0)
C
C=======================================================================
C      
      RETURN
      END   
C      
C=======================================================================
C=======================================================================
C
      FUNCTION SPIN_J(INUCLI,ISOSPI_AUXILI,ZARGUM,IPOINT,LQNUMB)
C          
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDIM_N.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1) 
C      
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          DENDER(1:NDGAUS,0:NDIM_N,0:NDIM_N,0:NDIM_L),
     *          AUXILI(1:NDGAUS)
C
      COMMON
     *       /POLDEN/ 
     *        XPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *        XDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)    
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /NMLCNT/ XNORNL(0:NDIM_N,0:NDIM_L)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
       COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
      COMMON
     *       /DENSIF/ ITRNUM
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
C=======================================================================   
C
       CALL CPUTIM('SPIN_J',1)
C
C=======================================================================   
C  
CID        This FUNCTION calculates the SPIN CURRENT J(r) 
C
C=======================================================================     
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Entering SPIN_J'',/,
c     *                   9X,/,9X,''ISOSPI_AUXILI='',I1)')ISOSPI_AUXILI
c      END IF
C
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================    
C
c      WRITE(0,*)'ENTERING IN THE DENSITY FUNCTION'      
                  
      IF (ISOSPI_AUXILI.EQ.1) THEN
        
        N_PART=IZ_FIX
        NSHELL=NSHELL_PROTON
        LDSING=LDSING_PROTON
        
        AOSCIL=AOSCIL_PROTON(INUCLI)
C
        IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_PROTON(INUCLI)
              DELTA2=DELT_2(INUCLI,1)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,1)
          END IF
        
        DO INDEXX=1,LDSING
          
          LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
          NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
          JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
          
        END DO
        
        DO INDEXX=1,LDSING
C
           JQNAUX=JWSSPH(INDEXX)
           LQNAUX=LWSSPH(INDEXX)
	   NNBAUX=NWSSPH(INDEXX)
           NBBASE=(NSHELL-LQNAUX)/2  
             
           LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	  =LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
             
           ENERUP(LQNAUX,NNBAUX+1)
     *    =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          

           ENERDN(LQNAUX,NNBAUX+1)
     *    =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
           DO N1NUMB=0,NBBASE
C		  
              CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *       =CMATUP_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
              CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *       =CMATDN_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C
           END DO
        END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI_AUXILI.EQ.0) THEN
        
        N_PART=IN_FIX
        NSHELL=NSHELL_NEUTRS
        LDSING=LDSING_NEUTRS
        
        AOSCIL=AOSCIL_NEUTRS(INUCLI)
C     
        IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_NEUTRS(INUCLI)
              DELTA2=DELT_2(INUCLI,2)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,2)
          END IF
        
        DO INDEXX=1,LDSING
          
          LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
          NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
          JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
          
        END DO
        
        DO INDEXX=1,LDSING
C
           JQNAUX=JWSSPH(INDEXX)
           LQNAUX=LWSSPH(INDEXX)
	   NNBAUX=NWSSPH(INDEXX)
           NBBASE=(NSHELL-LQNAUX)/2  
             
           LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	  =LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
           ENERUP(LQNAUX,NNBAUX+1)
     *    =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
           ENERDN(LQNAUX,NNBAUX+1)
     *    =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C     
           DO N1NUMB=0,NBBASE
C		  
              CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *       =CMATUP_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
              CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *       =CMATDN_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
        END DO                  
C
      END IF
C
C=======================================================================     
C
C                          Calculating J(r)
C
C=======================================================================        
C   
      PINUMB=4.*ATAN(1.0)
      FACTOR=1./(PINUMB*AOSCIL**4)      
C
C  Here we calculate J_UP block
C       
      TESTV2=0.0
      XJR_UP=0.0
C      
      DO LQPRIM=NSHELL,0,-1 
C         
         JNUMUP=2*LQPRIM+1
C          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
C             
            ENERGY=ENERUP(LQPRIM,NWSNUM)
C            
            IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 1
C           
            IF (IF_PAI.EQ.0
     *          .AND.LABORD(NWSNUM-1,LQPRIM,JNUMUP).EQ.0) GO TO 1
C            
            XNL_UP=0.0
C            
            DO N1NUMB=0,(NSHELL-LQPRIM)/2
C                
               DO N2NUMB=0,(NSHELL-LQPRIM)/2
C                  
                  CFACT1=LQPRIM*(LQPRIM+1)
     *                  *CMATUP(LQPRIM,N1NUMB+1,NWSNUM)
     *                  *CMATUP(LQPRIM,N2NUMB+1,NWSNUM)
C              
                  POLPOL=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
     *                  *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
C                
                  XNL_UP=XNL_UP+EXP(-ZARGUM)*ZARGUM**(LQPRIM-0.5)
     *                         *CFACT1*POLPOL
C                  
               END DO !N2NUMB
C              
            END DO !N1NUMB
C            
            IF (IF_PAI.EQ.1) THEN
                V2_PUP=V2PAIR(ENERGY,XLAMBD,DELTA2)
                XJR_UP=XJR_UP+XNL_UP*V2_PUP  
                TESTV2=TESTV2+V2_PUP*(JNUMUP+1)   
            ELSE
                XJR_UP=XJR_UP+XNL_UP
            END IF
C            
   1        CONTINUE
C            
         END DO !NWSNUM
C      
      END DO !LQPRIM
C
C  Here we calculate J_DOWN block
C      
      XJR_DW=0.0
C      
      DO LQPRIM=NSHELL,0,-1 
C         
         JNUMDW=2*LQPRIM-1
C
         IF (JNUMDW.GE.0) THEN
C          
             DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
C             
                ENERGY=ENERDN(LQPRIM,NWSNUM)
C                
                IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 2
C           
                IF (IF_PAI.EQ.0
     *              .AND.LABORD(NWSNUM-1,LQPRIM,JNUMDW).EQ.0) GO TO 2
C                    
                XNL_DW=0.0
C            
                DO N1NUMB=0,(NSHELL-LQPRIM)/2
C                
                   DO N2NUMB=0,(NSHELL-LQPRIM)/2
C    
                      CFACT2=(-LQPRIM)*(LQPRIM+1)
     *                      *CMATDN(LQPRIM,N1NUMB+1,NWSNUM)
     *                      *CMATDN(LQPRIM,N2NUMB+1,NWSNUM)
C              
                      POLPOL=XPOLYN_DENSIT(IPOINT,N1NUMB,LQPRIM,LQNUMB) 
     *                      *XPOLYN_DENSIT(IPOINT,N2NUMB,LQPRIM,LQNUMB)
C                
                      XNL_DW=XNL_DW+EXP(-ZARGUM)*ZARGUM**(LQPRIM-0.5)
     *                             *CFACT2*POLPOL
C                
                   END DO !N2NUMB
C              
                END DO !N1NUMB
C                
                IF (IF_PAI.EQ.1) THEN
                    V2_PDW=V2PAIR(ENERGY,XLAMBD,DELTA2)
                    XJR_DW=XJR_DW+XNL_DW*V2_PDW
                    TESTV2=TESTV2+V2_PDW*(JNUMDW+1) 
                ELSE
                    XJR_DW=XJR_DW+XNL_DW
                END IF
C            
   2            CONTINUE 
C            
             END DO !NWSNUM
C
         END IF
C      
      END DO !LQPRIM
C      
      SPIN_J=(XJR_UP+XJR_DW)*FACTOR
C
C=======================================================================     
C
      IF (IF_PAI.EQ.1) THEN
          IF (ABS(TESTV2-N_PART).GT.1.E-4) THEN
              WRITE(LOGFIL,'(''ITRNUM= '',I2)')ITRNUM
              WRITE(LOGFIL,'(''ISOSPI_AUXILI='',I2)')ISOSPI_AUXILI
              WRITE(LOGFIL,'(''In SPIN_J: TESTV2='',F20.13)')TESTV2
              WRITE(LOGFIL,'(11X,''N_PART='',I6)')N_PART
     
              IF (ISCREN.GE.5) THEN
                  WRITE(0,'(''ITRNUM= '',I2)')ITRNUM
                  WRITE(0,'(''ISOSPI_AUXILI='',I2)')ISOSPI_AUXILI
                  WRITE(0,'(''In SPIN_J: TESTV2='',F20.13)')TESTV2
                  WRITE(0,'(11X,''N_PART='',I6)')N_PART
              END IF
     
C              STOP 'Stop in DENSIT_GRADNT: TESTV2 not correct!'
          END IF
      END IF
C
C=======================================================================     
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Exiting SPIN_J'')')
c      END IF
C
C=======================================================================
C
      CALL CPUTIM('SPIN_J',0)
C
C=======================================================================
C      
      RETURN
      END   
C      
C=======================================================================
C=======================================================================
C
      FUNCTION SPIN_J_PLOTIN(INUCLI,ISOSPI_AUXILI,ZARGUM)
C          
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDIM_N.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1) 
C      
      REAL*16
     *          QARGUM,QFLAGN,QDFLAG,QNORNL
C
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          DENDER(1:NDGAUS,0:NDIM_N,0:NDIM_N,0:NDIM_L),
     *          AUXILI(1:NDGAUS)
      DIMENSION
     *          QFLAGN(0:NDIM_N,0:NDIM_L),
     *          QDFLAG(0:NDIM_N,0:NDIM_L),
     *          XFLAGN(0:NDIM_N,0:NDIM_L),
     *          XDFLAG(0:NDIM_N,0:NDIM_L)
C
      COMMON
     *       /POLDEN/ 
     *        XPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *        XDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)    
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /NMLCNT/ XNORNL(0:NDIM_N,0:NDIM_L)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
       COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
      COMMON
     *       /DENSIF/ ITRNUM
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
C=======================================================================   
C
       CALL CPUTIM('SPIN_J',1)
C
C=======================================================================   
C  
CID        This FUNCTION calculates the SPIN CURRENT J(r) 
C
C=======================================================================     
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Entering SPIN_J'',/,
c     *                   9X,/,9X,''ISOSPI_AUXILI='',I1)')ISOSPI_AUXILI
c      END IF
C
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================    
C
c      WRITE(0,*)'ENTERING IN THE DENSITY FUNCTION'      
                  
      IF (ISOSPI_AUXILI.EQ.1) THEN
        
        N_PART=IZ_FIX
        NSHELL=NSHELL_PROTON
        LDSING=LDSING_PROTON
        
        AOSCIL=AOSCIL_PROTON(INUCLI)
C
        IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_PROTON(INUCLI)
              DELTA2=DELT_2(INUCLI,1)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,1)
          END IF
        
        DO INDEXX=1,LDSING
          
          LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
          NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
          JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
          
        END DO
        
        DO INDEXX=1,LDSING
C
           JQNAUX=JWSSPH(INDEXX)
           LQNAUX=LWSSPH(INDEXX)
	   NNBAUX=NWSSPH(INDEXX)
           NBBASE=(NSHELL-LQNAUX)/2  
             
           LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	  =LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
             
           ENERUP(LQNAUX,NNBAUX+1)
     *    =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          

           ENERDN(LQNAUX,NNBAUX+1)
     *    =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
           DO N1NUMB=0,NBBASE
C		  
              CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *       =CMATUP_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
              CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *       =CMATDN_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C
           END DO
        END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI_AUXILI.EQ.0) THEN
        
        N_PART=IN_FIX
        NSHELL=NSHELL_NEUTRS
        LDSING=LDSING_NEUTRS
        
        AOSCIL=AOSCIL_NEUTRS(INUCLI)
C     
        IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_NEUTRS(INUCLI)
              DELTA2=DELT_2(INUCLI,2)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,2)
          END IF
        
        DO INDEXX=1,LDSING
          
          LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
          NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
          JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
          
        END DO
        
        DO INDEXX=1,LDSING
C
           JQNAUX=JWSSPH(INDEXX)
           LQNAUX=LWSSPH(INDEXX)
	   NNBAUX=NWSSPH(INDEXX)
           NBBASE=(NSHELL-LQNAUX)/2  
             
           LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	  =LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
           ENERUP(LQNAUX,NNBAUX+1)
     *    =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
           ENERDN(LQNAUX,NNBAUX+1)
     *    =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C     
           DO N1NUMB=0,NBBASE
C		  
              CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *       =CMATUP_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
              CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *       =CMATDN_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
        END DO                  
C
      END IF

C
C=======================================================================     
C
C       Calculating the polynomials in the desired ZARGUM point
C
C=======================================================================          
C      
      KIND_L=1
      NORDER=NSHELL/2
      LORDER=NSHELL
      
      QARGUM=QEXT(ZARGUM)    !passing the argument to real*16
      
      CALL LAGUER(QARGUM,QFLAGN,QDFLAG,NORDER,LORDER,KIND_L,
     *                                        NDIM_L,NDIM_N)
     
      DO NAUXIL=0,NORDER
        DO LAUXIL=0,LORDER
            XFLAGN(NAUXIL,LAUXIL)=REAL(QFLAGN(NAUXIL,LAUXIL))
            XDFLAG(NAUXIL,LAUXIL)=REAL(QDFLAG(NAUXIL,LAUXIL))
        END DO
      END DO
C
C=======================================================================     
C
C                          Calculating J(r)
C
C=======================================================================        
C   
      PINUMB=4.*ATAN(1.0)
      FACTOR=1./(PINUMB*AOSCIL**4)      
C
C  Here we calculate J_UP block
C       
      TESTV2=0.0
      XJR_UP=0.0
C      
      DO LQPRIM=NSHELL,0,-1 
C         
         JNUMUP=2*LQPRIM+1
C          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
C             
            ENERGY=ENERUP(LQPRIM,NWSNUM)
C            
            IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 1
C           
            IF (IF_PAI.EQ.0
     *          .AND.LABORD(NWSNUM-1,LQPRIM,JNUMUP).EQ.0) GO TO 1
C            
            XNL_UP=0.0
C            
            DO N1NUMB=0,(NSHELL-LQPRIM)/2
C                
               DO N2NUMB=0,(NSHELL-LQPRIM)/2
C                  
                  CFACT1=LQPRIM*(LQPRIM+1)
     *                  *CMATUP(LQPRIM,N1NUMB+1,NWSNUM)
     *                  *CMATUP(LQPRIM,N2NUMB+1,NWSNUM)
C              
                  POLPOL=XNORNL(N1NUMB,LQPRIM)*XFLAGN(N1NUMB,LQPRIM)
     *                  *XNORNL(N2NUMB,LQPRIM)*XFLAGN(N2NUMB,LQPRIM)
C                
                  XNL_UP=XNL_UP+EXP(-ZARGUM)*ZARGUM**(LQPRIM-0.5)
     *                         *CFACT1*POLPOL
C                  
               END DO !N2NUMB
C              
            END DO !N1NUMB
C            
            IF (IF_PAI.EQ.1) THEN
                V2_PUP=V2PAIR(ENERGY,XLAMBD,DELTA2)
                XJR_UP=XJR_UP+XNL_UP*V2_PUP  
                TESTV2=TESTV2+V2_PUP*(JNUMUP+1)   
            ELSE
                XJR_UP=XJR_UP+XNL_UP
            END IF
C            
   1        CONTINUE
C            
         END DO !NWSNUM
C      
      END DO !LQPRIM
C
C  Here we calculate J_DOWN block
C      
      XJR_DW=0.0
C      
      DO LQPRIM=NSHELL,0,-1 
C         
         JNUMDW=2*LQPRIM-1
C
         IF (JNUMDW.GE.0) THEN
C          
             DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
C             
                ENERGY=ENERDN(LQPRIM,NWSNUM)
C                
                IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 2
C           
                IF (IF_PAI.EQ.0
     *              .AND.LABORD(NWSNUM-1,LQPRIM,JNUMDW).EQ.0) GO TO 2
C                    
                XNL_DW=0.0
C            
                DO N1NUMB=0,(NSHELL-LQPRIM)/2
C                
                   DO N2NUMB=0,(NSHELL-LQPRIM)/2
C    
                      CFACT2=(-LQPRIM)*(LQPRIM+1)
     *                      *CMATDN(LQPRIM,N1NUMB+1,NWSNUM)
     *                      *CMATDN(LQPRIM,N2NUMB+1,NWSNUM)
C              
                      POLPOL=XNORNL(N1NUMB,LQPRIM)*XFLAGN(N1NUMB,LQPRIM)
     *                      *XNORNL(N2NUMB,LQPRIM)*XFLAGN(N2NUMB,LQPRIM)
C                
                      XNL_DW=XNL_DW+EXP(-ZARGUM)*ZARGUM**(LQPRIM-0.5)
     *                             *CFACT2*POLPOL
C                
                   END DO !N2NUMB
C              
                END DO !N1NUMB
C                
                IF (IF_PAI.EQ.1) THEN
                    V2_PDW=V2PAIR(ENERGY,XLAMBD,DELTA2)
                    XJR_DW=XJR_DW+XNL_DW*V2_PDW
                    TESTV2=TESTV2+V2_PDW*(JNUMDW+1) 
                ELSE
                    XJR_DW=XJR_DW+XNL_DW
                END IF
C            
   2            CONTINUE 
C            
             END DO !NWSNUM
C
         END IF
C      
      END DO !LQPRIM
C      
      SPIN_J_PLOTIN=(XJR_UP+XJR_DW)*FACTOR
C
C=======================================================================     
C
      IF (IF_PAI.EQ.1) THEN
          IF (ABS(TESTV2-N_PART).GT.1.E-4) THEN
              WRITE(LOGFIL,'(''ITRNUM= '',I2)')ITRNUM
              WRITE(LOGFIL,'(''ISOSPI_AUXILI='',I2)')ISOSPI_AUXILI
              WRITE(LOGFIL,'(''In SPIN_J: TESTV2='',F20.13)')TESTV2
              WRITE(LOGFIL,'(11X,''N_PART='',I6)')N_PART
     
              IF (ISCREN.GE.5) THEN
                  WRITE(0,'(''ITRNUM= '',I2)')ITRNUM
                  WRITE(0,'(''ISOSPI_AUXILI='',I2)')ISOSPI_AUXILI
                  WRITE(0,'(''In SPIN_J: TESTV2='',F20.13)')TESTV2
                  WRITE(0,'(11X,''N_PART='',I6)')N_PART
              END IF
     
C              STOP 'Stop in DENSIT_GRADNT: TESTV2 not correct!'
          END IF
      END IF
C
C=======================================================================     
C
c      IF (LOGWRI.GT.0) THEN
c          WRITE(LOGFIL,'(/,9X,''Exiting SPIN_J'')')
c      END IF
C
C=======================================================================
C
      CALL CPUTIM('SPIN_J',0)
C
C=======================================================================
C      
      RETURN
      END   
C      
C=======================================================================
C=======================================================================
C
      FUNCTION DENSIT_PLOTIN(INUCLI,ISOSPI_AUXILI,ZARGUM)
C      
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDIM_N.f'
      INCLUDE  'MATDIM/NDGAUS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1) 
      REAL*16
     *          QARGUM,QFLAGN,QDFLAG,QNORNL
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          DENSIT_VECTOR(1:NDGAUS,0:NDIM_L),
     *          DENAUX_TEST_L(0:NDIM_L)
      DIMENSION
     *          QFLAGN(0:NDIM_N,0:NDIM_L),
     *          QDFLAG(0:NDIM_N,0:NDIM_L),
     *          XFLAGN(0:NDIM_N,0:NDIM_L),
     *          XDFLAG(0:NDIM_N,0:NDIM_L)
C
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)   
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /NMLCNT/ XNORNL(0:NDIM_N,0:NDIM_L)
      COMMON
     *       /POLDEN/ 
     *        XPOLYN_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L), 
     *        XDPOLY_DENSIT(1:NDGAUS,0:NDIM_N,0:NDIM_L,0:NDIM_L)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
       COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
C
C=======================================================================   
C  
C  ###  This FUNCTION calculates the TOTAL DENSITY FUNCTION Eq.(4.7.14)
C          
C  ###     It is prepared to distinct between netrons and protons and
C          the way of integrating:  Gauss-Laguerre  or  Gauss-Hermite
C
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================    
C      
      IF (ISOSPI_AUXILI.EQ.1) THEN
        
          N_PART=IZ_FIX
          NSHELL=NSHELL_PROTON
          LDSING=LDSING_PROTON
        
          AOSCIL=AOSCIL_PROTON(INUCLI)
          
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_PROTON(INUCLI)
              DELTA2=DELT_2(INUCLI,1)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,1)
          END IF
        
          DO INDEXX=1,LDSING
          
             LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
          
          END DO
        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          

             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
         END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI_AUXILI.EQ.0) THEN
        
          N_PART=IN_FIX
          NSHELL=NSHELL_NEUTRS
          LDSING=LDSING_NEUTRS
        
          AOSCIL=AOSCIL_NEUTRS(INUCLI)
          
          IF (IF_PAI.EQ.1) THEN
              XLAMBD=XLAMBD_NEUTRS(INUCLI)
              DELTA2=DELT_2(INUCLI,2)
              ENEMAX=ENEMAX_BCSPAI(INUCLI,2)
          END IF
        
          DO INDEXX=1,LDSING
          
             LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
          
          END DO
        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C     
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
     
C
             END DO
         END DO                  
C
      END IF
C
C=======================================================================     
C
C       Calculating the polynomials in the desired ZARGUM point
C
C=======================================================================          
C      
      KIND_L=1
      NORDER=NSHELL/2
      LORDER=NSHELL
      
      QARGUM=QEXT(ZARGUM)    !passing the argument to real*16
      
      CALL LAGUER(QARGUM,QFLAGN,QDFLAG,NORDER,LORDER,KIND_L,
     *                                        NDIM_L,NDIM_N)
     
      DO NAUXIL=0,NORDER
        DO LAUXIL=0,LORDER
            XFLAGN(NAUXIL,LAUXIL)=REAL(QFLAGN(NAUXIL,LAUXIL))
            XDFLAG(NAUXIL,LAUXIL)=REAL(QDFLAG(NAUXIL,LAUXIL))
        END DO
      END DO
C
C=======================================================================     
C
C                   Calculating the DENSITY Eq.(4.7.14)
C
C=======================================================================        
C      
      PINUMB=4.0*ATAN(1.0)
      FACTOR=1.0/(PINUMB*(AOSCIL**3)) ! multiplied by 2/a 
C                                             from N_{n1,l}*N_{n2,l}
C
C  Here we calculate J_UP block
C
      DEN_UP=0.0
      
      DO LQPRIM=NSHELL,0,-1
         
         JNUMUP=2*LQPRIM+1  
          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
             
            ENERGY=ENERUP(LQPRIM,NWSNUM)
            
            IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 1
           
            IF (IF_PAI.EQ.0
     *          .AND.LABORD(NWSNUM-1,LQPRIM,JNUMUP).EQ.0) GO TO 1
                
                DNL_UP=0.0
            
            DO N1NUMB=0,(NSHELL-LQPRIM)/2
                
               DO N2NUMB=0,(NSHELL-LQPRIM)/2
                  
                  CFACT1=(LQPRIM+1)*CMATUP(LQPRIM,N1NUMB+1,NWSNUM)
     *                             *CMATUP(LQPRIM,N2NUMB+1,NWSNUM)
    
                  POLPOL=XNORNL(N1NUMB,LQPRIM)*XFLAGN(N1NUMB,LQPRIM)
     *                  *XNORNL(N2NUMB,LQPRIM)*XFLAGN(N2NUMB,LQPRIM)
                
                  DNL_UP=DNL_UP+ZARGUM**LQPRIM*EXP(-ZARGUM)
     *                         *POLPOL*CFACT1
                  
               END DO !N2NUMB
              
            END DO !N1NUMB
            
            IF (IF_PAI.EQ.1) THEN
                V2_PUP=V2PAIR(ENERGY,XLAMBD,DELTA2)
                DEN_UP=DEN_UP+DNL_UP*V2_PUP  
            ELSE
                DEN_UP=DEN_UP+DNL_UP
            END IF
              
   1        CONTINUE
            
         END DO !NWSNUM
        
      END DO !LQPRIM
C
C  Here we calculate J_DOWN block
C
      DEN_DW=0.0
      
      DO LQPRIM=NSHELL,0,-1 
          
         JNUMDW=2*LQPRIM-1
          
         DO NWSNUM=1,(NSHELL-LQPRIM)/2+1
             
            ENERGY=ENERDN(LQPRIM,NWSNUM)
            
            IF (JNUMDW.GE.0) THEN
                
                IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 2
           
                IF (IF_PAI.EQ.0
     *              .AND.LABORD(NWSNUM-1,LQPRIM,JNUMDW).EQ.0) GO TO 2
                    
                    DNL_DW=0.0
            
                    DO N1NUMB=0,(NSHELL-LQPRIM)/2
                
                       DO N2NUMB=0,(NSHELL-LQPRIM)/2
    
                          CFACT2=(LQPRIM)
     *                          *CMATDN(LQPRIM,N1NUMB+1,NWSNUM)
     *                          *CMATDN(LQPRIM,N2NUMB+1,NWSNUM)
    
                          POLPOL
     *                   =
     *                    XNORNL(N1NUMB,LQPRIM)*XFLAGN(N1NUMB,LQPRIM)
     *                   *XNORNL(N2NUMB,LQPRIM)*XFLAGN(N2NUMB,LQPRIM)
                
                          DNL_DW=DNL_DW+ZARGUM**LQPRIM*EXP(-ZARGUM)
     *                                 *POLPOL*CFACT2
                  
                       END DO !N2NUMB
              
                    END DO !N1NUMB
                    
                    IF (IF_PAI.EQ.1) THEN
                        V2_PDW=V2PAIR(ENERGY,XLAMBD,DELTA2)
                        DEN_DW=DEN_DW+DNL_DW*V2_PDW
                   ELSE
                        DEN_DW=DEN_DW+DNL_DW
                   END IF

            END IF
            
   2        CONTINUE 
            
         END DO !NWSNUM
        
      END DO !LQPRIM
C
C=======================================================================
C      
      DENSIT_PLOTIN=(DEN_UP+DEN_DW)*FACTOR
C
C=======================================================================
C     
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE RHONLJ_SUMMED(INUCLI,ISOSPI,ZARGUM,IPOINT,
     *                                N_CURV,Y_CURV,L_CURV)
C    
      INCLUDE 'MATDIM/NDMESH.f'
      INCLUDE 'MATDIM/NDSPEC.f'
      INCLUDE 'MATDIM/NDMAIN.f'
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDIM_N.f'
      
      PARAMETER
     *         (NDORBI=NDMAIN,NDJTOT=2*NDORBI+1,NDIM_L=NDIM_N,
     *                                          NDBASE=NDIM_N+1) 
      CHARACTER
     *          L_CURV*100,LBSHEL*6,JOPTIO*2,AUXLAB*100
      CHARACTER 
     *          LABTEX*11,LABEXP*6
      DIMENSION
     *          LBSHEL(0:NDMAIN,0:NDORBI,1:NDJTOT)
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          Y_CURV(1:NDMESH,1:NDSPEC),
     *          L_CURV(1:NDMESH,1:NDSPEC)
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /BCSENE/ ENEMAX_BCSPAI(1:NDNUCL,1:2)
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
C_______________________________________________________________________
C
      DATA !      n  L  J
     *     LBSHEL(00,00,01) / '1s1/2 ' /   ! Shell no. 0
      DATA
     *     LBSHEL(01,01,03) / '1p3/2 ' /, 
     *     LBSHEL(01,01,01) / '1p1/2 ' /   ! Shell no. 1
      DATA
     *     LBSHEL(02,00,01) / '2s1/2 ' /, 
     *     LBSHEL(02,02,05) / '1d5/2 ' /, 
     *     LBSHEL(02,02,03) / '1d3/2 ' /   ! Shell no. 2
      DATA
     *     LBSHEL(03,01,03) / '2p3/2 ' /, 
     *     LBSHEL(03,01,01) / '2p1/2 ' /, 
     *     LBSHEL(03,03,07) / '1f7/2 ' /, 
     *     LBSHEL(03,03,05) / '1f5/2 ' /   ! Shell no. 3
      DATA
     *     LBSHEL(04,00,01) / '3s1/2 ' /, 
     *     LBSHEL(04,02,05) / '2d5/2 ' /, 
     *     LBSHEL(04,02,03) / '2d3/2 ' /, 
     *     LBSHEL(04,04,09) / '1g9/2 ' /, 
     *     LBSHEL(04,04,07) / '1g7/2 ' /   ! Shell no. 4
      DATA
     *     LBSHEL(05,01,03) / '3p3/2 ' /, 
     *     LBSHEL(05,01,01) / '3p1/2 ' /, 
     *     LBSHEL(05,03,07) / '2f7/2 ' /, 
     *     LBSHEL(05,03,05) / '2f5/2 ' /, 
     *     LBSHEL(05,05,11) / '1h11/2' /, 
     *     LBSHEL(05,05,09) / '1h9/2 ' /   ! Shell no. 5
      DATA
     *     LBSHEL(06,00,01) / '4s1/2 ' /, 
     *     LBSHEL(06,02,05) / '3d5/2 ' /, 
     *     LBSHEL(06,02,03) / '3d3/2 ' /, 
     *     LBSHEL(06,04,09) / '2g9/2 ' /, 
     *     LBSHEL(06,04,07) / '2g7/2 ' /, 
     *     LBSHEL(06,06,13) / '1i13/2' /, 
     *     LBSHEL(06,06,11) / '1i11/2' /   ! Shell no. 6
      DATA
     *     LBSHEL(07,01,03) / '4p3/2 ' /, 
     *     LBSHEL(07,01,01) / '4p1/2 ' /, 
     *     LBSHEL(07,03,07) / '3f7/2 ' /, 
     *     LBSHEL(07,03,05) / '3f5/2 ' /, 
     *     LBSHEL(07,05,11) / '2h11/2' /, 
     *     LBSHEL(07,05,09) / '2h9/2 ' /, 
     *     LBSHEL(07,07,15) / '1j15/2' /, 
     *     LBSHEL(07,07,13) / '1j13/2' /   ! Shell no. 7
      DATA
     *     LBSHEL(08,00,01) / '5s1/2 ' /, 
     *     LBSHEL(08,02,05) / '4d5/2 ' /, 
     *     LBSHEL(08,02,03) / '4d3/2 ' /, 
     *     LBSHEL(08,04,09) / '3g9/2 ' /, 
     *     LBSHEL(08,04,07) / '3g7/2 ' /, 
     *     LBSHEL(08,06,13) / '2i13/2' /, 
     *     LBSHEL(08,06,11) / '2i11/2' /, 
     *     LBSHEL(08,08,17) / '1k17/2' /, 
     *     LBSHEL(08,08,15) / '1k15/2' /   ! Shell no. 8
      DATA
     *     LBSHEL(09,01,03) / '5p3/2 ' /, 
     *     LBSHEL(09,01,01) / '5p1/2 ' /, 
     *     LBSHEL(09,03,07) / '4f7/2 ' /, 
     *     LBSHEL(09,03,05) / '4f5/2 ' /, 
     *     LBSHEL(09,05,11) / '3h11/2' /, 
     *     LBSHEL(09,05,09) / '3h9/2 ' /, 
     *     LBSHEL(09,07,15) / '2j15/2' /, 
     *     LBSHEL(09,07,13) / '2j13/2' /, 
     *     LBSHEL(09,09,19) / '1l19/2' /, 
     *     LBSHEL(09,09,17) / '1l17/2' /   ! Shell no. 9
      DATA
     *     LBSHEL(10,00,01) / '6s1/2 ' /, 
     *     LBSHEL(10,02,05) / '5d5/2 ' /, 
     *     LBSHEL(10,02,03) / '5d3/2 ' /, 
     *     LBSHEL(10,04,09) / '4g9/2 ' /, 
     *     LBSHEL(10,04,07) / '4g7/2 ' /, 
     *     LBSHEL(10,06,13) / '3i13/2' /, 
     *     LBSHEL(10,06,11) / '3i11/2' /, 
     *     LBSHEL(10,08,17) / '2k17/2' /, 
     *     LBSHEL(10,08,15) / '2k15/2' /, 
     *     LBSHEL(10,10,21) / '1m21/2' /, 
     *     LBSHEL(10,10,19) / '1m19/2' /   ! Shell no.10
      DATA
     *     LBSHEL(11,01,03) / '6p3/2 ' /, 
     *     LBSHEL(11,01,01) / '6p1/2 ' /, 
     *     LBSHEL(11,03,07) / '5f7/2 ' /, 
     *     LBSHEL(11,03,05) / '5f5/2 ' /, 
     *     LBSHEL(11,05,11) / '4h11/2' /, 
     *     LBSHEL(11,05,09) / '4h9/2 ' /, 
     *     LBSHEL(11,07,15) / '3j15/2' /, 
     *     LBSHEL(11,07,13) / '3j13/2' /, 
     *     LBSHEL(11,09,19) / '2l19/2' /, 
     *     LBSHEL(11,09,17) / '2l17/2' /, 
     *     LBSHEL(11,11,23) / '1n23/2' /, 
     *     LBSHEL(11,11,21) / '1n21/2' /   ! Shell no.11
      DATA
     *     LBSHEL(12,00,01) / '7s1/2 ' /, 
     *     LBSHEL(12,02,05) / '6d5/2 ' /, 
     *     LBSHEL(12,02,03) / '6d3/2 ' /, 
     *     LBSHEL(12,04,09) / '5g9/2 ' /, 
     *     LBSHEL(12,04,07) / '5g7/2 ' /, 
     *     LBSHEL(12,06,13) / '4i13/2' /, 
     *     LBSHEL(12,06,11) / '4i11/2' /, 
     *     LBSHEL(12,08,17) / '3k17/2' /, 
     *     LBSHEL(12,08,15) / '3k15/2' /, 
     *     LBSHEL(12,10,21) / '2m21/2' /, 
     *     LBSHEL(12,10,19) / '2m19/2' /, 
     *     LBSHEL(12,12,25) / '2o25/2' /, 
     *     LBSHEL(12,12,23) / '2o23/2' /   ! Shell no.12
      DATA
     *     LBSHEL(13,01,03) / '7p3/2 ' /, 
     *     LBSHEL(13,01,01) / '7p1/2 ' /, 
     *     LBSHEL(13,03,07) / '6f7/2 ' /, 
     *     LBSHEL(13,03,05) / '6f5/2 ' /, 
     *     LBSHEL(13,05,11) / '5h11/2' /, 
     *     LBSHEL(13,05,09) / '5h9/2 ' /, 
     *     LBSHEL(13,07,15) / '4j15/2' /, 
     *     LBSHEL(13,07,13) / '4j13/2' /, 
     *     LBSHEL(13,09,19) / '3l19/2' /, 
     *     LBSHEL(13,09,17) / '3l17/2' /, 
     *     LBSHEL(13,11,23) / '2n23/2' /, 
     *     LBSHEL(13,11,21) / '2n21/2' /, 
     *     LBSHEL(13,13,27) / '1r27/2' /, 
     *     LBSHEL(13,13,25) / '1r25/2' /   ! Shell no.13
      DATA
     *     LBSHEL(14,00,01) / '8s1/2 ' /, 
     *     LBSHEL(14,02,05) / '7d5/2 ' /, 
     *     LBSHEL(14,02,03) / '7d3/2 ' /, 
     *     LBSHEL(14,04,09) / '6g9/2 ' /, 
     *     LBSHEL(14,04,07) / '6g7/2 ' /, 
     *     LBSHEL(14,06,13) / '5i13/2' /, 
     *     LBSHEL(14,06,11) / '5i11/2' /, 
     *     LBSHEL(14,08,17) / '4k17/2' /, 
     *     LBSHEL(14,08,15) / '4k15/2' /, 
     *     LBSHEL(14,10,21) / '3m21/2' /, 
     *     LBSHEL(14,10,19) / '3m19/2' /, 
     *     LBSHEL(14,12,25) / '2o25/2' /, 
     *     LBSHEL(14,12,23) / '2o23/2' /,
     *     LBSHEL(14,14,29) / '1q29/2' /, 
     *     LBSHEL(14,14,27) / '1q27/2' /   ! Shell no.14
      DATA
     *     LBSHEL(15,01,03) / '8p3/2 ' /, 
     *     LBSHEL(15,01,01) / '8p1/2 ' /, 
     *     LBSHEL(15,03,07) / '7f7/2 ' /, 
     *     LBSHEL(15,03,05) / '7f5/2 ' /, 
     *     LBSHEL(15,05,11) / '6h11/2' /, 
     *     LBSHEL(15,05,09) / '6h9/2 ' /, 
     *     LBSHEL(15,07,15) / '5j15/2' /, 
     *     LBSHEL(15,07,13) / '5j13/2' /, 
     *     LBSHEL(15,09,19) / '4l19/2' /, 
     *     LBSHEL(15,09,17) / '4l17/2' /, 
     *     LBSHEL(15,11,23) / '3n23/2' /, 
     *     LBSHEL(15,11,21) / '3n21/2' /, 
     *     LBSHEL(15,13,27) / '2r27/2' /, 
     *     LBSHEL(15,13,25) / '2r25/2' /, 
     *     LBSHEL(15,15,31) / '1t31/2' /, 
     *     LBSHEL(15,15,29) / '1t29/2' /   ! Shell no.15
      DATA
     *     LBSHEL(16,00,01) / '9s1/2 ' /, 
     *     LBSHEL(16,02,05) / '8d5/2 ' /, 
     *     LBSHEL(16,02,03) / '8d3/2 ' /, 
     *     LBSHEL(16,04,09) / '7g9/2 ' /, 
     *     LBSHEL(16,04,07) / '7g7/2 ' /, 
     *     LBSHEL(16,06,13) / '6i13/2' /, 
     *     LBSHEL(16,06,11) / '6i11/2' /, 
     *     LBSHEL(16,08,17) / '5k17/2' /, 
     *     LBSHEL(16,08,15) / '5k15/2' /, 
     *     LBSHEL(16,10,21) / '4m21/2' /, 
     *     LBSHEL(16,10,19) / '4m19/2' /, 
     *     LBSHEL(16,12,25) / '3o25/2' /, 
     *     LBSHEL(16,12,23) / '3o23/2' /,
     *     LBSHEL(16,14,29) / '2q29/2' /, 
     *     LBSHEL(16,14,27) / '2q27/2' /,
     *     LBSHEL(16,16,33) / '1u33/2' /, 
     *     LBSHEL(16,16,31) / '1u31/2' /   ! Shell no.16
      DATA
     *     LBSHEL(17,01,03) / '9p3/2 ' /, 
     *     LBSHEL(17,01,01) / '9p1/2 ' /, 
     *     LBSHEL(17,03,07) / '8f7/2 ' /, 
     *     LBSHEL(17,03,05) / '8f5/2 ' /, 
     *     LBSHEL(17,05,11) / '7h11/2' /, 
     *     LBSHEL(17,05,09) / '7h9/2 ' /, 
     *     LBSHEL(17,07,15) / '6j15/2' /, 
     *     LBSHEL(17,07,13) / '6j13/2' /, 
     *     LBSHEL(17,09,19) / '5l19/2' /, 
     *     LBSHEL(17,09,17) / '5l17/2' /, 
     *     LBSHEL(17,11,23) / '4n23/2' /, 
     *     LBSHEL(17,11,21) / '4n21/2' /, 
     *     LBSHEL(17,13,27) / '3r27/2' /, 
     *     LBSHEL(17,13,25) / '3r25/2' /, 
     *     LBSHEL(17,15,31) / '2t31/2' /, 
     *     LBSHEL(17,15,29) / '2t29/2' /, 
     *     LBSHEL(17,17,35) / '1v35/2' /, 
     *     LBSHEL(17,17,33) / '1v33/2' /   ! Shell no.17
      DATA
     *     LBSHEL(18,00,01) / '10s1/2' /, 
     *     LBSHEL(18,02,05) / '9d5/2 ' /, 
     *     LBSHEL(18,02,03) / '9d3/2 ' /, 
     *     LBSHEL(18,04,09) / '8g9/2 ' /, 
     *     LBSHEL(18,04,07) / '8g7/2 ' /, 
     *     LBSHEL(18,06,13) / '7i13/2' /, 
     *     LBSHEL(18,06,11) / '7i11/2' /, 
     *     LBSHEL(18,08,17) / '6k17/2' /, 
     *     LBSHEL(18,08,15) / '6k15/2' /, 
     *     LBSHEL(18,10,21) / '5m21/2' /, 
     *     LBSHEL(18,10,19) / '5m19/2' /, 
     *     LBSHEL(18,12,25) / '4o25/2' /, 
     *     LBSHEL(18,12,23) / '4o23/2' /,
     *     LBSHEL(18,14,29) / '3q29/2' /, 
     *     LBSHEL(18,14,27) / '3q27/2' /,
     *     LBSHEL(18,16,33) / '2u33/2' /, 
     *     LBSHEL(18,16,31) / '2u31/2' /,
     *     LBSHEL(18,18,37) / '1w39/2' /, 
     *     LBSHEL(18,18,35) / '1w37/2' /   ! Shell no.18
      DATA
     *     LBSHEL(19,01,03) / '10p3/2' /, 
     *     LBSHEL(19,01,01) / '10p1/2' /, 
     *     LBSHEL(19,03,07) / '9f7/2 ' /, 
     *     LBSHEL(19,03,05) / '9f5/2 ' /, 
     *     LBSHEL(19,05,11) / '8h11/2' /, 
     *     LBSHEL(19,05,09) / '8h9/2 ' /, 
     *     LBSHEL(19,07,15) / '7j15/2' /, 
     *     LBSHEL(19,07,13) / '7j13/2' /, 
     *     LBSHEL(19,09,19) / '6l19/2' /, 
     *     LBSHEL(19,09,17) / '6l17/2' /, 
     *     LBSHEL(19,11,23) / '5n23/2' /, 
     *     LBSHEL(19,11,21) / '5n21/2' /, 
     *     LBSHEL(19,13,27) / '4r27/2' /, 
     *     LBSHEL(19,13,25) / '4r25/2' /, 
     *     LBSHEL(19,15,31) / '3t31/2' /, 
     *     LBSHEL(19,15,29) / '3t29/2' /, 
     *     LBSHEL(19,17,35) / '2v35/2' /, 
     *     LBSHEL(19,17,33) / '2v33/2' /, 
     *     LBSHEL(19,19,39) / '1x39/2' /, 
     *     LBSHEL(19,19,37) / '1x37/2' /   ! Shell no.19
      DATA
     *     LBSHEL(20,00,01) / '11s1/2' /, 
     *     LBSHEL(20,02,05) / '10d5/2' /, 
     *     LBSHEL(20,02,03) / '10d3/2' /, 
     *     LBSHEL(20,04,09) / '9g9/2 ' /, 
     *     LBSHEL(20,04,07) / '9g7/2 ' /, 
     *     LBSHEL(20,06,13) / '8i13/2' /, 
     *     LBSHEL(20,06,11) / '8i11/2' /, 
     *     LBSHEL(20,08,17) / '7k17/2' /, 
     *     LBSHEL(20,08,15) / '7k15/2' /, 
     *     LBSHEL(20,10,21) / '6m21/2' /, 
     *     LBSHEL(20,10,19) / '6m19/2' /, 
     *     LBSHEL(20,12,25) / '5o25/2' /, 
     *     LBSHEL(20,12,23) / '5o23/2' /,
     *     LBSHEL(20,14,29) / '4q29/2' /, 
     *     LBSHEL(20,14,27) / '4q27/2' /,
     *     LBSHEL(20,16,33) / '3u33/2' /, 
     *     LBSHEL(20,16,31) / '3u31/2' /,
     *     LBSHEL(20,18,37) / '2w39/2' /, 
     *     LBSHEL(20,18,35) / '2w37/2' /,
     *     LBSHEL(20,20,41) / '1y43/2' /, 
     *     LBSHEL(20,20,39) / '1y41/2' /   ! Shell no.20
C
C=======================================================================
C
C     This subroutine sums "state by state" the single 
C     state densities from the DENSIT_STATES subroutine.
C
C     In this way we will be able to plot the "partial" densities in 
C     such a way that we will have as many curves as occupied states
C     and the first curve is the first state curve, and the last one
C     is the total sum (i.e. total density) of the state densities.
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================    
C      
      IF (ISOSPI.EQ.1) THEN
C        
        NSHELL=NSHELL_PROTON
        LDSING=LDSING_PROTON
        
        IF (IF_PAI.EQ.1) THEN
            XLAMBD=XLAMBD_PROTON(INUCLI)
            DELTA2=DELT_2(INUCLI,1)
            ENEMAX=ENEMAX_BCSPAI(INUCLI,1)
        END IF
C        
        DO INDEXX=1,LDSING
C          
          LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
          NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
          JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
          
        END DO
C        
        DO INDEXX=1,LDSING
C
           JQNAUX=JWSSPH(INDEXX)
           LQNAUX=LWSSPH(INDEXX)
	   NNBAUX=NWSSPH(INDEXX)
           NBBASE=(NSHELL-LQNAUX)/2  
C             
           LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	  =
     *     LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
     
           ENERUP(LQNAUX,NNBAUX+1)
     *    =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          
C
           ENERDN(LQNAUX,NNBAUX+1)
     *    =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
        END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI.EQ.0) THEN
C        
          NSHELL=NSHELL_NEUTRS
          LDSING=LDSING_NEUTRS
        
          IF (IF_PAI.EQ.1) THEN
            XLAMBD=XLAMBD_NEUTRS(INUCLI)
            DELTA2=DELT_2(INUCLI,2)
            ENEMAX=ENEMAX_BCSPAI(INUCLI,2)
          END IF
C        
          DO INDEXX=1,LDSING
C          
             LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
C          
          END DO
C        
        DO INDEXX=1,LDSING
C
           JQNAUX=JWSSPH(INDEXX)
           LQNAUX=LWSSPH(INDEXX)
	   NNBAUX=NWSSPH(INDEXX)
           NBBASE=(NSHELL-LQNAUX)/2  
C             
           LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	  =
     *     LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
     
           ENERUP(LQNAUX,NNBAUX+1)
     *    =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
           ENERDN(LQNAUX,NNBAUX+1)
     *    =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C     
        END DO                  
C
      END IF
C
C=======================================================================          
C
      RHOSUM=0.0
C      
      I_CURV=0
C      
      DO INDEXX=1,LDSING
C
         JSMALL=0
C            
         LQNUMB=LWSSPH(INDEXX)
         NNUMBR=NWSSPH(INDEXX)
         JQNUMB=JWSSPH(INDEXX)
            
         NWSNUM=NNUMBR+1
            
         J1AUXI=2*LQNUMB+1
            
         IF (J1AUXI.EQ.JQNUMB) THEN
             JOPTIO='UP'
             J2AUXI=JQNUMB
             ENERGY=ENERUP(LQNUMB,NNUMBR+1)
         END IF
            
         J1AUXI=2*LQNUMB-1
            
         IF (J1AUXI.EQ.JQNUMB) THEN
             JOPTIO='DW'
             J2AUXI=JQNUMB
             ENERGY=ENERDN(LQNUMB,NNUMBR+1)
         END IF
C            
         IF (IF_PAI.EQ.1.AND.ENERGY.GT.ENEMAX) GO TO 1
         
         IF (IF_PAI.EQ.0.AND.LABORD(NWSNUM-1,LQNUMB,JQNUMB).EQ.0)
     *                                                         GO TO 1
C            
         CALL RHONLJ_STATES(INUCLI,ISOSPI,LQNUMB,NWSNUM,
     *                             JOPTIO,ZARGUM,RHONLJ)
         I_CURV=I_CURV+1
                
         NSMALL=NNUMBR
         LSMALL=LQNUMB
         JSMALL=JQNUMB
         N_BIGG=2*NSMALL+LSMALL
C            
         IF(IF_PAI.EQ.1) THEN
            V2FACT=V2PAIR(ENERGY,XLAMBD,DELTA2)
            RHOSUM=RHOSUM+RHONLJ!*V2FACT
         ELSE
            RHOSUM=RHOSUM+RHONLJ
         END IF
C            
         Y_CURV(IPOINT,I_CURV)=RHOSUM
C                
         LABEXP=LBSHEL(N_BIGG,LSMALL,JSMALL)
         CALL LATEXS_LABELS(LABEXP,LABTEX)
C                
         WRITE(AUXLAB,'(''\\boldmath'',a)') LABTEX
C     
         L_CURV(IPOINT,I_CURV)=AUXLAB
C
   1     CONTINUE
C                     
      END DO
C      
      N_CURV=I_CURV
C
C=======================================================================
C      
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE RHONLJ_STATES(INUCLI,ISOSPI,LQNUMB,NWSNUM,
     *                                JOPTIO,ZARGUM,RHONLJ)
     
C
      INCLUDE 'MATDIM/NDGAUS.f'
      INCLUDE 'MATDIM/NDSPEC.f'
      INCLUDE 'MATDIM/NDIM_N.f'
      INCLUDE 'MATDIM/NDNUCL.f'
      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1) 
      REAL*16
     *          QARGUM,QFLAGN,QDFLAG,QNORNL
      CHARACTER
     *          JOPTIO*2
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          QFLAGN(0:NDIM_N,0:NDIM_L),
     *          QDFLAG(0:NDIM_N,0:NDIM_L),
     *          XFLAGN(0:NDIM_N,0:NDIM_L),
     *          XDFLAG(0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          DENJUP(1:NDGAUS,0:NDIM_L),
     *          DENJDW(1:NDGAUS,0:NDIM_L)
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /NMLCNT/ XNORNL(0:NDIM_N,0:NDIM_L)
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *      	      LWSSPH_PROTON(1:NDSPEC),
     *      	      JWSSPH_PROTON(1:NDSPEC),
     *
     *      	      NWSSPH_NEUTRS(1:NDSPEC),
     *      	      LWSSPH_NEUTRS(1:NDSPEC),
     *      	      JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)  
      COMMON
     *       /LEVORD/ LABORD_PROTON(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1),
     *                LABORD_NEUTRS(1:NDNUCL,
     *                              0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
C
C=======================================================================     
C   This subroutine calculates the density \rho(r) of every
C   occupied state  s e p a r a t e l y (for fixed NLJ numbers) and
c   the sum runs only for the indices n_1 and n_2
C=======================================================================     
C
C                        P R O T O N S 
C
C=======================================================================    
C      
      IF (ISOSPI.EQ.1) THEN
C        
        NSHELL=NSHELL_PROTON
        LDSING=LDSING_PROTON
C        
        AOSCIL=AOSCIL_PROTON(INUCLI)
C        
        DO INDEXX=1,LDSING
C          
          LWSSPH(INDEXX)=LWSSPH_PROTON(INDEXX)
          NWSSPH(INDEXX)=NWSSPH_PROTON(INDEXX)
          JWSSPH(INDEXX)=JWSSPH_PROTON(INDEXX)
          
        END DO
C        
        DO INDEXX=1,LDSING
C
           JQNAUX=JWSSPH(INDEXX)
           LQNAUX=LWSSPH(INDEXX)
	   NNBAUX=NWSSPH(INDEXX)
           NBBASE=(NSHELL-LQNAUX)/2  
C             
           LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	  =LABORD_PROTON(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
           ENERUP(LQNAUX,NNBAUX+1)
     *    =ENERUP_AUXPRO(LQNAUX,NNBAUX+1)          
C
           ENERDN(LQNAUX,NNBAUX+1)
     *    =ENERDN_AUXPRO(LQNAUX,NNBAUX+1)
C
           DO N1NUMB=0,NBBASE
C		  
              CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *       =CMATUP_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
              CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *       =CMATDN_AUXPRO(LQNAUX,N1NUMB+1,NNBAUX+1)
C
           END DO
        END DO                  
C
      END IF
C
C=======================================================================     
C
C                        N E U T R O N S 
C
C=======================================================================          
C      
      IF (ISOSPI.EQ.0) THEN
C        
          NSHELL=NSHELL_NEUTRS
          LDSING=LDSING_NEUTRS
C        
          AOSCIL=AOSCIL_NEUTRS(INUCLI)
C        
          DO INDEXX=1,LDSING
C          
             LWSSPH(INDEXX)=LWSSPH_NEUTRS(INDEXX)
             NWSSPH(INDEXX)=NWSSPH_NEUTRS(INDEXX)
             JWSSPH(INDEXX)=JWSSPH_NEUTRS(INDEXX)
C          
          END DO
C        
          DO INDEXX=1,LDSING
C
             JQNAUX=JWSSPH(INDEXX)
             LQNAUX=LWSSPH(INDEXX)
	     NNBAUX=NWSSPH(INDEXX)
             NBBASE=(NSHELL-LQNAUX)/2  
C             
             LABORD(NNBAUX,LQNAUX,JQNAUX)
     *	    =LABORD_NEUTRS(INUCLI,NNBAUX,LQNAUX,JQNAUX)
C     
             ENERUP(LQNAUX,NNBAUX+1)
     *      =ENERUP_AUXNEU(LQNAUX,NNBAUX+1)          
C
             ENERDN(LQNAUX,NNBAUX+1)
     *      =ENERDN_AUXNEU(LQNAUX,NNBAUX+1)
C
             DO N1NUMB=0,NBBASE
C		  
                CMATUP(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATUP_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C		  
                CMATDN(LQNAUX,N1NUMB+1,NNBAUX+1)
     *         =CMATDN_AUXNEU(LQNAUX,N1NUMB+1,NNBAUX+1)
C
             END DO
          END DO                  
C
      END IF
C
C=======================================================================     
C
C       Calculating the polynomials in the desired ZARGUM point
C
C=======================================================================          
C      
      KIND_L=1
      NORDER=NSHELL/2
      LORDER=NSHELL
      
      QARGUM=QEXT(ZARGUM)    !passing the argument to real*16
      
      CALL LAGUER(QARGUM,QFLAGN,QDFLAG,NORDER,LORDER,KIND_L,
     *                                        NDIM_L,NDIM_N)
     
      DO NAUXIL=0,NORDER
        DO LAUXIL=0,LORDER
            XFLAGN(NAUXIL,LAUXIL)=REAL(QFLAGN(NAUXIL,LAUXIL))
            XDFLAG(NAUXIL,LAUXIL)=REAL(QDFLAG(NAUXIL,LAUXIL))
        END DO
      END DO
C
C=======================================================================     
C
      PINUMB=4.*ATAN(1.0)
      FACTOR=1./(PINUMB*AOSCIL**3)
      
      DENAUX=0.0
            
      DO N1NUMB=0,(NSHELL-LQNUMB)/2
                
         DO N2NUMB=0,(NSHELL-LQNUMB)/2
                
            CFACT1=(LQNUMB+1)*CMATUP(LQNUMB,N1NUMB+1,NWSNUM)
     *                       *CMATUP(LQNUMB,N2NUMB+1,NWSNUM)
    
            CFACT2=(LQNUMB  )*CMATDN(LQNUMB,N1NUMB+1,NWSNUM)
     *                       *CMATDN(LQNUMB,N2NUMB+1,NWSNUM)
     
            POLPRD=ZARGUM**LQNUMB*EXP(-ZARGUM)
     *            *XNORNL(N1NUMB,LQNUMB)*XFLAGN(N1NUMB,LQNUMB)
     *            *XNORNL(N2NUMB,LQNUMB)*XFLAGN(N2NUMB,LQNUMB)
              
            IF (JOPTIO.EQ.'UP') THEN
               
                DENAUX=DENAUX+CFACT1*POLPRD
               
            END IF
               
            IF (JOPTIO.EQ.'DW') THEN
               
                DENAUX=DENAUX+CFACT2*POLPRD

            END IF
                
         END DO
          
      END DO
      
      RHONLJ=DENAUX*FACTOR
C
C=======================================================================
C      
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C      
      FUNCTION V2PAIR(ENERGY,XLAMBD,DELTA2)
      
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
C=======================================================================
C 
C      WRITE(LOGFIL,'(''in FUNCTION V2PAIR: XLAMBD= '',F20.13,
C     *               '' DELTA2= '',F20.13,'' ENERGY= '',F20.13)')
C     *                  XLAMBD,DELTA2,ENERGY
C
C=======================================================================
C         
      V2PAIR=0.5*(1-((ENERGY-XLAMBD)/SQRT((ENERGY-XLAMBD)**2+DELTA2)))
C
C=======================================================================
C      
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE CONSIS_VERIFS(IABORT)
C
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NITERA.f'
C
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                              LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                              LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /ENRGYY/ ENERGY_PROTON(1:NDSPEC,0:NITERA), 
     *                ENERGY_NEUTRS(1:NDSPEC,0:NITERA)
      COMMON
     *       /QUANTN/ NWSSPH_PROTON(1:NDSPEC),
     *                LWSSPH_PROTON(1:NDSPEC),
     *                JWSSPH_PROTON(1:NDSPEC),
     *
     *                NWSSPH_NEUTRS(1:NDSPEC),
     *                LWSSPH_NEUTRS(1:NDSPEC),
     *                JWSSPH_NEUTRS(1:NDSPEC)
      COMMON
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON
     *       /DENSIF/ ITRNUM
     *       /WHENST/ DIFFVA
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS   
C      
C=======================================================================
C     This subroutine verifies the self-consistency condition in terms
C     of single-particle eigenvalues for the density-dependent Hamilt.     
C=======================================================================
C
      IABORT=0
C                        Starting with protons
      DIFFVA=0.0
C      
      IF (IFTEST.EQ.1) THEN
      
          IF (LOGWRI.GT.1) THEN
      
              WRITE(LOGFIL,'(/,''Testing the Self-Consistency'')')
      
              WRITE(LOGFIL,'(/,''ITRNUM    ENERGY(ITRUM-1)     '',
     *                                         ''ENERGY(ITRNUM)'',/)')
      
              WRITE(LOGFIL,'(''Protons'')')
       
          END IF
      
      END IF
C      
C=======================================================================
C
      DO I=1,LDSING_PROTON
C
         IF (ITRNUM.EQ.0) THEN
             DIFFVA=DIFFVA+ENERGY_PROTON(I,ITRNUM)**2
             GO TO 1
         END IF
C	    
         DO J=1,LDSING_PROTON
C	    
            IF (NWSSPH_PROTON(I).EQ.NWSSPH_PROTON(J).AND.
     *	        LWSSPH_PROTON(I).EQ.LWSSPH_PROTON(J).AND.
     *	        JWSSPH_PROTON(I).EQ.JWSSPH_PROTON(J)) THEN
C     
                DIFFVA=DIFFVA+(ENERGY_PROTON(I,ITRNUM)
     *                        -ENERGY_PROTON(J,ITRNUM-1))**2
                
                IF (IFTEST.EQ.1) THEN
                
                IF (LOGWRI.GT.1)  WRITE(LOGFIL,'(I5.3,3ES20.10)')ITRNUM,
     *                                       ENERGY_PROTON(I,ITRNUM-1),
     *                                       ENERGY_PROTON(J,ITRNUM),
     *                                       ENERGY_PROTON(I,ITRNUM-1)-
     *                                       ENERGY_PROTON(J,ITRNUM)
                END IF
C     
	        GO TO 1
C     
            END IF
C	    
         END DO
C	    
   1     CONTINUE
C	    
      END DO	         
C      
C=======================================================================      
C                      ... continuing with neutrons
C=======================================================================      
C     
  
      IF (IFTEST.EQ.1) THEN
                
      IF (LOGWRI.GT.1) WRITE(21,'(''Neutrons'')')
      
      END IF
      
      DO I=1,LDSING_NEUTRS
C
         IF (ITRNUM.EQ.0) THEN
	     DIFFVA=DIFFVA+ENERGY_NEUTRS(I,ITRNUM)**2
	     GO TO 2
	 END IF
C	    
         DO J=1,LDSING_NEUTRS
C	    
            IF (NWSSPH_NEUTRS(I).EQ.NWSSPH_NEUTRS(J).AND.
     *	        LWSSPH_NEUTRS(I).EQ.LWSSPH_NEUTRS(J).AND.
     *	        JWSSPH_NEUTRS(I).EQ.JWSSPH_NEUTRS(J)) THEN
C     
                DIFFVA=DIFFVA+(ENERGY_NEUTRS(I,ITRNUM)
     *                        -ENERGY_NEUTRS(J,ITRNUM-1))**2
                
                IF (IFTEST.EQ.1) THEN
                
                IF (LOGWRI.GT.1) WRITE(21,'(I5.3,2ES20.10)')ITRNUM,
     *                                   ENERGY_NEUTRS(I,ITRNUM-1),
     *                                     ENERGY_NEUTRS(J,ITRNUM)
     
                END IF
C     
	        GO TO 2
C     
            END IF
C	    
         END DO
C	    
   2     CONTINUE
C	    
      END DO	 
C           
C=======================================================================
C      
      IF (ITRNUM.EQ.NITERA) THEN
          WRITE(0,'(''ITRNUM>'',I3,'' No convergence in HAMMAT'')')
     *                NITERA
	  IABORT=1
      END IF
C           
C=======================================================================
C
      RETURN
      END    
C
C=======================================================================
C=======================================================================
C 
      FUNCTION CHOICE(ISOSPI,IDEFCN,INUCLI)
    
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDIM_M.f'
      INCLUDE   'MATDIM/ND_RHO.f'
      INCLUDE   'MATDIM/N_NOYX.f'
      
      CHARACTER
     *          TYPCHI*6,SYMBNU*5
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          LABEXP*6,LABTHE*6
C      DIMENSION
C     *          MEXPER(1:NDIM_M),MTHEOR(1:NDIM_M)
      DIMENSION
     *          ENETHE(1:NDSPEC),LABTHE(1:NDSPEC)
      DIMENSION
     *          EXPEXP(1:NDLEXP),IDEGEX(1:NDLEXP)
      DIMENSION
     *          IDGLEV(1:NDSPEC)
      DIMENSION
     *          LABEXP(1:NDLEXP)
      DIMENSION
     *          DEGENE(1:NDIM_M)
      DIMENSION
     *          GAPEXP(1:NDNUCL),FERMEX(1:NDNUCL),
     *          DENSUP(1:NDNUCL),DENSDW(1:NDNUCL)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /DEGENE/ IDGLEV_PROTON(1:NDSPEC),
     *                ICUMUL_PROTON(0:NDSPEC),
     *                IDGLEV_NEUTRS(1:NDSPEC),
     *                ICUMUL_NEUTRS(0:NDSPEC)
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /CHIVAL/ CHISQU_CORREL,DIFSQU_RADIUS,CHISQU_INVERT,
     *                DIFSQU_EFERMI,DIFSQU_ENEGAP,CHIWEI_ENERGY,
     *                CHIWEI_ENEDEG,ERRABS_WEIDEG,EABSAV,ERRMAX,
     *                       DIFSQU_DENSUP,DIFSQU_DENSDW,CHIRHO
      COMMON
     *       /NUCWEI/ WEINUC_PROTON(1:NDNUCL),
     *                WEINUC_NEUTRS(1:NDNUCL),
     *                WEIRAD_PROTON(1:NDNUCL),
     *                WEIRAD_NEUTRS(1:NDNUCL)
      COMMON
     *       /WEIGHT/ WEIGHT_CORREL,WEIGHT_RADIUS,WEIGHT_INVERT,
     *                WEIGHT_EFERMI,WEIGHT_ENEGAP,WEIWEI,
     *                WEIGHT_ERRABS,WEIGHT_EABSAV,WEIGHT_ERRMAX,
     *                WEIGHT_DENSUP,WEIGHT_DENSDW,WEIGHT_RHODEN
      COMMON
     *       /DECOMP/ VEICOR,VEIRAD,VEIINV,VEIFER,VEIGAP,VEIWEI,
     *                       VEIDIF,VEIABS,VEIMAX,VEIDUP,VEIDDW
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL) 
      COMMON
     *       /EXPDEN/ LABELN(1:N_NOYX,1:2),
     *                R_MESH(1:ND_RHO,1:N_NOYX),
     *                RHOEXP(1:ND_RHO,1:N_NOYX)
     *
     *       /EXPSYM/ SYMBNU(1:N_NOYX)
      COMMON
     *       /THEDEN/ N_NUCL,I_NUCL(1:N_NOYX),
     *                RHOTHE(1:ND_RHO,1:N_NOYX)
      COMMON
     *       /CNTCNT/ ICOUNT_DENGRD,ICOUNT_FUNMIN,ICOUNT_HAMMAT,
     *                ICOUNT_EXPTHE,ICOUNT_CHOICE,ICOUNT_DIAMAT
C
C=======================================================================
C
C     This SUBROUTINE collects all the contributions to the \chi^2.
C
C     It is called from EXPTHE and it is mainly used for printing.
C
C=======================================================================
C
      ICOUNT_CHOICE=ICOUNT_CHOICE+1

      IF (ISOSPI.EQ.1) THEN
C
          LEVTHE=LDSING_PROTON ! Number of levels below user defined 
C                                                       limit SPHMAX
          LEVEXP=LEVEXP_PROTON(INUCLI)
          RMSEXP=RMSEXP_PROTON(INUCLI)
          RMSTHE=RMSTHE_PROTON
C
          DO ITHEOR=1,LEVTHE
             LABTHE(ITHEOR)=LABTHE_PROTON(ITHEOR)
             ENETHE(ITHEOR)=ENETHE_PROTON(ITHEOR)
             IDGLEV(ITHEOR)=IDGLEV_PROTON(ITHEOR)
          END DO
C          
          DO IEXPER=1,LEVEXP
             LABEXP(IEXPER)=LABEXP_PROTON(INUCLI,IEXPER)
             EXPEXP(IEXPER)=EXPEXP_PROTON(INUCLI,IEXPER)
             IDEGEX(IEXPER)=IDEGEX_PROTON(INUCLI,IEXPER)
          END DO
          
          WEINUC=WEINUC_PROTON(INUCLI)
          WEIRAD=WEIRAD_PROTON(INUCLI)
C          
      END IF 
C
      IF (ISOSPI.EQ.0) THEN
C
          LEVTHE=LDSING_NEUTRS  
          LEVEXP=LEVEXP_NEUTRS(INUCLI)
C
          RMSEXP=RMSEXP_NEUTRS(INUCLI)
          RMSTHE=RMSTHE_NEUTRS
C          
          DO ITHEOR=1,LEVTHE
             LABTHE(ITHEOR)=LABTHE_NEUTRS(ITHEOR)
             ENETHE(ITHEOR)=ENETHE_NEUTRS(ITHEOR)
             IDGLEV(ITHEOR)=IDGLEV_NEUTRS(ITHEOR)
          END DO
C          
          DO IEXPER=1,LEVEXP
             LABEXP(IEXPER)=LABEXP_NEUTRS(INUCLI,IEXPER)
             EXPEXP(IEXPER)=EXPEXP_NEUTRS(INUCLI,IEXPER)
             IDEGEX(IEXPER)=IDEGEX_NEUTRS(INUCLI,IEXPER)
          END DO
C         
          WEINUC=WEINUC_NEUTRS(INUCLI)
          WEIRAD=WEIRAD_NEUTRS(INUCLI)
  
      END IF
C
C=======================================================================
C
      VEICOR=0.0
      VEIRAD=0.0
      VEIINV=0.0
      VEIFER=0.0
      VEIGAP=0.0
      VEIWEI=0.0
      VEIDIF=0.0
      VEIABS=0.0
      VEIMAX=0.0
      VEIDUP=0.0
      VEIDDW=0.0
C      
      NO_ACT=1
C
C=======================================================================
C     Initialising all the chi^2 values 
C=======================================================================
C      
      CHI2_1=0.  ! Single Particle Energies
      CHI2_2=0.  ! RMS
      CHI2_3=0.  ! Gap Energy
      CHI2_4=0.  ! Fermi Energy
      CHI2_5=0.  ! Densities below and above the shell closure
      CHI2_6=0.  ! Density rho(r)
      CHI2_7=0.  ! Level inversions      
C
C=======================================================================
C     Starting with CHI2_1, related to SPE
C=======================================================================
C        
       IF (IF_SPE.EQ.1) THEN
C       
C       WRITE(LOGFIL,'(''Calculating chi2_1...'')')
C           
         CHI2_1=CHI2_1+CHIWEI_ENEDEG*WEINUC
C         
         VEIWEI=1
C         
         NO_ACT=0
C       
       END IF !IF_SPE=1
C       
C       WRITE(LOGFIL,'(''Calculating chi2_1...OK!'')')
C
C=======================================================================
C               Continuating with CHI2_2, realted to RMS
C=======================================================================
C      
      IF (IF_RAD.EQ.1) THEN 
C       
       CHI2_2=CHI2_2+DIFSQU_RADIUS*WEIRAD*WEINUC
C       
       VEIRAD=1
C       
       NO_ACT=0
C      
      END IF ! IF_RAD=1
C
C=======================================================================
C                  CHI2_3, realted to the Gap Energy
C=======================================================================
C      
      IF (IF_GAP.EQ.1) THEN 
C       
       CHI2_3=CHI2_3+DIFSQU_ENEGAP*WEIGHT_ENEGAP
C       
       VEIGAP=1
C       
       NO_ACT=0
C      
      END IF ! IF_GAP=1  
C
C=======================================================================
C                  CHI2_4, realted to the Fermi Energy
C                   (first protons, then neutrons)
C=======================================================================
C      
      IF (IF_FER.EQ.1) THEN 
C       
       CHI2_4=CHI2_4+DIFSQU_EFERMI*WEIGHT_EFERMI
C       
       VEIFER=1
C       
       NO_ACT=0
C      
      END IF ! IF_FER=1  
C
C=======================================================================
C   CHI2_5, realted to the Densities below and above the shell closure
C                   (first protons, then neutrons)
C=======================================================================
C      
      IF (IF_DEN.EQ.1) THEN 
C       
          CHI2_5=CHI2_5+DIFSQU_DENSUP*WEIGHT_DENSDW
     *                 +DIFSQU_DENSDW*WEIGHT_DENSUP
C     
          VEIDUP=1
          VEIDDW=1
C       
          NO_ACT=0
C      
      END IF ! IF_DEN=1   
C
C=======================================================================
C              CHI2_6, realted to the Densities rho(r)
C                   (first protons, then neutrons)
C=======================================================================
C      
      IF (IF_RHO.EQ.1) THEN 
C         
C          CHI2_6=CHI2_6+CHIRHO*WEIGHT_RHODEN
C
C          VEIRHO=1
C          NO_ACT=0
C      
      END IF ! IF_RHO=1
C
C=======================================================================
C              CHI2_7, realted to the Level Inversions
C                   (first protons, then neutrons)
C=======================================================================
C      
      IF (IF_INV.EQ.1) THEN 
       
*       DO I=1,LEVTOT
               
*        IF (I.LT.LEVTOT) THEN
               
*             IEXPE1=MEXPER(I)       !Experimental
*             IEXPE2=MEXPER(I+1)
*             DIFEXP=EXPEXP(IEXPE2)-EXPEXP(IEXPE1)
             
*             ITHEO1=MTHEOR(I)       !Theoretical
*             ITHEO2=MTHEOR(I+1)               
*             DIFTHE=ENETHE(ITHEO2)-ENETHE(ITHEO1)
             
*             IF (((DIFEXP.LT.0.).AND.(DIFTHE.GT.0.)).OR.
*     *           ((DIFEXP.GT.0.).AND.(DIFTHE.LT.0.))) THEN  !bad order of the levels
             
*                  AUXIL1=ENETHE(ILWTHE)*DEGENE(I)
*                  AUXIL2=ENETHE(IUPTHE)*DEGENE(I+1)
                  
*                  AUXILI=AUXIL2-AUXIL1
                 
*C                  CHI2_7=CHI2_7+AUXILI*AUXILI*WEIGHT_INVERT
                  
*             END IF
         
*        END IF
             
*       END DO
       
*       CHI2_7=CHI2_7+CHISQU_INVERT
       
*       VEIINV=1
       
*       NO_ACT=0
      
      END IF ! IF_INV=1 
C
C=======================================================================
C           Finally we sum all the contributions to the total chi^2
C=======================================================================
C
      CHOICE=CHI2_1+CHI2_2+CHI2_3+CHI2_4+CHI2_5+CHI2_6+CHI2_7
C
C=======================================================================
C      
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE COUNTI_RHOEXP(INUCLI,NRHOEX)
      
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/ND_RHO.f'
      INCLUDE  'MATDIM/N_NOYX.f'
    
      CHARACTER 
     *          NUCSYM*6,SYMBNU*5
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /EXPDEN/ LABELN(1:N_NOYX,1:2),
     *                R_MESH(1:ND_RHO,1:N_NOYX),
     *                RHOEXP(1:ND_RHO,1:N_NOYX)
     *
     *       /EXPSYM/ SYMBNU(1:N_NOYX)
C
C=======================================================================
C      
      IZ_FIX=NUMB_Z(INUCLI)
      IN_FIX=NUMB_N(INUCLI)
C      
      DO I_NOYX=1,N_NOYX
C          
         IZ_AUX=LABELN(I_NOYX,1)
         IN_AUX=LABELN(I_NOYX,2)
C         
         IF (IZ_FIX.EQ.IZ_AUX .AND. IN_FIX.EQ.IN_AUX) THEN
C             
             DO ID_RHO=1,ND_RHO
                NRHOEX=NRHOEX+1
             END DO
C             
         END IF
C         
      END DO      
C
C=======================================================================
C      
      RETURN
      END          
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE EXPTHE(IZ_FIX,IN_FIX,DENSUP,DENSDW,FERMEX,GAPEXP,
     *                  IDEFCN,ISOSPI,IPARAM,CHISQU_CHOICE,I_FLAG,
     *                                                     INUCLI)
C
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDLEXP.f'
      INCLUDE  'MATDIM/NDPARS.f'
      INCLUDE  'MATDIM/NDITEH.f'
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/NDISOS.f'
      INCLUDE  'MATDIM/ND_RHO.f'
      INCLUDE  'MATDIM/N_NOYX.f'
C
      CHARACTER
     *          LABEXP*6,LABTHE*6,LWINDW*6,CHIDEF*6
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          NUCLID*10,TYPCHI*6,SYMBNU*5
C
      DIMENSION
     *          CORELE(1:NDLEXP,1:NDLEXP),CORELT(1:NDLEXP,1:NDLEXP)
      DIMENSION
     *          CHNORM(1:NDLEXP),CHWEIG(1:NDLEXP),INDTRU(1:NDLEXP)
      DIMENSION
     *          EWINDW(1:NDLEXP),LWINDW(1:NDLEXP)
      DIMENSION
     *          ENETHE(1:NDSPEC),LABTHE(1:NDSPEC)
      DIMENSION
     *          EXPEXP(1:NDLEXP),IDEGEX(1:NDLEXP)
      DIMENSION
     *          IDGLEV(1:NDSPEC)
      DIMENSION
     *          LABEXP(1:NDLEXP)
      DIMENSION
     *          ICOLEC(1:NDSPEC)
      DIMENSION
     *          NUCLID(0:NDISOS)
      DIMENSION
     *          GAPEXP(1:NDNUCL),FERMEX(1:NDNUCL),
     *          DENSUP(1:NDNUCL),DENSDW(1:NDNUCL)
C
C=======================================================================
C     Follows the full information about  theoretical spherical
C                                                   l e v e l s
C=======================================================================
C
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /DEGENE/ IDGLEV_PROTON(1:NDSPEC),
     *                ICUMUL_PROTON(0:NDSPEC),
     *                IDGLEV_NEUTRS(1:NDSPEC),
     *                ICUMUL_NEUTRS(0:NDSPEC)
C
C=======================================================================
C     Follows the full information about experimental spherical
C                                                   l e v e l s
C=======================================================================
C
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS
      COMMON 
     *       /RMSVAL/ HINORM_PROTON,HINORM_NEUTRS
      COMMON
     *       /CHIVAL/ CHISQU_CORREL,DIFSQU_RADIUS,CHISQU_INVERT,
     *                DIFSQU_EFERMI,DIFSQU_ENEGAP,CHIWEI_ENERGY,
     *                CHIWEI_ENEDEG,ERRABS_WEIDEG,EABSAV,ERRMAX,
     *                       DIFSQU_DENSUP,DIFSQU_DENSDW,CHIRHO
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
C
C                     <<<=== Here:  Storing the minimum of chi2 
C                                   &other discrepancy measures
      COMMON
     *       /CHIMIN/ HIWMIN,HICMIN,ERRMIN,SHEMIN,SHWMIN
C     
C     Starting ('old') and obtained ('new') potential parameters     
C     
      COMMON
     *       /CRITR1/ SCHIWE,SDIFWE,SCHICO,SABSAV,SERMAX,
     *                SDENUP,SDENSU,SDENLO,SDENSD,CHITOT,
     *                                            RADDIF
      COMMON
     *       /CRITR2/ ICHIWE,IDIFWE,ICHICO,IABSAV,IERMAX,
     *                IDENUP,IDENSU,IDENLO,IDENSD,IHITOT
       COMMON
     *       /THEORF/ FERTHE_PROTON,GAPTHE_PROTON,
     *                DENUPP_PROTON,DENLOW_PROTON,
     *
     *                FERTHE_NEUTRS,GAPTHE_NEUTRS,
     *                DENUPP_NEUTRS,DENLOW_NEUTRS 
      COMMON
     *       /INVINV/ INVRSN_PROTON(0:NDITEH),
     *                INVRSN_NEUTRS(0:NDITEH)
C
C=======================================================================
C     Follows the full information about theoretical and experimental
C                                                   d e n s i t i e s
C=======================================================================
C      
      COMMON
     *       /EXPDEN/ LABELN(1:N_NOYX,1:2),
     *                R_MESH(1:ND_RHO,1:N_NOYX),
     *                RHOEXP(1:ND_RHO,1:N_NOYX)
     *
     *       /EXPSYM/ SYMBNU(1:N_NOYX)
      COMMON
     *       /THEDEN/ N_NUCL,I_NUCL(1:N_NOYX),
     *                RHOTHE(1:ND_RHO,1:N_NOYX)
C
C=======================================================================
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /OCCREC/ N_ACTU_PROTON,N_CORR_PROTON,
     *                N_ACTU_NEUTRS,N_CORR_NEUTRS
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /WHERBE/ IRUNMI,NEWOLD
      COMMON
     *       /MAXIER/ EMAXER
      COMMON
     *       /CNTCNT/ ICOUNT_DENGRD,ICOUNT_FUNMIN,ICOUNT_HAMMAT,
     *                ICOUNT_EXPTHE,ICOUNT_CHOICE,ICOUNT_DIAMAT
C
      DATA
     *      NUCLID(0) / '[Neutrons]' /,
     *      NUCLID(1) / '[Protons] ' /
C
      DATA
     *      HIWLIM / 0.7500 /
      DATA
     *      VALLIM / 1.5000 /
      DATA
     *      EPSLIM / 1.0e-9 /
C
C=======================================================================
C
C     This subroutine compares  the theoretical  and experimental
C     spectra for spherical nuclei and calculates the mean-square
C     deviations
C
C=======================================================================
C
C     Meaning of some parameters:
C
C     HISQUA - CHI-SQUARE as a measure of the difference between the
C              experimental and theoretical sets of energy levels
C
C     ERRMAX - maximum absolute value of the error (theory-experim.)
C
C     EABSAV - arithmetical average of the absolute values of errors
C
C     FERMEX - experimental estimate of the Fermi level
C     FERMTH - theoretical  position of the Fermi level
C
C     GAPEXP - experimental estimate  of the shell closure
C     GAPTHE - theoretical  result  for  the shell closure
C
C     DENSUP - experimental estimate of the level  density A B O V E
C                                             the main shell closure
C     DENSDW - experimental estimate of the level  density B E L O W
C                                             the main shell closure
C
C     DNTHUP - theoretical result for the level density    A B O V E
C                                             the main shell closure
C     DNTHDW - theoretical result for the level  density   B E L O W
C                                             the main shell closure
C
C     N_THUP - the number of theoretical levels  A B O V E  the main
C              closure which appear  too high compared to experiment
C
C     N_THDW - the number of theoretical levels  B E L O W  the main
C              closure which appear  too high compared to experiment
C
C=======================================================================
C
      ICOUNT_EXPTHE=ICOUNT_EXPTHE+1
C
C=======================================================================
C
      V0CENT_PROTON=PARPOT( 1)
      R0CENT_PROTON=PARPOT( 2)
      A0CENT_PROTON=PARPOT( 3)
      V0SORB_PROTON=PARPOT( 4)
      R0SORB_PROTON=PARPOT( 5)
      A0SORB_PROTON=PARPOT( 6)
      V0EFFM_PROTON=PARPOT( 7)
      R0EFFM_PROTON=PARPOT( 8)
      A0EFFM_PROTON=PARPOT( 9)
      R0COUL       =PARPOT(10)
C     
      XK_V0C_PROTON=PARPOT(11)
      XK_R0C_PROTON=PARPOT(12)
      XK_A0C_PROTON=PARPOT(13)
      XK_LAM_PROTON=PARPOT(14)
      XK_RSO_PROTON=PARPOT(15)
      XK_ASO_PROTON=PARPOT(16)
      XK_LEF_PROTON=PARPOT(17)
      XK_REF_PROTON=PARPOT(18)
      XK_AEF_PROTON=PARPOT(19)
      XK_COU	   =PARPOT(20)
C     
      V0CENT_NEUTRS=PARPOT(21)
      R0CENT_NEUTRS=PARPOT(22)
      A0CENT_NEUTRS=PARPOT(23)
      V0SORB_NEUTRS=PARPOT(24)
      R0SORB_NEUTRS=PARPOT(25)
      A0SORB_NEUTRS=PARPOT(26)
      V0EFFM_NEUTRS=PARPOT(27)
      R0EFFM_NEUTRS=PARPOT(28)
      A0EFFM_NEUTRS=PARPOT(29)
C     
      XK_V0C_NEUTRS=PARPOT(30)
      XK_R0C_NEUTRS=PARPOT(31)
      XK_A0C_NEUTRS=PARPOT(32)
      XK_LAM_NEUTRS=PARPOT(33)
      XK_RSO_NEUTRS=PARPOT(34)
      XK_ASO_NEUTRS=PARPOT(35)
      XK_LEF_NEUTRS=PARPOT(36)
      XK_REF_NEUTRS=PARPOT(37)
      XK_AEF_NEUTRS=PARPOT(38)
C     
      ALAMPP       =PARPOT(39)
      ALAMPN       =PARPOT(40)
      ALAMNP       =PARPOT(41)
      ALAMNN       =PARPOT(42)
C
      TLAMPP       =PARPOT(43)
      TLAMPN       =PARPOT(44)
      TLAMNP       =PARPOT(45)
      TLAMNN       =PARPOT(46)
C      
      CLAMPP       =PARPOT(47)
      CLAMPN       =PARPOT(48)
      CLAMNP       =PARPOT(49)
      CLAMNN       =PARPOT(50)
C
C=======================================================================
C
      IF (IDEFCN.EQ.1) THEN
C
C=======================================================================
C         Initialising the chi^2  type minimum control variables
C=======================================================================
C
          HIWMIN=1.0E+10
          HICMIN=1.0E+10
          ERRMIN=1.0E+10
          SHEMIN=1.0E+10
          SHWMIN=1.0E+10
C          
          CHITOT=1.0E+10
C
      END IF
C
C=======================================================================
C
      IF (ISOSPI.EQ.1) THEN
C
          LEVTHE=LDSING_PROTON ! Number of levels below user defined 
C                                                       limit SPHMAX
          LEVEXP=LEVEXP_PROTON(INUCLI)
          RMSEXP=RMSEXP_PROTON(INUCLI)
          RMSTHE=RMSTHE_PROTON
C
          DO ITHEOR=1,LEVTHE
             LABTHE(ITHEOR)=LABTHE_PROTON(ITHEOR)
             ENETHE(ITHEOR)=ENETHE_PROTON(ITHEOR)
             IDGLEV(ITHEOR)=IDGLEV_PROTON(ITHEOR)
          END DO
C          
          DO IEXPER=1,LEVEXP
             LABEXP(IEXPER)=LABEXP_PROTON(INUCLI,IEXPER)
             EXPEXP(IEXPER)=EXPEXP_PROTON(INUCLI,IEXPER)
             IDEGEX(IEXPER)=IDEGEX_PROTON(INUCLI,IEXPER)
          END DO
C          
      END IF 
C
C=======================================================================
C
      IF (ISOSPI.EQ.0) THEN
C
          LEVTHE=LDSING_NEUTRS ! Number of levels below user defined 
C                                                       limit SPHMAX  
          LEVEXP=LEVEXP_NEUTRS(INUCLI)
C
          RMSEXP=RMSEXP_NEUTRS(INUCLI)
          RMSTHE=RMSTHE_NEUTRS
C          
          DO ITHEOR=1,LEVTHE
             LABTHE(ITHEOR)=LABTHE_NEUTRS(ITHEOR)
             ENETHE(ITHEOR)=ENETHE_NEUTRS(ITHEOR)
             IDGLEV(ITHEOR)=IDGLEV_NEUTRS(ITHEOR)
          END DO
C          
          DO IEXPER=1,LEVEXP
             LABEXP(IEXPER)=LABEXP_NEUTRS(INUCLI,IEXPER)
             EXPEXP(IEXPER)=EXPEXP_NEUTRS(INUCLI,IEXPER)
             IDEGEX(IEXPER)=IDEGEX_NEUTRS(INUCLI,IEXPER)
          END DO
C          
      END IF
C
C=======================================================================
C     Calculating the lowest (EMINTH) and the highest (EMAXTH) 
C     theoretical energies and comparing with all the existing 
C     experimental data
C=======================================================================
C
      EMINTH=+1.0E+10
      EMAXTH=-1.0E+10
C
      KTHEOR=0
C
      DO IEXPER=1,LEVEXP
         DO ITHEOR=1,LEVTHE
            ENERGY=ENETHE(ITHEOR)
            IF (LABEXP(IEXPER).EQ.LABTHE(ITHEOR)) THEN
                KTHEOR=KTHEOR+1
                IF (EMINTH.GE.ENERGY) EMINTH=ENERGY
                IF (EMAXTH.LE.ENERGY) EMAXTH=ENERGY
            END IF
         END DO
      END DO
C
      IF (KTHEOR.NE.LEVEXP) THEN
C 
          WRITE(LOGFIL,'(/,''The program does not find all theoretical''
     *                '' levels - according to experimental data !'')')
          WRITE(LOGFIL,'(/,''KTHEOR='',I3,''; LEVEXP='',I3)')
     *                       KTHEOR,          LEVEXP
C
          WRITE(LSCREN,'(/,''The program does not find all theoretical''
     *                '' levels - according to experimental data !'')')
          WRITE(LSCREN,'(/,''KTHEOR='',I3,''; LEVEXP='',I3)')
     *                       KTHEOR,          LEVEXP
          STOP 'STOP in EXPTHE: Missing correspondence with experiment'
C
      END IF
C
      EMINTH=EMINTH-EPSLIM
      EMAXTH=EMAXTH+EPSLIM
C
      DO ITHEOR=1,LEVTHE
         IF (ENETHE(ITHEOR).GT.EMAXTH) THEN
             GO TO 1
         END IF
      END DO
C
   1  CONTINUE
C
      LEVTHE=ITHEOR-1   
C
C=======================================================================
C
C     Attention: The instructions below are meant for the fully
C                closed shells and sub-shells (our experimental
C                data bank contains only those and consequently
C                this should be sufficient for us (so far))
C
C=======================================================================
C
C     Calculating the theoretical gap and Fermi level
C
      IOCCUP=IDGLEV(1)
                       NPARTI=IZ_FIX
      IF (ISOSPI.EQ.0) NPARTI=IN_FIX
C
      DO ITHEOR=2,LEVTHE
C
         IOCCUP=IOCCUP+IDGLEV(ITHEOR)
C
         IF (IOCCUP.GT.NPARTI) THEN
C
             GAPTHE=ENETHE(ITHEOR)-ENETHE(ITHEOR-1)
             FERTHE=0.5*(ENETHE(ITHEOR)+ENETHE(ITHEOR-1))
C
             GO TO 2
C
         END IF
C
      END DO
C
C=======================================================================
C
   2  CONTINUE
C
      IOCCUP=IOCCUP-IDGLEV(ITHEOR)
C
      N_ACTU=NPARTI
      N_CORR=NPARTI
C
      IF (IOCCUP.NE.NPARTI) THEN
C
          N_ACTU=IOCCUP
C
          IF (LOGWRI.GT.4) THEN
C
              DO I=1,20          
              WRITE(LOGFIL,'(''Occupation number ='',i3,'' in EXPTHE '',
     *                       ''should be equal to NPARTI='',i3)') 
     *                                     IOCCUP,NPARTI
              END DO
C
C             STOP 'Occupation number inconsistent, STOP from EXPTHE'
C
          END IF
C
      ELSE
C
          IF (LOGWRI.GT.5) THEN
C
              WRITE(LOGFIL,'(18X,''Occupation number ='',i3,1x,
     *                           ''should be equal to NPARTI='',i3)') 
     *                                         IOCCUP,NPARTI
          END IF
C
      END IF
C
C=======================================================================
C
      IPRIN1=0
      IPRIN2=0
      IPRIN3=0
C
C=======================================================================
C
      DO IEXPER=1,LEVEXP
         INDTRU(IEXPER)=0
      END DO
C
      ITHUPP=0
      ITHLOW=0
      IDEGER=0
C
      ELOMIN=+10000.
      EUPMIN=+10000.
C
      ELOMAX=-10000.
      EUPMAX=-10000.
C
      VALMAX=-1.0E+10
C
      DIFSUM=0.0
      CHISUM=0.0
C
      CHIWEI_ENERGY=0.0
      CHIWEI_ENEDEG=0.0
      ERRABS_WEIDEG=0.0
C
      EABSAV=0.0
C
      IHISUM=0
C
      DO ITHEOR=1,LEVTHE
C
         ETHEOR=ENETHE(ITHEOR)
C
         DO IEXPER=1,LEVEXP
C
            IF (LABEXP(IEXPER).EQ.LABTHE(ITHEOR)) THEN
C
                INDTRU(IEXPER)=1
C
                IHISUM=IHISUM+1
                EWINDW(IHISUM)=ETHEOR                
                LWINDW(IHISUM)=LABTHE(ITHEOR)             
C
                IDEGER=IDEGER+IDEGEX(IEXPER)
C
                ENEDIF=ETHEOR-EXPEXP(IEXPER)
                ESQUAR=ENEDIF*ENEDIF
C
                ERRABS=ABS(ENEDIF)
C
                EABSAV=EABSAV+ERRABS
C
                CHISUM=CHISUM+ESQUAR
                CHIWEI_ENERGY=CHIWEI_ENERGY+ESQUAR*IDEGEX(IEXPER)
C
                DIFSUM=DIFSUM+ERRABS
                ERRABS_WEIDEG=ERRABS_WEIDEG+ERRABS*IDEGEX(IEXPER)
C
                IF (ERRABS.GT.VALMAX) VALMAX=ERRABS
C
                CHNORM(IEXPER)=SQRT(CHISUM/IHISUM)
                CHWEIG(IEXPER)=SQRT(CHIWEI_ENERGY/IDEGER)
C
C=======================================================================
C               Below, we calculate average level densities
C               above the Fermi level (particle states) and
C               below the Fermi level (hole states)
C=======================================================================
C
                IF (ETHEOR.GT.FERTHE) THEN
C                                                      Particles:
                    ITHUPP=ITHUPP+IDGLEV(ITHEOR)
C
                    IF (EUPMIN.GT.ETHEOR) EUPMIN=ETHEOR
                    IF (EUPMAX.LT.ETHEOR) EUPMAX=ETHEOR
C
                ELSE
C                                                      Holes:
                    ITHLOW=ITHLOW+IDGLEV(ITHEOR)
C
                    IF (ELOMIN.GT.ETHEOR) ELOMIN=ETHEOR
                    IF (ELOMAX.LT.ETHEOR) ELOMAX=ETHEOR
C
                END IF
C
C=======================================================================
C            
            END IF
C
         END DO
C
      END DO
C
      INWIND=IHISUM 
C
      HWNORM=SQRT(CHIWEI_ENERGY/IDEGER)
      HINORM=SQRT(CHISUM/IHISUM)
C
      EABSAV=EABSAV/LEVEXP
      ERRMAX=VALMAX
      
      EMAXER=ERRMAX ! changed for LMMINI
C
C=======================================================================
C     Calculating and storing the inversions: theory vs. experiment
C=======================================================================
C
      ITHBIS=0
      CHISQU_INVERT=0.0
C
      DO ITHEOR=1,INWIND
C
         ETHEOR=EWINDW(ITHEOR)
C
         DO IEXPER=1,LEVEXP
C
            IF (LABEXP(IEXPER).EQ.LWINDW(ITHEOR)) THEN
C
                ITHBIS=ITHBIS+1
C
                ICOLEC(ITHBIS)=IEXPER
C
                IF (IEXPER.NE.ITHEOR) THEN
C
                    CHISQU_INVERT=CHISQU_INVERT
     *                           +
     *                           (ETHEOR-EXPEXP(IEXPER))**2
     *                           *IDEGEX(IEXPER)
                END IF
C
            END IF	    
C
         END DO
C
      END DO
C
      IF (ITHBIS.NE.LEVEXP) THEN
C
          WRITE(LSCREN,'(/,''Alarm in EXPTHE with INUCLI= '',I2,
     *                     '' and ISOSPI= '',I1,
     *                     '' : ITHBIS= '',I3,'' and LEVEXP= '',I3,
     *                     '' ==> They should be equal!'',/)')
     *                        INUCLI,ISOSPI,ITHBIS,LEVEXP
C
          STOP 'STOP in EXPTHE: ITHBIS.NE.LEVEXP'  
C  
      END IF
C
C=======================================================================
C     Estimating the number of inversions theory vs. experiment
C=======================================================================
C
      CALL INVERT(ICOLEC,NDSPEC,ITHBIS,NOFINV)
C
      IF (ISOSPI.EQ.1) THEN
          INVRSN_PROTON(IDEFCN)=NOFINV
      END IF
C
      IF (ISOSPI.EQ.0) THEN
          INVRSN_NEUTRS(IDEFCN)=NOFINV
      END IF
C
C=======================================================================
C     Defining the 'normalised' final expression of the 'chi2' 
C=======================================================================
C
      CHIWEI_ENEDEG=CHIWEI_ENERGY
      CHIWEI_ENERGY=CHIWEI_ENERGY/IDEGER
      CHINOR=SQRT(CHISUM/IHISUM)
C
C=======================================================================
C     Calculating energy densities below and above the Fermi level
C=======================================================================
C
      ERRABS_WEIDEG=ERRABS_WEIDEG/IDEGER
C
      DENLOW=ITHLOW/(ELOMAX-ELOMIN)
      DENUPP=ITHUPP/(EUPMAX-EUPMIN)
C
C=======================================================================
C=======================================================================
C     Calculating the correlation matrices for experiment and theory
C=======================================================================
C=======================================================================
C
      DO IEXPEL=1,LEVEXP
         DO IEXPER=1,LEVEXP
            CORELE(IEXPEL,IEXPER)=(EXPEXP(IEXPEL)-EXPEXP(IEXPER))
         END DO
      END DO
C
      DO ITHEOL=1,INWIND
         DO ITHEOR=1,INWIND
            CORELT(ITHEOL,ITHEOR)=(EWINDW(ITHEOL)-EWINDW(ITHEOR))
         END DO
      END DO
C
C=======================================================================
C     Below taking into account level degeneracies when calculating
C     correlation matrices and the corresponding chi^2 contribution 
C=======================================================================
C
      CHISQU_CORREL=0.0
      XNORMA=0.0
C
      DO IEXPEL=1,LEVEXP
         DO IEXPER=1,LEVEXP
C
            DEGDEG=IDEGEX(IEXPEL)*IDEGEX(IEXPER)
            DEGDEG=SQRT(DEGDEG)
            DIFFER=CORELT(IEXPEL,IEXPER)-CORELE(IEXPEL,IEXPER)
            DIFFER=DIFFER*DIFFER
C
            CHISQU_CORREL=CHISQU_CORREL+DEGDEG*DIFFER
            XNORMA=XNORMA+DEGDEG
C
         END DO
      END DO
C
      CHISQU_CORREL=SQRT(0.5*CHISQU_CORREL/XNORMA)
C
C=======================================================================
C     Quantities below are used in the minimisation procedure
C=======================================================================
C
      DIFSQU_EFERMI=(FERMEX(INUCLI)-FERTHE)**2
      DIFSQU_ENEGAP=(GAPEXP(INUCLI)-GAPTHE)**2
      DIFSQU_DENSUP=(DENUPP-DENSUP(INUCLI))**2
      DIFSQU_DENSLW=(DENLOW-DENSDW(INUCLI))**2
C
      DIFSQU_RADIUS=(RMSEXP-RMSTHE)**2
C
C=======================================================================
C     Calculating the proposed shift of the central radius r0
C=======================================================================
C
      CALL SHIFTR(INUCLI,IZ_FIX,IN_FIX,ISOSPI)
C
C=======================================================================
C     Calculating the \rho(r) \chi^2
C=======================================================================
*C      
*      CHIRHO=0.0
*C          
*      DO I_AUXI=1,N_NUCL
*C             
*         I_NOYX=I_NUCL(I_AUXI)
*C             
*         DO ID_RHO=1,ND_RHO
                
*            CHIRHO=CHIRHO+(RHOTHE(ID_RHO,I_NOYX)
*     *                   - RHOEXP(ID_RHO,I_NOYX))**2
*         END DO
*C          
*      END DO
C
C=======================================================================
C     Calculating the actual (weighted) chi^2 function value
C=======================================================================
C
      HISQUA=CHOICE(ISOSPI,IDEFCN,INUCLI)
      CHISQU_CHOICE=HISQUA
C
C=======================================================================
C
      IF (HICMIN.GT.CHISQU_CORREL) THEN
          HICMIN=CHISQU_CORREL
          IPRIN3=1
      END IF
C
      IF (HIWMIN.GT.CHIWEI_ENERGY) THEN
          HIWMIN=CHIWEI_ENERGY
          IPRIN1=1
      END IF
C
      IF (CHIWEI_ENERGY.LE.HIWLIM) IPRIN1=1
C
      IF (VALMAX.LE.VALLIM) IPRIN2=1
C
      IF (ERRMIN.GT.VALMAX) THEN
          ERRMIN=VALMAX
          IPRIN2=1
      END IF
C
C=======================================================================
C
      IF (CHITOT.GT.HISQUA) THEN
          CHITOT=HISQUA
          IHITOT=IDEFCN
          RADDIF=SQRT(DIFSQU_RADIUS)
          IPRIN3=1
      END IF
C
      IPRIN3=1
C
C=======================================================================
C     If the results on chi^2 and maximum error were improved, 
C     we print them ...
C=======================================================================
C
      IF (I_FLAG.EQ.1) THEN
C
          IF ((IPRIN1.EQ.1).OR.(IPRIN2.EQ.1).OR.(IPRIN3.EQ.1)) THEN
C
              CALL CMPRSN(INUCLI,IZ_FIX,IN_FIX,ISOSPI,NDISOS,NUCLID,
     *                    IRUNMI,IDEFCN,EMINTH,EMAXTH,R0COUL,CHNORM,
     *                    FERMEX,FERTHE,GAPEXP,GAPTHE,CHIWEI_ENERGY,
     *                    ERRABS_WEIDEG,CHISQU_CORREL,EABSAV,ERRMAX,
     *                    DENUPP,DENSUP,DENLOW,DENSDW,CHWEIG,
     *                    CHISQU_INVERT,CHISQU_CHOICE,INDTRU,IPARAM)
C
          END IF
C
      END IF
C
C=======================================================================
C     Collecting the minimum values of the criterion functions
C=======================================================================
C
C     ... first the total chi^2 i.e. the one defined by CHOICE
C
C     IF (CHITOT.GT.HISQUA) THEN
C         CHITOT=HISQUA
C         IHITOT=IDEFCN
C     END IF
C
C         ... then the rest ...
C
      IF (SCHIWE.GT.CHIWEI_ENERGY) THEN
          SCHIWE=CHIWEI_ENERGY
          ICHIWE=IDEFCN
      END IF
C
      IF (SDIFWE.GT.ERRABS_WEIDEG) THEN
          SDIFWE=ERRABS_WEIDEG
          IDIFWE=IDEFCN
      END IF
C      
      IF (SCHICO.GT.CHISQU_CORREL) THEN
          SCHICO=CHISQU_CORREL
          ICHICO=IDEFCN
      END IF
C      
      IF (SABSAV.GT.EABSAV) THEN
          SABSAV=EABSAV
          IABSAV=IDEFCN
      END IF
      
      IF (SERMAX.GT.ERRMAX) THEN
          SERMAX=ERRMAX
          IERMAX=IDEFCN
      END IF
      
      IF (SDENUP.GT.DENUPP) THEN
          SDENUP=DENUPP
          IDENUP=IDEFCN
      END IF
      
      IF (SDENSU.GT.DENSUP(INUCLI)) THEN
          SDENSU=DENSUP(INUCLI)
          IDENSU=IDEFCN
      END IF
      
      IF (SDENLO.GT.DENLOW) THEN
          SDENLO=DENLOW
          IDENLO=IDEFCN
      END IF
      
      IF (SDENSD.GT.DENSDW(INUCLI)) THEN
          SDENSD=DENSDW(INUCLI)
          IDENSD=IDEFCN
      END IF
C
C=======================================================================
C     Storing the results on disk
C=======================================================================
C
      IF (ISOSPI.EQ.1) THEN
C      
          CHICOR_PROTON=CHISQU_CORREL
          RADDIF_PROTON=DIFSQU_RADIUS
          CHIINV_PROTON=CHISQU_INVERT
          FERDIF_PROTON=DIFSQU_EFERMI
          GAPDIF_PROTON=DIFSQU_ENEGAP
          CHIWEI_PROTON=CHIWEI_ENERGY
          CHIDEG_PROTON=CHIWEI_ENEDEG
          EABSWD_PROTON=ERRABS_WEIDEG
          EABSAV_PROTON=EABSAV
          ERRMAX_PROTON=ERRMAX
          DIFFUP_PROTON=DIFSQU_DENSUP
          DIFFDW_PROTON=DIFSQU_DENSDW
          N_ACTU_PROTON=N_ACTU
          N_CORR_PROTON=N_CORR
C
          GAPTHE_PROTON=GAPTHE
          FERTHE_PROTON=FERTHE
          DENLOW_PROTON=DENLOW
          DENUPP_PROTON=DENUPP
C
          HINORM_PROTON=HINORM
C
          CHIRHO_PROTON=CHIRHO
C
          IF (LOGWRI.GT.0) THEN
              WRITE(NOUTPT,'(80(''#''),/,''#'',T80,''#'',/,
     *                   ''#  Proton Energy RMS= '',f15.6,T80,''#'',/,
     *                   ''#'',T80,''#'',/,80(''#''))')
     *                              SQRT(CHIWEI_PROTON)
          END IF
C
      END IF          
C
C=======================================================================
C
      IF (ISOSPI.EQ.0) THEN
C      
          CHICOR_NEUTRS=CHISQU_CORREL
          RADDIF_NEUTRS=DIFSQU_RADIUS
          CHIINV_NEUTRS=CHISQU_INVERT
          FERDIF_NEUTRS=DIFSQU_EFERMI
          GAPDIF_NEUTRS=DIFSQU_ENEGAP
          CHIWEI_NEUTRS=CHIWEI_ENERGY
          CHIDEG_NEUTRS=CHIWEI_ENEDEG
          EABSWD_NEUTRS=ERRABS_WEIDEG
          EABSAV_NEUTRS=EABSAV
          ERRMAX_NEUTRS=ERRMAX
          DIFFUP_NEUTRS=DIFSQU_DENSUP
          DIFFDW_NEUTRS=DIFSQU_DENSDW
          N_ACTU_NEUTRS=N_ACTU
          N_CORR_NEUTRS=N_CORR
C
          GAPTHE_NEUTRS=GAPTHE
          FERTHE_NEUTRS=FERTHE
          DENLOW_NEUTRS=DENLOW
          DENUPP_NEUTRS=DENUPP
C
          HINORM_NEUTRS=HINORM
C
          IF (LOGWRI.GT.0) THEN
              WRITE(NOUTPT,'(80(''#''),/,''#'',T80,''#'',/,
     *                   ''#  Neutron Energy RMS= '',f15.6,T80,''#'',/,
     *                   ''#'',T80,''#'',/,80(''#''))')
     *                              SQRT(CHIWEI_NEUTRS)
          END IF
C
      END IF 
C
C=======================================================================
C
                
C
C=======================================================================
C
      IMODUL=IDEFCN-1
C
      IF ((IDEFCN.EQ.1).OR.(MOD(IMODUL,20).EQ.0)) THEN
C
          IF (ISOSPI.EQ.1) THEN
C
              IF (LOGWRI.GT.0) THEN               
C
                  WRITE(LOGCHP,'(/,''From EXPTHE'',/)')
C
                  WRITE(LOGCHP,'(/,80(''#''),/,''#'',78X,''#'',/,
     *                ''#  Test of the quality of the spherical '',
     *                ''s.p. spectrum  PROTONS Z ='',I3,
     *                ''  N ='',I3,''  #'',/,''#'',78X,''#'',/,
     *                ''#  No:  HiWei  HiCor  HiNor  ErrAv  ErrMx'',
     *                ''  GapT   D_UpT  D_DwT   R_th    F_th  #'',/,
     *                ''#                                 Ex -->>'',
     *                F6.2,F8.3,F7.3,F7.3,F8.2,''  #'')')
     *
     *                IZ_FIX,IN_FIX,GAPEXP(INUCLI),DENSUP(INUCLI),
     *                DENSDW(INUCLI),RMSEXP,FERMEX(INUCLI)
              END IF
C
          END IF
C
          IF (ISOSPI.EQ.0) THEN
C
              IF (LOGWRI.GT.0) THEN
C
                  WRITE(LOGCHN,'(/,''From EXPTHE'',/)')
C                        
                  WRITE(LOGCHN,'(/,80(''#''),/,''#'',78X,''#'',/,
     *                ''#  Test of the quality of the spherical '',
     *                ''s.p. spectrum NEUTRONS Z ='',I3,
     *                ''  N ='',I3,''  #'',/,''#'',78X,''#'',/,
     *                ''#  No:  HiWei  HiCor  HiNor  ErrAv  ErrMx'',
     *                ''  GapT   D_UpT  D_DwT   R_th    F_th  #'',/,
     *                ''#                                 Ex -->>'',
     *                F6.2,F8.3,F7.3,F7.3,F8.2,''  #'')')
     *
     *                IZ_FIX,IN_FIX,GAPEXP(INUCLI),DENSUP(INUCLI),
     *                DENSDW(INUCLI),RMSEXP,FERMEX(INUCLI)
              END IF
C              
          END IF
C
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          IF (ISOSPI.EQ.1) THEN
C                              
              WRITE(LOGCHP,'(''#'',I5,5F7.3,F6.2,F8.3,2F7.3,F8.2,
     *                                                 ''  #'')')
     *
     *           IDEFCN,CHIWEI_ENERGY,CHISQU_CORREL,CHINOR,EABSAV,
     *                  ERRMAX,GAPTHE,DENUPP,DENLOW,RMSTHE,FERTHE
          END IF
C
          IF (ISOSPI.EQ.0) THEN
C                              
              WRITE(LOGCHN,'(''#'',I5,5F7.3,F6.2,F8.3,2F7.3,F8.2,
     *                                                 ''  #'')')
     *
     *           IDEFCN,CHIWEI_ENERGY,CHISQU_CORREL,CHINOR,EABSAV,
     *                  ERRMAX,GAPTHE,DENUPP,DENLOW,RMSTHE,FERTHE
          END IF
C
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(15X,''Exiting  EXPTHE'')')
      END IF 
C
C=======================================================================
C      
      RETURN
      END
C
C=======================================================================      
C=======================================================================      
C      
      SUBROUTINE SHIFTR(INUCLI,IZ_FIX,IN_FIX,ISOSPI)
C          
      INCLUDE  'MATDIM/NDNUCL.f'
C
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /DERIVD/ IDERID
      COMMON
     *       /PRINAL/ IMTALK
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================      
C     This function performs dynamical shift of the central
C     radius constant when minimising the ch2^2
C=======================================================================      
C
C     PUSHIN - A small proportion of the actual discrepancy
C              between Rtheo and Rexp;
C              expected to be generally between 0.1 and 0.5
C
C     RMODIF - Accumulated modification of the radius; each
C              time the new iteration has been performed it
C              will be increased  as long as the difference
C                         DELTAR=RMSTHE-RMSEXP
C              is positive - otherwise it will be decreased
C
C=======================================================================      
C
      IF (ISOSPI.EQ.1) THEN
         RMSTHE=RMSTHE_PROTON
	 RMSEXP=RMSEXP_PROTON(INUCLI)
      END IF
C      
      IF (ISOSPI.EQ.0) THEN
         RMSTHE=RMSTHE_NEUTRS
	 RMSEXP=RMSEXP_NEUTRS(INUCLI)
      END IF
C
      IF (IDERID.EQ.1) THEN
          RMODIF=0
      ELSE
C
          A_MASS=REAL(IZ_FIX+IN_FIX)
          FACTOR=A_MASS**(1.0/3.0)
C
C         Below we calculate an estimate of the central-radius par.
C                                                  modification
          DELTAR=RMSTHE-RMSEXP
          DELTAR=DELTAR/FACTOR
C
          RMODIF=PUSHIN*DELTAR
C
          IF (ISOSPI.EQ.1) THEN
	  
	     RMODIF_PROTON=RMODIF
	  
             IF (IMTALK.EQ.1 .AND. LOGWRI.GT.0) THEN
                 WRITE(NOUTPT,'(''In SHIFTR (P): RMSEXP='',f7.4,
     *		               '' RMSTHE='',f10.7,'' DELTAR = '',F14.7,
     *                             '' RMODIF = '',F14.7)') 
     *                     RMSEXP,RMSTHE,DELTAR,RMODIF
             END IF
	  END IF
C
          IF (ISOSPI.EQ.0) THEN
	  
	     RMODIF_NEUTRS=RMODIF
	  
             IF (IMTALK.EQ.1 .AND. LOGWRI.GT.0) THEN
                 WRITE(NOUTPT,'(''In SHIFTR (N): RMSEXP='',f7.4,
     *		             '' RMSTHE='',f10.7,'' DELTAR = '',F14.7,
     *                             '' RMODIF = '',F14.7)') 
     *                     RMSEXP,RMSTHE,DELTAR,RMODIF
             END IF
	  END IF
C
      END IF      
C
C=======================================================================      
C      
      RETURN
      END    
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE INVERT(INVERS,NDSPEC,LEVACT,NOFINV)
      DIMENSION
     *          INVERS(1:NDSPEC)
C
      COMMON
     *       /PRINAL/ IMTALK
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C
C=======================================================================
C     This routine  e s t i m a t e s   the number of inversions
C     of the theoretical levels with respect to the experimental 
C     order
C=======================================================================
C
      IF (LEVACT.LT.1.OR.LEVACT.GT.NDSPEC) THEN
C
          IF (IMTALK.EQ.1) THEN
              WRITE(NOUTPT,'(/,''LEVACT='',I5,'' is out of range, '',
     *                    ''NDSPEC='',I5)') LEVACT,NDSPEC
          END IF
C      
          LEVACT=NDSPEC
C
      END IF          
C
C=======================================================================
C
      NOFINV=0
C
      IF (LEVACT.EQ.1) RETURN
C
      IF (LEVACT.EQ.2.AND.INVERS(1).GT.INVERS(2)) NOFINV=1      
C
C=======================================================================
C
      IF (LEVACT.GT.2) THEN
C
          NOFINV=0      
C      
          DO I=1,LEVACT-1
             I_DIFF=INVERS(I+1)-INVERS(I)
             IF (I_DIFF.NE.1) NOFINV=NOFINV+1
          END DO
C
      END IF          
C
C=======================================================================
C
      RETURN
      END      
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE CMPRSN(INUCLI,IZ_FIX,IN_FIX,ISOSPI,NDISOS,NUCLID,
     *                  IRUNMI,IDEFCN,EMINTH,EMAXTH,RCOULO,CHNORM,
     *                  FERMEX,FERTHE,GAPEXP,GAPTHE,CHIWEI,DIFWEI,
     *                  CHICOR,EABSAV,ERRMAX,DENUPP,DENSUP,DENLOW,
     *                  DENSDW,CHWEIG,CHIINV,CHISQU_CHOICE,INDTRU,
     *                                                     IPARAM)
C
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDLEXP.f'
      INCLUDE  'MATDIM/NDITEH.f'
      INCLUDE  'MATDIM/NDPARS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
C
      CHARACTER
     *          LABEXP*6,LABTHE*6,CHIDEF*6,NUCLID*10
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6,
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6
C
      DIMENSION
     *          CHNORM(1:NDLEXP),CHWEIG(1:NDLEXP),INDTRU(1:NDLEXP)
      DIMENSION
     *          ENETHE(1:NDSPEC),
     *          LABTHE(1:NDSPEC)
      DIMENSION
     *          EXPEXP(1:NDLEXP),
     *          LABEXP(1:NDLEXP)
      DIMENSION
     *          NUCLID(0:NDISOS)
      DIMENSION
     *          GAPEXP(1:NDNUCL),FERMEX(1:NDNUCL),
     *          DENSUP(1:NDNUCL),DENSDW(1:NDNUCL)
C     
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS                                                  
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL) 
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /INVINV/ INVRSN_PROTON(0:NDITEH),
     *                INVRSN_NEUTRS(0:NDITEH)
      COMMON
     *       /ACTIVE/ IACTIV,IwMODE
      COMMON
     *       /WHICHI/ CHIDEF
C
C=======================================================================
C     Printing routine only - but what does it do ???
C=======================================================================
C
C=======================================================================
C
      V0CENT_PROTON=PARPOT( 1)
      R0CENT_PROTON=PARPOT( 2)
      A0CENT_PROTON=PARPOT( 3)
      V0SORB_PROTON=PARPOT( 4)
      R0SORB_PROTON=PARPOT( 5)
      A0SORB_PROTON=PARPOT( 6)
      V0EFFM_PROTON=PARPOT( 7)
      R0EFFM_PROTON=PARPOT( 8)
      A0EFFM_PROTON=PARPOT( 9)
      R0COUL       =PARPOT(10)
     
      XK_V0C_PROTON=PARPOT(11)
      XK_R0C_PROTON=PARPOT(12)
      XK_A0C_PROTON=PARPOT(13)
      XK_LAM_PROTON=PARPOT(14)
      XK_RSO_PROTON=PARPOT(15)
      XK_ASO_PROTON=PARPOT(16)
      XK_LEF_PROTON=PARPOT(17)
      XK_REF_PROTON=PARPOT(18)
      XK_AEF_PROTON=PARPOT(19)
      XK_COU	   =PARPOT(20)
     
      V0CENT_NEUTRS=PARPOT(21)
      R0CENT_NEUTRS=PARPOT(22)
      A0CENT_NEUTRS=PARPOT(23)
      V0SORB_NEUTRS=PARPOT(24)
      R0SORB_NEUTRS=PARPOT(25)
      A0SORB_NEUTRS=PARPOT(26)
      V0EFFM_NEUTRS=PARPOT(27)
      R0EFFM_NEUTRS=PARPOT(28)
      A0EFFM_NEUTRS=PARPOT(29)
     
      XK_V0C_NEUTRS=PARPOT(30)
      XK_R0C_NEUTRS=PARPOT(31)
      XK_A0C_NEUTRS=PARPOT(32)
      XK_LAM_NEUTRS=PARPOT(33)
      XK_RSO_NEUTRS=PARPOT(34)
      XK_ASO_NEUTRS=PARPOT(35)
      XK_LEF_NEUTRS=PARPOT(36)
      XK_REF_NEUTRS=PARPOT(37)
      XK_AEF_NEUTRS=PARPOT(38)
     
      ALAMPP       =PARPOT(39)
      ALAMPN       =PARPOT(40)
      ALAMNP       =PARPOT(41)
      ALAMNN       =PARPOT(42)

      TLAMPP       =PARPOT(43)
      TLAMPN       =PARPOT(44)
      TLAMNP       =PARPOT(45)
      TLAMNN       =PARPOT(46)
      
      CLAMPP       =PARPOT(47)
      CLAMPN       =PARPOT(48)
      CLAMNP       =PARPOT(49)
      CLAMNN       =PARPOT(50)
C
      IF (ISOSPI.EQ.1) THEN
          LEVTHE_PROTON=LDSING_PROTON
C
          LEVTHE=LDSING_PROTON ! Number of levels below user defined 
C                                  limit SPHMAX
          LEVEXP=LEVEXP_PROTON(INUCLI)
c	  
	  V0CENT=V0CENT_PROTON
	  R0CENT=R0CENT_PROTON
	  A0CENT=A0CENT_PROTON
	  V0SORB=V0SORB_PROTON
	  R0SORB=R0SORB_PROTON
	  A0SORB=A0SORB_PROTON
	  V0EFFM=V0EFFM_PROTON
	  R0EFFM=R0EFFM_PROTON
	  A0EFFM=A0EFFM_PROTON
	  XK_V0C=XK_V0C_PROTON
	  XK_R0C=XK_R0C_PROTON
	  XK_A0C=XK_A0C_PROTON
     	  XK_LAM=XK_LAM_PROTON
          XK_RSO=XK_RSO_PROTON
	  XK_ASO=XK_ASO_PROTON
	  XK_LEF=XK_LEF_PROTON
	  XK_REF=XK_REF_PROTON
	  XK_AEF=XK_AEF_PROTON
C
          RMSEXP=RMSEXP_PROTON(INUCLI)
	  RMSTHE=RMSTHE_PROTON
	  RMODIF=RMODIF_PROTON
C
          DO ITHEOR=1,LEVTHE
             LABTHE(ITHEOR)=LABTHE_PROTON(ITHEOR)
             ENETHE(ITHEOR)=ENETHE_PROTON(ITHEOR)
          END DO
C          
          DO IEXPER=1,LEVEXP
             LABEXP(IEXPER)=LABEXP_PROTON(INUCLI,IEXPER)
             EXPEXP(IEXPER)=EXPEXP_PROTON(INUCLI,IEXPER)
          END DO
C          
      END IF 
C
      IF (ISOSPI.EQ.0) THEN
          LEVTHE_NEUTRS=LDSING_NEUTRS
C
          LEVTHE=LDSING_NEUTRS  
          LEVEXP=LEVEXP_NEUTRS(INUCLI)
C          
	  V0CENT=V0CENT_NEUTRS
	  R0CENT=R0CENT_NEUTRS
	  A0CENT=A0CENT_NEUTRS
	  V0SORB=V0SORB_NEUTRS
	  R0SORB=R0SORB_NEUTRS
	  A0SORB=A0SORB_NEUTRS
	  V0EFFM=V0EFFM_NEUTRS
	  R0EFFM=R0EFFM_NEUTRS
	  A0EFFM=A0EFFM_NEUTRS
	  XK_V0C=XK_V0C_NEUTRS
	  XK_R0C=XK_R0C_NEUTRS
	  XK_A0C=XK_A0C_NEUTRS
     	  XK_LAM=XK_LAM_NEUTRS
          XK_RSO=XK_RSO_NEUTRS
	  XK_ASO=XK_ASO_NEUTRS
	  XK_LEF=XK_LEF_NEUTRS
	  XK_REF=XK_REF_NEUTRS
	  XK_AEF=XK_AEF_NEUTRS
C
	  RMSEXP=RMSEXP_NEUTRS(INUCLI)
	  RMSTHE=RMSTHE_NEUTRS
	  RMODIF=RMODIF_NEUTRS
C
          DO ITHEOR=1,LEVTHE
             LABTHE(ITHEOR)=LABTHE_NEUTRS(ITHEOR)
             ENETHE(ITHEOR)=ENETHE_NEUTRS(ITHEOR)
          END DO
C          
          DO IEXPER=1,LEVEXP
             LABEXP(IEXPER)=LABEXP_NEUTRS(INUCLI,IEXPER)
             EXPEXP(IEXPER)=EXPEXP_NEUTRS(INUCLI,IEXPER)
          END DO
C          
      END IF
C
      CALL PRINTI(IDEFCN)
C
      IF (ISOSPI.EQ.0 .AND. LOGWRI.GT.4) THEN
C
          WRITE(IRESUL,'(80(''#''),/,''#'',78X,''#'',/,
     *                    ''#  Comparison between the calculated '',
     *                    ''and experimental results:  Z='',I2,
     *                    ''   N='',I3,''   #'',/,
     *                    ''#  '',A10,''                            '',
     *                    ''                RST='',I2,
     *                    '' IDEFCN='',I5,''   #'',/,
     *                    ''#'',78X,''#'',/,
     *                    80(''#''),/,''#'',78X,''#'',/,
     *                    ''#   No)   E_calc    E_expe    Lab_th    '',
     *                    ''Lab_exp    Eth-Eex   Chisqr   ChisqW   #'',
     *                    /,''#'',78X,''#'')')
     *
     *                                    IZ_FIX,IN_FIX,NUCLID(ISOSPI),
     *                                                  IRUNMI,IDEFCN
C
          IF (IwMODE.EQ.2 .AND. LOGWRI.GT.4)
     *
     *    WRITE(LOGNEU,'(/,80(''#''),/,''#'',78X,''#'',/,
     *                    ''#  Comparison between the calculated '',
     *                    ''and experimental results:  Z='',I2,
     *                    ''   N='',I3,''   #'',/,
     *                    ''#  '',A10,''                            '',
     *                    ''                RST='',I2,
     *                    '' IDEFCN='',I5,''   #'',/,
     *                    ''#'',78X,''#'',/,
     *                    80(''#''),/,''#'',78X,''#'',/,
     *                    ''#   No)   E_calc    E_expe    Lab_th    '',
     *                    ''Lab_exp    Eth-Eex   Chisqr   ChisqW   #'',
     *                    /,''#'',78X,''#'')')
     *
     *                                    IZ_FIX,IN_FIX,NUCLID(ISOSPI),
     *                                                  IRUNMI,IDEFCN
C
      END IF
C
      IF (ISOSPI.EQ.1 .AND. LOGWRI.GT.4) THEN
C
          WRITE(IRESUL,'(80(''#''),/,''#'',78X,''#'',/,
     *                    ''#  Comparison between the calculated '',
     *                    ''and experimental results:  Z='',I2,
     *                    ''   N='',I3,''   #'',/,
     *                    ''#  '',A10,'' {Coulomb Effective Radius ='',
     *                    F6.3,''*A^(1/3)}'','' RST='',I2,
     *                    '' IDEFCN='',I5,''   #'',/,''#'',78X,''#'',/,
     *                    80(''#''),/,''#'',78X,''#'',/,
     *                    ''#   No)   E_calc    E_expe    Lab_th    '',
     *                    ''Lab_exp    Eth-Eex   Chisqr   ChisqW   #'',
     *                    /,''#'',78X,''#'')')
     *
     *                                    IZ_FIX,IN_FIX,NUCLID(ISOSPI),
     *                                           RCOULO,IRUNMI,IDEFCN
C
          IF (IwMODE.EQ.2 .AND. LOGWRI.GT.4)
     *
     *    WRITE(LOGPRO,'(/,80(''#''),/,''#'',78X,''#'',/,
     *                    ''#  Comparison between the calculated '',
     *                    ''and experimental results:  Z='',I2,
     *                    ''   N='',I3,''   #'',/,
     *                    ''#  '',A10,'' {Coulomb Effective Radius ='',
     *                    F6.3,''*A^(1/3)}'','' RST='',I2,
     *                    '' IDEFCN='',I5,''   #'',/,''#'',78X,''#'',/,
     *                    80(''#''),/,''#'',78X,''#'',/,
     *                    ''#   No)   E_calc    E_expe    Lab_th    '',
     *                    ''Lab_exp    Eth-Eex   Chisqr   ChisqW   #'',
     *                    /,''#'',78X,''#'')')
     *
     *                                    IZ_FIX,IN_FIX,NUCLID(ISOSPI),
     *                                           RCOULO,IRUNMI,IDEFCN
C
      END IF
C
C=======================================================================
C
      DO ITHEOR=1,LEVTHE
C
         ETHEOR=ENETHE(ITHEOR)
C
         DO IEXPER=1,LEVEXP
C
            IF ((LABEXP(IEXPER).EQ.LABTHE(ITHEOR)).AND.
     *         ((ETHEOR.GE.EMINTH).AND.(ETHEOR.LE.EMAXTH))) THEN
C
                 IF (LOGWRI.GT.4)
     *
     *           WRITE(IRESUL,'(''#   '',I2,'') '',F8.3,2X,F8.3,4X,
     *                             A6,5X,A6,F11.4,2F9.4,''   #'')')
     *
     *                 IEXPER,ETHEOR,EXPEXP(IEXPER),LABTHE(ITHEOR),
     *                               LABEXP(IEXPER),
     *                        ETHEOR-EXPEXP(IEXPER),CHNORM(IEXPER),
     *                                              CHWEIG(IEXPER)
C
                 IF (ISOSPI.EQ.1 .AND. IwMODE.EQ.2 .AND. LOGWRI.GT.4)
     *                 
     *           WRITE(LOGPRO,'(''#   '',I2,'') '',F8.3,2X,F8.3,4X,
     *                             A6,5X,A6,F11.4,2F9.4,''   #'')')
     *
     *                 IEXPER,ETHEOR,EXPEXP(IEXPER),LABTHE(ITHEOR),
     *                               LABEXP(IEXPER),
     *                        ETHEOR-EXPEXP(IEXPER),CHNORM(IEXPER),
     *                                              CHWEIG(IEXPER)
C
                 IF (ISOSPI.EQ.0 .AND. IwMODE.EQ.2 .AND. LOGWRI.GT.4)
     *                 
     *           WRITE(LOGNEU,'(''#   '',I2,'') '',F8.3,2X,F8.3,4X,
     *                             A6,5X,A6,F11.4,2F9.4,''   #'')')
     *
     *                 IEXPER,ETHEOR,EXPEXP(IEXPER),LABTHE(ITHEOR),
     *                               LABEXP(IEXPER),
     *                        ETHEOR-EXPEXP(IEXPER),CHNORM(IEXPER),
     *                                              CHWEIG(IEXPER)
C
            END IF
C
         END DO
C
      END DO
C
C=======================================================================
C
      DO IEXPER=1,LEVEXP
         IF (INDTRU(IEXPER).EQ.0 .AND. LOGWRI.GT.0) THEN
             WRITE(IRESUL,'(80(''!''))')
             WRITE(IRESUL,'(''!!!  Warning : experimental level '',
     *                      ''number '',I3.3,'' has no theoretical '',
     *                      ''counterpart   !!!'')') IEXPER
             WRITE(IRESUL,'(80(''!''))')
         END IF
      END DO
C
C=======================================================================
C     Printing a short table if weighted chi^2 or Max. error or
C     else the correlation matrix test when improved
C=======================================================================
C
      IF (ISOSPI.EQ.0 .AND. LOGWRI.GT.4) THEN
C
          WRITE(IRESUL,'(/,80(''#''),/,''#'',78X,''#'',/,
     *                 ''#   Numerical measures of discrepancies '',
     *                 '' theory/experiment    Z ='',I3,
     *                 ''   N='',I3,''   #'',/,''#   '',A10,
     *                 ''                                        '',
     *                 ''RST='',I2,
     *                 ''  IDEFCN ='',I6,''   #'',/,
     *                 ''#   FermEx='',F7.3,
     *                 ''  FermTh='',F7.3,''   GapEx='',F5.2,
     *                 '' GapTh='',F5.2,'' Re='',F4.2,'' Rt='',F4.2,
     *                 ''   #'',/,
     *                 ''#                                    '',
     *                 ''INVER='',I3,''               Ct='',F7.4,
     *                 ''        #'',/,
     *                 ''#   ChiWei  DifWei  ChiCor  EAbsAv   ErrMx'',
     *                 ''   DenUpT  DenUpE   DenDwT  DenDwE   #'')')
     *
     *                                   IZ_FIX,IN_FIX,NUCLID(ISOSPI),
     *                                                 IRUNMI,IDEFCN,
     *                                   FERMEX(INUCLI),FERTHE,
     *                                   GAPEXP(INUCLI),GAPTHE,
     *                                   RMSEXP,RMSTHE,
     *                                   INVRSN_NEUTRS(IDEFCN),RMODIF
C
          IF (IwMODE.EQ.2 .AND. LOGWRI.GT.4)
     *          
     *    WRITE(LOGNEU,'(/,80(''#''),/,''#'',78X,''#'',/,
     *                 ''#   Numerical measures of discrepancies '',
     *                 '' theory/experiment    Z ='',I3,
     *                 ''   N='',I3,''   #'',/,''#   '',A10,
     *                 ''                                        '',
     *                 ''RST='',I2,
     *                 ''  IDEFCN ='',I6,''   #'',/,
     *                 ''#   FermEx='',F7.3,
     *                 ''  FermTh='',F7.3,''   GapEx='',F5.2,
     *                 '' GapTh='',F5.2,'' Re='',F4.2,'' Rt='',F4.2,
     *                 ''   #'',/,
     *                 ''#                                    '',
     *                 ''INVER='',I3,''               Ct='',F7.4,
     *                 ''        #'',/,
     *                 ''#   ChiWei  DifWei  ChiCor  EAbsAv   ErrMx'',
     *                 ''   DenUpT  DenUpE   DenDwT  DenDwE   #'')')
     *
     *                                   IZ_FIX,IN_FIX,NUCLID(ISOSPI),
     *                                                 IRUNMI,IDEFCN,
     *                                   FERMEX(INUCLI),FERTHE,
     *                                   GAPEXP(INUCLI),GAPTHE,
     *                                   RMSEXP,RMSTHE,
     *                                   INVRSN_NEUTRS(IDEFCN),RMODIF
C
      END IF
C
C=======================================================================
C
      IF (ISOSPI.EQ.1 .AND. LOGWRI.GT.4) THEN
C
          WRITE(IRESUL,'(/,80(''#''),/,''#'',78X,''#'',/,
     *                 ''#   Numerical measures of discrepancies '',
     *                 '' theory/experiment    Z ='',I3,
     *                 ''   N='',I3,''   #'',/,
     *                 ''#   '',A10,''  {Coulomb Eff. Radius ='',
     *                 F6.3,''*A^(1/3)} RST='',I2,''  IDEFCN ='',
     *                 I6,''   #'',/,
     *                 ''#   FermEx='',F7.3,
     *                 ''  FermTh='',F7.3,''   GapEx='',F5.2,
     *                 '' GapTh='',F5.2,'' Re='',F4.2,'' Rt='',F4.2,
     *                 ''   #'',/,
     *                 ''#                                    '',
     *                 ''INVER='',I3,''               Ct='',F7.4,
     *                 ''        #'',/,
     *                 ''#   ChiWei  DifWei  ChiCor  EAbsAv   ErrMx'',
     *                 ''   DenUpT  DenUpE   DenDwT  DenDwE   #'')')
     *
     *                                   IZ_FIX,IN_FIX,NUCLID(ISOSPI),
     *                                          RCOULO,IRUNMI,IDEFCN,
     *                                   FERMEX(INUCLI),FERTHE,
     *                                   GAPEXP(INUCLI),GAPTHE,
     *                                   RMSEXP,RMSTHE,
     *                                   INVRSN_PROTON(IDEFCN),RMODIF
C
          IF (IwMODE.EQ.2 .AND. LOGWRI.GT.4)
     *          
     *    WRITE(LOGPRO,'(/,80(''#''),/,''#'',78X,''#'',/,
     *                 ''#   Numerical measures of discrepancies '',
     *                 '' theory/experiment    Z ='',I3,
     *                 ''   N='',I3,''   #'',/,
     *                 ''#   '',A10,''  {Coulomb Eff. Radius ='',
     *                 F6.3,''*A^(1/3)} RST='',I2,''  IDEFCN ='',
     *                 I6,''   #'',/,
     *                 ''#   FermEx='',F7.3,
     *                 ''  FermTh='',F7.3,''   GapEx='',F5.2,
     *                 '' GapTh='',F5.2,'' Re='',F4.2,'' Rt='',F4.2,
     *                 ''   #'',/,
     *                 ''#                                    '',
     *                 ''INVER='',I3,''               Ct='',F7.4,
     *                 ''        #'',/,
     *                 ''#   ChiWei  DifWei  ChiCor  EAbsAv   ErrMx'',
     *                 ''   DenUpT  DenUpE   DenDwT  DenDwE   #'')')
     *
     *                                   IZ_FIX,IN_FIX,NUCLID(ISOSPI),
     *                                          RCOULO,IRUNMI,IDEFCN,
     *                                   FERMEX(INUCLI),FERTHE,
     *                                   GAPEXP(INUCLI),GAPTHE,
     *                                   RMSEXP,RMSTHE,
     *                                   INVRSN_PROTON(IDEFCN),RMODIF
C
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.4) 
     *    WRITE(IRESUL,'(''# '',4F8.4,F8.3,F9.4,F8.4,F9.4,F8.4,
     *      ''   #'')')CHIWEI,DIFWEI,CHICOR,EABSAV,ERRMAX,DENUPP,DENSUP,
     *                                                    DENLOW,DENSDW
C
      IF (LOGWRI.GT.4) 
     *    WRITE(IRESUL,'(''#'',T37,A6,'':'',T46,''CHISQU_CHOICE='',
     *             F12.4,T80,''#'',/, 80(''#''))')CHIDEF,CHISQU_CHOICE
C
      IF (ISOSPI.EQ.0 .AND. IwMODE.EQ.2 .AND. LOGWRI.GT.4) THEN
C      
          WRITE(LOGNEU,'(''# '',4F8.4,F8.3,F9.4,F8.4,F9.4,F8.4,
     *                                                       ''   #'')')
     *          CHIWEI,DIFWEI,CHICOR,EABSAV,ERRMAX,DENUPP,DENSUP,
     *                                             DENLOW,DENSDW
C
          WRITE(LOGNEU,'(''#'',T37,A6,'':'',T46,''CHISQU_CHOICE='',
     *                   F12.4,T80,''#'',/, 80(''#''))')
     *                                            CHIDEF,CHISQU_CHOICE
      END IF
C
      IF (ISOSPI.EQ.1 .AND. IwMODE.EQ.2 .AND. LOGWRI.GT.4) THEN
C      
          WRITE(LOGPRO,'(''# '',4F8.4,F8.3,F9.4,F8.4,F9.4,F8.4,
     *                                                       ''   #'')')
     *          CHIWEI,DIFWEI,CHICOR,EABSAV,ERRMAX,DENUPP,DENSUP,
     *                                             DENLOW,DENSDW
C
          WRITE(LOGPRO,'(''#'',T37,A6,'':'',T46,''*CHISQU_CHOICE='',
     *                  F12.4,T80,''#'',/, 80(''#''))')
     *                                            CHIDEF,CHISQU_CHOICE
C
      END IF
C
C=======================================================================    
C
      CALL WEIPRI(IRESUL)
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE WARNIN(N_UNIT,WHATEX)
      CHARACTER
     *          WHATEX*6
C
C=======================================================================
C     This is a WARNING PRINT routine only
C=======================================================================
C
      IF (WHATEX.EQ.'EXTRUE'.or.WHATEX.EQ.'EXPNEW') RETURN
C
      WRITE(N_UNIT,'(''  N   N   OOO  TTTTT    EEEEE  X   X  PPPP '',
     *               ''  EEEEE  RRRR   III  M   M  !!!!!!'',/,
     *               ''  NN  N  O   O   T      E       X X   P   P'',
     *               ''  E      R   R   I   MM MM   !!!! '',/,
     *               ''  N N N  O   O   T      EEE      X    PPPP '',
     *               ''  EEE    RRRR    I   M M M    !!  '',/,
     *               ''  N  NN  O   O   T      E       X X   P    '',
     *               ''  E      R  R    I   M   M        '',/,
     *               ''  N   N   OOO    T      EEEEE  X   X  P    '',
     *               ''  EEEEE  R   R  III  M   M    !!  '',//,
     *               80(''=''),/,80(''=''),/)')            
C
C=======================================================================
C
      RETURN
      END      
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE WEIPRI(N_UNIT)
C
      COMMON
     *       /WEIGHT/ WEIGHT_CORREL,WEIGHT_RADIUS,WEIGHT_INVERT,
     *                WEIGHT_EFERMI,WEIGHT_ENEGAP,WEIWEI,
     *                WEIGHT_ERRABS,WEIGHT_EABSAV,WEIGHT_ERRMAX,
     *                WEIGHT_DENSUP,WEIGHT_DENSDW,WEIGHT_RHODEN
      COMMON
     *       /CHIVAL/ CHISQU_CORREL,DIFSQU_RADIUS,CHISQU_INVERT,
     *                DIFSQU_EFERMI,DIFSQU_ENEGAP,CHIWEI_ENERGY,
     *                CHIWEI_ENEDEG,ERRABS_WEIDEG,EABSAV,ERRMAX,
     *                       DIFSQU_DENSUP,DIFSQU_DENSDW,CHIRHO
      COMMON
     *       /DECOMP/ VEICOR,VEIRAD,VEIINV,VEIFER,VEIGAP,VEIWEI,
     *                       VEIDIF,VEIABS,VEIMAX,VEIDUP,VEIDDW
      COMMON
     *         /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                  LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                  NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                     LOGBIS  
C
C=======================================================================
C     This subroutine ???
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(N_UNIT,'(/,80(''#''),/,''#'',78X,''#'',/,
     *                 ''# WEICOR WEIRAD WEIINV WEIFER WEIGAP WEIWEI'',
     *                 '' WEIDIF WEIABS WEIMAX WEIDUP WEIDDW #'',/,
     *                 ''#'',11(1X,F6.2),'' #'')')
     *
     *                 WEIGHT_CORREL,WEIGHT_RADIUS,WEIGHT_INVERT,
     *                 WEIGHT_EFERMI,WEIGHT_ENEGAP,WEIWEI,
     *                 WEIGHT_ERRABS,WEIGHT_EABSAV,WEIGHT_ERRMAX,
     *                 WEIGHT_DENSUP,WEIGHT_DENSDW
C
          WRITE(N_UNIT,'(  ''# CHICOR DIFRAD CHIINV FERDIF GAPDIF'',
     *                 '' CHIWEI DIFWEI EABSAV ERRMAX DIFFUP DIFFDW #'',
     *                 /,''#'',1X,2F6.3,1X,9(F7.1),'' #'')')
     *
     *                 CHISQU_CORREL,DIFSQU_RADIUS,CHISQU_INVERT,
     *                 DIFSQU_EFERMI,DIFSQU_ENEGAP,CHIWEI_ENERGY,
     *                 ERRABS_WEIDEG,EABSAV,ERRMAX,DIFSQU_DENSUP,
     *                                             DIFSQU_DENSDW 
C
      END IF
C
      FEICOR=VEICOR*WEIGHT_CORREL*CHISQU_CORREL
      FEIRAD=VEIRAD*WEIGHT_RADIUS*DIFSQU_RADIUS
      FEIINV=VEIINV*WEIGHT_INVERT*CHISQU_INVERT
      FEIFER=VEIFER*WEIGHT_EFERMI*DIFSQU_EFERMI
      FEIGAP=VEIGAP*WEIGHT_ENEGAP*DIFSQU_ENEGAP
      FEIWEI=VEIWEI*WEIWEI*CHIWEI_ENERGY
      FEIDIF=VEIDIF*WEIGHT_ERRABS*ERRABS_WEIDEG
      FEIABS=VEIABS*WEIGHT_EABSAV*EABSAV
      FEIMAX=VEIMAX*WEIGHT_ERRMAX*ERRMAX
      FEIDUP=VEIDUP*WEIGHT_DENSUP*DIFSQU_DENSUP
      FEIDDW=VEIDDW*WEIGHT_DENSDW*DIFSQU_DENSDW
C
      IF (LOGWRI.GT.4) THEN
          WRITE(N_UNIT,'( ''# FEICOR FEIRAD FEIINV FEIFER FEIGAP'',
     *                 '' FEIWEI FEIDIF FEIABS FEIMAX FEIDUP FEIDDW #'',
     *                 /,''#'',11(F7.2),'' #'',/,
     *                 ''#'',78X,''#'',/,80(''#''))')
     *
     *                    FEICOR,FEIRAD,FEIINV,FEIFER,FEIGAP,FEIWEI,
     *           	         FEIDIF,FEIABS,FEIMAX,FEIDUP,FEIDDW  
      END IF              
C
C=======================================================================
C
      RETURN
      END      
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE STRLNG(STRING,LENGTH,STRAUX)
C      
      INCLUDE  'MATDIM/NDLNGT.f'
      INCLUDE  'MATDIM/NDX256.f'
C      
      CHARACTER
     *          STRING*256,BLANCK*1
      CHARACTER
     *          STRAUX*256
      DATA
     *     BLANCK / ' ' /
C
C=======================================================================
C     This subroutine gives the length of a string "STRING"
C     counting all non-blank characters
C=======================================================================
C
      LENGTH=0
C
      DO I=1,NDLNGT
         IF (STRING(I:I).NE.BLANCK) THEN
             LENGTH=LENGTH+1
         END IF
      END DO
C
      DO I=1,NDX256
         STRAUX(I:I)='.'
      END DO
C
      DO I=1,MIN(LENGTH,NDX256)
         STRAUX(I:I)=STRING(I:I)
      END DO
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C 
C FILE NAME = wspher07_radius_15.f ! Keep this symbol:    $ident@string$
C
C=======================================================================     
C=======================================================================     
C                R.M.S. RADIUS CALCULATION RELATED ROUTINES
C=======================================================================     
C=======================================================================     
C      
      SUBROUTINE NUCRAD(NDSPEC,LDSPEC,NDGAUS,NGAUSS,NDBASE,POLYNL,
     *                  NDIM_L,NDIM_N,RAD_UP,RAD_DN,RNODES,RWEIGH,
     *                  AOSCIL,RFUNUP,RFUNDN,NSHELL,ENERUP,ENERDN,
     *                  NWSSPH,LWSSPH,JWSSPH,RMSTHE,RPAIRI,RNOPAI,
     *                  LABORD,CMATUP,CMATDN,ENETHE,VCOEUP,VCOEDN,
     *                                       ISOSPI,N_PART,INUCLI)
C
      INCLUDE   'MATDIM/NDNUCL.f'
C
      DIMENSION
     *          LABORD(0:NDIM_N,0:NDIM_L,0:2*NDIM_L+1)
      DIMENSION
     *          RFUNUP(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNDN(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION     
     *          POLYNL(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          RNODES(1:NDGAUS,0:NDIM_L),
     *          RWEIGH(1:NDGAUS,0:NDIM_L)
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          RAD_UP(0:NDIM_L,0:NDIM_N),
     *          RAD_DN(0:NDIM_L,0:NDIM_N)
      DIMENSION
     *          ENETHE(1:NDSPEC)
      DIMENSION
     *          NWSSPH(1:NDSPEC),
     *          LWSSPH(1:NDSPEC),
     *          JWSSPH(1:NDSPEC)
      DIMENSION
     *          AOSCIL(1:NDNUCL) 
C      
      COMMON
     *         /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *         /BCSBCS_ENEMAX/ ENEMAX
      COMMON
     *         /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                  LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                  NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                     LOGBIS  
C
      DATA
     *          EPS_V2 / 1.0e-6 /     
C
C=======================================================================     
C     This subroutine calculates the nuclear r.m.s. radius for
C     protons or neutrons,  including (optionally) the pairing  
C=======================================================================     
C
      FACTOR=2.0*AOSCIL(INUCLI)**2
C
C=======================================================================
C     Calculating the single-particle nucleonic wave functions
C     in their spatial representations to be used to integrate         
C=======================================================================
C
      CALL FUNRAD(CMATUP,CMATDN,NGAUSS,NSHELL,NDIM_L,NDBASE,
     *                   NDGAUS,NDIM_N,RFUNUP,RFUNDN,POLYNL)
C           
C=======================================================================
C     Calculating the root-mean-square radius, no pairing case         
C=======================================================================
C           
      RUPAUX=0.
      RDNAUX=0.
      ICUMUL=0
C           
      DO I=1,LDSPEC  !  Do-loop over the spherically-degenerate states
C
         LQNUMB=LWSSPH(I)
         NNUMBR=NWSSPH(I)
         JNUMBR=JWSSPH(I)
C
         JNUMUP=LQNUMB+LQNUMB+1
         JNUMDN=LQNUMB+LQNUMB-1
C
C        LABORD contains the information about the nuclear s.p. levels
C        that should be taken into account in no-pairing case. Even if
C        the levels cross at variance with experiment the right states
C        will be taken  for the summations of the radius contributions 
C
         IF (LABORD(NNUMBR,LQNUMB,JNUMBR).EQ.1) THEN
C
             ICUMUL=ICUMUL+(JWSSPH(I)+1) ! Formally number of particles
C                                          on occupied WS states with (2j+1) dgs
C
C            Below we Gauss-integrate the expectation value of r^2
C                     one WS single-particle state after the other
	            UPPAUX=0.
	            DWNAUX=0.
	 
	            DO I_PNTS=1,NGAUSS
C
                IF (JWSSPH(I).EQ.JNUMUP) THEN 
C
                    UPPAUX=UPPAUX+(RFUNUP(I_PNTS,NNUMBR,LQNUMB)
     *                            *RNODES(I_PNTS,LQNUMB))**2
     *                            *RWEIGH(I_PNTS,LQNUMB)
                ELSE
                    UPPAUX=0.		  
                END IF
C
                IF (JWSSPH(I).EQ.JNUMDN) THEN
C
                    DWNAUX=DWNAUX+(RFUNDN(I_PNTS,NNUMBR,LQNUMB)
     *                            *RNODES(I_PNTS,LQNUMB))**2
     *                            *RWEIGH(I_PNTS,LQNUMB)
                ELSE
                    DWNAUX=0.  
                END IF
C 
             END DO
C
             RUPAUX=RUPAUX+UPPAUX*(LQNUMB+1)
             RDNAUX=RDNAUX+DWNAUX*LQNUMB
C
         END IF
C
      END DO
C
      IF (ICUMUL.NE.N_PART) THEN
C
          WRITE(0,'(/,''No-pairing, cumulative sum must give N_PART='',
     *                                             i3,'' ICUMUL='',i3)')
     *                                             N_PART,ICUMUL
          IF (ISOSPI.EQ.1) THEN
              STOP 'Ballaggane with the radius for protons  in NUCRAD'
          ELSE
              STOP 'Ballaggane with the radius for neutrons in NUCRAD'
          END IF 
C
      END IF
C  
      RADIUS=RUPAUX+RDNAUX  
      RMSRAA=SQRT((RADIUS*FACTOR/N_PART))
      RNOPAI=RMSRAA
C  
      RMSTHE=RMSRAA
C           
C=======================================================================
C
      IF (IF_PAI.EQ.0) THEN
          IF (LOGWRI.GT.5) THEN
              WRITE(LOGFIL,'(15X,''Exiting  NUCRAD, no pairing option''
     *                                                              )')
          END IF 
          RETURN
      END IF           
C           
C=======================================================================
C=======================================================================
C     Calculating the  rms  radius within the BCS pairing      
C=======================================================================
C=======================================================================
C
C     In the case of monopole pairing we take into account 
C     the following two possibilities:
C
C     a. The usual BCS system of 2 equations with given G
C
      IF (IFGPAI.EQ.1) THEN
          CALL PAIRIN(ENERUP,ENERDN,NSHELL,NGAUSS,ENEMAX,
     *                       VCOEUP,VCOEDN,NDIM_L,NDBASE)
      END IF
C
C     b. Calculating at empirical Delta -> finding Lambda
C
      IF (IFDPAI.EQ.1) THEN
          CALL PAIDEL(ENERUP,ENERDN,NSHELL,ENEMAX,
     *                VCOEUP,VCOEDN,NDIM_L,NDBASE,INUCLI)
      END IF
C
C     c. Solving particle number and Delta^(3) equations
C
      IFDEL3=1
      IFDEL3=0
C
      IF (IFDEL3.EQ.1) THEN
C
          CALL PAIDL3(ENERUP,ENERDN,NSHELL,NGAUSS,ENEMAX,
     *                       VCOEUP,VCOEDN,NDIM_L,NDBASE)
      END IF
C           
C=======================================================================
C     The above calls provide the occupation coefficients 
C     calculated  using two alternative approaches;  what
C     we do below,  is independent of the algorithm above        
C=======================================================================
C
      ICUMUL=0
      ACUMUL=0.
      RUPAUX=0.
      RDNAUX=0.
C
      DO I=1,LDSPEC ! The do-loop over the spher.-degenerate states
C
         IF (ENETHE(I).GT.ENEMAX) GO TO 1
C
         LQNUMB=LWSSPH(I)
       	 NNUMBR=NWSSPH(I)
	        JNUMBR=JWSSPH(I)
C
         JNUMUP=LQNUMB+LQNUMB+1
	        JNUMDN=LQNUMB+LQNUMB-1
C
         ICUMUL=ICUMUL+(JWSSPH(I)+1) ! Formally the number of particles
C                                      on all WS states with (2j+1) dgs
         IF (JWSSPH(I).EQ.JNUMUP) THEN 
             ACUMUL=ACUMUL+(JWSSPH(I)+1)*(VCOEUP(LQNUMB,NNUMBR+1))
         END IF
C
         IF (JWSSPH(I).EQ.JNUMDN) THEN 
             ACUMUL=ACUMUL+(JWSSPH(I)+1)*(VCOEDN(LQNUMB,NNUMBR+1))
         END IF
C
C        Below we Gauss-integrate the expectation value of r^2
C                 one WS single-particle state after the other
	        UPPAUX=0.
	        DWNAUX=0.
	 
	        DO I_PNTS=1,NGAUSS
C
            IF (JWSSPH(I).EQ.JNUMUP) THEN 
C
                UPPAUX=UPPAUX+(RFUNUP(I_PNTS,NNUMBR,LQNUMB)
     *                        *RNODES(I_PNTS,LQNUMB))**2
     *                        *RWEIGH(I_PNTS,LQNUMB)
            ELSE
                UPPAUX=0.		  
            END IF
C
            IF (JWSSPH(I).EQ.JNUMDN) THEN
C
                DWNAUX=DWNAUX+(RFUNDN(I_PNTS,NNUMBR,LQNUMB)
     *                        *RNODES(I_PNTS,LQNUMB))**2
     *                        *RWEIGH(I_PNTS,LQNUMB)
            ELSE
                DWNAUX=0.  
            END IF
C 
         END DO
C   
         UPPAUX=UPPAUX*VCOEUP(LQNUMB,NNUMBR+1)
         DWNAUX=DWNAUX*VCOEDN(LQNUMB,NNUMBR+1)
C
	        RUPAUX=RUPAUX+UPPAUX*(LQNUMB+1)
         RDNAUX=RDNAUX+DWNAUX*LQNUMB
C
   1     CONTINUE
C
      END DO
C  
      RADIUS=RUPAUX+RDNAUX  
      RMSRAA=SQRT((RADIUS*FACTOR/N_PART))
      RPAIRI=RMSRAA
C  
      RMSTHE=RMSRAA
C           
C=======================================================================
C
      IF (ABS(ACUMUL-REAL(N_PART)).GT.EPS_V2) THEN
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,''ACUMUL='',f16.12,'' should be equal '',
     *                         ''to N_PART='',I3,'' with precision '',
     *                         ''EPS_V2='',e10.3)')
     *                           ACUMUL,N_PART,EPS_V2
          END IF
C
      ELSE
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,''ACUMUL='',f16.12,'' compared '',
     *                         ''to N_PART='',I3,'' with precision '',
     *                         ''EPS_V2='',e10.3)')
     *                           ACUMUL,N_PART,EPS_V2
          END IF
C
      END IF
C           
C=======================================================================
C
      IF (LOGWRI.GT.5) THEN
          WRITE(LOGFIL,'(12X,''Exiting  NUCRAD, after pairing option''
     *                                                             )')
      END IF 
C           
C=======================================================================
C
      RETURN
      END
C
C=======================================================================     
C=======================================================================     
C
      SUBROUTINE FUNRAD(CMATUP,CMATDN,NGAUSS,NSHELL,NDIM_L,NDBASE,
     *                         NDGAUS,NDIM_N,RFUNUP,RFUNDN,POLYNL)
C      
      DIMENSION
     *          CMATUP(0:NDIM_L,1:NDBASE,1:NDBASE),
     *          CMATDN(0:NDIM_L,1:NDBASE,1:NDBASE)
      DIMENSION     
     *          POLYNL(1:NDGAUS,0:NDIM_N,0:NDIM_L)
      DIMENSION
     *          RFUNUP(1:NDGAUS,0:NDIM_N,0:NDIM_L),
     *          RFUNDN(1:NDGAUS,0:NDIM_N,0:NDIM_L)
C
C=======================================================================     
C     This subroutine calculates the spatial representation of the
C     radial wave-functions, solutions to the WS problem, at Gauss
C     nodes - the same that have been used for the matrix-elements
C=======================================================================     
C
      DO I_PNTS=1,NGAUSS
      
         DO LQNUMB=NSHELL,0,-1
C
            NBBASE=(NSHELL-LQNUMB)/2
C
            DO NNUMBR=0,NBBASE
C 
               AUXUPP=0. ! Below: NNUMBR+1 denumerates eigenvectors
               AUXDWN=0. ! while  N1NUMB+1 its expansion components
C
               DO N1NUMB=0,NBBASE
	       
                  AUXUPP=AUXUPP+POLYNL(I_PNTS,N1NUMB,LQNUMB)
     *                         *CMATUP(LQNUMB,N1NUMB+1,NNUMBR+1)
C     
                  AUXDWN=AUXDWN+POLYNL(I_PNTS,N1NUMB,LQNUMB)
     *                         *CMATDN(LQNUMB,N1NUMB+1,NNUMBR+1)

     	       END DO
C
	           RFUNUP(I_PNTS,NNUMBR,LQNUMB)=AUXUPP ! Spatial represent.
	           RFUNDN(I_PNTS,NNUMBR,LQNUMB)=AUXDWN ! for up's & down's
C	       
            END DO
         END DO

      END DO
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C 
C FILE NAME = wspher08_diamat_15.f ! Keep this symbol:    $ident@string$
C       
C=======================================================================
C=======================================================================
C                SYMMETRIC MATRIX DIAGONALISATION PACKAGE     
C=======================================================================
C=======================================================================
C
      SUBROUTINE DIAMAT(HAMILT,SPENER,AUXVEC,NDBASE,LDBASE,EIGVEC)
C
      LOGICAL
     *          ISFULL,EIGVEC
C
      DIMENSION
     *          HAMILT(1:NDBASE,1:NDBASE)
      DIMENSION
     *          SPENER(1:NDBASE),
     *          AUXVEC(1:NDBASE)
      COMMON
     *       /CNTCNT/ ICOUNT_DENGRD,ICOUNT_FUNMIN,ICOUNT_HAMMAT,
     *                ICOUNT_EXPTHE,ICOUNT_CHOICE,ICOUNT_DIAMAT
C
C=======================================================================
C
C     This routine diagonalises a real symmetric LDBASExLDBASE matrix 
C
C     EIGVEC => To be set .FALSE.  if  wave functions  are not needed
C     AUXVEC => Auxiliary vector,  its starting values are irrelevant
C     SPENER => At output the eigen-values, on the entry - irrelevant
C
C     HAMILT => The matrix to diagonalize -> must be symmetric though
C
C     NDBASE => The maximum dimension of matrices to be diagonalised
C     LDBASE => The actual  dimension  of the basis  for  our problem
C
C=======================================================================
C
      CALL CPUTIM('DIAMAT',1)
      ICOUNT_DIAMAT=ICOUNT_DIAMAT+1
C      
      ISFULL=.TRUE.
C
      CALL DIAGON(HAMILT,LDBASE,NDBASE,SPENER,AUXVEC,EIGVEC,ISFULL)
C      
      CALL CPUTIM('DIAMAT',0)
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DIAGON(A,N,NP,D,E,EIGVEC,ISFULL)
C
C     This routine diagonalises a REAL and SYMMETRIC matrix; based
C     on "Numerical Recipies"
C
C_______________________________________________________________________
C_______________________________________________________________________
C
C                 TO BE COMPILED IN AUTODOUBLE MODE !!!!
C                 TO BE COMPILED IN AUTODOUBLE MODE !!!!
C                 TO BE COMPILED IN AUTODOUBLE MODE !!!!
C_______________________________________________________________________
C_______________________________________________________________________
C
C
C        Parameters of the routine:
C
C           A  - NxN matrix, declared as NPxNP in the caller
C           N  - integer: actual dimension of A
C           NP - integer: physical dimension of A declared in the caller
C           D  - vector of dimension at least N
C           E  - vector of dimension at least N
C           EIGVEC  - logical
C           ISFULL  - logical
C
C
C                The routine  can perform  two tasks:
C                ------------------------------------
C
C    1.) ISFULL = .TRUE. (i.e., matrix A is full,  n o t  tridiagonal)
C
C        Finds  eigenvalues  and (optionally)  eigenvectors of a real,
C        symmetric, NxN matrix  declared  as NPxNP  matrix in calling
C        program.  D on output will  contain eigenvalues in ascending
C        order. On input the contents od D and E is irrelevant.
C        Then:
C
C           If EIGVEC is .FALSE., eigenvectors will not be calculated
C           (but matrix A will be changed anyway).
C
C           If EIGVEC is  .TRUE., the normalised  eigenvector corres-
C           ponding to eigenvalue D(K) will sit in A(I,K), I = 1, N.
C
C           Vector E provides working space; it is irrelevant on both
C           input and output.
C
C        In this case the routine will call "TRES2"
C
C    2.) ISFULL = .FALSE. (i.e., matrix A is already tridiagonal)
C
C        Finds  eigenvalues  and (optionally)  eigenvectors of a real,
C        symmetric, tridiagonal, NxN matrix declared as NPxNP  matrix
C        in calling program. D on output will  contain eigenvalues in
C        ascending order.  On input D  contains  diagonal elements of
C        the matrix  to be diagonalised,  while vector E(I), I = 2, N
C        contains its subdiagonal elements - E(1) is irrelevant.
C        Values in matrix A are also irrelevant on input in this case.
C        On output D and A will have the same meaning as in case 1.
C        The vector E will be changed, but its contents is irrelevant
C        on output.
C
C_______________________________________________________________________
C
C        THE ROUTINE USES "PYTHAG" AND "TRES2" (INCLUDED BELOW)
C_______________________________________________________________________
C
C        BASED ON  "NUMERICAL  RECIPES"
C                                                  T.R. Werner, May 1991
C                                           Last modified: November 1993
C_______________________________________________________________________
C
      PARAMETER 
     *         (NDITER=100,ONEONE=1.0)
C
      DIMENSION  
     *          A(NP,N),D(N),E(N)
C
      LOGICAL    
     *          NONLY,EIGVEC,ISFULL
C
C=======================================================================
C
C      CALL CPUTIM('DIAGON',1)
C
C=======================================================================
C
      IF (N.GT.NP.OR.N.LT.1) STOP 'Incorrrect matrix size in DIAGON'
C
C=======================================================================
C
      IF (N.EQ.1) THEN
          D(1)=A(1,1)
          A(1,1)=1
          RETURN
      END IF
C
C=======================================================================
C
      IF (EIGVEC) THEN
C
          NONLY=.TRUE.
C
          IF (.NOT.ISFULL) THEN
              DO J=1,N
                 DO I=1,N
                    A(I,J)=0
                 END DO
                 A(J,J)=1
              END DO
          ELSE
              CALL TRES2(A,N,NP,D,E,NONLY)
          END IF
C
      ELSE
                                           NONLY=.FALSE.
         IF (ISFULL) CALL TRES2(A,N,NP,D,E,NONLY)
C
      END IF
C
      DO I=2,N
         E(I-1)=E(I)
      END DO
C
      E(N)=0
C
      DO 4 L=1,N
         ITER=0
    1    DO M=L,N-1
            DD=ABS(D(M))+ABS(D(M+1))
            IF (ABS(E(M))+DD.EQ.DD) GO TO 2
         END DO
         M=N
C
    2    IF (M.NE.L) THEN
C
            IF (ITER.EQ.NDITER) THEN
               PRINT '(''No convergence in DIAGON. ITER='',I3)',
     *                                                    ITER
               STOP 'No convergence in DIAGON'
            END IF
C
            ITER=ITER+1
            G=(D(L+1)-D(L))/(2*E(L))
            R=PYTHAG(G,ONEONE)
            G=D(M)-D(L)+E(L)/(G+SIGN(R,G))
            S=1
            C=1
            P=0
C
            DO 3 I=M-1,L,-1
               F=S*E(I)
               B=C*E(I)
               R=PYTHAG(F,G)
               E(I+1)=R
               IF (R.EQ.0) THEN
                  D(I+1)=D(I+1)-P
                  E(M)=0
                  GO TO 1
               END IF
               S=F/R
               C=G/R
               G=D(I+1)-P
               R=(D(I)-G)*S+2*C*B
               P=S*R
               D(I+1)=G+P
               G=C*R-B
               IF (NONLY) THEN
                  DO  K=1,N
                     F=A(K,I+1)
                     A(K,I+1)=S*A(K,I)+C*F
                     A(K,I)=C*A(K,I)-S*F
                  END DO
               END IF
    3       END DO
C
            D(L)=D(L)-P
            E(L)=G
            E(M)=0
            GO TO 1
         ENDIF
    4 END DO
C
      DO 5 I=1,N-1
         K=I
         P=D(I)
         DO J=I+1,N
            IF (D(J).LT.P) THEN
               K=J
               P=D(J)
            END IF
         END DO
         IF (K.NE.I) THEN
            D(K)=D(I)
            D(I)=P
            DO J=1,N
               P=A(J,I)
               A(J,I)=A(J,K)
               A(J,K)=P
            END DO
         END IF
    5 END DO
C
C=======================================================================
C
C      CALL CPUTIM('DIAGON',0)
C
C=======================================================================
C      
      RETURN
      END
C
C=======================================================================
C
      SUBROUTINE TRES2(A,N,NP,D,E,NONLY)
C
      DIMENSION 
     *          A(NP,N),D(N),E(N)
      LOGICAL   
     *          NONLY
C
      IF (N.GT.NP.OR.N.LT.1) THEN
          STOP 'Incorrect matrix dimension in TRES2'
      ELSE IF (N.EQ.1) THEN
          D(1)=A(1,1)
          E(1)=0
          A(1,1)=1
          RETURN
      END IF
C
      DO 1 I=N,2,-1
         L=I-1
         H=0
         SCALE=0
         IF (L.GT.1) THEN
            DO K=1,L
               SCALE=SCALE+ABS(A(I,K))
            END DO
            IF (SCALE.EQ.0) THEN
               E(I)=A(I,L)
            ELSE
               DO K=1,L
                  A(I,K)=A(I,K)/SCALE
                  H=H+A(I,K)**2
               END DO
               F=A(I,L)
               G=-SIGN(SQRT(H),F)
               E(I)=SCALE*G
               H=H-F*G
               A(I,L)=F-G
               F=0
               DO J=1,L
                  IF (NONLY) A(J,I)=A(I,J)/H
                  G=0
                  DO K=1,J
                     G=G+A(J,K)*A(I,K)
                  END DO
                  IF (L.GT.J) THEN
                     DO K=J+1,L
                        G=G+A(K,J)*A(I,K)
                     END DO
                  ENDIF
                  E(J)=G/H
                  F=F+E(J)*A(I,J)
               END DO
               HH=F/(H+H)
               DO J=1,L
                  F=A(I,J)
                  G=E(J)-HH*F
                  E(J)=G
                  DO K=1,J
                     A(J,K)=A(J,K)-F*E(K)-G*A(I,K)
                  END DO
               END DO
            ENDIF
         ELSE
            E(I)=A(I,L)
         ENDIF
         D(I)=H
    1 END DO
C
      E(1)=0
C
      IF (.NOT.NONLY) THEN
         DO I=1,N
            D(I)=A(I,I)
         END DO
         RETURN
      ELSE
C
         D(1)=0
C
         DO 2 I=1,N
            L=I-1
            IF (D(I).NE.0) THEN
               DO J=1,L
                  G=0
                  DO K=1,L
                     G=G+A(I,K)*A(K,J)
                  END DO
                  DO K=1,L
                     A(K,J)=A(K,J)-G*A(K,I)
                  END DO
               END DO
            ENDIF
            D(I)=A(I,I)
            A(I,I)=1
            IF (L.GE.1) THEN
               DO J=1,L
                  A(I,J)=0
                  A(J,I)=0
               END DO
            END IF
    2    END DO
C
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      FUNCTION PYTHAG(A,B)
C
C     THE ROUTINE CALCULATES SQRT(A**2+B**2) ACCURATELY
C
      ABSA=ABS(A)
      ABSB=ABS(B)
C
      IF (ABSA.GT.ABSB) THEN
          PYTHAG=ABSA*SQRT(1+(ABSB/ABSA)**2)
      ELSE
         IF (ABSB.EQ.0) THEN
             PYTHAG=0
         ELSE
             PYTHAG=ABSB*SQRT(1+(ABSA/ABSB)**2)
         END IF
      END IF
C
      END
C      
C=======================================================================
C=======================================================================
C
C FILE NAME = wspher09_pairin_15.f ! Keep this symbol:    $ident@string$
C      
C=======================================================================
C=======================================================================
C                       PAIRING SUBROUTINE PACKAGE
C=======================================================================
C=======================================================================
C
      SUBROUTINE EQSBCS(BCSLMB,DELTA2,DNOVDL,DNOVDD,DGOVDL,DGOVDD,
     *                                              AN_BCS,AG_BCS)
C
      INCLUDE  'MATDIM/NDSPEC.f'
C
      DIMENSION
     *          NBLOCK(1:NDSPEC)
C
      COMMON
     *         /BCSBCS_RES_WS/ ESINGP(1:NDSPEC)
      COMMON
     *         /BCSBCS_BLCKLV/ NBLOCK
      COMMON
     *         /BCSBCS_LIMPAI/ NOLEVT,INDEXX_MAXSPH
C
C=======================================================================
C
C     This subroutine calculates the rhs of BCS-equations and
C     their derivatives.  It is called  in subroutine  SYSPAI
C
C     Left hand sides are:  The particle number  and 2/G_PAIR
C
C=======================================================================
C
C     BCSLMB - Denotes the pairing BCS - lambda
C
C=======================================================================
C
      DELTA2=MAX(DELTA2,1.0E-9)
C
      AN_BCS=0
      AG_BCS=0
C
      SUMM_0=0
      SUMM_1=0
C
      DO LEVELS=1,NOLEVT
C
         IF (NBLOCK(LEVELS).EQ.1) GO TO 1
C
         ENEDIF=ESINGP(LEVELS)-BCSLMB
         ENER_2=ENEDIF*ENEDIF +DELTA2
C
         ONEOSQ=1/SQRT(ENER_2)
         ONEOE2=ONEOSQ/ENER_2
C
         AN_BCS=AN_BCS-ONEOSQ*ENEDIF+1.0
         AG_BCS=AG_BCS+ONEOSQ
C
         SUMM_0=SUMM_0+ONEOE2
         SUMM_1=SUMM_1+ONEOE2*ENEDIF
C
   1     CONTINUE
C
      END DO
C
      DNOVDL=+SUMM_0*DELTA2
      DNOVDD=+SUMM_1*0.5000
C
      DGOVDL=+SUMM_1
      DGOVDD=-SUMM_0*0.5000
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE EQSBC3(BCSLMB,DELTA2,DNOVDL,DNOVDD,DGOVDL,DGOVDD,
     *                                              AN_BCS,AG_BCS)
C
      INCLUDE  'MATDIM/NDSPEC.f'
C
      DIMENSION
     *          NBLOCK(1:NDSPEC)
C
      COMMON
     *         /BCSBCS_RES_WS/ ESINGP(1:NDSPEC)
      COMMON
     *         /BCSBCS_DELTA3/ DELTA3_INDICT
      COMMON
     *         /BCSBCS_BLCKLV/ NBLOCK
      COMMON
     *         /BCSBCS_LIMPAI/ NOLEVT,INDEXX_MAXSPH
C
C=======================================================================
C
C     This subroutine calculates the rhs  of BCS-LIKE equations and
C     and their derivatives.  It is called  from subroutine  SYSPAI
C
C     Left hand sides are:  The particle number  and  DELTA3_INDICT
C
C=======================================================================
C
C     BCSLMB - Denotes the pairing BCS - lambda
C
C=======================================================================
C
      DELTA2=MAX(DELTA2,1.0E-9)
C
      AN_BCS=0
      AG_BCS=0
C
      SUMM_0=0
      SUMM_1=0
      LEVCNT=0
C
      DO LEVELS=1,NOLEVT
C
         IF (NBLOCK(LEVELS).EQ.1) THEN  ! Only one level must be 
             LEVBLK=LEVELS              !          blocked  here
             LEVCNT=LEVCNT+1
             IF (LEVCNT.GT.1) THEN
                 STOP 'Level count > 1 not allowed here <<= EQSBC3'
             END IF
             GO TO 1
         END IF
C         
         ENEDIF=ESINGP(LEVELS)-BCSLMB
         ENER_2=ENEDIF*ENEDIF +DELTA2   ! Quasiparticle squared
C
         ONEOSQ=1/SQRT(ENER_2)          ! Term  in 2/G equation
         ONEOE2=ONEOSQ/ENER_2           ! 1.0 / quasiparticle^3
C
         AN_BCS=AN_BCS-ONEOSQ*ENEDIF+1.0! sum_k [1-(e-l)/quasip]
C                             Proceeding to calculate derivatives
         SUMM_0=SUMM_0+ONEOE2
         SUMM_1=SUMM_1+ONEOE2*ENEDIF
C
   1     CONTINUE
C
      END DO
C
      ENEDIF=ESINGP(LEVBLK)-BCSLMB
C
      AG_BCS=SQRT(ENEDIF**2+DELTA2)
C
      DNOVDL=SUMM_0*DELTA2
      DNOVDD=SUMM_1*0.5000
C
      DGOVDL=ENEDIF/SQRT(ENEDIF**2+DELTA2) 
C
      DGOVDD=0.5000/SQRT(ENEDIF**2+DELTA2)
      WRITE(66,'(''LEVBLK='',I3,'' NOLEVT='',I3)') LEVBLK,NOLEVT
      WRITE(66,'(''BCSLMB,DELTA2,ENEDIF,='',3F20.12,
     *           '' AG,AN='',2F20.12)') BCSLMB,SQRT(DELTA2),ENEDIF,
     *                                  AG_BCS,AN_BCS
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE SYSPAI(X_INIT,Y_INIT,FFUNCT,GFUNCT,EPS_XY,EPS_FG,
     *                  IERROR,MXITER,ITERAC,DIFF_F,DIFF_G,FNNAME)
C
      PARAMETER
     *         (SHIUPP=1.001,SHIDWN=0.999,DETMIN=1.0E-30)
C
      EXTERNAL
     *          FNNAME
C
      DIMENSION
     *          DXPUSH(0:7),DYPUSH(0:7)
C
C=======================================================================
C
      DATA
     *     DXPUSH /  SHIUPP, SHIUPP, 0.00E0, SHIDWN,
     *               SHIDWN, SHIDWN, 0.00E0, SHIUPP /
      DATA
     *     DYPUSH /  0.00E0, SHIDWN, SHIDWN, SHIDWN,
     *               0.00E0, SHIUPP, SHIUPP, SHIUPP /
C
C=======================================================================
C
C     This subroutine solves system of two non-linear equations of
C     the form:
C                     FN_ACT(XARGUM,YARGUM)=FFUNCT
C                     GN_ACT(XARGUM,YARGUM)=GFUNCT
C
C     using Newton method.
C
C     FFUNCT and GFUNCT are input constants, whereas the functions 
C     FN_ACT and GN_ACT are provided by the external subroutine:
C
C              FNNAME(XARGUM,YARGUM,DFOVDX,DFOVDY,DGOVDX,DGOVDY,
C                                                 FN_ACT,GN_ACT)
C
C     XARGUM - The actual value of the x-argument
C     YARGUM - The actual value of the x-argument
C
C     FN_ACT - The actual value of the f-function
C     GN_ACT - The actual value of the g-function
C
C     X_INIT - on entry => an initial guess for x
C              on exit  => the f i n a l solution
C
C     Y_INIT - on entry => an initial guess for y
C              on exit  => the f i n a l solution
C
C     ITERAC - on exit: if 0 no solution found within the iteration
C                                                             limit
C                       if non zer0 => actual no of iterations used
C
C     MXITER - Maximum number of iterations allowed
C
C     If convergence has not been achieved, ITERAC  is set to 0. In
C     any case  X_INIT and  Y_INIT  contain the best solution found
C     so far, while DIFF_F  and DIFF_G contain  deviation of FN_ACT
C     and GN_ACT from FFUNCT and GFUNCT at this point.  The routine
C     terminates successfully when:
C
C           ABS(FN_ACT-FFUNCT) + ABS(GN_ACT-GFUNCT) .LE. EPS_FG,
C     or
C                  ABS(DELTAX) + ABS(DELTAY) .LE. EPS_XY
C
C=======================================================================
C
      DEVIAT=1.0E+37
      IERROR=0
C
C=======================================================================
C
      DO I=1,MXITER
C
         ITERAC=I
C
         CALL FNNAME(X_INIT,Y_INIT,DFOVDX,DFOVDY,DGOVDX,DGOVDY,
     *                                           FN_ACT,GN_ACT)
C
         F_DIFF=FN_ACT-FFUNCT
         G_DIFF=GN_ACT-GFUNCT
C
         ABSFDI=ABS(F_DIFF)
         ABSGDI=ABS(G_DIFF)
C
         SUMABS=ABSFDI+ABSGDI
C
C=======================================================================
C        Minimising the deviation in terms of functions
C=======================================================================
C
         IF (SUMABS.LT.DEVIAT) THEN
C
             DIFF_F=ABSFDI
             DIFF_G=ABSGDI
             DEVIAT=SUMABS
             X_BEST=X_INIT
             Y_BEST=Y_INIT
C
         END IF
C
C=======================================================================
C        Checking the precision in terms of functions
C=======================================================================
C
         IF (SUMABS.LE.EPS_FG) GO TO 2
C
C=======================================================================
C
         DETERM=DFOVDX*DGOVDY-DFOVDY*DGOVDX
C
C=======================================================================
C        Checking  for possibly vanishing determinant
C=======================================================================
C
         IF (ABS(DETERM).LE.DETMIN) THEN
C
             IAUXIL=MOD(ITERAC-1,8)
C
             X_INIT=DXPUSH(IAUXIL)*X_INIT
             Y_INIT=DYPUSH(IAUXIL)*Y_INIT
C
             GO TO 1
C
         END IF
C
C=======================================================================
C
         DELTAX=(F_DIFF*DGOVDY-G_DIFF*DFOVDY)/DETERM
         DELTAY=(G_DIFF*DFOVDX-F_DIFF*DGOVDX)/DETERM
C
C=======================================================================
C        Checking the precision in arguments (increments small enough?)
C=======================================================================
C
         IF (ABS(DELTAX)+ABS(DELTAY).LE.EPS_XY) GO TO 2
C
C=======================================================================
C        Correct the running arguments XARGUM and YARGUM and proceed
C=======================================================================
C
         X_INIT=X_INIT-DELTAX
         Y_INIT=Y_INIT-DELTAY
C
   1     CONTINUE
C
      END DO
C
C=======================================================================
C
      IERROR=1
      RETURN
C
C=======================================================================
C
   2  CONTINUE
C
      X_INIT=X_BEST
      Y_INIT=Y_BEST
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE PAIRIN(ENERUP,ENERDN,NSHELL,NGAUSS,ENEMAX,
     *                         VCOEUP,VCOEDN,NDIM_L,NDBASE)
C
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDIM_N.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDGAUS.f'
C
      EXTERNAL
     *          EQSBCS
C
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
C
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *      	      LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *      	      ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /DEGENE/ IDGLEV_PROTON(1:NDSPEC),
     *                ICUMUL_PROTON(0:NDSPEC),
     *                IDGLEV_NEUTRS(1:NDSPEC),
     *                ICUMUL_NEUTRS(0:NDSPEC)
C
      COMMON
     *       /BCSBCS_ENETHE/ ENETHE(1:NDSPEC)
     *       /BCSBCS_IDGLEV/ IDGLEV(1:NDSPEC)
      COMMON
     *       /BCSBCS_BLCKLV/ NBLOCK(1:NDSPEC)
      COMMON
     *       /BCSBCS_RES_WS/ ESINGP(1:NDSPEC)
      COMMON
     *       /BCSBCS_LIMPAI/ NOLEVT,INDEXX_MAXSPH
C
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI    
      COMMON
     *       /BCSVAL/ XLAMBD,DELTA2
C
      DATA
     *        EPS_XY / 5.0E-9 /,
     *        EPS_FG / 5.0E-9 /,
     *        EPSILO / 5.0E-8 /
      DATA
     *        MXITER /  100 /
C
C=======================================================================     
C     This subroutine calculates the BCS pairing Delta and Lambda
C     parameters as well as the pairing v2 occupation coefficients
C     assuming the G-pairing strength known
C=======================================================================
C
      IF (ISOSPI.EQ.1) THEN
C
          N_PART=IZ_FIX
          LDSING=LDSING_PROTON      
C                     LDSING = The number of degenerate 
          DO INDEXX=1,LDSING ! spherical  proton-levels 
	     ENETHE(INDEXX)=ENETHE_PROTON(INDEXX)
             IDGLEV(INDEXX)=IDGLEV_PROTON(INDEXX)
          END DO
C
      END IF
C
      IF (ISOSPI.EQ.0) THEN
C
          N_PART=IN_FIX
          LDSING=LDSING_NEUTRS
C                     LDSING = The number of degenerate 
          DO INDEXX=1,LDSING ! spherical neutron-levels
	     ENETHE(INDEXX)=ENETHE_NEUTRS(INDEXX)
             IDGLEV(INDEXX)=IDGLEV_NEUTRS(INDEXX)
          END DO
C
      END IF
C
C=======================================================================
C
      NOLEVT=0
      INDEKS=1
      EPSENE=1.0E-11
C      
C     We artificially remove the spherical degeneracy in order
C     to use the standard BCS equations-solving routine EQSBCS     
C 
      DO INDEXX=1,LDSING
C
         IF (INDEKS.LE.N_PART) THEN
C
             IDEGEN=IDGLEV(INDEXX)/2
             IDEGE2=IDEGEN/2
C
	     DO I=0,IDEGEN-1
                ESINGP(INDEKS)=ENETHE(INDEXX)+(REAL(I)-IDEGE2)*EPSENE
                INDEKS=INDEKS+1
	     END DO
C
	 END IF 
C
      END DO 
C
      NOLEVT=INDEKS-1
C
      ENEMAX=ESINGP(NOLEVT)+EPSENE ! Energy limit for summations
C
      GACTIV=G_FITT(IN_FIX,IZ_FIX,ISOSPI)
C
      A_MASS=REAL(IZ_FIX+IN_FIX)
C
C=======================================================================
C     Blocking of levels is not taken into account
C=======================================================================
C
      DO LEVELS=1,NDSPEC
         NBLOCK(LEVELS)=0
      END DO
C
C=======================================================================
C     BCS (to start with)
C=======================================================================
C
      DELTA2=(12.0/(SQRT(A_MASS)))**2
C
      XLAMBD=0.5*(ESINGP(N_PART/2)+ESINGP(N_PART/2+1))
C
      TWOVRG=2.0/GACTIV
C
      PARTIC=N_PART
C
C=======================================================================
C     Solving the usual BCS-equations
C=======================================================================
C
      CALL SYSPAI(XLAMBD,DELTA2,PARTIC,TWOVRG,EPS_XY,EPS_FG,
     *            IERROR,MXITER,ITERAC,DIFF_F,DIFF_G,EQSBCS)
C
      IF (IERROR.EQ.1) THEN
          XLAMBD=0.5*(ESINGP(N_PART/2)+ESINGP(N_PART/2+1))
          DELTA2=0.01
      END IF
C
C=======================================================================
C      
      DO LQNUMB=NSHELL,0,-1
C
         DO NNUMBR=0,(NSHELL-LQNUMB)/2
C	
	    EMLAUP=ENERUP(LQNUMB,NNUMBR+1)-XLAMBD
	    EMLADN=ENERDN(LQNUMB,NNUMBR+1)-XLAMBD
C	 
            VCOEUP(LQNUMB,NNUMBR+1)
     *     =
     *	    0.5*(1.-EMLAUP/(SQRT(EMLAUP**2+DELTA2)))
C	 
            IF (LQNUMB.NE.0) THEN
C	 
                VCOEDN(LQNUMB,NNUMBR+1)
     *         =
     *          0.5*(1.-EMLADN/(SQRT(EMLADN**2+DELTA2)))
            ELSE
	        VCOEDN(LQNUMB,NNUMBR+1)=0.0
            END IF
C
         END DO
      END DO     
C
C=======================================================================
C     Testing the v2 coefficients...
C=======================================================================
C
      IF (IERROR.EQ.0) THEN
C
          TESTV2=0.
C
          DO INDEXX=1,NOLEVT
      	     EMLAMB=ESINGP(INDEXX)-XLAMBD	       
             V2COEF=0.5*(1.-EMLAMB/(SQRT(EMLAMB**2+DELTA2)))
	     TESTV2=TESTV2+V2COEF
          END DO
C
          TESTV2=2.*TESTV2
          COMPV2=TESTV2-N_PART
C
          IF (ABS(COMPV2).GT.EPSILO) THEN ! STOP 'V2 coefficients!!!'
              WRITE(0,'(''Test v2='',f30.16)')TESTV2
          END IF
C
      END IF
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE PAIDL3(ENERUP,ENERDN,NSHELL,NGAUSS,ENEMAX,
     *                         VCOEUP,VCOEDN,NDIM_L,NDBASE)
C
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDIM_N.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDGAUS.f'
C
      EXTERNAL
     *          EQSBC3
C
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
C
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *      	      LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *      	      ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /DEGENE/ IDGLEV_PROTON(1:NDSPEC),
     *                ICUMUL_PROTON(0:NDSPEC),
     *                IDGLEV_NEUTRS(1:NDSPEC),
     *                ICUMUL_NEUTRS(0:NDSPEC)
C
      COMMON
     *       /BCSBCS_ENETHE/ ENETHE(1:NDSPEC)
     *       /BCSBCS_IDGLEV/ IDGLEV(1:NDSPEC)
      COMMON
     *       /BCSBCS_BLCKLV/ NBLOCK(1:NDSPEC)
      COMMON
     *       /BCSBCS_RES_WS/ ESINGP(1:NDSPEC)
C
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI    
      COMMON
     *       /BCSBCS_DELTA3/ DELTA3_INDICT
      COMMON
     *       /BCSBCS_LIMPAI/ NOLEVT,INDEXX_MAXSPH
      COMMON
     *       /BCSVAL/ XLAMBD,DELTA2
C
      DATA
     *        EPS_XY / 5.0E-9 /,
     *        EPS_FG / 5.0E-9 /,
     *        EPSILO / 5.0E-8 /
      DATA
     *        MXITER /  100 /
C
C=======================================================================     
C     This subroutine calculates the BCS pairing Delta and Lambda
C     parameters as well as the pairing v2 occupation coefficients
C     assuming the pairing Delta^(3) indicator is known (odd n_o)
C=======================================================================
C
      IZ_FIX=19
      DELTA3_INDICT=3.1
C
      IF (ISOSPI.EQ.1) THEN
C
          N_PART=IZ_FIX
          LDSING=LDSING_PROTON      
C                     LDSING = The number of degenerate 
          DO INDEXX=1,LDSING ! spherical  proton-levels 
	     ENETHE(INDEXX)=ENETHE_PROTON(INDEXX)
             IDGLEV(INDEXX)=IDGLEV_PROTON(INDEXX)
          END DO
C
      END IF
C
      IF (ISOSPI.EQ.0) THEN
C
          N_PART=IN_FIX
          LDSING=LDSING_NEUTRS
C                     LDSING = The number of degenerate 
          DO INDEXX=1,LDSING ! spherical neutron-levels
	     ENETHE(INDEXX)=ENETHE_NEUTRS(INDEXX)
             IDGLEV(INDEXX)=IDGLEV_NEUTRS(INDEXX)
          END DO
C
      END IF
C
C=======================================================================
C
      NOLEVT=0
      INDEKS=1
      EPSENE=1.0E-11
C      
C     We artificially remove the spherical degeneracy in order
C     to use the standard BCS equations-solving routine EQSBCS     
C 
      DO INDEXX=1,LDSING
C
         IF (INDEKS.LE.N_PART) THEN
C
             IDEGEN=IDGLEV(INDEXX)/2
             IDEGE2=IDEGEN/2
C
	     DO I=0,IDEGEN-1
                ESINGP(INDEKS)=ENETHE(INDEXX)+(REAL(I)-IDEGE2)*EPSENE
                INDEKS=INDEKS+1
                WRITE(67,'(I3,'' ESINGP='',F14.8)')INDEKS,ESINGP(INDEKS)
	     END DO
C
	 END IF 
C
      END DO 
C
      NOLEVT=INDEKS-1
      NOLEVT=(N_PART/2)*2
      WRITE(0,'(''N_PART,NOLEVT='',2I3)')N_PART,NOLEVT
      WRITE(66,'(''N_PART,NOLEVT='',2I3)')N_PART,NOLEVT
C
      ENEMAX=ESINGP(NOLEVT)+EPSENE ! Energy limit for summations
C
C=======================================================================
C     Blocking of levels is not taken into account
C=======================================================================
C
      DO LEVELS=1,NDSPEC
         NBLOCK(LEVELS)=0
      END DO
C
      LEVELS=N_PART/2
      NBLOCK(LEVELS)=1
C
C=======================================================================
C     Intitial values for the solutions (to be)
C=======================================================================
C
      DELTA2=DELTA3_INDICT**2
C
      XLAMBD=0.5*(ESINGP(N_PART/2)+ESINGP(N_PART/2+1))
C
      PARTIC=(N_PART/2)*2
C
C=======================================================================
C     Solving the system of Delta^(3) & Particle numbe equations
C=======================================================================
C
      CALL SYSPAI(XLAMBD,DELTA2,PARTIC,DELTA3_INDICT,EPS_XY,EPS_FG,
     *            IERROR,MXITER,ITERAC,DIFF_F,DIFF_G,EQSBC3)
C
      write(0,'(''XLAMBD='',f12.6,'' DELTA2='',f16.12)')
     *   XLAMBD,sqrt(DELTA2)
      IF (IERROR.EQ.1) THEN
          XLAMBD=0.5*(ESINGP(N_PART/2)+ESINGP(N_PART/2+1))
          DELTA2=0.01
      END IF
C
C=======================================================================
C      
      DO LQNUMB=NSHELL,0,-1
C
         DO NNUMBR=0,(NSHELL-LQNUMB)/2
C	
	    EMLAUP=ENERUP(LQNUMB,NNUMBR+1)-XLAMBD
	    EMLADN=ENERDN(LQNUMB,NNUMBR+1)-XLAMBD
C	 
            VCOEUP(LQNUMB,NNUMBR+1)
     *     =
     *	    0.5*(1.-EMLAUP/(SQRT(EMLAUP**2+DELTA2)))
C	 
            IF (LQNUMB.NE.0) THEN
C	 
                VCOEDN(LQNUMB,NNUMBR+1)
     *         =
     *          0.5*(1.-EMLADN/(SQRT(EMLADN**2+DELTA2)))
            ELSE
	        VCOEDN(LQNUMB,NNUMBR+1)=0.0
            END IF
C
         END DO
      END DO     
C
C=======================================================================
C     Testing the v2 coefficients...
C=======================================================================
C
      IF (IERROR.EQ.0) THEN
C
          TESTV2=0.
C
          DO INDEXX=1,NOLEVT
      	     EMLAMB=ESINGP(INDEXX)-XLAMBD	       
             V2COEF=0.5*(1.-EMLAMB/(SQRT(EMLAMB**2+DELTA2)))
	     TESTV2=TESTV2+V2COEF
          END DO
C
          TESTV2=2.*TESTV2
          COMPV2=TESTV2-N_PART
C
          IF (ABS(COMPV2).GT.EPSILO) THEN ! STOP 'V2 coefficients!!!'
              WRITE(0,'(''Test v2='',f30.16)')TESTV2
          END IF
C
      END IF
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE PAIDEL(ENERUP,ENERDN,NSHELL,ENEMAX,
     *                  VCOEUP,VCOEDN,NDIM_L,NDBASE,INUCLI)
C
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDIM_N.f'
      INCLUDE   'MATDIM/NDNUCL.f'
C
      EXTERNAL
     *          ONEBCS
C
      DIMENSION
     *          ENERUP(0:NDIM_L,1:NDBASE),
     *          ENERDN(0:NDIM_L,1:NDBASE)
      DIMENSION
     *          VCOEUP(0:NDIM_L,1:NDBASE),
     *          VCOEDN(0:NDIM_L,1:NDBASE)
C
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *      	      LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *      	      ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /DEGENE/ IDGLEV_PROTON(1:NDSPEC),
     *                ICUMUL_PROTON(0:NDSPEC),
     *                IDGLEV_NEUTRS(1:NDSPEC),
     *                ICUMUL_NEUTRS(0:NDSPEC)
C
      COMMON
     *       /BCSBCS_ENETHE/ ENETHE(1:NDSPEC)
     *       /BCSBCS_IDGLEV/ IDGLEV(1:NDSPEC)
      COMMON
     *       /BCSBCS_BLCKLV/ NBLOCK(1:NDSPEC)
      COMMON
     *       /BCSBCS_RES_WS/ ESINGP(1:NDSPEC)
      COMMON
     *       /BCSBCS_LIMPAI/ NOLEVT,INDEXX_MAXSPH
C
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI    
      COMMON
     *       /BCSVAL/ XLAMBD,DELTA2
      COMMON
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
      COMMON
     *       /STEPBI/ BISTEP
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
C
      DATA
     *        EPSBIS / 1.0E-14 /,
     *        EPSILO / 5.0E-08 /
      DATA
     *        MXITER /  150 /
C
C=======================================================================     
C     This subroutine calculates the BCS pairing Delta and Lambda
C     parameters as well as the paring v2 occupation coefficients
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,''Entering PAIDEL with ISOSPI= '',I1,2X,
     *                     ''IZ_FIX= '',I3,2X,''and IN_FIX= '',I3)')
     *                                  ISOSPI,IZ_FIX,IN_FIX
      END IF
C
C=======================================================================     
C
      IF (ISOSPI.EQ.1) THEN
C
          N_PART=IZ_FIX
          LDSING=LDSING_PROTON      
C                     LDSING = The number of degenerate 
          DO INDEXX=1,LDSING ! spherical  proton-levels 
	     ENETHE(INDEXX)=ENETHE_PROTON(INDEXX)
             IDGLEV(INDEXX)=IDGLEV_PROTON(INDEXX)
          END DO
C
      END IF
C
      IF (ISOSPI.EQ.0) THEN
C
          N_PART=IN_FIX
          LDSING=LDSING_NEUTRS
C                     LDSING = The number of degenerate 
          DO INDEXX=1,LDSING ! spherical neutron-levels
	     ENETHE(INDEXX)=ENETHE_NEUTRS(INDEXX)
             IDGLEV(INDEXX)=IDGLEV_NEUTRS(INDEXX)
          END DO
C
      END IF
C
C=======================================================================
C
      NOLEVT=0
      INDEKS=0
      EPSENE=1.0E-11
C      
C     We artificially remove the spherical degeneracy in order
C     to use particle-number equation  solving  routine ONEBCS  
C
C     IMPORTANT: we are taking the convention to split the le-
C                vels in (2j+1) "new" levels. With this choice
C                the particle equation to solve is N=\sum v^2   
C 
      DO INDEXX=1,LDSING
C
         IF (INDEKS.LE.2*N_PART) THEN
C
             IDEGEN=IDGLEV(INDEXX)   !/2
             IDEGE2=IDEGEN           !/2
C
	     DO I=0,IDEGEN-1
C
                INDEKS=INDEKS+1
                ESINGP(INDEKS)=ENETHE(INDEXX)+(REAL(I)-IDEGE2)*EPSENE
C
                IF (LOGWRI.GE.5) THEN
                    WRITE(LOGFIL,'('' INDEXX= '',I4,'' I= '',I4,
     *                         '' INDEKS= '',I4,'' ENETHE(INDEXX)= '',
     *                            F16.12,'' ESINGP(INDEKS)= '',F16.12)')
     *                            INDEXX,I,INDEKS,ENETHE(INDEXX),
     *                                            ESINGP(INDEKS)
                END IF
C                
	     END DO
C             
             INDEXX_MAXSPH=INDEXX
C
         END IF 
C
      END DO 
C
      NOLEVT=INDEKS
C
      ENEMAX=ESINGP(NOLEVT)+EPSENE ! Energy limit for summations
C      
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,24X,''Before entering BISECT: N_PART= '',I5,
     *                     '' NOLEVT= '',I5,'' ENEMAX= '',F20.9,/)')
     *                        N_PART,NOLEVT,ENEMAX
      END IF
C
C=======================================================================
C     Blocking of levels is not taken into account
C=======================================================================
C
      DO LEVELS=1,NDSPEC
         NBLOCK(LEVELS)=0
      END DO
C
C=======================================================================
C     Preparing empirical Delta's for one BCS equation run
C=======================================================================
C
CID      DELTAP=DELEXP(IZ_FIX,IN_FIX,ISOSPI)
      IF (ISOSPI.EQ.1) DELTA2=DELT_2(INUCLI,1)
      IF (ISOSPI.EQ.0) DELTA2=DELT_2(INUCLI,2)
          
      DELTAP=SQRT(DELTA2)
C
CID      XLAMBD=0.5*(ESINGP(N_PART/2)+ESINGP(N_PART/2+1))
      XLAMBD=0.5*(ESINGP(N_PART)+ESINGP(N_PART+1))
C
      ALIMIT=XLAMBD-BISTEP
      BLIMIT=XLAMBD+BISTEP
C
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(24X,''DELTA2= '',F20.13,'' XLAMBD= '',F20.13)')
     *                                          DELTA2,XLAMBD
          WRITE(LOGFIL,'(24X,''ALIMIT= '',F20.13,'' BLIMIT= '',F20.13)')
     *                                          ALIMIT,BLIMIT
      END IF
C
C=======================================================================
C
C     Defining MXITER from EPSBIS using the mathematical theorem
C
      ABS_AB=ABS(ALIMIT-BLIMIT)
    
      MXITER=NINT(LOG(ABS_AB/EPSBIS)/LOG(2.0))
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,24X,''MXITER= '',I3)')MXITER
      END IF
C
C=======================================================================
C     Solving particle number BCS-equation at fixed Delta
C=======================================================================
C
      CALL BISECT(ALIMIT,BLIMIT,XLAMB1,ONEBCS,EPSBIS,MXITER,
     *                                 BISTEP,IT_ACT,IERBIS)
C
      IF (IERBIS.NE.0) THEN
C
          XLAMBD=0.5*(ESINGP(N_PART)+ESINGP(N_PART+1))
C
          WRITE(LOGFIL,'(''BISECT: IERBIS='',I3,'' MXITER='',I3,
     *              '' IT_ACT= '',i3)')IERBIS,MXITER,IT_ACT
          WRITE(LOGFIL,'(''ALIMIT= '',F20.13,'' BLIMIT= '',F20.13,
     *                   '' XLAMBD= '',F20.13)') ALIMIT,BLIMIT,XLAMBD
     
          ONEBCS_FUNCTN=ONEBCS(XLAMB1)
          
          WRITE(LOGFIL,'(''AFTER BISECT: ONEBCS_FUNCTN= '',F20.13)')
     *                                   ONEBCS_FUNCTN
          
          WRITE(0,'(''BISECT: IERBIS='',I3,'' MXITER='',I3,
     *              '' IT_ACT= '',i3)')IERBIS,MXITER,IT_ACT
          STOP 'STOP from PAIDEL: IERBIS.NE.0 !!'
      ELSE
      
          XLAMBD=XLAMB1
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(/,24X,''ONEBCS Solution: DELTAP= '',f20.13,
     *               '' XLAMBD= '',F20.13,/)')DELTAP,XLAMBD
          END IF
     
          IF (ISOSPI.EQ.1) XLAMBD_PROTON(INUCLI)=XLAMBD
          IF (ISOSPI.EQ.0) XLAMBD_NEUTRS(INUCLI)=XLAMBD
          
      END IF
C
C=======================================================================
C      
      DO LQNUMB=NSHELL,0,-1
C
         DO NNUMBR=0,(NSHELL-LQNUMB)/2
C	
	    EMLAUP=ENERUP(LQNUMB,NNUMBR+1)-XLAMBD
	    EMLADN=ENERDN(LQNUMB,NNUMBR+1)-XLAMBD
C	 
            VCOEUP(LQNUMB,NNUMBR+1)
     *     =
     *	    0.5*(1.-EMLAUP/(SQRT(EMLAUP**2+DELTA2)))
C	 
            IF (LQNUMB.NE.0) THEN
C	 
                VCOEDN(LQNUMB,NNUMBR+1)
     *         =
     *          0.5*(1.-EMLADN/(SQRT(EMLADN**2+DELTA2)))
            ELSE
	        VCOEDN(LQNUMB,NNUMBR+1)=0.0
            END IF
C
         END DO
      END DO     
C
C=======================================================================
C     Testing the v2 coefficients...
C=======================================================================
C
      TESTV2=0.
C
      DO INDEXX=1,NOLEVT
         EMLAMB=ESINGP(INDEXX)-XLAMBD	       
         V2COEF=0.5*(1.-EMLAMB/(SQRT(EMLAMB**2+DELTA2)))
	 TESTV2=TESTV2+V2COEF
      END DO
C
      TESTV2=TESTV2    !*2
      COMPV2=TESTV2-N_PART
C
      IF (ABS(COMPV2).GT.EPSILO) THEN ! 
          WRITE(LOGFIL,'(''Test ONE-EQ v2='',f30.16)')TESTV2
          STOP 'STOP from PAIDEL: V2 coefficients!!!'
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,''Exiting PAIDEL'')')
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      FUNCTION ONEBCS(XLAMBD)
C
      INCLUDE   'MATDIM/NDSPEC.f'
C
      COMMON
     *       /BCSBCS_RES_WS/ ESINGP(1:NDSPEC)
      COMMON
     *       /BCSBCS_LIMPAI/ NOLEVT,INDEXX_MAXSPH
C
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI    
      COMMON
     *       /BCSVAL/ XDUMMY,DELTA2
C
C=======================================================================
C     Preparation for solving the particle-number equation 
C                         N-sum_j v_j^2 = 0
C     for Lambda 
C=======================================================================
C
      PARTEQ=0.
                       N_PART=IZ_FIX
      IF (ISOSPI.EQ.0) N_PART=IN_FIX
C
      DO INDEXX=1,NOLEVT
      	 EMLAMB=ESINGP(INDEXX)-XLAMBD	       
         V2COEF=0.5*(1.-EMLAMB/(SQRT(EMLAMB**2+DELTA2)))
	 PARTEQ=PARTEQ+V2COEF
      END DO
C
      PARTEQ=PARTEQ         !*2
      ONEBCS=PARTEQ-N_PART
C
C=======================================================================     
C
      RETURN
      END      
C
C=======================================================================
C=======================================================================
C
      FUNCTION DELEXP(IZ_FIX,IN_FIX,ISOSPI)
      PARAMETER
     *          (NDDATA=8)
      DIMENSION
     *           I_PROT(1:NDDATA),
     *           I_NEUT(1:NDDATA)
      DIMENSION
     *           DELPRO(1:NDDATA),
     *           DELNEU(1:NDDATA)
C
C=======================================================================
C
C     This function provides the results of the Delta^3 filter 
C     calculations, based on the mass tables of Wapstra et al.
C     For the meaning of this type of filters that approximate
C     the experimental pairing gaps cf.:
C
C     arXiv:nucl-th/0003019 
C
C     Title: Odd-even staggering of binding energies as 
C            a consequence of pairing and mean-field effects
C
C     Authors: J. Dobaczewski, P. Magierski, W. Nazarewicz, 
C              W. Satula, Z. Szymanski
C
C     Journal-ref: Phys.Rev. C63 (2001) 024308
C                                                          AND
C     arXiv:nucl-th/9804060
C
C     Title: Odd-Even Staggering of Nuclear Masses: Pairing or 
C            Shape Effect?
C
C     Authors: W. Satula, J. Dobaczewski, W. Nazarewicz
C     Journal-ref: Phys.Rev.Lett.81:3599-3602,1998
C
C=======================================================================
C
      I_PROT(1)=8      ! 16O
      I_NEUT(1)=8      ! 16O
C
      DELPRO(1)=1.6616 ! Delta in MeV
      DELNEU(1)=1.9505
C
      I_PROT(2)=20     ! 40Ca
      I_NEUT(2)=20     ! 40Ca
C
      DELPRO(2)=1.3415 ! Delta in MeV
      DELNEU(2)=1.5590
C
      I_PROT(3)=20     ! 48Ca
      I_NEUT(3)=28     ! 48Ca
C
      DELPRO(3)=1.2680 ! Delta in MeV
      DELNEU(3)=0.6031
C
      I_PROT(4)=28     ! 56Ni
      I_NEUT(4)=28     ! 56Ni
C
      DELPRO(4)=0.7911 ! Delta in MeV
      DELNEU(4)=0.9859
C
      I_PROT(5)=40     ! 90Zr
      I_NEUT(5)=50     ! 90Zr
C
      DELPRO(5)=1.1537 ! Delta in MeV
      DELNEU(5)=0.7201 
C
      I_PROT(6)=50     ! 132Sn
      I_NEUT(6)=82     ! 132Sn
C
      DELPRO(6)=0.6143 ! Delta in MeV
      DELNEU(6)=0.6614 
C
      I_PROT(7)=64     ! 146Gd
      I_NEUT(7)=82     ! 146Gd      
C
      DELPRO(7)=1.2243 ! Delta in MeV
      DELNEU(7)=0.8215 
C
      I_PROT(8)=82     ! 208Pb
      I_NEUT(8)=126    ! 208Pb      
C
      DELPRO(8)=0.5924 ! Delta in MeV
      DELNEU(8)=0.6244 
C
C=======================================================================
C
      DO I=1,NDDATA
         IF (I_PROT(I).EQ.IZ_FIX.AND.I_NEUT(I).EQ.IN_FIX) THEN
             IF (ISOSPI.EQ.1) DELEXP=DELPRO(I)
             IF (ISOSPI.EQ.0) DELEXP=DELNEU(I)
         END IF
      END DO
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE BISECT(ALIMIT,BLIMIT,XARGUM,FUNBIS,EPSBIS,ITEMAX,
     *                                       BISTEP,IT_ACT,IERBIS)
      EXTERNAL
     *         FUNBIS
      COMMON
     *        /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                 LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                 NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                    LOGBIS
C
C=======================================================================
C
C     BISECTION METHOD FOR THE SOLUTION OF NONLINEAR EQUATIONS
C
C=======================================================================
C
C     ALIMIT = Lower limit for the search interval (input)
C     BLIMIT = Upper limit for the search interval (input)
C
C     XARGUM = On exit ===>>>> the solution of the problem
C
C     EPSBIS = Solution tolerance: if the function studied
C              satisfies F(x)< EPSBIS iterations will stop
C
C     ITEMAX = Maximum number of iterations allowed
C
C     FUNBIS = External function name; this FUNBIS defines
C              the function to be studied
C
C=======================================================================
C
C     IERBIS = Error index; If solution found  IERBIS=0
C
C                           If the function does not 
C                           change sign in the original
C                           interval          IERBIS=10
C
C                           If the number of iterations
C                           exceeded         IERBIS=100
C
C=======================================================================
C
      XA_LIM=ALIMIT
      XB_LIM=BLIMIT
C
      IT_ACT=0
C
C=======================================================================
C
      FA_BIS=FUNBIS(XA_LIM)
C
      FB_BIS=FUNBIS(XB_LIM)
C
C=======================================================================
C
      IF (LOGWRI.GE.5) THEN
C
          WRITE(LOGBIS,'(''Routine Parameters: EPSBIS= '',E10.2,
     *                   '' ITEMAX= '',I4,'' BISTEP= '',F10.4,/)')
     *                                       EPSBIS,ITEMAX,BISTEP
          
          WRITE(LOGBIS,'(''Initial guess: XA_LIM= '',F20.13,
     *                                 '' FA_BIS= '',F20.13,/,14X,
     *                                 '' XB_LIM= '',F20.13,
     *                                 '' FB_BIS= '',F20.13,/)') XA_LIM,
     *                                             FA_BIS,XB_LIM,FB_BIS
      END IF
C
C=======================================================================
C     Verifying whether the solution is not lying on the interval
C                                                          limits
C=======================================================================
C
      IF (LOGWRI.GE.5) THEN
          WRITE(LOGBIS,'(''Verifying whether the solution is not '',
     *                   ''lying on the interval limits...'')')
      END IF
      
      ABS_FA=ABS(FA_BIS)
      XARGUM=ALIMIT
C
      IF (ABS_FA.LT.EPSBIS) THEN
          IERBIS=0
          IF (LOGWRI.GE.5) THEN
              WRITE(LOGBIS,'(''ABS_FA= '',F20.13,'' is less than '',
     *                       ''EPSBIS= '',E10.2,'' ==> IERBIS=0 ==>'',
     *                       '' the solution is XARGUM= '',F20.13,/)')
     *                         ABS_FA,EPSBIS,XARGUM
              WRITE(LOGBIS,'(''RETURN'',/,/,''Exiting BISECT'')')
          END IF
          RETURN
      END IF
C
      ABS_FB=ABS(FB_BIS)
      XARGUM=BLIMIT
C
      IF (ABS_FB.LT.EPSBIS) THEN
          IERBIS=0
          IF (LOGWRI.GE.5) THEN
              WRITE(LOGBIS,'(''ABS_FB= '',F20.13,'' is less than '',
     *                       ''EPSBIS= '',E10.2,'' ==> IERROR=0 ==>'',
     *                       '' the solution is XARGUM= '',F20.13,/)')
     *                         ABS_FB,EPSBIS,XARGUM
              WRITE(LOGBIS,'(''RETURN'',/,/,''Exiting BISECT'')')
          END IF
          RETURN
      END IF
      
      IF (LOGWRI.GE.5) THEN
          WRITE(LOGFIL,'(''No solution in the interval limits. '',
     *                   ''We continue...'',/)')
      END IF
C
C=======================================================================
C         The two IF's below verify whether we are still within
C         the correcct interval (function changes sign) and we
C         constrain the interval 
C=======================================================================
C
      IF (LOGWRI.GE.5) THEN
          WRITE(LOGBIS,'(''Verifying whether we are in the correct '',
     *                   ''interval...'',/)')
      END IF
C      
      IF (FA_BIS*FB_BIS.GT.0.0) THEN
C          
          IF (LOGWRI.GE.5) THEN 
              WRITE(LOGBIS,'(''1st Time: FA_BIS*FB_BIS.GT.0.0'',/)')
          END IF
C
          IF (FB_BIS.GT.0.0) THEN
C
              XB_LIM=XB_LIM-BISTEP
C
              FB_BIS=FUNBIS(XB_LIM)
C
              IF (LOGWRI.GE.5) THEN
                  WRITE(LOGFIL,'(''FB_BIS.GT.0.0: new '',
     *                           ''XB_NEW=XB_OLD-BISTEP= '',F20.13,
     *                           '' FB_BIS= '',F20.13,/)')XB_LIM,FB_BIS
              END IF
C
          ELSE
C
              XB_LIM=XB_LIM+BISTEP
C
              FB_BIS=FUNBIS(XB_LIM)
C              
              IF (LOGWRI.GE.5) THEN
                  WRITE(LOGFIL,'(''FB_BIS.LT.0.0: new '',
     *                           ''XB_NEW=XB_OLD+BISTEP= '',F20.13,
     *                           '' FB_BIS= '',F20.13,/)')XB_LIM,FB_BIS
              END IF
C
          END IF
C
      END IF
C
C=======================================================================
C
      IF (FA_BIS*FB_BIS.GT.0.0) THEN
C
          IF (LOGWRI.GE.5) THEN 
              WRITE(LOGBIS,'(''2nd Time: FA_BIS*FB_BIS.GT.0.0'',/)')
          END IF
C
          IF (FB_BIS.GT.0.0) THEN
C
              XB_LIM=XB_LIM-2.0*BISTEP
C
              FB_BIS=FUNBIS(XB_LIM)
C              
              IF (LOGWRI.GE.5) THEN
                  WRITE(LOGFIL,'(''FB_BIS.GT.0.0: new '',
     *                           ''XB_NEW=XB_OLD-2.0*BISTEP= '',F20.13,
     *                           '' FB_BIS= '',F20.13,/)')XB_LIM,FB_BIS
              END IF
C
          ELSE
C
              XB_LIM=XB_LIM+2.0*BISTEP
C
              FB_BIS=FUNBIS(XB_LIM)
C              
              IF (LOGWRI.GE.5) THEN
                  WRITE(LOGFIL,'(''FB_BIS.GT.0.0: new '',
     *                           ''XB_NEW=XB_OLD+2.0*BISTEP= '',F20.13,
     *                           '' FB_BIS= '',F20.13,/)')XB_LIM,FB_BIS
              END IF
C
          END IF
C
      END IF
C
C=======================================================================
C
      IF (FA_BIS*FB_BIS.GT.0.0) THEN
C
          IERBIS=10
C
          WRITE(NOUTPT,'(/,80(1H=),/,30X,
     *              ''BISECT OUT OF RANGE: '',/,
     *              ''XA_LIM='',E11.4,1X, ''XB_LIM='',E11.4,1X,
     *              '' F(XA_LIM)='',E10.3,'' F(XB_LIM)='',E10.3,/,
     *                                                80(1H=),/)')
     *
     *                                  XA_LIM,XB_LIM,FA_BIS,FB_BIS
          
          IF (LOGWRI.GE.5) THEN
C          
              WRITE(LOGBIS,'(''IERBIS= '',I2)')IERBIS
              WRITE(LOGBIS,'(/,80(1H=),/,30X,
     *              ''BISECT OUT OF RANGE: '',/,
     *              ''XA_LIM='',E11.4,1X, ''XB_LIM='',E11.4,1X,
     *              '' F(XA_LIM)='',E10.3,'' F(XB_LIM)='',E10.3,/,
     *                                                80(1H=),/)')
     *
     *                                  XA_LIM,XB_LIM,FA_BIS,FB_BIS
C              
              WRITE(LOGBIS,'(''RETURN'',/,/,''Exiting BISECT'')')
C          
          END IF
C          
          RETURN
C
C=======================================================================
C
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GE.5) THEN
          WRITE(LOGBIS,'(/,''...everything seems ok, we begin with '',
     *                   ''the real algorithm'',/,/)')
      END IF
C
C=======================================================================
C                   Bisection algorithm begins here ...
C=======================================================================
C
   1  CONTINUE
C
      IT_ACT=IT_ACT+1
C
C      IF (ABS(XB_LIM-XA_LIM).LT.1.0E-14) THEN
C
C          WRITE(NOUTPT,'(1H*,78(1H=),1H*,/,1H*,
C     *              19X,''FURTHER ITERATIONS BELOW 8 BYTE ACCURACY'',
C     *              19X,1H*,/,1H*,78(1H=),1H*)')
C          FX_BIS=0.
C          GO TO  8
C
C      END IF
C
C=======================================================================
C
      XARGUM=0.5*(XA_LIM+XB_LIM)
C
      FX_BIS=FUNBIS(XARGUM)
C
C   8  CONTINUE
C
      ABS_FX=ABS(FX_BIS)
C      
      IF (LOGWRI.GE.5) THEN
          WRITE(LOGBIS,'(''IT_ACT= '',I4,
     *                   '' XA_LIM= '',F20.15,'' XB_LIM= '',F20.15,/)')
     *                                         IT_ACT,XA_LIM,XB_LIM
C          
          WRITE(LOGBIS,'(13X,''ABS_FX= '',F40.35,
     *                           '' XARGUM= '',F40.35,/,
     *                        13X,''EPSBIS= '',F40.35,/)')ABS_FX,
     *                                                    XARGUM,EPSBIS 
      END IF 
C
      IF (ABS_FX.LT.EPSBIS) THEN
          IERBIS=0
          IF (LOGWRI.GE.5) THEN
              WRITE(LOGBIS,'(''ABS_FX= '',F20.15,'' is less than '',/,
     *                       ''EPSBIS= '',F20.15,''  ==> IERBIS=0'')')
     *                         ABS_FX,EPSBIS
              WRITE(LOGBIS,'(/,''===>>> XARGUM= '',F20.15,/)')XARGUM
              WRITE(LOGBIS,'(''RETURN'',/,/,''Exiting BISECT'')')
          END IF
          RETURN
      END IF
C
      IF (IT_ACT.GT.ITEMAX) THEN
          IERBIS=0  !100
          IF (LOGWRI.GE.5) THEN
              WRITE(LOGBIS,'(''IT_ACT= '',I4,'' is bigger than '',
     *                       ''ITEMAX= '',i4,'' ==> IERBIS=100'')')
     *                         IT_ACT,ITEMAX
              WRITE(LOGBIS,'(''RETURN'',/,/,''Exiting BISECT'')')
          END IF
          RETURN
      END IF
C
C=======================================================================
C         Function changes sign in the left subinterval
C=======================================================================
C
      IF (FA_BIS*FX_BIS.LT.0.0) THEN
C
          XB_LIM=XARGUM
          
          IF (LOGWRI.GE.5) THEN
              WRITE(LOGBIS,'(''Function changes sign in the '',
     *                       ''left subinterval: FA_BIS*FX_BIS.LT.0.0'',
     *                       '': new XB_LIM= '',F20.13)') XB_LIM
              WRITE(LOGBIS,'(''...we go to the next iteration...'',/)')
          END IF
C
          GO TO 1
C
      END IF
C
C=======================================================================
C         Function changes sign in the right subinterval
C=======================================================================
C
      IF (FA_BIS*FX_BIS.GT.0.0) THEN
C
          XA_LIM=XARGUM
          
          IF (LOGWRI.GE.5) THEN
              WRITE(LOGBIS,'(''Function changes sign in the '',
     *                       ''left subinterval: FA_BIS*FX_BIS.GT.0.0'',
     *                       '': new XA_LIM= '',F20.13)') XA_LIM
              WRITE(LOGBIS,'(''...we go to the next iteration...'',/)')
          END IF
C
          GO TO 1
C
      END IF      
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      FUNCTION G_FITT(INCALC,IZCALC,ISOSPI)
C
C=======================================================================
C     P A I R I N G    P A R A M E T R I Z A T I O N    (empirical)
C=======================================================================
C
      A_MASS=INCALC+IZCALC
C
      IF (ISOSPI.EQ.0) THEN
C
          IF (IZCALC.GE.88) THEN
C
              G_FITT=(19.3-0.084*(INCALC-IZCALC))/A_MASS
C
          ELSE
C
              G_FITT=(18.95-0.078*(INCALC-IZCALC))/A_MASS
C
          END IF
C
      ELSE
C
          IF (IZCALC.GE.88) THEN
C
              G_FITT=(13.3+0.217*(INCALC-IZCALC))/A_MASS
C
          ELSE
C
              G_FITT=(17.90+0.176*(INCALC-IZCALC))/A_MASS
C
          END IF
C
      END IF
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C     
C FILE NAME = wspher10_jacmat_15.f ! Keep this symbol:    $ident@string$
C
C=======================================================================
C=======================================================================
C             JACOBIAN AND PARTIAL DERIVATIVES FOR MINIMISATION
C=======================================================================
C=======================================================================
C
      SUBROUTINE JMATRX(LDFUNC,ARGPAR)
C      
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDIM_M.f'
      INCLUDE   'MATDIM/NDFUNC.f'
      INCLUDE   'MATDIM/ND_RHO.f'
      INCLUDE   'MATDIM/N_NOYX.f'
C
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          LABPRO_PRINTG*8,LABNEU_PRINTG*8,
     *          LABTOT_PRINTG*8
      CHARACTER
     *          ACTION*1,CALLED*6
      CHARACTER
     *          JOBU*1,JOBVT*1
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6,SYMBNU*5
C
      DIMENSION
     *          ARGPAR(1:NDPARS),DERIVF(1:NDPARS)
      DIMENSION
     *          IDPROT(1:NDIM_M),IDNEUT(1:NDIM_M)
      DIMENSION
     *          DEGENE(1:NDIM_M)
      DIMENSION  
     *                 XJMATR(1:NDIM_M,1:NDPARS),
     *          XJMATR_PROTON(1:NDIM_M,1:NDPARS),
     *          XJMATR_NEUTRS(1:NDIM_M,1:NDPARS)
      DIMENSION  
     *                 CONVER(1:NDPARS,1:NDPARS),
     *                 CONVOL(1:NDPARS,1:NDPARS),
     *                 YJTJMX(1:NDPARS,1:NDPARS),
     *          CONVER_PROTON(1:NDPARS,1:NDPARS),
     *          CONVOL_PROTON(1:NDPARS,1:NDPARS),
     *          YJTJMX_PROTON(1:NDPARS,1:NDPARS),
     *          CONVER_NEUTRS(1:NDPARS,1:NDPARS),
     *          CONVOL_NEUTRS(1:NDPARS,1:NDPARS),
     *          YJTJMX_NEUTRS(1:NDPARS,1:NDPARS),
     *                   TEST(1:NDPARS,1:NDPARS),
     *            TEST_PROTON(1:NDPARS,1:NDPARS),
     *            TEST_NEUTRS(1:NDPARS,1:NDPARS)
      DIMENSION
     *          SINGLE_PROTON(1:NDPARS),
     *          UMATRI_PROTON(1:NDIM_M,1:NDIM_M),
     *          VTMATR_PROTON(1:NDPARS,1:NDPARS),
     *          SINGLE_NEUTRS(1:NDPARS),
     *          UMATRI_NEUTRS(1:NDIM_M,1:NDIM_M),
     *          VTMATR_NEUTRS(1:NDPARS,1:NDPARS),
     *                 SINGLE(1:NDPARS),
     *                 UMATRI(1:NDIM_M,1:NDIM_M),
     *                 VTMATR(1:NDPARS,1:NDPARS)
      DIMENSION  
     *          DERIVV(1:NDPARS,1:NDIM_M)
      DIMENSION
     *          FUNCT0(1:NDIM_M),
     *          FUNCT1(1:NDIM_M),
     *          LEVELS(1:NDIM_M),
     *          LEXPLS(1:NDIM_M),
     *          WEISQR_PROTON(1:NDIM_M),
     *          WEISQR_NEUTRS(1:NDIM_M),
     *          WEISQR(1:NDIM_M),
     *          FUNEXP(1:NDIM_M)
      DIMENSION
     *          PARNEW_PROTON(1:NDPARS),
     *          PARNEW_NEUTRS(1:NDPARS),
     *                 PARNEW(1:NDPARS)
      DIMENSION
     *          LABPRO_PRINTG(1:NDIM_M),LABNEU_PRINTG(1:NDIM_M),
     *          LABTOT_PRINTG(1:NDIM_M)
      DIMENSION
     *          WORK(1:NDSPEC),IPIV(1:NDPARS)
      DIMENSION
     *          CHISQU_GRADNT(1:NDPARS),
     *          FUNAUX(1:NDIM_M)
C     
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS
      COMMON
     *       /NUCWEI/ WEINUC_PROTON(1:NDNUCL),
     *                WEINUC_NEUTRS(1:NDNUCL),
     *                WEIRAD_PROTON(1:NDNUCL),
     *                WEIRAD_NEUTRS(1:NDNUCL)
      COMMON
     *       /WEIGHT/ WEIGHT_CORREL,WEIGHT_RADIUS,WEIGHT_INVERT,
     *                WEIGHT_EFERMI,WEIGHT_ENEGAP,WEIWEI,
     *                WEIGHT_ERRABS,WEIGHT_EABSAV,WEIGHT_ERRMAX,
     *                WEIGHT_DENSUP,WEIGHT_DENSDW,WEIGHT_RHODEN
      COMMON
     *       /BETDAT/ APARAM,BPARAM,PROBAB,FREDEG
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
       COMMON
     *       /THEORF/ FERTHE_PROTON,GAPTHE_PROTON,
     *                DENUPP_PROTON,DENLOW_PROTON,
     *
     *                FERTHE_NEUTRS,GAPTHE_NEUTRS,
     *                DENUPP_NEUTRS,DENLOW_NEUTRS 
      COMMON
     *       /FERGPS/ FERMEX_PROTON(1:NDNUCL),GAPEXP_PROTON(1:NDNUCL),
     *                DENSUP_PROTON(1:NDNUCL),DENSDW_PROTON(1:NDNUCL),
     *
     *                FERMEX_NEUTRS(1:NDNUCL),GAPEXP_NEUTRS(1:NDNUCL),
     *                DENSUP_NEUTRS(1:NDNUCL),DENSDW_NEUTRS(1:NDNUCL) 
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /MESHIN/ I_MESH(1:NDPARS),
     *                XMIN_I(1:NDPARS),
     *                XMAX_I(1:NDPARS),
     *                MAXPAR(1:NDPARS)
      COMMON
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON
     *       /EXPDEN/ LABELN(1:N_NOYX,1:2),
     *                R_MESH(1:ND_RHO,1:N_NOYX),
     *                RHOEXP(1:ND_RHO,1:N_NOYX)
     *
     *       /EXPSYM/ SYMBNU(1:N_NOYX)
      COMMON
     *       /THEDEN/ N_NUCL,I_NUCL(1:N_NOYX),
     *                RHOTHE(1:ND_RHO,1:N_NOYX)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /ACTACT/ ACTION(1:NDPARS)
      COMMON
     *       /CNTROL/ PARAMT(1:NDPARS),
     *                DPARAM(1:NDPARS)     
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /ARGINI/ XINITS(1:NDPARS)
      COMMON
     *       /MINITE/ IDEFCN,ITECHI 
      COMMON
     *       /CHI_PN/ CHISQU_PROTON,CHISQU_NEUTRS
      COMMON
     *       /CHICHO/ VALCHI
      COMMON
     *       /CHIGRD/ CHISQU_GRDNRM,
     *                CHISQU_GRADIE(1:NDPARS)
      COMMON
     *       /DENSTR/ IFDENS
CID      COMMON
CID     *       /SVDSVC/ SVDCUT
      COMMON
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
      DATA    EPSTES /1.0E-7/
C
C=======================================================================
C
C     This subroutine calculates first the JACOBIAN matrix of the form
C
C                           J(k,j)=dF(k)/dp(j) 
C
C     where F denotes all the calculated theoretical quantities  which 
C     are compared with experimental values, mainly sp levels but also 
C     r.m.s. radii and optionally, Fermi level, energy gaps and others 
C     All the parameters which are used for the minimisation are deno-
C     det "p" for short.
C @@@
C     The J matrix gives the covariance matrix (on output --> CONVER):
C
C                            [C]=[J^T J]^(-1)
C
C     The choice of the physical quantities for the Jacobian depends 
C     on the definition of the chi^2 function to be minimised.
C
C=======================================================================
C     
CID      CALL CPUTIM('JMATRX',1)
C
C=======================================================================
C      
      If (ISCREN.GT.0) WRITE(LSCREN,'(''entering JMATRX...'')')
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(12X,''entering JMATRX...'')')
          WRITE(LOGAUX,'(''entering JMATRX...'')')
      END IF
C
C=======================================================================
C
      LDSEAR=0
      IACTIV=0
C      
      DO IPARAM=1,NDPARS
         ACTION(IPARAM)=' '
         IF (IFTAKE(IPARAM).EQ.1) THEN
             IACTIV=IACTIV+1
             PARPOT(IPARAM)=ARGPAR(IACTIV)
         END IF
C
         IF (LOGWRI.GT.4) THEN
             WRITE(LOGFIL,'(20X,I3,F10.4)')IPARAM,PARPOT(IPARAM)
         END IF
C         
         IF (IFMESH.EQ.1) THEN
             IF (I_MESH(IPARAM).EQ.1) THEN
                 PARPOT(IPARAM)=XINITS(IPARAM)
             END IF
         END IF
C
      END DO
C
      LDSEAR=IACTIV
C_______________________________________________________________________
C
C     Initialising auxiliary variables
C      
      DO I_NDEX=1,NDIM_M
         FUNCT0(I_NDEX)=0.
         FUNCT1(I_NDEX)=0.
         LEVELS(I_NDEX)=0
         LEXPLS(I_NDEX)=0
	 WEISQR(I_NDEX)=0.
      END DO
C      
      DO IPARAM=1,NDPARS
         DO INDEXX=1,NDFUNC
            XJMATR(INDEXX,IPARAM)=0.
            XJMATR_PROTON(INDEXX,IPARAM)=0.
            XJMATR_NEUTRS(INDEXX,IPARAM)=0.
         END DO
      END DO
C      
      CHIENE_WEIPRO=0.0
      CHIENE_WEINEU=0.0
      CHIRAD_WEIPRO=0.0
      CHIRAD_WEINEU=0.0
      CHIRHO_WEIPRO=0.0
C      
      ILEVEL=0
      LEVPRO=0
      LEVNEU=0
      
      ILEVEL_PROTON=0
      ILEVEL_NEUTRS=0
       
      INITI1=0
      INITI2=0
      
      I_JMAT=0
      I_JMAT_PROTON=0
      I_JMAT_NEUTRS=0
C
C     The meaning of the variables below:
C
C     CHISQU_PROTON and CHISQU_NEUTRS =>> total chi^2 summed on all
C                                         the components and nuclei
C
      CHISQU_PROTON=0.0 ! As above, for protons
      CHISQU_NEUTRS=0.0 ! As above, for neutrosn
      CHISQU_TOTALS=0.0 ! As above, protons and neutrons togehter
C
C=======================================================================
C
C     First, calculating the total weights (protons and neutrons)
C     that will be used as the normalizing constants of the \chi^2
C
      WEIGHT_PROTON=0.0
      WEIGHT_NEUTRS=0.0
C
      DEGPRO_NOWEIG=0.0
      DEGNEU_NOWEIG=0.0
C
      SUMWEI_PROTON=0.0
      SUMWEI_NEUTRS=0.0
C
      DO INUCLI=1,LDNUCL
         IF (ITAKNU(INUCLI).EQ.1) THEN
C_______________________________________________________________________
C
             IF (IF_SPE.EQ.1) THEN
C
                 DEGSUM_PROTON=0.0
C
                 DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                    DEGAUX=REAL(IDEGEX_PROTON(INUCLI,IEXPER))
                    DEGSUM_PROTON=DEGSUM_PROTON+DEGAUX
                 END DO
C
                 DEGPRO_NOWEIG=DEGPRO_NOWEIG+DEGSUM_PROTON
C
                 WEIGHT_PROTON=WEIGHT_PROTON+DEGSUM_PROTON
     *                                      *WEINUC_PROTON(INUCLI)
C
                 DEGSUM_NEUTRS=0.0
C
                 DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                    DEGAUX=REAL(IDEGEX_NEUTRS(INUCLI,IEXPER))
                    DEGSUM_NEUTRS=DEGSUM_NEUTRS+DEGAUX
                 END DO
C
                 DEGNEU_NOWEIG=DEGNEU_NOWEIG+DEGSUM_NEUTRS
C
                 WEIGHT_NEUTRS=WEIGHT_NEUTRS+DEGSUM_NEUTRS
     *                                      *WEINUC_NEUTRS(INUCLI)
C
             END IF
C_______________________________________________________________________
C
             IF (IF_RAD.EQ.1) THEN
C
                 WEIGHT_PROTON=WEIGHT_PROTON+WEIRAD_PROTON(INUCLI)
                 WEIGHT_NEUTRS=WEIGHT_NEUTRS+WEIRAD_NEUTRS(INUCLI)
C
             END IF
C_______________________________________________________________________
C
             SUMWEI_PROTON=SUMWEI_PROTON+WEINUC_PROTON(INUCLI)
             SUMWEI_NEUTRS=SUMWEI_NEUTRS+WEINUC_NEUTRS(INUCLI)
C
         END IF
      END DO
C
C=======================================================================
C    
      DO INUCLI=1,LDNUCL
         
         IF (ITAKNU(INUCLI).EQ.1) THEN
             
             IZ_FIX=NUMB_Z(INUCLI)
             IN_FIX=NUMB_N(INUCLI)
C
C=======================================================================
C
             IF (LOGWRI.GT.4) THEN
                 WRITE(LOGFIL,'(12X,''Entering WS_RUN from JMATRX '',
     *                              ''[1] IZ_FIX='',I3,
     *                                 '' IN_FIX='',I3)')
     *                                    IZ_FIX,IN_FIX
             END IF
                                                     I_MODE=2
                                                            I_FLAG=1
             CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,I_FLAG,
     *                                 CHISQU_AUXIL1,CHISQU_AUXIL2)      
C
             IF (IDEFCN.GE.ITECHI) THEN
                 WRITE(LSCREN,'(/,''Omitting JMATRX, no-convergence '',
     *                       ''case -> RETURN from JMATRX'',/)')
                 GO TO 100
CID                 RETURN
             END IF
C
C=======================================================================                 
C
C            The following quantities contain ALL \chi^2 contributions 
C            They already contain their corresponding weight factors
C
C            These quantites are the ones printed in the LOGAUX files
C        
             CHISQU_PROTON=CHISQU_PROTON+(CHISQU_AUXIL1/SUMWEI_PROTON)
C
             CHISQU_NEUTRS=CHISQU_NEUTRS+(CHISQU_AUXIL2/SUMWEI_NEUTRS)
C
             CHISQU_TOTALS=CHISQU_TOTALS+(CHISQU_AUXIL1/SUMWEI_PROTON)
     *                                  +(CHISQU_AUXIL2/SUMWEI_NEUTRS)
C_______________________________________________________________________
C
C            These quantites are the ones printed in the LOGAUX files
C
             CHIENE_WEIPRO=CHIENE_WEIPRO+CHIDEG_PROTON
             CHIENE_WEINEU=CHIENE_WEINEU+CHIDEG_NEUTRS
C
             CHIRAD_WEIPRO=CHIRAD_WEIPRO+RADDIF_PROTON
     *                                  *WEIRAD_PROTON(INUCLI)
             CHIRAD_WEINEU=CHIRAD_WEINEU+RADDIF_NEUTRS
     *                                  *WEIRAD_NEUTRS(INUCLI)
C
             CHIRHO_WEIPRO=CHIRHO_WEIPRO+CHIRHO_PROTON*WEIGHT_RHODEN
C
C=======================================================================                 
C            Beginning the IF sequence to choose the selected
C            components of the total chi^2 = chi_1^2 + ch_2^2 + ...  
C=======================================================================                 
C         
             IF (IF_SPE.EQ.1) THEN
C            
                 DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                    DO ITHEOR=1,LEVTHE_PROTON
C                   
                       IF (LABEXP_PROTON(INUCLI,IEXPER).EQ.
     *                     LABTHE_PROTON(ITHEOR)) THEN
C                      
                           ILEVEL=ILEVEL+1
                           LEVPRO=ILEVEL
C                      
                           ILEVEL_PROTON=ILEVEL_PROTON+1
                           IDPROT(ILEVEL_PROTON)=ILEVEL
C                      
                           IF (IEXPER.EQ.1) INITI1=ILEVEL
C                      
                           LEVELS(ILEVEL)=ITHEOR
                           LEXPLS(ILEVEL)=IEXPER
C                      
                           DEGENE(ILEVEL)
     *                    =
     *                     REAL(IDEGEX_PROTON(INUCLI,IEXPER))
C                      
                           FUNCT0(ILEVEL)=ENETHE_PROTON(ITHEOR)
                           FUNEXP(ILEVEL)=EXPEXP_PROTON(INUCLI,IEXPER)
C                      
                           WEISQR(ILEVEL)
     *                    =
     *                     SQRT(DEGENE(ILEVEL)*WEINUC_PROTON(INUCLI)
     *                                        /SUMWEI_PROTON        ) 
                       END IF
C                   
                    END DO
                 END DO
C
                 DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                    DO ITHEOR=1,LEVTHE_NEUTRS
C                   
                       IF (LABEXP_NEUTRS(INUCLI,IEXPER).EQ.
     *                     LABTHE_NEUTRS(ITHEOR)) THEN
C                      
                           ILEVEL=ILEVEL+1
                           LEVNEU=ILEVEL
C                      
                           ILEVEL_NEUTRS=ILEVEL_NEUTRS+1
                           IDNEUT(ILEVEL_NEUTRS)=ILEVEL
C                      
                           IF (IEXPER.EQ.1) INITI2=ILEVEL
C                      
                           LEVELS(ILEVEL)=ITHEOR
                           LEXPLS(ILEVEL)=IEXPER
C                      
                           DEGENE(ILEVEL)
     *                    =
     *                     REAL(IDEGEX_NEUTRS(INUCLI,IEXPER))
C                      
                           FUNCT0(ILEVEL)=ENETHE_NEUTRS(ITHEOR)
                           FUNEXP(ILEVEL)=EXPEXP_NEUTRS(INUCLI,IEXPER)
C                      
                           WEISQR(ILEVEL)
     *                    =
     *                     SQRT(DEGENE(ILEVEL)*WEINUC_NEUTRS(INUCLI)
     *                                        /SUMWEI_NEUTRS        )
C                      
                       END IF
C                   
                    END DO
                 END DO
C            
             END IF ! IF_SPE=1
C         
C=======================================================================
C 
             IF (IF_RAD.EQ.1) THEN
C
                 ILEVEL=ILEVEL+1
C
                 ILEVEL_PROTON=ILEVEL_PROTON+1
                 IDPROT(ILEVEL_PROTON)=ILEVEL
C
                 FUNCT0(ILEVEL)=RMSTHE_PROTON
                 FUNEXP(ILEVEL)=RMSEXP_PROTON(INUCLI)
                 WEISQR(ILEVEL)=SQRT(WEIRAD_PROTON(INUCLI)
     *                         *     WEINUC_PROTON(INUCLI)
     *                         /     SUMWEI_PROTON) 
C
                 ILEVEL=ILEVEL+1
C
                 ILEVEL_NEUTRS=ILEVEL_NEUTRS+1
                 IDNEUT(ILEVEL_NEUTRS)=ILEVEL
C
                 FUNCT0(ILEVEL)=RMSTHE_NEUTRS
                 FUNEXP(ILEVEL)=RMSEXP_NEUTRS(INUCLI)
                 WEISQR(ILEVEL)=SQRT(WEIRAD_NEUTRS(INUCLI)
     *                         *     WEINUC_NEUTRS(INUCLI)
     *                         /     SUMWEI_NEUTRS) 
C
             END IF ! IF_RAD=1
C         
C=======================================================================
C
             IF (IF_GAP.EQ.1) THEN
C
                 ILEVEL=ILEVEL+1
C
                 ILEVEL_PROTON=ILEVEL_PROTON+1
                 IDPROT(ILEVEL_PROTON)=ILEVEL
C
                 FUNCT0(ILEVEL)=GAPTHE_PROTON
                 FUNEXP(ILEVEL)=GAPEXP_PROTON(INUCLI)
                 WEISQR(ILEVEL)=SQRT(WEIGHT_ENEGAP/WEIGHT_PROTON) 
C
                 ILEVEL=ILEVEL+1
C
                 ILEVEL_NEUTRS=ILEVEL_NEUTRS+1
                 IDNEUT(ILEVEL_NEUTRS)=ILEVEL
C
                 FUNCT0(ILEVEL)=GAPTHE_NEUTRS
                 FUNEXP(ILEVEL)=GAPEXP_NEUTRS(INUCLI)
                 WEISQR(ILEVEL)=SQRT(WEIGHT_ENEGAP/WEIGHT_NEUTRS)
C
             END IF ! IF_GAP=1
C         
C=======================================================================
C
             IF (IF_FER.EQ.1) THEN
C
                 ILEVEL=ILEVEL+1
C
                 ILEVEL_PROTON=ILEVEL_PROTON+1
                 IDPROT(ILEVEL_PROTON)=ILEVEL
C
                 FUNCT0(ILEVEL)=FERTHE_PROTON
                 FUNEXP(ILEVEL)=FERMEX_PROTON(INUCLI)
                 WEISQR(ILEVEL)=SQRT(WEIGHT_EFERMI/WEIGHT_PROTON)
C
                 ILEVEL=ILEVEL+1
C
                 ILEVEL_NEUTRS=ILEVEL_NEUTRS+1
                 IDNEUT(ILEVEL_NEUTRS)=ILEVEL
C
                 FUNCT0(ILEVEL)=FERTHE_NEUTRS
                 FUNEXP(ILEVEL)=FERMEX_NEUTRS(INUCLI)
                 WEISQR(ILEVEL)=SQRT(WEIGHT_EFERMI/WEIGHT_NEUTRS)
C
             END IF ! IF_FER=1
C         
C=======================================================================
C
             IF (IF_DEN.EQ.1) THEN
C
                 ILEVEL=ILEVEL+1
C
                 ILEVEL_PROTON=ILEVEL_PROTON+1
                 IDPROT(ILEVEL_PROTON)=ILEVEL
C
                 FUNCT0(ILEVEL)=DENLOW_PROTON
                 FUNEXP(ILEVEL)=DENSDW_PROTON(INUCLI)
                 WEISQR(ILEVEL)=SQRT(WEIGHT_DENSDW/WEIGHT_PROTON)
C
                 ILEVEL=ILEVEL+1
C
                 ILEVEL_PROTON=ILEVEL_PROTON+1
                 IDPROT(ILEVEL_PROTON)=ILEVEL
C
                 FUNCT0(ILEVEL)=DENUPP_PROTON
                 FUNEXP(ILEVEL)=DENSUP_PROTON(INUCLI)
                 WEISQR(ILEVEL)=SQRT(WEIGHT_DENSUP/WEIGHT_PROTON)
C_______________________________________________________________________
C            
                 ILEVEL=ILEVEL+1
C
                 ILEVEL_NEUTRS=ILEVEL_NEUTRS+1
                 IDNEUT(ILEVEL_NEUTRS)=ILEVEL
C
                 FUNCT0(ILEVEL)=DENLOW_NEUTRS
                 FUNEXP(ILEVEL)=DENSDW_NEUTRS(INUCLI)
                 WEISQR(ILEVEL)=SQRT(WEIGHT_DENSDW/WEIGHT_NEUTRS)
C
                 ILEVEL=ILEVEL+1
C
                 ILEVEL_NEUTRS=ILEVEL_NEUTRS+1
                 IDNEUT(ILEVEL_NEUTRS)=ILEVEL
C
                 FUNCT0(ILEVEL)=DENUPP_NEUTRS
                 FUNEXP(ILEVEL)=DENSUP_NEUTRS(INUCLI)
                 WEISQR(ILEVEL)=SQRT(WEIGHT_DENSUP/WEIGHT_NEUTRS)
C
             END IF ! IF_DEN=1  
C         
C=======================================================================
C  @@@ irene - what is this?
             IF (IF_RHO.EQ.1) THEN
*C            
*                CALL RHOTHE_DENSIT(INUCLI,IZ_FIX,IN_FIX)
*C             
*                DO K_NOYX=1,N_NUCL
*C                 
*                   I_NOYX=I_NUCL(K_NOYX)
*C                 
*                   DO ID_RHO=1,ND_RHO
*C                   
*                      ILEVEL=ILEVEL+1
*                      ILEVEL_PROTON=ILEVEL_PROTON+1
*                      IDPROT(ILEVEL_PROTON)=ILEVEL
*C                   
*                      FUNCT0(ILEVEL)=RHOTHE(ID_RHO,I_NOYX)
*                      FUNEXP(ILEVEL)=RHOEXP(ID_RHO,I_NOYX)
*                      WEISQR(ILEVEL)=SQRT(WEIGHT_RHODEN)
*C                   
*                   END DO
*C            
*                END DO 
C             
             END IF ! IF_RHO=1
C         
C=======================================================================
C
             IPARTL=ILEVEL ! partial dimension of FUNCT0 AND FUNEXP
C         
C=======================================================================
C
C            Calculating partial derivatives of the energies and other
C            observables taken into account in the minimisation
C
C=======================================================================
C
             IACTIV=0
             IACPRO=0
             IACNEU=0
C
             DO IPARAM=1,NDPARS
                DERIVF(IPARAM)=0.0
             END DO
C
             IAUXI1=I_JMAT_PROTON
             IAUXI2=IAUXI1
C
             IAUXI3=I_JMAT_NEUTRS
             IAUXI4=IAUXI3
C         
C=======================================================================
C=======================================================================
C            Main DO LOOP over the parameters of the fit    
C=======================================================================
C=======================================================================
C
             DO IPARAM=1,NDPARS
C            
                IF (IFTAKE(IPARAM).EQ.1) THEN
C                
                    IACTIV=IACTIV+1
C                
                    IF (IFPROT.EQ.1) THEN
                        IACPRO=IACPRO+1
                    END IF
C                
                    IF (IFNEUT.EQ.1) THEN
                        IACNEU=IACNEU+1
                    END IF
C                
                    PARPOT(IPARAM)=PARPOT(IPARAM)+DPARAM(IPARAM)
                    ACTION(IPARAM)='*'
C
                    IF (LOGWRI.GT.4) THEN
                        WRITE(LOGFIL,'(12X,''Entering WS_RUN from '',
     *                                     ''JMATRX [2] IPARAM='',I2,
     *                                  1X,''IZ_FIX='',I3,1X,
     *                                     ''IN_FIX='',I3)') IPARAM,
     *                                       IZ_FIX,IN_FIX
                    END IF
                                                            I_MODE=1
                                                            I_FLAG=5
                    CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,
     *                                        I_FLAG,AUXIL1,AUXIL2)
C         
C=======================================================================
C                
                    IF (IF_SPE.EQ.1) THEN
C      
                        DO INDEXX=INITI1,LEVPRO
                        
                           IAUXI1=IAUXI1+1
C                       
                           IWHICH=LEVELS(INDEXX)
C                       
                           FUNCT1(INDEXX)=ENETHE_PROTON(IWHICH)
C                       
                           DERIVF(IACTIV)
     *                    =
     *                     (FUNCT1(INDEXX)-FUNCT0(INDEXX))
     *                                    /DPARAM(IPARAM)
C     
                           IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
C
                               XJMATR_PROTON(IAUXI1,IACPRO)
     *                        =
     *                         DERIVF(IACTIV)*WEISQR(INDEXX)
                               LABPRO_PRINTG(IAUXI1)
     *                        =
     *                         'p '//LABTHE_NEUTRS(IWHICH)
                           END IF
C    
                           IF (IFDENS.EQ.1 .OR. 
     *                        (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                               XJMATR(INDEXX,IACTIV)=DERIVF(IACTIV)
     *                                              *WEISQR(INDEXX)
                               LABTOT_PRINTG(INDEXX)
     *                        =
     *                        'p '//LABTHE_NEUTRS(IWHICH)
                           END IF
C                       
                        END DO ! of INDEXX
C
                        I_JMAT_PROTON=IAUXI1
                        IAUXI1=IAUXI2
C                    
                        DO INDEXX=INITI2,LEVNEU
C
                           IAUXI3=IAUXI3+1
C                       
                           IWHICH=LEVELS(INDEXX)
C                       
                           FUNCT1(INDEXX)=ENETHE_NEUTRS(IWHICH)
C                       
                           DERIVF(IACTIV)
     *                    =
     *                     (FUNCT1(INDEXX)-FUNCT0(INDEXX))
     *                                    /DPARAM(IPARAM)
C     
                           IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
C
                               XJMATR_NEUTRS(IAUXI3,IACNEU)
     *                        =
     *                         DERIVF(IACTIV)*WEISQR(INDEXX)
                               LABNEU_PRINTG(IAUXI3)
     *                        =
     *                         'n '//LABTHE_NEUTRS(IWHICH)
                           END IF
C                       
                           IF (IFDENS.EQ.1 .OR. 
     *                        (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                               XJMATR(INDEXX,IACTIV)=DERIVF(IACTIV)
     *                                             *WEISQR(INDEXX)
                               LABTOT_PRINTG(INDEXX)
     *                        =
     *                         'n '//LABTHE_NEUTRS(IWHICH)
                           END IF
C                       
                        END DO
C
                        I_JMAT_NEUTRS=IAUXI3
                        IAUXI3=IAUXI4
C
                        I_JMAT=LEVNEU
C                    
                    END IF ! IF_SPE=1
C         
C=======================================================================
C
                    IF (IF_RAD.EQ.1) THEN
C                    
                        I_JMAT=I_JMAT+1
                        I_JMAT_PROTON=I_JMAT_PROTON+1
C                    
                        FUNCT1(I_JMAT)=RMSTHE_PROTON
C                    
                        IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
C
                            XJMATR_PROTON(I_JMAT_PROTON,IACPRO)
     *                                         =(FUNCT1(I_JMAT)
     *                                         - FUNCT0(I_JMAT))
     *                                         / DPARAM(IPARAM)
     *                                         * WEISQR(I_JMAT)
                            LABPRO_PRINTG(I_JMAT_PROTON)='p radius'
                        END IF
C                       
                        IF (IFDENS.EQ.1 .OR. 
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                            XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
     *                                           - FUNCT0(I_JMAT))
     *                                           / DPARAM(IPARAM)
     *                                           * WEISQR(I_JMAT)
                            LABTOT_PRINTG(I_JMAT)='p radius'
                        END IF
C_______________________________________________________________________
C                    
                        I_JMAT=I_JMAT+1
                        I_JMAT_NEUTRS=I_JMAT_NEUTRS+1
C
                        FUNCT1(I_JMAT)=RMSTHE_NEUTRS
C
                        IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
C
                            XJMATR_NEUTRS(I_JMAT_NEUTRS,IACNEU)
     *                                         =(FUNCT1(I_JMAT)
     *                                         - FUNCT0(I_JMAT))
     *                                         / DPARAM(IPARAM)
     *                                         * WEISQR(I_JMAT)
                            LABNEU_PRINTG(I_JMAT_NEUTRS)='n radius'
                        END IF
C                       
                        IF (IFDENS.EQ.1 .OR. 
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                            XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
     *                                           - FUNCT0(I_JMAT))
     *                                           / DPARAM(IPARAM)
     *                                           * WEISQR(I_JMAT)
                            LABTOT_PRINTG(I_JMAT)='n radius'
                        END IF
C
                    END IF ! IF_RAD=1
C         
C=======================================================================
C
                    IF (IF_GAP.EQ.1) THEN
C
                        I_JMAT=I_JMAT+1
                        I_JMAT_PROTON=I_JMAT_PROTON+1
C
                        FUNCT1(I_JMAT)=GAPTHE_PROTON
C
                        IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
C
                            XJMATR_PROTON(I_JMAT_PROTON,IACPRO)
     *                                         =(FUNCT1(I_JMAT)
     *                                         - FUNCT0(I_JMAT))
     *                                         / DPARAM(IPARAM)
     *                                         * WEISQR(I_JMAT)
                        END IF
C                       
                        IF (IFDENS.EQ.1 .OR.
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                            XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
     *                                           - FUNCT0(I_JMAT))
     *                                           / DPARAM(IPARAM)
     *                                           * WEISQR(I_JMAT)
                        END IF
C_______________________________________________________________________
C                    
                        I_JMAT=I_JMAT+1
                        I_JMAT_NEUTRS=I_JMAT_NEUTRS+1
C
                        FUNCT1(I_JMAT)=GAPTHE_NEUTRS
C
                        IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
C
                            XJMATR_NEUTRS(I_JMAT_NEUTRS,IACNEU)
     *                                         =(FUNCT1(I_JMAT)
     *                                         - FUNCT0(I_JMAT))
     *                                         / DPARAM(IPARAM)
     *                                         * WEISQR(I_JMAT)
                        END IF
C                       
                        IF (IFDENS.EQ.1 .OR.
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                            XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
     *                                           - FUNCT0(I_JMAT))
     *                                           / DPARAM(IPARAM)
     *                                           * WEISQR(I_JMAT)
                        END IF
C
                    END IF ! IF_GAP=1
C         
C=======================================================================
C
                    IF (IF_FER.EQ.1) THEN
C
                        I_JMAT=I_JMAT+1
                        I_JMAT_PROTON=I_JMAT_PROTON
C
                        FUNCT1(I_JMAT)=FERTHE_PROTON
C
                        IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
C
                            XJMATR_PROTON(I_JMAT_PROTON,IACPRO)
     *                                         =(FUNCT1(I_JMAT)
     *                                         - FUNCT0(I_JMAT))
     *                                         / DPARAM(IPARAM)
     *                                         * WEISQR(I_JMAT)
                        END IF
C                       
                        IF (IFDENS.EQ.1 .OR.
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                            XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
     *                                           - FUNCT0(I_JMAT))
     *                                           / DPARAM(IPARAM)
     *                                           * WEISQR(I_JMAT)
                        END IF
C_______________________________________________________________________
C                    
                        I_JMAT=I_JMAT+1
                        I_JMAT_NEUTRS=I_JMAT_NEUTRS+1
C
                        FUNCT1(I_JMAT)=FERTHE_NEUTRS
C
                        IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
C
                            XJMATR_NEUTRS(I_JMAT_NEUTRS,IACNEU)
     *                                         =(FUNCT1(I_JMAT)
     *                                         - FUNCT0(I_JMAT))
     *                                         / DPARAM(IPARAM)
     *                                         * WEISQR(I_JMAT)
                        END IF
C                       
                        IF (IFDENS.EQ.1 .OR.
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                            XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
     *                                           - FUNCT0(I_JMAT))
     *                                           / DPARAM(IPARAM)
     *                                           * WEISQR(I_JMAT)
                        END IF
C
                    END IF ! IF_FER=1
C
C=======================================================================
C
                    IF (IF_DEN.EQ.1) THEN
C
                        I_JMAT=I_JMAT+1
                        I_JMAT_PROTON=I_JMAT_PROTON
C
                        FUNCT1(I_JMAT)=DENLOW_PROTON
C
                        IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
C
                            XJMATR_PROTON(I_JMAT_PROTON,IACPRO)
     *                                         =(FUNCT1(I_JMAT)
     *                                         - FUNCT0(I_JMAT))
     *                                         / DPARAM(IPARAM)
     *                                         * WEISQR(I_JMAT)
                        END IF
C                       
                        IF (IFDENS.EQ.1 .OR.
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                            XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
     *                                           - FUNCT0(I_JMAT))
     *                                           / DPARAM(IPARAM)
     *                                           * WEISQR(I_JMAT)
                        END IF
C_______________________________________________________________________
C                    
                        I_JMAT=I_JMAT+1
                        I_JMAT_PROTON=I_JMAT_PROTON
C
                        FUNCT1(I_JMAT)=DENUPP_PROTON
C
                        IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
C
                            XJMATR_PROTON(I_JMAT_PROTON,IACPRO)
     *                                         =(FUNCT1(I_JMAT)
     *                                         - FUNCT0(I_JMAT))
     *                                         / DPARAM(IPARAM)
     *                                         * WEISQR(I_JMAT)
                        END IF
C                       
                        IF (IFDENS.EQ.1 .OR.
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                            XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
     *                                           - FUNCT0(I_JMAT))
     *                                           / DPARAM(IPARAM)
     *                                           * WEISQR(I_JMAT)
                        END IF
C_______________________________________________________________________
C
                        I_JMAT=I_JMAT+1
                        I_JMAT_NEUTRS=I_JMAT_NEUTRS+1
C  
                        FUNCT1(I_JMAT)=DENLOW_NEUTRS
C
                        IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
C
                            XJMATR_NEUTRS(I_JMAT_NEUTRS,IACNEU)
     *                                         =(FUNCT1(I_JMAT)
     *                                         - FUNCT0(I_JMAT))
     *                                         / DPARAM(IPARAM)
     *                                         * WEISQR(I_JMAT)
                        END IF
C                       
                        IF (IFDENS.EQ.1 .OR.
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                            XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
     *                                           - FUNCT0(I_JMAT))
     *                                           / DPARAM(IPARAM)
     *                                           * WEISQR(I_JMAT)
                        END IF
C_______________________________________________________________________
C
                        I_JMAT=I_JMAT+1
                        I_JMAT_NEUTRS=I_JMAT_NEUTRS+1
C
                        FUNCT1(I_JMAT)=DENUPP_NEUTRS
C
                        IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
C
                            XJMATR_NEUTRS(I_JMAT_NEUTRS,IACNEU)
     *                                         =(FUNCT1(I_JMAT)
     *                                         - FUNCT0(I_JMAT))
     *                                         / DPARAM(IPARAM)
     *                                         * WEISQR(I_JMAT)
                        END IF
C                       
                        IF (IFDENS.EQ.1 .OR.
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
                            XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
     *                                           - FUNCT0(I_JMAT))
     *                                           / DPARAM(IPARAM)
     *                                           * WEISQR(I_JMAT)
                        END IF
C                
                    END IF ! IF_DEN=1
C         
C=======================================================================
C
C  @@@ IRENE: WHAT DOES THIS MEAN?
                    IF (IF_RHO.EQ.1) THEN
*C            
*                       CALL RHOTHE_DENSIT(INUCLI,IZ_FIX,IN_FIX)
*C             
*                       DO K_NOYX=1,N_NUCL
*C                 
*                          I_NOYX=I_NUCL(K_NOYX)
*C                 
*                          DO ID_RHO=1,ND_RHO
*C                   
*                             I_JMAT=I_JMAT+1
*                             I_JMAT_PROTON=I_JMAT_PROTON+1
                    
*                             FUNCT1(I_JMAT)=RHOTHE(ID_RHO,I_NOYX)
                          
*                             IF (IFDENS.EQ.0 .AND. IPARAM.LE.20) THEN
C
*                                 XJMATR_PROTON(I_JMAT_PROTON,IACPRO)
*     *                                              =(FUNCT1(I_JMAT)
*     *                                              - FUNCT0(I_JMAT))
*     *                                              / DPARAM(IPARAM)
*     *                                              * WEISQR(I_JMAT)
*                             END IF
*C                       
*                             IF (IFDENS.EQ.1) THEN
C
*                                 XJMATR(I_JMAT,IACTIV)=(FUNCT1(I_JMAT)
*     *                                                - FUNCT0(I_JMAT))
*     *                                                / DPARAM(IPARAM)
*     *                                                * WEISQR(I_JMAT)
*                             END IF
*C                   
*                          END DO
*                       END DO
*C                      
                    END IF ! of IF_RHO
C                
C                   IF (IF_INV.EQ.1) THEN
CID                 END IF
C         
C=======================================================================
C                
                    ACTION(IPARAM)=' ' 
                    PARPOT(IPARAM)=PARPOT(IPARAM)-DPARAM(IPARAM)
            
                END IF ! (IFTAKE(IPARAM).EQ.1)
C            
             END DO ! IPARAM
C         
C=======================================================================
C         
             IF (IPARTL.NE.I_JMAT) THEN
                 WRITE(0,'(/,''Alarm in JMATRX: IPARTL= '',I3,
     *                 '' is different from I_JMAT= '',I3,
     *                 '' -> They should be equal!'',/)') IPARTL,I_JMAT
                 STOP 'STOP in JMATRX: IPARTL.NE.I_JMAT'
             END IF
C         
C=======================================================================
C     
         END IF ! Over (ITAKNU(INUCLI).EQ.1)
      
      END DO ! Over INUCLI
C
C=======================================================================
C=======================================================================
C=======================================================================
C      
      LEVNUM=ILEVEL
C      
      ITOTAL=ILEVEL_PROTON+ILEVEL_NEUTRS
C
      VALCHI=CHISQU_TOTALS
C
C=======================================================================
C                       Some 'alarm' prints 
C=======================================================================
C     
      IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
          
          IF (LEVNUM.NE.LDFUNC) THEN
              WRITE(LSCREN,'(/,''Alarm in JMATRX: LEVNUM= '',I3,
     *                 '' is different from LDFUNC= '',I3,
     *                 '' -> They should be equal!'',/)') LEVNUM,LDFUNC
              STOP 'STOP in JMATRX: LEVNUM.NE.LDFUNC'
          END IF
C_______________________________________________________________________
C      
          IF (I_JMAT.NE.LDFUNC) THEN
              WRITE(LSCREN,'(/,''Alarm in JMATRX: I_JMAT= '',I3,
     *                '' is different from LDFUNC= '',I3,
     *                '' -> They should be equal!'',/)') I_JMAT,LDFUNC
              STOP 'STOP in JMATRX: I_JMAT.NE.LDFUNC'
          END IF
C_______________________________________________________________________
C      
          IF (ITOTAL.NE.LDFUNC) THEN
              WRITE(LSCREN,'(/,''Alarm in JMATRX: '',
     *                ''ITOTAL=ILEVEL_PROTON+ILEVEL_NEUTRS= '',
     *                  I3,'' = '',I3,'' + '',I3,
     *                '' is different from LDFUNC= '',I3,
     *                '' -> They should be equal!'',/)') ITOTAL,
     *                                                   ILEVEL_PROTON,
     *                                                   ILEVEL_NEUTRS,
     *                                                          LDFUNC
             STOP 'STOP in JMATRX: ITOTAL.NE.LDFUNC'
          END IF
      
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
C          
          IF (ILEVEL_PROTON.NE.LDFUNC) THEN
              WRITE(LSCREN,'(/,''Alarm in JMATRX: ILEVEL_PROTON= '',I3,
     *                 '' is different from LDFUNC= '',I3,
     *                 '' -> They should be equal!'',/)')ILEVEL_PROTON,
     *                                                          LDFUNC
              STOP 'STOP in JMATRX: ILEVEL_PROTON.NE.LDFUNC'
          END IF
C_______________________________________________________________________
C      
          IF (I_JMAT_PROTON.NE.LDFUNC) THEN
              WRITE(LSCREN,'(/,''Alarm in JMATRX: I_JMAT_PROTON= '',I3,
     *                '' is different from LDFUNC= '',I3,
     *                '' -> They should be equal!'',/)') I_JMAT_PROTON,
     *                                                          LDFUNC
              STOP 'STOP in JMATRX: I_JMAT.NE.LDFUNC'
          END IF
C      
      END IF      
C
C=======================================================================
C      
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
C
          IF (ILEVEL_NEUTRS.NE.LDFUNC) THEN
              WRITE(LSCREN,'(/,''Alarm in JMATRX: ILEVEL_NEUTRS= '',I3,
     *                 '' is different from LDFUNC= '',I3,
     *                 '' -> They should be equal!'',/)')ILEVEL_NEUTRS,
     *                                                          LDFUNC
              STOP 'STOP in JMATRX: ILEVEL_NEUTRS.NE.LDFUNC'
          END IF
C_______________________________________________________________________
C      
          IF (I_JMAT_NEUTRS.NE.LDFUNC) THEN
              WRITE(LSCREN,'(/,''Alarm in JMATRX: I_JMAT_NEUTRS= '',I3,
     *                '' is different from LDFUNC= '',I3,
     *                '' -> They should be equal!'',/)') I_JMAT_NEUTRS,
     *                                                          LDFUNC
              STOP 'STOP in JMATRX: I_JMAT.NE.LDFUNC'
          END IF
C      
      END IF
C
C=======================================================================
C      
                                I_MODE=2
      CALL INPRIN(IDEFCN,IACTIV,I_MODE,CHISQU_PROTON,CHISQU_NEUTRS,
     *                                 CHIENE_WEIPRO,CHIENE_WEINEU,
     *                                 CHIRAD_WEIPRO,CHIRAD_WEINEU,
     *                                               CHIRHO_WEIPRO)  
C
C=======================================================================
C          Calculating the chi^2 gradient
C=======================================================================
C     
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
C 
           CHISQU_GRDNRM=0.0 ! \chi^2 gradient norm
C
           DO INDEXP=1,IACPRO
               CHISQU_GRADNT(INDEXP)=0.0
           END DO
C_______________________________________________________________________
C        
           DO INDEXP=1,IACPRO ! parameters
C        
              DO INDEXF=1,ILEVEL_PROTON ! functions
C
                 ILEVEL=IDPROT(INDEXF)
C            
                 FUNAUX(INDEXF)=(FUNCT0(ILEVEL)-FUNEXP(ILEVEL))
     *                         * WEISQR(ILEVEL)
C
                 CHISQU_GRADNT(INDEXP)=CHISQU_GRADNT(INDEXP)
     *                                +FUNAUX(INDEXF)
     *                                *XJMATR_PROTON(INDEXF,INDEXP)
C
             END DO
C         
             CHISQU_GRADNT(INDEXP)=2*CHISQU_GRADNT(INDEXP)
             CHISQU_GRDNRM=CHISQU_GRDNRM+(CHISQU_GRADNT(INDEXP))**2
C         
          END DO 
C
          CHISQU_GRDNRM=SQRT(CHISQU_GRDNRM)
C
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
C 
           CHISQU_GRDNRM=0.0 ! \chi^2 gradient norm
C
           DO INDEXP=1,IACNEU
               CHISQU_GRADNT(INDEXP)=0.0
           END DO
C________________________________________________________________________
C        
           DO INDEXP=1,IACNEU ! parameters
C        
              DO INDEXF=1,ILEVEL_NEUTRS ! functions
C
                 ILEVEL=IDNEUT(INDEXF)
C            
                 FUNAUX(INDEXF)=(FUNCT0(ILEVEL)-FUNEXP(ILEVEL))
     *                         * WEISQR(ILEVEL)
C
                 CHISQU_GRADNT(INDEXP)=CHISQU_GRADNT(INDEXP)
     *                                +FUNAUX(INDEXF)
     *                                *XJMATR_NEUTRS(INDEXF,INDEXP)
C
             END DO
C         
             CHISQU_GRADNT(INDEXP)=2*CHISQU_GRADNT(INDEXP)
             CHISQU_GRDNRM=CHISQU_GRDNRM+(CHISQU_GRADNT(INDEXP))**2
C         
          END DO 
C
          CHISQU_GRDNRM=SQRT(CHISQU_GRDNRM)
C
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C 
           CHISQU_GRDNRM=0.0 ! \chi^2 gradient norm
C
           DO INDEXP=1,IACTIV
               CHISQU_GRADNT(INDEXP)=0.0
           END DO
C________________________________________________________________________
C        
           DO INDEXP=1,IACTIV ! parameters
C        
              DO INDEXF=1,LDFUNC ! functions
C            
                 FUNAUX(INDEXF)=(FUNCT0(INDEXF)-FUNEXP(INDEXF))
     *                         * WEISQR(INDEXF)
C
                 CHISQU_GRADNT(INDEXP)=CHISQU_GRADNT(INDEXP)
     *                                +FUNAUX(INDEXF)
     *                                *XJMATR(INDEXF,INDEXP)
C
             END DO
C         
             CHISQU_GRADNT(INDEXP)=2*CHISQU_GRADNT(INDEXP)
             CHISQU_GRDNRM=CHISQU_GRDNRM+(CHISQU_GRADNT(INDEXP))**2
C         
          END DO 
C
          CHISQU_GRDNRM=SQRT(CHISQU_GRDNRM)
C
      END IF 
C
C=======================================================================
C     Checking whether we proceed with the estimation of the 
C     confidence intervals for parameters.
C     If number of parameters is greater than number of experimental
C     levels (plus the rms radii) further calculations are pointless
C=======================================================================
C
      IF (IFDENS.EQ.0) THEN
C
          IF (IACPRO.GE.ILEVEL_PROTON) THEN
C
              IF (LOGWRI.GT.0) 
     *           WRITE(IRESUL,'(''The confidence intervals CANNOT be '',
     *                       ''calculated'',/,''NUMBER OF PARAMETERS '',
     *                       ''> NUMBER OF LEVELS --> PROTONS'')')
              WRITE(LSCREN,'(/,''RETURN in JMATRX: '',
     *                  ''The confidence intervals CANNOT be '',
     *                  ''calculated'',/,''NUMBER OF PARAMETERS '',
     *                  ''> NUMBER OF LEVELS --> PROTONS'',/)')
C
               GO TO 100
C              CALL CPUTIM('JMATRX',0)
C              RETURN
          END IF
C
          IF (IACNEU.GE.ILEVEL_NEUTRS) THEN
C
              IF (LOGWRI.GT.0) 
     *           WRITE(IRESUL,'(''The confidence intervals CANNOT be '',
     *                       ''calculated'',/,''NUMBER OF PARAMETERS '',
     *                       ''> NUMBER OF LEVELS --> NEUTRONS'')')
              WRITE(LSCREN,'(/,''RETURN in JMATRX: '',
     *                  ''The confidence intervals CANNOT be '',
     *                  ''calculated'',/,''NUMBER OF PARAMETERS '',
     *                  ''> NUMBER OF LEVELS --> NEUTRS'',/)')
C
               GO TO 100
C              CALL CPUTIM('JMATRX',0)
C              RETURN
          END IF
      ELSE
          IF (IACTIV.GE.LEVNUM) THEN
C
              IF (LOGWRI.GT.0) 
     *           WRITE(IRESUL,'(''The confidence intervals CANNOT be '',
     *                       ''calculated'',/,''NUMBER OF PARAMETERS '',
     *                       ''> NUMBER OF LEVELS'')')
              WRITE(LSCREN,'(/,''RETURN in JMATRX: '',
     *                  ''The confidence intervals CANNOT be '',
     *                  ''calculated'',/,''NUMBER OF PARAMETERS '',
     *                  ''> NUMBER OF LEVELS'',/)')
C
               GO TO 100
C              CALL CPUTIM('JMATRX',0)
C              RETURN
          END IF
      END IF
C
C=======================================================================
C     Calculating the S^2 and the critical t...
C=======================================================================
C
      PROBAB=0.975
C
      IF (IFDENS.EQ.1) THEN
C
          FREDEG=FLOAT(LEVNUM-IACTIV+1) !!!check definition
          SUMSQA=0.
C
          DO INDEXX=1,LEVNUM
             AUXILL=WEISQR(INDEXX)*(FUNCT0(INDEXX)-FUNEXP(INDEXX))
             SUMSQA=SUMSQA+AUXILL*AUXILL
          END DO
C
          SUMSQA=SUMSQA/FREDEG
C
          CALL TCRITC(CRITIC)
C
          DELTAP=SQRT(SUMSQA)*CRITIC!/SQRT(FREDEG)
C
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.0) THEN
C
          FREDEG=FLOAT(ILEVEL_PROTON-IACPRO+1)
          SUMSQA_PROTON=0.
C
          DO INDEXX=1,ILEVEL_PROTON
             INDEX2=IDPROT(INDEXX)
             AUXILL=WEISQR(INDEX2)
     *             *(FUNCT0(INDEX2)-FUNEXP(INDEX2))
             SUMSQA_PROTON=SUMSQA_PROTON+AUXILL*AUXILL
          END DO
C
          SUMSQA_PROTON=SUMSQA_PROTON/FREDEG
C
          CALL TCRITC(CRITIC)
C
          DELTAP_PROTON=SQRT(SUMSQA_PROTON)*CRITIC!/SQRT(FREDEG)
C_______________________________________________________________________
C
          FREDEG=FLOAT(ILEVEL_NEUTRS-IACNEU+1)
          SUMSQA_NEUTRS=0.
C
          DO INDEXX=1,ILEVEL_NEUTRS
             INDEX3=IDNEUT(INDEXX)
             AUXILL=WEISQR(INDEX3)
     *             *(FUNCT0(INDEX3)-FUNEXP(INDEX3))
             SUMSQA_NEUTRS=SUMSQA_NEUTRS+AUXILL*AUXILL
          END DO
C
          SUMSQA_NEUTRS=SUMSQA_NEUTRS/FREDEG
C
          CALL TCRITC(CRITIC)
C
          DELTAP_NEUTRS=SQRT(SUMSQA_NEUTRS)*CRITIC!/SQRT(FREDEG)
C
      END IF
C
C=======================================================================
C
C     Printing the J(k,l) matrix...
C
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(IRESUL,'(/,80(''*''),/,80(''*''),/,''*'',78X,''*'',/,
     *                 ''*   RESULTS OF THE ERROR ANALYSIS'',
     *                 T80,''*'',/,''*'',78X,''*'',/,80(''*''))')
C
          WRITE(IRESUL,'(80(''*''),/,''*'',78X,''*'',/,
     *                 ''*   Jacobian for '',I2,'' active parameters '',
     *                 ''and '',I2,'' proton and/or neutron levels:'',
     *                 T80,''*'',/,''*'',78X,''*'')')IACTIV,LEVNUM-2
      END IF
C
      IF (IFDENS.EQ.0) THEN
C
          IF (IFPROT.EQ.1) THEN
C          
              WRITE(LOGAUX,'(/,''<<JACOBMATRX>>    '',
     *                       <IACPRO>(''Par'',i2.2,4X))')(I,I=1,IACPRO)
C
              DO I_LEVL=1,ILEVEL_PROTON
C                WRITE(111,'(<IACPRO>(F15.8))')
C     *           (XJMATR_PROTON(I_LEVL,I_PARM),I_PARM=1,IACPRO)
                 IF (LOGWRI.GT.4)
     *               WRITE(IRESUL,'(''*'',<IACPRO>(F9.3),T80,''*'')')
     *                 (XJMATR_PROTON(I_LEVL,I_PARM),I_PARM=1,IACPRO)
                 WRITE(LOGAUX,'(4x,''Lev'',i3.3,4x,<IACPRO>(F9.3))')
     *             I_LEVL,
     *            (XJMATR_PROTON(I_LEVL,I_PARM),I_PARM=1,IACPRO)
              END DO
C
              IF (LOGWRI.GT.4)
     *               WRITE(IRESUL,'(''*'',78X,''*'')')
          
          END IF
C
          IF (IFNEUT.EQ.1) THEN
              
              WRITE(LOGAUX,'(/,''<<JACOBMATRX>>    '',
     *                       <IACNEU>(''Par'',i2.2,4X))')(I,I=1,IACNEU)
C
              DO I_LEVL=1,ILEVEL_NEUTRS
C                WRITE(111,'(<IACNEU>(F15.8))')
C     *           (XJMATR_NEUTRS(I_LEVL,I_PARM),I_PARM=1,IACNEU)
                 IF (LOGWRI.GT.4)
     *               WRITE(IRESUL,'(''*'',<IACNEU>(F9.3),T80,''*'')')
     *            (XJMATR_NEUTRS(I_LEVL,I_PARM),I_PARM=1,IACNEU)
                 WRITE(LOGAUX,'(4x,''Lev'',i3.3,4x,<IACNEU>(F9.3))')
     *             I_LEVL,
     *            (XJMATR_NEUTRS(I_LEVL,I_PARM),I_PARM=1,IACNEU)
              END DO
          
          END IF
C
      ELSE ! ( IFDENS.EQ.1 )
      
          WRITE(LOGAUX,'(/,''<<JACOBMATRX>>    '',
     *                       <IACTIV>(''Par'',i2.2,4X))')(I,I=1,IACTIV)
C
          DO I_LEVL=1,LEVNUM
C            WRITE(111,'(<IACTIV>(F15.8))')
C     *           (XJMATR(I_LEVL,I_PARM),I_PARM=1,IACTIV)
             IF (LOGWRI.GT.4)
     *               WRITE(IRESUL,'(''*'',<IACTIV>(F9.3),T80,''*'')')
     *           (XJMATR(I_LEVL,I_PARM),I_PARM=1,IACTIV)
             WRITE(LOGAUX,'(''Lev'',i2.2,1X,a8,<IACTIV>(F9.3))')
     *            I_LEVL,LABTOT_PRINTG(I_LEVL),
     *           (XJMATR(I_LEVL,I_PARM),I_PARM=1,IACTIV)
          END DO
C
      END IF

      IF (LOGWRI.GT.4) WRITE(IRESUL,'(''*'',78X,''*'',/,80(''*''))')
C
C=======================================================================
C     Calculating the inverse covariance matrix (CONVER)
C     [C]^(-1)=[J^T J] --> CONVER(k,l)=\sum_i J(i,k)J(i,l)
C=======================================================================
C
      IF (IFDENS.EQ.0) THEN
C
          IF (IFPROT.EQ.1) THEN
C
          DO I_PARL=1,IACPRO
             DO I_PARK=1,IACPRO
C         
                CONVER_PROTON(I_PARL,I_PARK)=0.
C
                DO I_LEVL=1,ILEVEL_PROTON
C
                   CONVER_PROTON(I_PARL,I_PARK)
     *            =                   
     *             CONVER_PROTON(I_PARL,I_PARK) 
     *            +
     *             XJMATR_PROTON(I_LEVL,I_PARK)
     *            *
     *             XJMATR_PROTON(I_LEVL,I_PARL)
C
               END DO
C
               CONVOL_PROTON(I_PARL,I_PARK)
     *        = 
     *         CONVER_PROTON(I_PARL,I_PARK)
C
            END DO
         END DO
C
         END IF
C  
         IF (IFNEUT.EQ.1) THEN
C
         DO I_PARL=1,IACNEU
            DO I_PARK=1,IACNEU
C         
               CONVER_NEUTRS(I_PARL,I_PARK)=0.
C
               DO I_LEVL=1,ILEVEL_NEUTRS
C
                  CONVER_NEUTRS(I_PARL,I_PARK)=
     *            CONVER_NEUTRS(I_PARL,I_PARK)+
     *            XJMATR_NEUTRS(I_LEVL,I_PARK)*
     *            XJMATR_NEUTRS(I_LEVL,I_PARL)
C
               END DO
C
               CONVOL_NEUTRS(I_PARL,I_PARK)
     *        =
     *         CONVER_NEUTRS(I_PARL,I_PARK)
C
            END DO
         END DO
C
         END IF
C     
C         IF (IFPROT.EQ.0) THEN 
C     
C             DO I_PARL=1,IACPRO
C                WRITE(112,'(25(F15.8))')
C     *               (CONVER_PROTON(I_PARL,I_PARM),I_PARM=1,IACPRO)
C             END DO
C             WRITE(112,'( )')
C         END IF
C     
C         IF (IFNEUT.EQ.0) THEN
C             DO I_PARL=1,IACNEU
C                WRITE(112,'(25(F15.8))')
C     *               (CONVER_NEUTRS(I_PARL,I_PARM),I_PARM=1,IACNEU)
C             END DO
C         END IF
C
C=======================================================================
C        Inverting the CONVER matrix; at the output CONVER stores
C        the covariance matrix
C=======================================================================
C 
C        DGETRF calculates LU decomposition  of the CONVER matrix 
C        for subroutine DGETRI...
C
         IF (IFPROT.EQ.0) GO TO 5
C
         CALL DGETRF(IACPRO,IACPRO,CONVER_PROTON,NDPARS,IPIV,INFOP)
C
C        If INFOP(N) is not equal to 0, the matrix will not be inverted!
C
         IF (INFOP.NE.0) THEN
             IF (LOGWRI.GT.4)
     *           WRITE(IRESUL,'(''* ...in DGETRF... INFOP='',I3,T80,
     *                          ''*'')')INFOP
         END IF
C
         CALL DGETRI(IACPRO,CONVER_PROTON,NDPARS,IPIV,WORK,NDSPEC,INFOP) 
C
         IF (INFOP.NE.0) THEN
             IF (LOGWRI.GT.4)
     *           WRITE(IRESUL,'(''* ...in DGETRF... INFOP='',I3,T80,
     *                          ''*'')')INFOP
         END IF
C
  5      IF (IFNEUT.EQ.0) GO TO 6
C
         CALL DGETRF(IACNEU,IACNEU,CONVER_NEUTRS,NDPARS,IPIV,INFON)
C
         IF (INFON.NE.0) THEN
             IF (LOGWRI.GT.4)
     *           WRITE(IRESUL,'(''* ...in DGETRF... INFON='',I3,T80,
     *                          ''*'')')INFON
         END IF
C
         CALL DGETRI(IACNEU,CONVER_NEUTRS,NDPARS,IPIV,WORK,NDSPEC,INFON) 
C
         IF (INFON.NE.0) THEN
             IF (LOGWRI.GT.4)
     *           WRITE(IRESUL,'(''* ...in DGETRF... INFON='',I3,T80,
     *                          ''*'')')INFON
         END IF
C
  6      CONTINUE
C
C-----------------------------------------------------------------------
C        Printing the covariance matrix...
C-----------------------------------------------------------------------
C
C         IF (IFPROT.EQ.0) THEN 
C             DO I_PARL=1,IACPRO
C                WRITE(112,'(<IACPRO>(F30.8))')
C     *               (CONVER_PROTON(I_PARL,I_PARM),I_PARM=1,IACPRO)
C             END DO
C             WRITE(112,'( )')
C         END IF
C
C         IF (IFNEUT.EQ.0) THEN
C             DO I_PARL=1,IACNEU
C                WRITE(112,'(<IACNEU>(F30.8))')
C     *               (CONVER_NEUTRS(I_PARL,I_PARM),I_PARM=1,IACNEU)
C             END DO
C             WRITE(112,'( )')
C         END IF
C
C-----------------------------------------------------------------------
C        Testing the result...
C-----------------------------------------------------------------------
C
         IERROP=0
	 IERRON=0
C
C        Proton part
C
         IF (IFPROT.EQ.0) GO TO 7
C
         DO L=1,IACPRO
            DO K=1,IACPRO
               TEST_PROTON(L,K)=0.
               DO I=1,IACPRO
                  TEST_PROTON(L,K)=TEST_PROTON(L,K)+
     *                             CONVER_PROTON(L,I)*CONVOL_PROTON(I,K)
               END DO
            END DO
         END DO
C
         DO L=1,IACPRO
            DO K=1,IACPRO
C
               IF (L.NE.K.AND.TEST_PROTON(L,K).GT.EPSTES) THEN
	           IERROP=1
	       END IF
C              
            END DO
C
	    DIFFVAL=TEST_PROTON(L,L)-1.0
C
            IF (DIFFVAL.GT.EPSTES) THEN
	        IERROP=1
	    END IF
C
         END DO
C
C        Neutron part
C
  7      IF (IFNEUT.EQ.0) GO TO 8
C
         DO L=1,IACNEU
            DO K=1,IACNEU
               TEST_NEUTRS(L,K)=0.
               DO I=1,IACTIV
                  TEST_NEUTRS(L,K)=TEST_NEUTRS(L,K)+
     *                             CONVER_NEUTRS(L,I)*CONVOL_NEUTRS(I,K)
               END DO
            END DO
         END DO
C
         DO L=1,IACPRO
            DO K=1,IACPRO
C
               IF (L.NE.K.AND.TEST_NEUTRS(L,K).GT.EPSTES) THEN
	           IERRON=1
	       END IF
C              
            END DO
C
	    DIFFVAL=TEST_NEUTRS(L,L)-1.0
C
            IF (DIFFVAL.GT.EPSTES) THEN
	        IERRON=1
            END IF
C
         END DO
C	 
  8      CONTINUE
C
C        Printing the information about unsuccesful/succesful inversion
C
         IF (LOGWRI.GT.4)
     *       WRITE(IRESUL,'(''*'',78X,''*'',/,
     *                    ''*   Covariance matrix:'',
     *                    T80,''*'',/,''*'',78X,''*'')')
C
         IF (IERROP.EQ.1) THEN
             IF (LOGWRI.GT.4)
     *         WRITE(IRESUL,'(''*   Covariance matrix is incorrectly'',
     *                      '' calculated!!! PROTONS'',T80,''*'')')
         ELSE
             IF (IFPROT.EQ.0) GO TO 9
             DO I_PARL=1,IACPRO
                IF (LOGWRI.GT.4)
     *              WRITE(IRESUL,'(''*'',<IACPRO>(F10.2),T80,''*'')')
     *               (CONVER_PROTON(I_PARL,I_PARM),I_PARM=1,IACPRO)
             END DO
	 END IF
C
  9      CONTINUE
C
         IF (LOGWRI.GT.4) WRITE(IRESUL,'(''*'',78X,''*'')')
C
         IF (IERRON.EQ.1) THEN
             IF (LOGWRI.GT.4)
     *         WRITE(IRESUL,'(''*   Covariance matrix is incorrectly'',
     *                      '' calculated!!! NEUTRONS'',T80,''*'')')
         ELSE
            IF (IFNEUT.EQ.0) GO TO 10
            DO I_PARL=1,IACNEU
               IF (LOGWRI.GT.4)
     *             WRITE(IRESUL,'(''*'',<IACNEU>(F10.2),T80,''*'')')
     *              (CONVER_NEUTRS(I_PARL,I_PARM),I_PARM=1,IACNEU)
            END DO
	 END IF
C
  10     CONTINUE
C
         IF (LOGWRI.GT.4) WRITE(IRESUL,'(''*'',78X,''*'')')
C
         IF (LOGWRI.GT.4) WRITE(IRESUL,'(80(''*''),/,''*'',78X,''*'',/,
     *                ''*   Confidence Intervals for parameters:'',
     *                T80,''*'',/,''*'',78X,''*'')')
C
         IF (IERROP.EQ.0) THEN
C
             IF (IFPROT.EQ.0) GO TO 11
C
             DO I_PARL=1,IACPRO
                IF (LOGWRI.GT.4)
     *              WRITE(IRESUL,'(''*'',F9.2,T80,''*'')')
     *                SQRT(CONVER_PROTON(I_PARL,I_PARL)*DELTAP_PROTON)
             END DO
	 ELSE
	     IF (LOGWRI.GT.4)
     *       WRITE(IRESUL,'(''*  NOT CALCULATED (PROTONS)'',T80,''*'')')
	 END IF
C
  11     CONTINUE
C
         IF (LOGWRI.GT.4) WRITE(IRESUL,'(''*'',78X,''*'')')
C
         IF (IERRON.EQ.0) THEN
            IF (IFNEUT.EQ.0) GO TO 12
            DO I_PARL=1,IACNEU
               IF (LOGWRI.GT.4)
     *             WRITE(IRESUL,'(''*'',F9.2,T80,''*'')')
     *              SQRT(CONVER_NEUTRS(I_PARL,I_PARL)*DELTAP_NEUTRS)
            END DO
	 ELSE
	    IF (LOGWRI.GT.4)
     *          WRITE(IRESUL,'(''*   NOT CALCULATED (NEUTRONS)'',T80,
     *                     ''*'')')
	    
	 END IF
         IF (LOGWRI.GT.4) WRITE(IRESUL,'(''*'',78X,''*'')')
C
  12     CONTINUE
C         
C=======================================================================
C
      ELSE
C
C=======================================================================
C
         DO I_PARL=1,IACTIV
            DO I_PARK=1,IACTIV
C         
               CONVER(I_PARL,I_PARK)=0.
C
               DO I_LEVL=1,LEVNUM
C
                  CONVER(I_PARL,I_PARK) =CONVER(I_PARL,I_PARK)+
     *                                   XJMATR(I_LEVL,I_PARK)*
     *                                   XJMATR(I_LEVL,I_PARL)
C
               END DO
               CONVOL(I_PARL,I_PARK)= CONVER(I_PARL,I_PARK)
            END DO
C
         END DO
C
         WRITE(112,'(''BEFORE GAUSSJ'')')
C
         DO I_PARL=1,IACTIV
            WRITE(112,'(<IACTIV>(F15.8))')
     *           (CONVER(I_PARL,I_PARM),I_PARM=1,IACTIV)
         END DO
C
C-----------------------------------------------------------------------
C        Inverting the CONVER matrix, at the output CONVER stores
C        the covariance matrix
C-----------------------------------------------------------------------
C
         CALL DGETRF(IACTIV,IACTIV,CONVER,NDPARS,IPIV,INFO)
         WRITE(0,*)INFO
C
         IF (INFO.NE.0) THEN
             IF (LOGWRI.GT.4)
     *       WRITE(IRESUL,'(''* ...in DGETRF... INFO='',I3,T80,''*'')')
     *             INFO
         END IF
C
         CALL DGETRI(IACTIV,CONVER,NDPARS,IPIV,WORK,NDSPEC,INFO)
C
         IF (INFO.NE.0) THEN
             IF (LOGWRI.GT.4)
     *       WRITE(IRESUL,'(''* ...in DGETRI... INFO='',I3,T80,''*'')')
     *             INFO
         END IF
         
C
C-----------------------------------------------------------------------
C        Printing the covariance matrix...
C-----------------------------------------------------------------------
C
         WRITE(112,'(''AFTER GAUSSJ'')')
         DO I_PARL=1,IACTIV
            WRITE(112,'(<IACTIV>(F30.8))')
     *           (CONVER(I_PARL,I_PARM),I_PARM=1,IACTIV)
         END DO
C      
C-----------------------------------------------------------------------
C        Testing the result...
C-----------------------------------------------------------------------
C
         I_ERRO=0
         DO L=1,IACTIV
            DO K=1,IACTIV
               TEST(L,K)=0.
               DO I=1,IACTIV
                  TEST(L,K)=TEST(L,K)+CONVER(L,I)*CONVOL(I,K)
               END DO
            END DO
         END DO
C
         DO I_PARL=1,IACTIV
            WRITE(113,'(<IACTIV>(F15.8))')
     *           (TEST(I_PARL,I_PARM),I_PARM=1,IACTIV)
         END DO
      
         DO L=1,IACTIV
            DO K=1,IACTIV
C
               IF (L.NE.K.AND.TEST(L,K).GT.EPSTES) THEN
	           I_ERRO=1
	       END IF
C              
            END DO
	    DIFFVAL=TEST(L,L)-1.0
            IF (DIFFVAL.GT.EPSTES) THEN
                I_ERRO=1
	    END IF
         END DO
C
C        Printing the results...
C
         IF (I_ERRO.EQ.1) THEN
             IF (LOGWRI.GT.4) THEN
                 WRITE(IRESUL,'(''*'',78X,''*'',/,
     *                     ''*   Covariance matrix is incorrectly'',
     *                     '' calculated!!!'',T80,''*'')')
                 WRITE(IRESUL,'(''*'',78X,''*'')')
	         WRITE(IRESUL,'(80(''*''),/,''*'',78X,''*'',/,
     *                        ''*   Confidence intervals '',
     *                        ''NOT CALCULATED'',T80,''*'')')
                 WRITE(IRESUL,'(''*'',78X,''*'')')
             END IF
         ELSE
             IF (LOGWRI.GT.4) THEN
	         WRITE(IRESUL,'(''*'',78X,''*'',/,
     *                    ''*   Covariance matrix:'',
     *                    T80,''*'',/,''*'',78X,''*'')')
                 DO I_PARL=1,IACTIV
                    WRITE(IRESUL,'(''*'',<IACTIV>(F9.2),T80,''*'')')
     *              (CONVER(I_PARL,I_PARM),I_PARM=1,IACTIV)
                 END DO
                 WRITE(IRESUL,'(''*'',78X,''*'')')
                 WRITE(IRESUL,'(80(''*''),/,''*'',78X,''*'',/,
     *                    ''*   Confidence Intervals for parameters:'',
     *                    T80,''*'',/,''*'',78X,''*'')')
	         DO I_PARL=1,IACTIV
                    WRITE(IRESUL,'(''*'',F9.2,T80,''*'')')
     *              SQRT(CONVER(I_PARL,I_PARL)*DELTAP)
                 END DO
                 WRITE(IRESUL,'(''*'',78X,''*'')')
             END IF
         END IF
C
      END IF
C
C
C
C
C
C
C
C
C
C
C
C=======================================================================
C
C     Now we test the J matrix using the Singular Value Decomposition 
C     routine from LAPACK.  The results are stored in SINGLE, UMATRI 
C     and VTMATR.  We chose  to call  the routines  with 'A' option, 
C     which gives full V and U matrix. 
C
C     REMARK: If one chooses to change this option, size declaration 
C     of these matrices has to be changed.
C
C=======================================================================
C
C     Choice of the method of storing the U and V - 'FULL'
C
*      INFO_P=0
*      INFO_N=0
*      JOBU ='A'
*      JOBVT='A'
*C
*      IF (IFDENS.EQ.0) THEN
*C
*         IF (IFPROT.EQ.0) GO TO 13
*C
*         NUMROW=LEVPRO+1
*C
*         CALL DGESVD(  JOBU, JOBVT,NUMROW,IACPRO,XJMATR_PROTON,NDIM_M,
*     *        NDPARS,SINGLE_PROTON,UMATRI_PROTON,NDIM_M,VTMATR_PROTON,
*     *        NDPARS, WORK ,NDSPEC, INFO_P)
*C
*  13     IF (IFNEUT.EQ.0) GO TO 14
*C
*         NUMROW=LEVNEU+1
*C
*         CALL DGESVD(  JOBU, JOBVT,NUMROW,IACNEU,XJMATR_NEUTRS,NDIM_M,
*     *        NDPARS,SINGLE_NEUTRS,UMATRI_NEUTRS,NDIM_M,VTMATR_NEUTRS,
*     *        NDPARS, WORK ,NDSPEC, INFO_N)
*C
*C If something goes wrong INFO values are not 0, and we print them
*C
*  14     CONTINUE
*C
*         IF (INFO_P.NE.0) THEN
*             WRITE(IRESUL,'(''* ...in DGESVD... INFO_P='',T80,''*'')')
*     *             INFO_P
*         END IF
*         IF (INFO_N.NE.0) THEN
*             WRITE(IRESUL,'(''* ...in DGESVD... INFO_N='',T80,''*'')')
*     *             INFO_N
*         END IF
*C
*C Printing the results to IRESUL file...
*C
*         WRITE(IRESUL,'(80(''*''))')
*C
*         IF (IFPROT.EQ.0) GO TO 15
*C
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         WRITE(IRESUL,'(''*   Proton  singular values:'',T80,''*'')')
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         DO INUM=1,IACPRO
*            WRITE(IRESUL,'(''*'',F11.6,T80,''*'')')SINGLE_PROTON(INUM)
*	 END DO
*C
* 15      IF (IFNEUT.EQ.0) GO TO 16
*C
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         WRITE(IRESUL,'(''*   Neutron singular values:'',T80,''*'')')
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*	 DO INUM=1,IACNEU
*            WRITE(IRESUL,'(''*'',F11.6,T80,''*'')')SINGLE_NEUTRS(INUM)
*         END DO
*C
*  16     IF (IFPROT.EQ.0) GO TO 17
*C
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         WRITE(IRESUL,'(''*   Proton  VT matrix:'',T80,''*'')')
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         DO INUL=1,IACPRO
*            WRITE(IRESUL,'(''*'',T5,<IACPRO>F9.4,T80,''*'')')
*     *           (VTMATR_PROTON(INUL,INUM),INUM=1,IACPRO)
*         END DO
*C
*  17     IF (IFNEUT.EQ.0) GO TO 18
*C
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         WRITE(IRESUL,'(''*   Neutron VT matrix:'',T80,''*'')')
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         DO INUL=1,IACNEU
*            WRITE(IRESUL,'(''*'',T5,<IACNEU>F9.4,T80,''*'')')
*     *           (VTMATR_NEUTRS(INUL,INUM),INUM=1,IACNEU)
*         END DO
*C
*  18     IF (IFPROT.EQ.0) GO TO 19
*C
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         WRITE(IRESUL,'(''*   Proton  U matrix:'',T80,''*'')')
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*C      
*         DO INUL=1,LEVPRO+1
*            WRITE(IRESUL,'(''*'',T2,<LEVPRO+3>F9.4,T80,''*'')')
*     *           (UMATRI_PROTON(INUL,INUM),INUM=1,LEVPRO+1)
*         END DO
*C
*  19     IF (IFNEUT.EQ.0) GO TO 20
*C
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         WRITE(IRESUL,'(''*   Neutron U matrix:'',T80,''*'')')
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         DO INUL=1,LEVNEU+1
*            WRITE(IRESUL,'(''*'',T2,<LEVNEU+3>F9.4,T80,''*'')')
*     *           (UMATRI_NEUTRS(INUL,INUM),INUM=1,LEVNEU+1)
*         END DO
*         WRITE(IRESUL,'(''*'',T80,''*'',/,80(''*''))')
*C
*C Calculating new set of uncorrelated parameters for protons..
*C both stored in PARNEW()
*C
*  20     IF (IFPROT.EQ.0) GO TO 21
*C
*         DO JPARNB=1,IACPRO
*	    SUM_VS=0.
*	    DO LPARNB=1,IACPRO
*	       SUMUWF=0.
*	       DO KLEVNB=1,LEVPRO+1
*	          SUMUWF=SUMUWF+UMATRI_PROTON(KLEVNB,LPARNB)
*     *			       *WEISQR_PROTON(KLEVNB)
*     *                         *(FUNEXP(KLEVNB)-FUNCT0(KLEVNB))
*	       END DO
*               IF (SINGLE_PROTON(LPARNB).GT.SVDCUT) THEN
*	           SUM_VS=SUM_VS+VTMATR_PROTON(LPARNB,JPARNB)
*     *                          *(1./SINGLE_PROTON(LPARNB))
*     *                          *SUMUWF
*C	       PRINT*,'SUMUWF',SUMUWF
*C	       PRINT*,'     v',VTMATR_PROTON(LPARNB,JPARNB)
*C	       PRINT*,'  S^-1',1./SINGLE_PROTON(LPARNB)
*               ELSE
*	           SUM_VS=SUM_VS
*	       END IF
*	    END DO
*C               PRINT*,'SUM_VS=',SUM_VS
*	    PARNEW(JPARNB)=ARGPAR(JPARNB)+SUM_VS
*C	    PRINT*,JPARNB,ARGPAR(JPARNB),PARNEW(JPARNB)
*	 END DO
*C      
*C Calculating new set of uncorrelated parameters for neutrons..
*C
*  21     IF (IFNEUT.EQ.0) GO TO 22
*C
*         DO JPARNB=1,IACNEU
*	    SUM_VS=0.
*	    DO LPARNB=1,IACNEU
*	       SUMUWF=0.
*	       DO KLEVNB=LEVPRO+2,LEVNUM
*	          SUMUWF=SUMUWF+UMATRI_NEUTRS(KLEVNB-LEVPRO-1,LPARNB)
*     *			       *WEISQR_NEUTRS(KLEVNB)
*     *                         *(FUNEXP(KLEVNB)-FUNCT0(KLEVNB))
*	       END DO
*               IF (SINGLE_NEUTRS(LPARNB).GT.SVDCUT) THEN
*	           SUM_VS=SUM_VS+VTMATR_NEUTRS(LPARNB,JPARNB)
*     *                          *(1./SINGLE_NEUTRS(LPARNB))
*     *                          *SUMUWF
*C	       PRINT*,'SUMUWF',SUMUWF
*C	       PRINT*,'     v',VTMATR_NEUTRS(LPARNB,JPARNB)
*C	       PRINT*,'  S^-1',1./SINGLE_neutrs(LPARNB)
*               ELSE
*	           SUM_VS=SUM_VS
*	       END IF
*	    END DO
*C            PRINT*,'SUM_VS=',SUM_VS
*	    PARNEW(JPARNB+IACPRO)=ARGPAR(JPARNB+IACPRO)+SUM_VS
*C	    PRINT*,JPARNB,ARGPAR(JPARNB+IACPRO),PARNEW(JPARNB+IACPRO)
*	 END DO
*C
*  22     CONTINUE
*C-----------------------------------------------------------------------
*      ELSE
*C-----------------------------------------------------------------------
*         NUMROW=LEVNUM
*C
*         CALL DGESVD(  JOBU, JOBVT,NUMROW,IACTIV,XJMATR,NDIM_M,
*     *        NDPARS,SINGLE,UMATRI,NDIM_M,VTMATR,NDPARS, WORK ,NDSPEC,
*     *                                                          INFO )
*C
*         IF (INFO.NE.0) THEN
*             WRITE(IRESUL,'(''* ...in DGESVD... INFO='',I3,T80,''*'')')
*     *             INFO
*         END IF
*C
*C Printing the results to IRESUL file...
*C
*         WRITE(IRESUL,'(80(''*''))')
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         WRITE(IRESUL,'(''*   Singular values:'',T80,''*'')')
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         DO INUM=1,IACTIV
*            WRITE(IRESUL,'(''*'',F11.6,T80,''*'')')SINGLE(INUM)
*	 END DO
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         WRITE(IRESUL,'(''*   VT matrix:'',T80,''*'')')
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         DO INUL=1,IACTIV
*            WRITE(IRESUL,'(''*'',T5,<IACTIV>F9.4,T80,''*'')')
*     *           (VTMATR(INUL,INUM),INUM=1,IACTIV)
*         END DO
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         WRITE(IRESUL,'(''*   U matrix:'',T80,''*'')')
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*C      
*         DO INUL=1,LEVNUM
*            WRITE(IRESUL,'(''*'',T2,<LEVNUM>F9.4,T80,''*'')')
*     *           (UMATRI_PROTON(INUL,INUM),INUM=1,LEVNUM)
*         END DO
*         WRITE(IRESUL,'(''*'',T80,''*'',/,80(''*''))')
*C
*         DO JPARNB=1,IACTIV
*	    SUM_VS=0.
*	    DO LPARNB=1,IACTIV
*	       SUMUWF=0.
*	       DO KLEVNB=1,LEVNUM
*	          SUMUWF=SUMUWF+UMATRI(KLEVNB,LPARNB)
*     *			       *WEISQR(KLEVNB)
*     *                         *(FUNEXP(KLEVNB)-FUNCT0(KLEVNB))
*	       END DO
*               IF (SINGLE(LPARNB).GT.SVDCUT) THEN
*	           SUM_VS=SUM_VS+VTMATR(LPARNB,JPARNB)
*     *                          *(1./SINGLE(LPARNB))
*     *                          *SUMUWF
*               ELSE
*	           SUM_VS=SUM_VS
*	       END IF
*	    END DO
*	    PARNEW(JPARNB)=ARGPAR(JPARNB)+SUM_VS
*	 END DO
*      END IF
*C
*C Printing old & new parameters to the IRESUL file
*C
*      WRITE(IRESUL,'(''*'',T80,''*'',/,''*   New set of parameters'',
*     *               '' from the SVD'',T80,''*'',/,''*'',T80,''*'')')
*      WRITE(IRESUL,'(''*'',T12,''OLD'',17X,''NEW'',T80,''*'')')
*      WRITE(IRESUL,'(''*'',T80,''*'')')
*      DO I=1,IACTIV
*         WRITE(IRESUL,'(''*'',2F20.8,T80,''*'')') ARGPAR(I),PARNEW(I)
*      END DO
*      WRITE(IRESUL,'(''*'',T80,''*'',/,80(''*''))')

*C-----------------------------------------------------------------------
*C  Again calculating the covariance matrix, this time using the SVD 
*C  results with singular values cut at the user defined level SVDCUT
*C
*C                        (J^TJ)^-1=VS^-2V^T
*C-----------------------------------------------------------------------
*      WRITE(IRESUL,'(''*'',78X,''*'',/,
*     *               ''*   Covariance matrix:'',
*     *           T80,''*'',/,''*'',78X,''*'')')

*      IF (IFDENS.EQ.0) THEN

*         DO LPARNB=1,IACPRO
*            DO KPARNB=1,IACPRO
*	       SUMSUM=0.
*	       DO IPARNB=1,IACPRO
*	          IF (SINGLE_PROTON(IPARNB).GT.SVDCUT) THEN
*	             SUMSUM=SUMSUM+VTMATR_PROTON(IPARNB,LPARNB)
*     *                            *(SINGLE_PROTON(IPARNB)**(-2))
*     *                            *VTMATR_PROTON(IPARNB,KPARNB)
*                  ELSE
*	             SUMSUM=SUMSUM
*                  END IF
*	       END DO
*	       YJTJMX_PROTON(LPARNB,KPARNB)=SUMSUM
*            END DO
*            WRITE(IRESUL,'(''*'',<IACPRO>(F10.4),T80,''*'')')
*     *                    (YJTJMX_PROTON(LPARNB,I),I=1,IACPRO)	 
*         END DO
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         DO LPARNB=1,IACNEU
*            DO KPARNB=1,IACNEU
*	       SUMSUM=0.
*	       DO IPARNB=1,IACNEU
*	          IF (SINGLE_NEUTRS(IPARNB).GT.SVDCUT) THEN
*	             SUMSUM=SUMSUM+VTMATR_NEUTRS(IPARNB,LPARNB)
*     *                            *(SINGLE_NEUTRS(IPARNB)**(-2))
*     *                            *VTMATR_NEUTRS(IPARNB,KPARNB)
*                  ELSE
*	             SUMSUM=SUMSUM
*	          END IF
*	       END DO
*               YJTJMX_NEUTRS(LPARNB,KPARNB)=SUMSUM
*            END DO
*            WRITE(IRESUL,'(''*'',<IACNEU>(F10.4),T80,''*'')')
*     *                    (YJTJMX_NEUTRS(LPARNB,I),I=1,IACNEU)	 
*         END DO
*C
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         WRITE(IRESUL,'(80(''*''),/,''*'',78X,''*'',/,
*     *                ''*   Confidence Intervals for parameters:'',
*     *                T80,''*'',/,''*'',78X,''*'')')
*         DO I_PARL=1,IACPRO
*            WRITE(IRESUL,'(''*'',F9.3,T80,''*'')')
*     *           SQRT(YJTJMX_PROTON(I_PARL,I_PARL)*DELTAP_PROTON)
*         END DO
*         WRITE(IRESUL,'(''*'',T80,''*'')')
*         DO I_PARL=1,IACNEU
*            WRITE(IRESUL,'(''*'',F9.3,T80,''*'')')
*     *           SQRT(YJTJMX_NEUTRS(I_PARL,I_PARL)*DELTAP_NEUTRS)
*         END DO
*         WRITE(IRESUL,'(''*'',T80,''*'',/,80(''*''))')

*      ELSE
*         DO LPARNB=1,IACTIV
*            DO KPARNB=1,IACTIV
*	       SUMSUM=0.
*	       DO IPARNB=1,IACTIV
*	          IF (SINGLE(IPARNB).GT.SVDCUT) THEN
*	             SUMSUM=SUMSUM+VTMATR(IPARNB,LPARNB)
*     *                            *(SINGLE(IPARNB)**(-2))
*     *                            *VTMATR(IPARNB,KPARNB)
*                  ELSE
*	             SUMSUM=SUMSUM
*                  END IF
*	       END DO
*	       YJTJMX(LPARNB,KPARNB)=SUMSUM
*            END DO
*            WRITE(IRESUL,'(''*'',<IACTIV>(F10.4),T80,''*'')')
*     *                    (YJTJMX(LPARNB,I),I=1,IACTIV)	 
*         END DO
*         WRITE(IRESUL,'(''*'',T80,''*'')')

*         WRITE(IRESUL,'(80(''*''),/,''*'',78X,''*'',/,
*     *                ''*   Confidence Intervals for parameters:'',
*     *                T80,''*'',/,''*'',78X,''*'')')
*         DO I_PARL=1,IACTIV
*            WRITE(IRESUL,'(''*'',F9.3,T80,''*'')')
*     *           SQRT(YJTJMX(I_PARL,I_PARL)*DELTAP)
*         END DO
*         WRITE(IRESUL,'(''*'',T80,''*'',/,80(''*''))')

*      END IF
C
C=======================================================================
C
  100 CONTINUE
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,9X,''Exiting  JMATRX'')')
          WRITE(LOGAUX,'(/,''... leaving JMATRX'',/)')
      END IF
C
      IF (ISCREN.GT.0) WRITE(LSCREN,'(/,''... leaving JMATRX'',/)')
C
C=======================================================================
C     
CID      CALL CPUTIM('JMATRX',0)
C
C=======================================================================
C 
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE TCRITC(CRITIC)
C
      PARAMETER (ITERNB=50)
      COMMON
     *     /BETDAT/ APARAM,BPARAM,PROBAB,FREDEG
      COMMON
     *     /XARGUM/ X_ARGU
      EXTERNAL
     *      BISEC,BETFUN,TFUNEV
      DATA
     *    AINTER /0.0/,
     *    BINTER /1.0/,
     *    ALIMTT /0.0/,
     *    BLIMTT /700.0/,
     *    EPSLOO /1.0E-13/
C
C=======================================================================
C
C  This routine calculates the critical t values
C  (student's distribution) for given ONE-SIDED (!)probability:
C  Pr(T<A)=1-p with A=t(p,n) where n is the number of 
C  degrees of freedom. We also have Pr(-A<T<A)=1-2p.
C  The confidence interval is given by: D=A*Sn/sqrt(n)
C
C  The probability function is given by incomplete beta functions:
C  P=Ix(a,b) with a=b=n/2 and x=(t+sqrt(t^2+n))/(2*sqrt(t^2+n))
C  
C
C  Meaning of the input parameters (common BETDAT):
C
C  PROBAB        - given propability (1-p)
C
C  FREDEG        - number of degrees of freedom (n)
C
C  APARAM,BPARAM - parameters for the evaluation of the inc. beta func.
C                  (a,b)
C  TCRITV        - calculated value of the critical t
C   
C      TT=1.37638191977842
c      TT=1.37638191977869
C      FREDEG=1.
C      Y=(TT+SQRT(TT**2+FREDEG))/(2.*SQRT(TT**2+FREDEG))
c      PRINT*,Y
      APARAM=0.5*FREDEG
      BPARAM=0.5*FREDEG
c      PROBAB=0.80
c     WRITE(666,'(3F12.5)')FREDEG,PROBAB
      
      CALL BISEC(AINTER,BINTER,XARGUM,BETFUN,EPSLOO,ITERNB,IERROR)
c     WRITE(666,'(F11.5,I3)')XARGUM,IERROR
      X_ARGU=XARGUM
      CALL BISEC(ALIMTT,BLIMTT,TARGUM,TFUNEV,EPSLOO,ITERNB,IERROR)       
c     WRITE(666,'(F11.5,I3)')TARGUM,IERROR
C
      CRITIC=TARGUM
C
C=======================================================================
C
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C
      FUNCTION BETFUN(X_ARGU)
C      
      COMMON
     *      /BETDAT/ APARAM,BPARAM,PROBAB,FREDEG
C
C=======================================================================
C     This routine prepares the function for the bisection routine
C                  f(x)=BETAI(x)-P
C=======================================================================
C
      BETFUN=BETAI(APARAM,BPARAM,X_ARGU)-PROBAB
C
C=======================================================================
C
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C
      FUNCTION TFUNEV(T_ARGU)
C      
      COMMON
     *       /BETDAT/ APARAM,BPARAM,PROBAB,FREDEG
      COMMON
     *       /XARGUM/ X_ARGU
C
C=======================================================================
C     This routine prepares the function for the bisection routine
C                  f(x)=sqrt(t^2+n)*(2*x-1)-t
C=======================================================================
C      
      TFUNEV=SQRT(T_ARGU**2+FREDEG)*(2.*X_ARGU-1.)-T_ARGU
C
C=======================================================================
C 
      RETURN     
      END
C
C=======================================================================
C
      SUBROUTINE BISEC(A,B,X,F,EPS,ITER,IER)
      EXTERNAL
     *         F
C
C=======================================================================
C         SOLVES THE EQUATION F(X)=0 USING A BISECTION METHOD
C=======================================================================
C
      XA=A
      XB=B
      IT=0
C
      FA=F(XA)
      FB=F(XB)
C
      ABFA=ABS(FA)
      X=A
C
      IF (ABFA.LT.EPS) GO TO 10
C
      ABFB=ABS(FB)
      X=B
C
      IF (ABFB.LT.EPS) GO TO 10
      IF (FA*FB.GT.0.0) GO TO 11
C
   1  CONTINUE
C
      IT=IT+1
      X=0.5*(XA+XB)
      FX=F(X)
      ABFF=ABS(FX)
C
      IF (ABFF.LT.EPS) GO TO 10
      IF (IT.GT.ITER) GO TO 20
      IF (FA*FX) 2,10,4
C
   2  CONTINUE
C
C=======================================================================
C         FUNCTION CHANGES SIGN IN THE LEFT SUBINTERVAL
C=======================================================================
C
      XB=X
C
      GO TO 1
C
   4  CONTINUE
C
C=======================================================================
C         FUNCTION CHANGES SIGN IN THE RIGHT SUBINTERVAL
C=======================================================================
C
      XA=X
C
      GO TO 1
C
   10 CONTINUE
C
      IER=0
C
      RETURN
C
   11 CONTINUE
C
      PRINT 30
   30 FORMAT(///,1X,18HBISEC OUT OF RANGE ,///)
C
      STOP 'BISEC'
C
   20 CONTINUE
C
      IER=10
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      FUNCTION betai(a,b,x)
      REAL betai,a,b,x
CU    USES betacf,gammln
      REAL bt,betacf,gammln
      if(x.lt.0..or.x.gt.1.)pause 'bad argument x in betai'
      if(x.eq.0..or.x.eq.1.)then
        bt=0.
      else
        bt=exp(gammln(a+b)-gammln(a)-gammln(b)+a*log(x)+b*log(1.-x))
      endif
      if(x.lt.(a+1.)/(a+b+2.))then
        betai=bt*betacf(a,b,x)/a
        return
      else
        betai=1.-bt*betacf(b,a,1.-x)/b
        return
      endif
      END
C
C=======================================================================
C=======================================================================
C
      FUNCTION gammln(xx)
      REAL gammln,xx
      INTEGER j
CID      DOUBLE PRECISION ser,stp,tmp,x,y,cof(6)
      DIMENSION cof(6)
      SAVE cof,stp
      DATA cof,stp/76.18009172947146d0,-86.50532032941677d0,
     *24.01409824083091d0,-1.231739572450155d0,.1208650973866179d-2,
     *-.5395239384953d-5,2.5066282746310005d0/
      x=xx
      y=x
      tmp=x+5.5d0
      tmp=(x+0.5d0)*log(tmp)-tmp
      ser=1.000000000190015d0
      do 11 j=1,6
        y=y+1.d0
        ser=ser+cof(j)/y
11    continue
      gammln=tmp+log(stp*ser/x)
      return
      END
C
C=======================================================================
C=======================================================================
C
      FUNCTION betacf(a,b,x)
      INTEGER MAXIT
      REAL betacf,a,b,x,EPS,FPMIN
      PARAMETER (MAXIT=100,EPS=3.e-7,FPMIN=1.e-30)
      INTEGER m,m2
      REAL aa,c,d,del,h,qab,qam,qap
      qab=a+b
      qap=a+1.
      qam=a-1.
      c=1.
      d=1.-qab*x/qap
      if(abs(d).lt.FPMIN)d=FPMIN
      d=1./d
      h=d
      do 11 m=1,MAXIT
        m2=2*m
        aa=m*(b-m)*x/((qam+m2)*(a+m2))
        d=1.+aa*d
        if(abs(d).lt.FPMIN)d=FPMIN
        c=1.+aa/c
        if(abs(c).lt.FPMIN)c=FPMIN
        d=1./d
        h=h*d*c
        aa=-(a+m)*(qab+m)*x/((a+m2)*(qap+m2))
        d=1.+aa*d
        if(abs(d).lt.FPMIN)d=FPMIN
        c=1.+aa/c
        if(abs(c).lt.FPMIN)c=FPMIN
        d=1./d
        del=d*c
        h=h*del
        if(abs(del-1.).lt.EPS)goto 1
11    continue
      pause 'a or b too big, or MAXIT too small in betacf'
1     betacf=h
      return
      END
C
C=======================================================================
C=======================================================================
C
C FILE NAME = wspher11_minimi_15.f ! Keep this symbol:    $ident@string$
C
C=======================================================================
C=======================================================================
C         INTERFACE: USER-DEFINED PROBLEM VS LEVENBERG PACKAGE
C=======================================================================
C=======================================================================
C
      SUBROUTINE LMMINI(ARGPAR,I_SEED,LDRAND,NEWSED,NDLAST)
C
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDIM_M.f'
      INCLUDE   'MATDIM/MAXFEV.f'
C
      EXTERNAL 
     *          FUNMIN
C      
      PARAMETER 
     *         (LENGTH=256,INMODE=1,NPRINT=-1)
C
      CHARACTER
     *          LABPRO*6,LABNEU*6,LABPRO_PRINTG*006,LABNEU_PRINTG*6
      CHARACTER
     *          DIRNAM*256,GENAME*256,STRING*126
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          ACTION*1,CALLED*6,TYPCHI*6
      CHARACTER
     *          FILNAM*256,FILNAM_ENDING*13,INPSYM*6,
     *          LABTHE*006,LABTHE_PRINTG*06,TEXLAM*20,
     *          FILNA2*256,NUCSYM*6,FITNUC*2,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*30,FILNA3*256,VERSIO*3
C    
      DIMENSION 
     *          ARGPAR(1:NDPARS),FUNVEC(1:NDIM_M),
     *          SCALFC(1:NDPARS),QTFARR(1:NDPARS)
      DIMENSION
     *          WORKA1(1:NDPARS),WORKA2(1:NDPARS),
     *          WORKA3(1:NDPARS),WORKA4(1:NDIM_M)
      DIMENSION 
     *          FUNJAC(1:NDIM_M,1:NDPARS)
      DIMENSION 
     *          IPIVOT(1:NDPARS)
      DIMENSION
     *          ENETHE(1:NDSPEC),LABTHE(1:NDSPEC)
      DIMENSION
     *          ENEPRO_PRINTG(1:NDSPEC),LABPRO_PRINTG(1:NDSPEC),
     *          ENENEU_PRINTG(1:NDSPEC),LABNEU_PRINTG(1:NDSPEC),
     *          ENETHE_PRINTG(1:NDSPEC),LABTHE_PRINTG(1:NDSPEC),
     *                                  PARPOT_PRINTG(1:NDPARS)
      DIMENSION
     *          ENEPRO(1:NDSPEC),LABPRO(1:NDSPEC),
     *          ENENEU(1:NDSPEC),LABNEU(1:NDSPEC)
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL)
C
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                              LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                              LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /CHI_PN/ CHISQU_PROTON,CHISQU_NEUTRS
      COMMON
     *       /CHICHO/ VALCHI
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)    
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /CHIGRD/ CHISQU_GRDNRM,
     *                CHISQU_GRADIE(1:NDPARS)
      COMMON
     *       /STOPIN/ HIAUXI(1:MAXFEV)
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
     *       /FEVALS/ IFUNCT_EVALUS
      COMMON
     *       /STOPAR/ EPSLAS,LDLAST
     *       /MASSIV/ IMASIV_PRODUC
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /DENSTR/ IFDENS
     *       /TENSOR/ IFTENS
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS    
      COMMON
     *       /TOLERS/ TOLERF,TOLERX,TOLERG,FACTOR  
      COMMON  
     *       /VERSIN/ VERSIO
C
      DATA 
     *     NpUNIT / 80 /, 
     *     NnUNIT / 81 / 
C
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' /
C
C=======================================================================
C     Levenberg-Marquardt minimisation routine ??
C=======================================================================
C
C     ILEVEL - Number of functions
C @@@ ILEVEL should be the running value changing from case to case?
C @@@ NDPARS according to conventions the MAXIMUM dimension
C     NDPARS - Number of parameters (not greater than ILEVEL)
C
C            chi=sum_m(FUNJAC_m)^2 
C
C     Testing case setting ILEVEL=1
C     NDIM_M leading dimension (ILEVEL)
C
C=======================================================================
C
      IFIRST=1
      IFPROT=0
      IFNEUT=0
      IFBOTH=0
      IACTIV=0
C
      DO IPARAM=1,NDPARS ! Fixed as NDPARS=48
C
         IF (IFTAKE(IPARAM).EQ.1) THEN
C
             IACTIV=IACTIV+1
C  @@@ IRENE? CHECK THE PRIVILEGED ROLE OF 20
             IF (IPARAM.LE.20 .AND. IFDENS.EQ.0) THEN
                 IFPROT=1
             END IF
C
             IF (IPARAM.GT.20 .AND. IFDENS.EQ.0) THEN
                 IFNEUT=1
             END IF
C
             IF (IPARAM.GE.51 .AND. IFDENS.EQ.0) THEN
                 IFPROT=0
                 IFNEUT=0
                 IFBOTH=1
             END IF
C
         END IF
C
      END DO
C_______________________________________________________________________
C
      IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1).AND.(IFPROT.EQ.1)) THEN
C  
           IFPROT=0
           IFNEUT=0
           IFBOTH=1
C
          WRITE(0,'(/,''ALERT in LMMINI!! Density is NOT activated'',1X,
     *                ''and IFNEUT and IFPROT are equal to 1 !!!!'',/)')
C
C          STOP 'Chose proton OR neutron parameters, stop FROM LMMINI'
C
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(/,9X,''Number of active parameters '',
     *                        ''IACTIV='',I2)') IACTIV
C
          IF (IFPROT.EQ.1) THEN
              WRITE(LOGFIL,'(9X,''Minimisation for protons'')')
          END IF
C
          IF (IFNEUT.EQ.1) THEN
              WRITE(LOGFIL,'(9X,''Minimisation for neutrons'')')
          END IF
C
          IF (IFBOTH.EQ.1) THEN
              WRITE(LOGFIL,'(9X,''Minimisation for protons '',
     *                          ''and neutrons'')')
          END IF
C
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) FILNAM_ENDING='P'
C
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) FILNAM_ENDING='N'
C          
      IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C              
          FILNAM_ENDING='B'
C              
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                               IFPAR1,IFPAR2,IFPAR3,IFPAR4
C          
      END IF
C
C=======================================================================
C 
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
      
      I1=3*KACTIV-1
      
      WRITE(FILNAM_NUCFIT,'(<NUCACT>(A2,''-''))')
     *                     (FITNUC_AUXILI(I),I=1,NUCACT)
C
C=======================================================================
C     
      IF (IFDENS.EQ.0) THEN
C      
          WRITE(FILNAM,'(''LogFiles/IFDENS-0/'',A,''_'',A1,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A3,''.log'')') 
     *
     *                      FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_RAD,IF_INV,IF_RHO,
     *                      IFDEEP,IFPRON,IFK_VC,IFK_VS,IFK_RC,
     *                      IFK_RS,IFK_AC,IFK_AS,LDRAND,VERSIO
C          
          IF (NUCACT.GT.1 .AND. NUCACT.LT.LDNUCL) THEN
C              
              WRITE(FILNA2,'(''LogFiles/IFDENS-0/'',A,''_'',
     *                                      A1,''_Energies'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IF-RHO-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LDRAND-'',I5.5,''_'',A3,''.log'')')
     * 
     *                          FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                          IFDENS,IFTENS,IF_RAD,IF_INV,IF_RHO,
     *                          IFDEEP,IFPRON,IFK_VC,IFK_VS,IFK_RC,
     *                          IFK_RS,IFK_AC,IFK_AS,LDRAND,VERSIO
             
              WRITE(FILNA3,'(''LogFiles/IFDENS-0/'',A,''_'',
     *                                         A1,''_Radii'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IF-RHO-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LDRAND-'',I5.5,''_'',A3,''.log'')')
     * 
     *                          FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                          IFDENS,IFTENS,IF_RAD,IF_INV,IF_RHO,
     *                          IFDEEP,IFPRON,IFK_VC,IFK_VS,IFK_RC,
     *                          IFK_RS,IFK_AC,IFK_AS,LDRAND,VERSIO
C          
              OPEN(LOGENE,FILE=FILNA2,STATUS='UNKNOWN',FORM='FORMATTED')
              OPEN(LOGRAD,FILE=FILNA3,STATUS='UNKNOWN',FORM='FORMATTED')
C
          END IF
C      
      END IF
C
C=======================================================================
C     
      IF (IFDENS.EQ.0) THEN
C      
          WRITE(FILNAM,'(''LogFiles/IFDENS-0/'',A,''_'',A1,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A3,''.log'')') 
     *
     *                          FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                          IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                          IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                                      VERSIO
C          
          IF (NUCACT.GT.1 .AND. NUCACT.LT.LDNUCL) THEN
C              
              WRITE(FILNA2,'(''LogFiles/IFDENS-0/'',A,''_'',
     *                                      A1,''_Energies'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IF-RHO-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LDRAND-'',I5.5,''_'',A3,''.log'')')
     * 
     *                          FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                          IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                          IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                                      VERSIO
             
              WRITE(FILNA3,'(''LogFiles/IFDENS-0/'',A,''_'',
     *                                         A1,''_Radii'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IF-RHO-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LDRAND-'',I5.5,''_'',A3,''.log'')')
     * 
     *                          FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                          IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                          IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                                      VERSIO
C          
              OPEN(LOGENE,FILE=FILNA2,STATUS='UNKNOWN',FORM='FORMATTED')
              OPEN(LOGRAD,FILE=FILNA3,STATUS='UNKNOWN',FORM='FORMATTED')
C
          END IF
C      
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.1) THEN
C      
          WRITE(FILNAM,'(''LogFiles/IFDENS-1_IFTENS-'',I1,''/'',
     *                                        A,''_'',A1,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')') 
     *
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                      IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,TEXLAM,
     *                                                         VERSIO
C______________________________________________________________________
C
          IF (IFTENS.EQ.1) THEN ! IFDENS=1
C
              WRITE(FILNAM,'(''LogFiles/IFDENS-1_IFTENS-'',I1,''/'',
     *                                        A,''_'',A1,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')') 
     *
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,TEXLAM,
     *                                                         VERSIO
          END IF
C______________________________________________________________________
C
          IF (NUCACT.GT.1 .AND. NUCACT.LT.LDNUCL) THEN ! IFDENS=1
C
              WRITE(FILNA2,'(''LogFiles/IFDENS-1_IFTENS-'',I1,''/'',
     *                              A,''_'',A1,''_Energies'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')') 
     *
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,TEXLAM,
     *                                                         VERSIO
C______________________________________________________________________
C
              WRITE(FILNA3,'(''LogFiles/IFDENS-1_IFTENS-'',I1,''/'',
     *                                 A,''_'',A1,''_Radii'',
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')') 
     * 
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,TEXLAM,
     *                                                         VERSIO
C______________________________________________________________________
C
              IF (IFTENS.EQ.1) THEN ! IFDENS=1
C
                  WRITE(FILNA2,'(''LogFiles/IFDENS-1_IFTENS-'',I1,''/'',
     *                              A,''_'',A1,''_Energies'',
     *                           ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                           ''_IF-PAI-'',I1,
     *                           ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                           ''_ITENSR-'',I1,
     *                           ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                           ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                           ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                           ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                           ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                           ''_LDRAND-'',I5.5,A15,''_'',A3,
     *                                                 ''.log'')') 
     *
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,TEXLAM,
     *                                                         VERSIO
C
C______________________________________________________________________
C
                  WRITE(FILNA3,'(''LogFiles/IFDENS-1_IFTENS-'',I1,''/'',
     *                                 A,''_'',A1,''_Radii'',
     *                           ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                           ''_IF-PAI-'',I1,
     *                           ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                           ''_ITENSR-'',I1,
     *                           ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                           ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                           ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                           ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                           ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                           ''_LDRAND-'',I5.5,A15,''_'',A3,
     *                                                 ''.log'')') 
     *
     *                      IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                      IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                      IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,TEXLAM,
     *                                                         VERSIO
C
              END IF
C          
              OPEN(LOGENE,FILE=FILNA2,STATUS='UNKNOWN',FORM='FORMATTED')
              OPEN(LOGRAD,FILE=FILNA3,STATUS='UNKNOWN',FORM='FORMATTED')
C
          END IF
C      
      END IF
C
C=======================================================================
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C=======================================================================
C @@@ IRENE WHAT IS THIS CONDITION EXACTLY? WHAT IS THE ROLE OF NUCACT?     
      IF (NUCACT.EQ.LDNUCL) THEN 
C
          IF (IFDENS.EQ.0) THEN
C
              WRITE(FILNAM,'(''LogFiles/IFDENS-0/All-Nuclei_'',A1,
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LDRAND-'',I5.5,''_'',A3,''.log'')')
     *
     *                          FILNAM_ENDING,IFDENS,IFTENS,IF_PAI,
     *                          IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,
     *                          IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                                               LDRAND,VERSIO
C
              WRITE(FILNA2,'(''LogFiles/IFDENS-0/All-Nuclei_Energies_'',
     *                    A1,''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LDRAND-'',I5.5,''_'',A3,''.log'')')
     *
     *                          FILNAM_ENDING,IFDENS,IFTENS,IF_PAI,
     *                          IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,
     *                          IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                                               LDRAND,VERSIO
C
              WRITE(FILNA3,'(''LogFiles/IFDENS-0/All-Nuclei_Radii_'',A1,
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LDRAND-'',I5.5,''_'',A3,''.log'')')
     *
     *                          FILNAM_ENDING,IFDENS,IFTENS,IF_PAI,
     *                          IF_RAD,IF_INV,IFDEEP,IFPRON,IFK_VC,
     *                          IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                                               LDRAND,VERSIO
C              
          END IF
C
C=======================================================================
C          
          IF (IFDENS.EQ.1) THEN 
C              
              WRITE(FILNAM,'(''LogFiles/IFDENS-1_IFTENS-'',I1,
     *                       ''/All-Nuclei_'',A1,
     *                       ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                       ''_IF-PAI-'',I1,
     *                       ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                       ''_ITENSR-'',I1,
     *                       ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                       ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                       ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                       ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                       ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                       ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')')
     *
     *                          IFTENS,FILNAM_ENDING,IFDENS,IFTENS,
     *                          IF_PAI,ICENTT,ISORBT,ITENSR,IF_RAD,
     *                          IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                               TEXLAM,VERSIO
C
               WRITE(FILNA2,'(''LogFiles/IFDENS-1_IFTENS-'',I1,
     *                        ''/All-Nuclei_Energies_'',A1,
     *                        ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                        ''_IF-PAI-'',I1,
     *                        ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                       ''_ITENSR-'',I1,
     *                        ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                        ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                        ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                        ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                        ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                        ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')')
     *
     *                          IFTENS,FILNAM_ENDING,IFDENS,IFTENS,
     *                          IF_PAI,ICENTT,ISORBT,ITENSR,IF_RAD,
     *                          IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                               TEXLAM,VERSIO
C
               WRITE(FILNA3,'(''LogFiles/IFDENS-1_IFTENS-'',I1,
     *                        ''/All-Nuclei_Radii_'',A1,
     *                        ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                        ''_IF-PAI-'',I1,
     *                        ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                       ''_ITENSR-'',I1,
     *                        ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                        ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                        ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                        ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                        ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                        ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')')
     *
     *                          IFTENS,FILNAM_ENDING,IFDENS,IFTENS,
     *                          IF_PAI,ICENTT,ISORBT,ITENSR,IF_RAD,
     *                          IF_INV,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                          IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                               TEXLAM,VERSIO
C
          END IF   
C
          OPEN(LOGENE,FILE=FILNA2,STATUS='UNKNOWN',FORM='FORMATTED')
          OPEN(LOGRAD,FILE=FILNA3,STATUS='UNKNOWN',FORM='FORMATTED')
C                    
      END IF
C
C=======================================================================
C      
      OPEN(LOGAUX,FILE=FILNAM,STATUS='UNKNOWN',FORM='FORMATTED')
C
C=======================================================================
C
C     Defining the dimension of the vector-function to be minimised
C
      LEVNUM=0
C
      IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
          DO INUCLI=1,LDNUCL
C
             IF (ITAKNU(INUCLI).EQ.1) THEN
C
                 IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_PROTON(INUCLI)
     *                                         +LEVEXP_NEUTRS(INUCLI)
     
                 IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+2 ! Two radii for each 
C                                                       nucleus, (P+N)
C                                                              
                 IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+2 ! Two Gap Energies 
C                                                   for each nucleus
C                                                                (P+N)
C                                                     
                 IF (IF_FER.EQ.1) LEVNUM=LEVNUM+2 ! Two Fermi Energies 
C                                                   for  each  nucleus
C                                                                (P+N)
C
                 IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+4 ! Four densities for 
C                                                   each nucleus: 
C                                                   below and above the 
C                                                   shell closure (P+N)
                 IF (IF_RHO.EQ.1) THEN
C             
c                     NRHOEX=0
C             
c                     CALL COUNTI_RHOEXP(INUCLI,NRHOEX)
C             
c                     LEVNUM=LEVNUM+NRHOEX
C             
                 END IF
C            
             END IF
C        
          END DO ! of LDNUCL
C       
       END IF ! IFDENS=1
C
C=======================================================================
C       
       IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN 
C           
           DO INUCLI=1,LDNUCL
C        
              IF (ITAKNU(INUCLI).EQ.1) THEN
C         
                  IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_PROTON(INUCLI)
C     
                  IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+1 ! Proton radius
C                                                              
                  IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+1 ! Proton Gap energy
C                                                     
                  IF (IF_FER.EQ.1) LEVNUM=LEVNUM+1 ! Proton Fermi energy
C        
                  IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+2 ! Proton up and down 
C                                                    density energies
C
                  IF (IF_RHO.EQ.1) THEN
*C             
*                      NRHOEX=0
*C             
*                      CALL COUNTI_RHOEXP(INUCLI,NRHOEX)
*C             
*                      LEVNUM=LEVNUM+NRHOEX
C             
                  END IF
C            
              END IF
C        
           END DO
C       
       END IF
C
C=======================================================================
C       
       IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1)) THEN 
C
           DO INUCLI=1,LDNUCL
C
              IF (ITAKNU(INUCLI).EQ.1) THEN
C
                  IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_NEUTRS(INUCLI)
     
                  IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+1 ! Neutron radius
C                                                              
                  IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+1 ! Neutron Gap energy
C                                                     
                  IF (IF_FER.EQ.1) LEVNUM=LEVNUM+1 ! Neutron Fermi 
C                                                                energy
C
                  IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+2 ! Neutron up and 
C                                                    down density 
C                                                              energies
C                 IF (IF_RHO.EQ.1)
C                 IF (IF_INV.EQ.1)
            
              END IF
         
           END DO
       
       END IF       
C
C=======================================================================
C
       IF (LEVNUM.GT.NDIM_M) THEN
C
           WRITE(LSCREN,'(/,''LEVNUM= '',I4,''and NDIM_M= '',I4,
     *                  ''--> LEVNUM should be LT NDIM_M!!'',/)')
C
           STOP 'STOP in LMMINI: LEVNUM.GT.NDIM_M!!'
C
       END IF
C
C=======================================================================
C 
      IF (LOGWRI.GT.0) THEN
C 
          WRITE(LOGFIL,'(9X,''LEVNUM='',I2,'' including: '')') LEVNUM
C
          IF (IF_SPE.EQ.1) WRITE(LOGFIL,'(30X,''Single Particle'',
     *                                        '' Energies'')')
C
          IF (IF_RAD.EQ.1) WRITE(LOGFIL,'(30X,''RMS Radii'')')
C
          IF (IF_GAP.EQ.1) WRITE(LOGFIL,'(30X,''Gap Energy'')')   
C       
          IF (IF_FER.EQ.1) WRITE(LOGFIL,'(30X,''Fermi Energy'')')  
       
          IF (IF_DEN.EQ.1) WRITE(LOGFIL,'(''Densities below and '',
     *                                    ''above the shell closure'')') 
C         IF (IF_RHO.EQ.1)
C         IF (IF_INV.EQ.1)      
C 
      END IF
C
      NUMPAR=IACTIV
      INFOER=111
C
C=======================================================================
C    
      CHISQU_MINIML=1.0E+10
      
      IMASIV_PRODUC=0
      
      DO IRANDO=1,LDRAND
          
         IFUNCT_EVALUS=0
C     
         IDEFCN=1
C
         DO I=1,MAXFEV
             HIAUXI(I)=0.0
         END DO
C         
         IF (ISCREN.EQ.1) THEN
C
             WRITE(LSCREN,'(/,58X,''New run: NEWSED='',i14,3x,
     *                            ''No.'',i3,''/'',i3,/,101(''=''),/)') 
     *                                       NEWSED,IRANDO,LDRAND
         END IF
C         
         IF (LOGWRI.GT.0) THEN
C
             WRITE(LOGAUX,'(/,58X,''New run: NEWSED='',i14,3x,
     *                            ''No.'',i3,''/'',i3,/,101(''=''),/)') 
     *                                       NEWSED,IRANDO,LDRAND
C             
             WRITE(LOGENE,'(/,58X,''New run: NEWSED='',i14,3x,
     *                            ''No.'',i3,''/'',i3,/,101(''=''),/)') 
     *                                       NEWSED,IRANDO,LDRAND
C             
             WRITE(LOGRAD,'(/,58X,''New run: NEWSED='',i14,3x,
     *                            ''No.'',i3,''/'',i3,/,101(''=''),/)') 
     *                                       NEWSED,IRANDO,LDRAND
         END IF
C
         WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *                  ''#'',5X,''IRANDO= '',I4,T80,''#'',/,
     *                  ''#'',T80,''#'',/,80(''#''))') IRANDO
C      
C=======================================================================
C
C        Generating random restarts
C
         IF (LOGWRI.GT.0) THEN
             WRITE(LOGFIL,'(//,9X,''Entering NEWRAN with IRANDO='',I3,
     *                         1X,''LDRAND='',I6,'' from LMMINI'')')
     *                              IRANDO,LDRAND
         END IF
C         
         CALL NEWRAN(NEWSED,IZ_FIX,IN_FIX,ISOSPI,ARGPAR,DIRNAM,
     *                                    GENAME,IFIRST,I_SEED)
C      
C=======================================================================
C        Calling the principal minimisation routine based on the
C        Levenberg-Marquardt algorithm (Argonne MINPACK project)  
C=======================================================================
C
         NDFUNC=NDIM_M    ! NDIM_M
         LDFUNC=LEVNUM    ! Actual number of functions, here: levels
C IRENE? NDPARS=NDPARS=48 ! ARGPAR(1:NDPARS)
         LDPARS=IACTIV
C 
C        MAXFEV=900       ! MAXFEV
C @@@ ??
         IFMODE=INMODE
C        NPRINT=-1        ! NPRINT
C @@@ WHAT DOES THIS MEAN???
         INFRUN=INFOER    ! In any case output variable
         NFCALL=0         ! NFUNEV    ! In any case output variable
         NJCALL=0         ! NJACEV    ! In any case output variable
C
C        I_PERM=IPIVOT    ! In any case output vector ?????????????
C                     
C        FJACOB(1:NDFUNC,1:NDPARS) <<=>> FUNJAC(1:NDIM_M,1:NDPARS)
C                 FARGUN(1:NDFUNC) <<=>> FUNVEC(1:NDIM_M)
C                 DIAGSC(1:NDPARS) <<=>> SCALFC(1:NDPARS)       
C                 I_PERM(1:NDPARS) <<=>> IPIVOT(1:NDPARS)       
C
C        Calling the Levenberg-Marquardt LAPACK minimisation routine 
C
         IF (LOGWRI.GT.0) THEN
             WRITE(LOGFIL,'(/,6X,''Entering LEVMAR from LMMINI      '',
     *                        5(3x,''IRANDO='',I2))')
     *                               IRANDO,IRANDO,IRANDO,IRANDO,IRANDO
         END IF
C
         CALL LEVMAR(FUNMIN,NDFUNC,LDFUNC,NDPARS,LDPARS,ARGPAR,
     *               FUNVEC,FUNJAC,TOLERF,TOLERX,TOLERG,MAXFEV,
     *               SCALFC,IFMODE,FACTOR,NPRINT,INFRUN,NFCALL,
     *               NJCALL,IPIVOT,QTFARR,WORKA1,WORKA2,WORKA3,
     *                                           WORKA4,NDLAST)
C
         INFOER=INFRUN 
C
         KK=0
         DO KPARAM=1,NDPARS
            IF (IFTAKE(KPARAM).EQ.1) THEN
                KK=KK+1
                PARPOT(KPARAM)=ARGPAR(KK)
            END IF
         END DO     
C
C=======================================================================
C
         WRITE(LOGAUX,'(/,''Number of WS_RUN Evaluations: '',I5,/)')
     *                      IFUNCT_EVALUS
C
         WRITE(LOGENE,'()') ! AESTHETICAL REASONS
         WRITE(LOGRAD,'()') ! AESTHETICAL REASONS
C
C=======================================================================
C      
         CALL TELLIT(INFOER,TOLERF,TOLERX,TOLERG,MAXFEV,LDLAST,EPSLAS)
C
C=======================================================================
C
         IF (LOGWRI.GT.0) THEN
             WRITE(LOGFIL,'(9X,''Entering JMATRX from LMMINI'')')
         END IF
C
         CALL JMATRX(LDFUNC,ARGPAR)
C
C=======================================================================
C  
C        Between the different restarts, we look for the one that
C        gives the smallest \chi^2
C
         IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) CHISQU=CHISQU_PROTON
C        
         IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) CHISQU=CHISQU_NEUTRS
C
         IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
             CHISQU=VALCHI
         END IF
C_______________________________________________________________________
C         
         IF (CHISQU.LT.CHISQU_MINIML) THEN
C
             CHISQU_MINIML=CHISQU
C
             IRANDO_PRINTG=IRANDO
             IEVALU_PRINTG=IFUNCT_EVALUS
             CHIGRD_PRINTG=CHISQU_GRDNRM
C
             DO IPARAM=1,NDPARS
                PARPOT_PRINTG(IPARAM)=PARPOT(IPARAM)
             END DO
C
         END IF
C
C=======================================================================
C
         IF (LOGWRI.GT.0) THEN
             WRITE(LOGFIL,'(9X,''Entering RADINF from LMMINI'')')
         END IF
C
         CALL RADINF(IFPROT,IFNEUT)
C
C=======================================================================
C
         I_SEED=NEWSED
C
      END DO  !IRANDO
C
C=======================================================================
      
      IMASIV_PRODUC=1
C
C=======================================================================
C
      CALL FINISH_LMMINI(IRANDO_PRINTG,LDRAND,PARPOT_PRINTG,
     *                   IEVALU_PRINTG,CHISQU_MINIML,CHIGRD_PRINTG)
C      
C=======================================================================
C 
      REWIND LOGPRO    
C      
C=======================================================================
C
   10 CONTINUE
C @@@ WHAT IS THIS?   
      READ (LOGPRO,'(A120)',END=11) STRING
      IF (LOGWRI.GT.4) WRITE(NpUNIT,'(A80)'        ) STRING
C      
      GO TO 10
C
   11 CONTINUE  ! Ready with the copy for the protons      
C      
C=======================================================================
C 
      REWIND LOGNEU    
C
   20 CONTINUE
C @@@ IDEM  
      READ (LOGNEU,'(A120)',END=21) STRING
      IF (LOGWRI.GT.4) WRITE(NnUNIT,'(A80)'        ) STRING
C      
      GO TO 20
C
   21 CONTINUE  ! Ready with the copy for the neutrons     
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,18X,''Exiting  LMMINI'')')
      END IF   
C
C=======================================================================
C 
      RETURN
      END    
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE FINISH_LMMINI(IRANDO_PRINTG,LDRAND,PARPOT_PRINTG,
     *                                IEVALU_PRINTG,CHISQU_MINIML,
     *                                              CHIGRD_PRINTG)
C      
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDMESH.f'
      INCLUDE   'MATDIM/ND_RHO.f'
      INCLUDE   'MATDIM/N_NOYX.f'
      INCLUDE   'MATDIM/NDIM_N.f'
      INCLUDE   'MATDIM/NDTITL.f'
    
      EXTERNAL
     *         DENSIT,DENTHE_INTEGR
C      
      PARAMETER
     *         (NDIM_L=NDIM_N,NDBASE=NDIM_N+1)
C      
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6,
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,
     *          LABTHE_PRONUC*6,LABTHE_NEUNUC*6,
     *          LABTHE_PRINTG*6
      CHARACTER
     *          L_CURV_PROTON*6,L_CURV_NEUTRS*6
      CHARACTER
     *          CURNAM*020,L_CURV*100,CURLAB*100,MAIN_T*256,
     *          XTITLE*256,YTITLE*256,TITLES*012,
     *          TITLES_LATEXS*100,NUCNAM_LATEXS*010
C
      DIMENSION
     *          PARPOT_PRINTG(1:NDPARS)
      DIMENSION
     *          RMSTHE_PRONUC(1:NDNUCL),
     *          LEVTHE_PRONUC(1:NDNUCL),
     *          ENETHE_PRONUC(1:NDSPEC,1:NDNUCL),
     *          LABTHE_PRONUC(1:NDSPEC,1:NDNUCL)
      DIMENSION
     *          RMSTHE_NEUNUC(1:NDNUCL),
     *          LEVTHE_NEUNUC(1:NDNUCL),
     *          ENETHE_NEUNUC(1:NDSPEC,1:NDNUCL),
     *          LABTHE_NEUNUC(1:NDSPEC,1:NDNUCL)
      DIMENSION
     *          ENETHE_PRINTG(1:NDSPEC),
     *          LABTHE_PRINTG(1:NDSPEC)
      DIMENSION
     *          EABSAV_PRONUC(1:NDNUCL),
     *          EABSAV_NEUNUC(1:NDNUCL),
     *          RMSVAL_PRONUC(1:NDNUCL),
     *          RMSVAL_NEUNUC(1:NDNUCL),
     *          ERRMAX_PRONUC(1:NDNUCL),
     *          ERRMAX_NEUNUC(1:NDNUCL)
      DIMENSION
     *          X_CURV_PROTON(1:NDMESH,1:NDSPEC),
     *          Y_CURV_PROTON(1:NDMESH,1:NDSPEC),
     *          L_CURV_PROTON(1:NDMESH,1:NDSPEC)
      DIMENSION
     *          X_CURV_NEUTRS(1:NDMESH,1:NDSPEC),
     *          Y_CURV_NEUTRS(1:NDMESH,1:NDSPEC),
     *          L_CURV_NEUTRS(1:NDMESH,1:NDSPEC)
      DIMENSION
     *          ND_MAX(1:NDSPEC),
     *          X_CURV(1:NDMESH,1:NDSPEC),
     *          Y_CURV(1:NDMESH,1:NDSPEC),
     *          L_CURV(1:NDMESH,1:NDSPEC)
      DIMENSION 
     *          ENERUP_PRONUC(0:NDIM_L,1:NDBASE,1:NDNUCL),
     *          ENERDN_PRONUC(0:NDIM_L,1:NDBASE,1:NDNUCL),
     *
     *          ENERUP_NEUNUC(0:NDIM_L,1:NDBASE,1:NDNUCL),
     *          ENERDN_NEUNUC(0:NDIM_L,1:NDBASE,1:NDNUCL)
      DIMENSION  
     *          CMATUP_PRONUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL),
     *          CMATDN_PRONUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL),
     *
     *          CMATUP_NEUNUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL),
     *          CMATDN_NEUNUC(0:NDIM_L,1:NDBASE,1:NDBASE,1:NDNUCL)
C          
      COMMON
     *       /GAUSHE/ NGAUSS,NSHELL_PROTON,NSHELL_NEUTRS
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /EUDAUX/ ENERUP_AUXPRO(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXPRO(0:NDIM_L,1:NDBASE),
     *
     *                ENERUP_AUXNEU(0:NDIM_L,1:NDBASE),
     *                ENERDN_AUXNEU(0:NDIM_L,1:NDBASE)
      COMMON
     *       /CUDAUX/ CMATUP_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXPRO(0:NDIM_L,1:NDBASE,1:NDBASE),
     *
     *                CMATUP_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE),
     *                CMATDN_AUXNEU(0:NDIM_L,1:NDBASE,1:NDBASE)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /DATA_V/ AOSCIL_PROTON(1:NDNUCL),
     *                AOSCIL_NEUTRS(1:NDNUCL),
     *                HOMEGA(1:NDNUCL)   
      COMMON
     *       /EXPDEN/ LABELN(1:N_NOYX,1:2),
     *                R_MESH(1:ND_RHO,1:N_NOYX),
     *                RHOEXP(1:ND_RHO,1:N_NOYX)
      COMMON
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /FITTED/ IFITED
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI
      COMMON
     *       /SIMUSE/ AOSCIL,RADCUT,INUCLI
      COMMON
     *       /CUTOFF/ RADIUS_CUTOFF(1:NDNUCL)
      COMMON
     *       /ARGUMN/ IARG_R,IARG_Z
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /RMSGLO_NUCLEU/ RMSGLO_TAKPRO,
     *                       RMSGLO_TAKNEU,
     *                       RMSVAL_TAKPRO(1:NDNUCL),
     *                       RMSVAL_TAKNEU(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS   
C
C=======================================================================
C
C     This routine calculates the energy levels for ALL the nuclei
C     with the optimal parameters resulting from the minimisation
C
C     The results are divided between "Fitted" & "Predic" folders
C
C=======================================================================
C  
      IPRINT_LMMINI=1
      
      DO IPARAM=1,NDPARS
         PARPOT(IPARAM)=PARPOT_PRINTG(IPARAM)
      END DO
      
      IF (NUCACT.LT.LDNUCL) RMSGLO_PRINTG=9.9999
          
      RMSGLO_PROTON=0.
      RMSGLO_NEUTRS=0.
C
      RMSGLO_PROAUX=0.
      RMSGLO_NEUAUX=0.
C
      RMSGLO_TAKPRO=0.
      RMSGLO_TAKNEU=0.
C
      IDEG_P=0
      IDEG_N=0
C
      IDEGEN_TAKPRO=0
      IDEGEN_TAKNEU=0
C
C=======================================================================
C      
      DO INUCLI=1,LDNUCL
          
         IZ_FIX=NUMB_Z(INUCLI)
         IN_FIX=NUMB_N(INUCLI)
C
         IF (LOGWRI.GT.4) THEN
             WRITE(LOGFIL,'(12X,''Entering WS_RUN from FINISH_LMMINI '',
     *                          ''INUCLI='',I2)') INUCLI
         END IF
                                                 I_MODE=0
         CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,I_FLAG,
     *                             CHISQU_AUXIL1,CHISQU_AUXIL2)
C_______________________________________________________________________
C     
         RMSTHE_PRONUC(INUCLI)=RMSTHE_PROTON
         LEVTHE_PRONUC(INUCLI)=LEVTHE_PROTON
         
         DO ITHEOR=1,LEVTHE_PROTON
            ENETHE_PRONUC(ITHEOR,INUCLI)=ENETHE_PROTON(ITHEOR)
            LABTHE_PRONUC(ITHEOR,INUCLI)=LABTHE_PROTON(ITHEOR)
         END DO
C_______________________________________________________________________
C         
         RMSTHE_NEUNUC(INUCLI)=RMSTHE_NEUTRS
         LEVTHE_NEUNUC(INUCLI)=LEVTHE_NEUTRS
         
         DO ITHEOR=1,LEVTHE_PROTON
            ENETHE_NEUNUC(ITHEOR,INUCLI)=ENETHE_NEUTRS(ITHEOR)
            LABTHE_NEUNUC(ITHEOR,INUCLI)=LABTHE_NEUTRS(ITHEOR)
         END DO
C_______________________________________________________________________
C
C        Calculating the TOTAL degenerancy of all the nuclei
C
         DO IEXPER=1,LEVEXP_PROTON(INUCLI)
            IDEG_P=IDEG_P+IDEGEX_PROTON(INUCLI,IEXPER)
         END DO
C
         DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
            IDEG_N=IDEG_N+IDEGEX_NEUTRS(INUCLI,IEXPER)
         END DO
C_______________________________________________________________________
C                  
         EABSAV_PRONUC(INUCLI)=EABSAV_PROTON
         EABSAV_NEUNUC(INUCLI)=EABSAV_NEUTRS
         
         ERRMAX_PRONUC(INUCLI)=ERRMAX_PROTON
         ERRMAX_NEUNUC(INUCLI)=ERRMAX_NEUTRS
         
         RMSVAL_PRONUC(INUCLI)=SQRT(CHIWEI_PROTON)
         RMSVAL_NEUNUC(INUCLI)=SQRT(CHIWEI_NEUTRS)
         
         RMSGLO_PROTON=RMSGLO_PROTON+CHIWEI_PROTON
         RMSGLO_NEUTRS=RMSGLO_NEUTRS+CHIWEI_NEUTRS

         RMSGLO_PROAUX=RMSGLO_PROAUX+CHIDEG_PROTON
         RMSGLO_NEUAUX=RMSGLO_NEUAUX+CHIDEG_NEUTRS
C
         IF (ITAKNU(INUCLI).EQ.1) THEN
C
             RMSGLO_TAKPRO=RMSGLO_TAKPRO+CHIDEG_PROTON
             RMSGLO_TAKNEU=RMSGLO_TAKNEU+CHIDEG_NEUTRS
C
             RMSVAL_TAKPRO(INUCLI)=RMSVAL_PRONUC(INUCLI)
             RMSVAL_TAKNEU(INUCLI)=RMSVAL_NEUNUC(INUCLI)
C
             DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                IDEGEN_TAKPRO=IDEGEN_TAKPRO+IDEGEX_PROTON(INUCLI,IEXPER)
             END DO
C
             DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                IDEGEN_TAKNEU=IDEGEN_TAKNEU+IDEGEX_NEUTRS(INUCLI,IEXPER)
             END DO
C
         END IF
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_PROTON,0,-1
            DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
C
               ENERUP_PRONUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERUP_AUXPRO(LQNUMB,NWSNUM)
C
               ENERDN_PRONUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERDN_AUXPRO(LQNUMB,NWSNUM)
C
               DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
C
                  CMATUP_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATUP_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
C
                  CMATDN_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATDN_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
C
               END DO
C
            END DO
         END DO  
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_NEUTRS,0,-1
            DO NWSNUM=1,(NSHELL_NEUTRS-LQNUMB)/2+1
C
               ENERUP_NEUNUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERUP_AUXNEU(LQNUMB,NWSNUM)
C
               ENERDN_NEUNUC(LQNUMB,NWSNUM,INUCLI)
     *        =
     *         ENERDN_AUXNEU(LQNUMB,NWSNUM)
C
               DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
C
                  CMATUP_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATUP_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
C
                  CMATDN_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
     *           =CMATDN_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
C
               END DO
C
            END DO
         END DO   
C_______________________________________________________________________
C          
      END DO !INUCLI
C_______________________________________________________________________
C      
      RMSGLO_PROTON=SQRT(RMSGLO_PROTON)
      RMSGLO_NEUTRS=SQRT(RMSGLO_NEUTRS)
C
      RMSGLO_PROAUX=SQRT(RMSGLO_PROAUX/IDEG_P)
      RMSGLO_NEUAUX=SQRT(RMSGLO_NEUAUX/IDEG_N)
C
      RMSGLO_TAKPRO=SQRT(RMSGLO_TAKPRO/IDEGEN_TAKPRO)
      RMSGLO_TAKNEU=SQRT(RMSGLO_TAKNEU/IDEGEN_TAKNEU)
C
C=======================================================================
C
C     Re-naming to have the right value for the lambdas
C     
      DO IPARAM=1,NDPARS
         PARPOT_PRINTG(IPARAM)=PARPOT(IPARAM)
      END DO
C
C=======================================================================
C     
      DO INUCLI=1,LDNUCL
          
         IZ_FIX=NUMB_Z(INUCLI)
         IN_FIX=NUMB_N(INUCLI)

         CALL INTROD(INUCLI)
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_PROTON,0,-1
            DO NWSNUM=1,(NSHELL_PROTON-LQNUMB)/2+1
C
               ENERUP_AUXPRO(LQNUMB,NWSNUM)
     *        =
     *         ENERUP_PRONUC(LQNUMB,NWSNUM,INUCLI)
C
               ENERDN_AUXPRO(LQNUMB,NWSNUM)
     *        =
     *         ENERDN_PRONUC(LQNUMB,NWSNUM,INUCLI)
C
               DO N1NUMB=0,(NSHELL_PROTON-LQNUMB)/2
C
                  CMATUP_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATUP_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
                  CMATDN_AUXPRO(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATDN_PRONUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
               END DO
C
            END DO
         END DO  
C_______________________________________________________________________
C
         DO LQNUMB=NSHELL_NEUTRS,0,-1
            DO NWSNUM=1,(NSHELL_NEUTRS-LQNUMB)/2+1
C
               ENERUP_AUXNEU(LQNUMB,NWSNUM)
     *        =
     *         ENERUP_NEUNUC(LQNUMB,NWSNUM,INUCLI)
C
               ENERDN_AUXNEU(LQNUMB,NWSNUM)
     *        =
     *         ENERDN_NEUNUC(LQNUMB,NWSNUM,INUCLI)
C
               DO N1NUMB=0,(NSHELL_NEUTRS-LQNUMB)/2
C
                  CMATUP_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATUP_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
                  CMATDN_AUXNEU(LQNUMB,N1NUMB+1,NWSNUM)
     *           =CMATDN_NEUNUC(LQNUMB,N1NUMB+1,NWSNUM,INUCLI)
C
               END DO
C
            END DO
         END DO   
C_______________________________________________________________________
C         
                                  IFITED=0
         IF (ITAKNU(INUCLI).EQ.1) IFITED=1
             
         IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
         
             ISOSPI=1
             
             ERRMAX_PRINTG=ERRMAX_PRONUC(INUCLI)
C             EABSAV_PRINTG=EABSAV_PRONUC(INUCLI)
             RMSVAL_PRINTG=RMSVAL_PRONUC(INUCLI)
             
             RMSEXP_PRINTG=RMSEXP_PROTON(INUCLI)
             RMSTHE_PRINTG=RMSTHE_PRONUC(INUCLI)
             LEVTHE_PRINTG=LEVTHE_PRONUC(INUCLI)
             
             DO ITHEOR=1,LEVTHE_PRINTG
                ENETHE_PRINTG(ITHEOR)=ENETHE_PRONUC(ITHEOR,INUCLI)
                LABTHE_PRINTG(ITHEOR)=LABTHE_PRONUC(ITHEOR,INUCLI)
             END DO
             
             CALL WRITIN_ENELEV(ISOSPI,IRANDO_PRINTG,LDRAND,
     *                                        IEVALU_PRINTG,
     *                          PARPOT_PRINTG,CHISQU_MINIML,
     *                          CHIGRD_PRINTG,ERRMAX_PRINTG,
     *                          RMSVAL_PRINTG,RMSGLO_PROAUX,
     *                          RMSEXP_PRINTG,RMSTHE_PRINTG,
     *                          LEVTHE_PRINTG,ENETHE_PRINTG,
     *                          LABTHE_PRINTG,INUCLI)
         END IF
C_______________________________________________________________________
C         
         IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
         
             ISOSPI=0
             
             ERRMAX_PRINTG=ERRMAX_NEUNUC(INUCLI)
C             EABSAV_PRINTG=EABSAV_NEUNUC(INUCLI)
             RMSVAL_PRINTG=RMSVAL_NEUNUC(INUCLI)
             
             RMSEXP_PRINTG=RMSEXP_NEUTRS(INUCLI)
             RMSTHE_PRINTG=RMSTHE_NEUNUC(INUCLI)
             LEVTHE_PRINTG=LEVTHE_NEUNUC(INUCLI)
             
             DO ITHEOR=1,LEVTHE_PRINTG
                ENETHE_PRINTG(ITHEOR)=ENETHE_NEUNUC(ITHEOR,INUCLI)
                LABTHE_PRINTG(ITHEOR)=LABTHE_NEUNUC(ITHEOR,INUCLI)
             END DO
             
             CALL WRITIN_ENELEV(ISOSPI,IRANDO_PRINTG,LDRAND,
     *                                        IEVALU_PRINTG,
     *                          PARPOT_PRINTG,CHISQU_MINIML,
     *                          CHIGRD_PRINTG,ERRMAX_PRINTG,
     *                          RMSVAL_PRINTG,RMSGLO_NEUAUX,
     *                          RMSEXP_PRINTG,RMSTHE_PRINTG,
     *                          LEVTHE_PRINTG,ENETHE_PRINTG,
     *                          LABTHE_PRINTG,INUCLI)
         END IF
C_______________________________________________________________________
C         
         IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
         
             ISOSPI=1
             
             ERRMAX_PRINTG=ERRMAX_PRONUC(INUCLI)
C             EABSAV_PRINTG=EABSAV_PRONUC(INUCLI)
             RMSVAL_PRINTG=RMSVAL_PRONUC(INUCLI)
             
             RMSEXP_PRINTG=RMSEXP_PROTON(INUCLI)
             RMSTHE_PRINTG=RMSTHE_PRONUC(INUCLI)
             LEVTHE_PRINTG=LEVTHE_PRONUC(INUCLI)
             
             DO ITHEOR=1,LEVTHE_PRINTG
                ENETHE_PRINTG(ITHEOR)=ENETHE_PRONUC(ITHEOR,INUCLI)
                LABTHE_PRINTG(ITHEOR)=LABTHE_PRONUC(ITHEOR,INUCLI)
             END DO
             
             CALL WRITIN_ENELEV(ISOSPI,IRANDO_PRINTG,LDRAND,
     *                                        IEVALU_PRINTG,
     *                          PARPOT_PRINTG,CHISQU_MINIML,
     *                          CHIGRD_PRINTG,ERRMAX_PRINTG,
     *                          RMSVAL_PRINTG,RMSGLO_PROAUX,
     *                          RMSEXP_PRINTG,RMSTHE_PRINTG,
     *                          LEVTHE_PRINTG,ENETHE_PRINTG,
     *                          LABTHE_PRINTG,INUCLI)
C_______________________________________________________________________
C     
             ISOSPI=0
             
             ERRMAX_PRINTG=ERRMAX_NEUNUC(INUCLI)
C             EABSAV_PRINTG=EABSAV_NEUNUC(INUCLI)
             RMSVAL_PRINTG=RMSVAL_NEUNUC(INUCLI)
             
             RMSEXP_PRINTG=RMSEXP_NEUTRS(INUCLI)
             RMSTHE_PRINTG=RMSTHE_NEUNUC(INUCLI)
             LEVTHE_PRINTG=LEVTHE_NEUNUC(INUCLI)
             
             DO ITHEOR=1,LEVTHE_PRINTG
                ENETHE_PRINTG(ITHEOR)=ENETHE_NEUNUC(ITHEOR,INUCLI)
                LABTHE_PRINTG(ITHEOR)=LABTHE_NEUNUC(ITHEOR,INUCLI)
             END DO
             
             CALL WRITIN_ENELEV(ISOSPI,IRANDO_PRINTG,LDRAND,
     *                                        IEVALU_PRINTG,
     *                          PARPOT_PRINTG,CHISQU_MINIML,
     *                          CHIGRD_PRINTG,ERRMAX_PRINTG,
     *                          RMSVAL_PRINTG,RMSGLO_NEUAUX,
     *                          RMSEXP_PRINTG,RMSTHE_PRINTG,
     *                          LEVTHE_PRINTG,ENETHE_PRINTG,
     *                          LABTHE_PRINTG,INUCLI)
         END IF
C
C=======================================================================
C     
C        Printing the results in the standard output
C
         IF (LOGWRI.GT.0) THEN 
             WRITE(NOUTPT,'()')
       
             WRITE(NOUTPT,'(80(''#''),/,''#'',78X,''#'')')
             WRITE(NOUTPT,'(''#'',20X,''IZ_FIX='',I3,20X,''IN_FIX='',I3,
     *                                   18X,''#'',/,''#'',78X,''#'')')
     *                         IZ_FIX,IN_FIX
             WRITE(NOUTPT,'(80(''#''),/,''#'',78X,''#'')')
             WRITE(NOUTPT,'(''#'',2X,''NEUTRONS: Theoretical vs. '',
     *                      ''Experimental Energies'',29x,''#'')')
             WRITE(NOUTPT,'(''#'',78X,''#'',/,80(''#''))')
             WRITE(NOUTPT,'(''#'',78X,''#'')')
       
             WRITE(NOUTPT,'(''#'',3X,''No)'',7x,''Labels'',7x,
     *          ''EneThe'',14X,''No)'',7x,''Labels'',7x,''EneExp'',3X,
     *                                                    ''#'')')
       
             DO ITHEOR=1,LEVTHE_NEUNUC(INUCLI)
           
                DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                   IF (LABEXP_NEUTRS(INUCLI,IEXPER).EQ.
     *                 LABTHE_NEUNUC(ITHEOR,INUCLI))THEN
                       WRITE(NOUTPT,'(''#'',i5,'')'',7x,a6,f20.13,
     *                          4X,i5,'')'',7x,a6,f15.4,1X,''#'')')
     *                                  ITHEOR,
     *                                  LABTHE_NEUNUC(ITHEOR,INUCLI),
     *                                  ENETHE_NEUNUC(ITHEOR,INUCLI),
     *                                  IEXPER,
     *                                  LABEXP_NEUTRS(INUCLI,IEXPER),
     *                                  EXPEXP_NEUTRS(INUCLI,IEXPER)
                       GO TO 3
                   END IF
                END DO
           
                WRITE(NOUTPT,'(''#'',i5,'')'',7x,a6,f20.13,39X,''#'')')    
     *                         ITHEOR,LABTHE_NEUNUC(ITHEOR,INUCLI),
     *                                ENETHE_NEUNUC(ITHEOR,INUCLI)
  3             CONTINUE
             END DO
       
             WRITE(NOUTPT,'(''#'',78X,''#'',/,80(''#''),/,
     *                                 ''#'',78X,''#'')')
       
             WRITE(NOUTPT,'(''#'',2X,''PROTONS: Theoretical vs. '',
     *                           ''Experimental Energies'',30x,''#'')')
             WRITE(NOUTPT,'(''#'',78X,''#'',/,80(''#''))')
             WRITE(NOUTPT,'(''#'',78X,''#'')')
       
             WRITE(NOUTPT,'(''#'',3X,''No)'',7x,''Labels'',7x,
     *           ''EneThe'',14X,''No)'',7x,''Labels'',7x,''EneExp'',3X,
     *                                                    ''#'')')
       
              DO ITHEOR=1,LEVTHE_PROTON
           
                 DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                    IF (LABEXP_PROTON(INUCLI,IEXPER).EQ.
     *                  LABTHE_PRONUC(ITHEOR,INUCLI)) THEN
                        WRITE(NOUTPT,'(''#'',i5,'')'',7x,a6,f20.13,
     *                          4X,i5,'')'',7x,a6,f15.4,1X,''#'')')
     *                                  ITHEOR,
     *                                  LABTHE_PRONUC(ITHEOR,INUCLI),
     *                                  ENETHE_PRONUC(ITHEOR,INUCLI),
     *                                  IEXPER,
     *                                  LABEXP_PROTON(INUCLI,IEXPER),
     *                                  EXPEXP_PROTON(INUCLI,IEXPER)
                        GO TO 4
                    END IF
                 END DO
           
                 WRITE(NOUTPT,'(''#'',i5,'')'',7x,a6,f20.13,39X,''#'')')
     *                           ITHEOR,LABTHE_PRONUC(ITHEOR,INUCLI),
     *                                  ENETHE_PRONUC(ITHEOR,INUCLI)
  4             CONTINUE
             END DO
       
             WRITE(NOUTPT,'(''#'',78X,''#'',/,80(''#''))')
C
         END IF
C
C=======================================================================
C
C        Now, preparing outputs for density-dependent functions
C
C=======================================================================
C
         ISPLIT=0
         CURNAM='Dens-'
C_______________________________________________________________________
C
C        Total Proton Densities: Theory vs. Experiment
C
         ISOSPI=1
C
         N_CURV=2
C                        
         DO I_CURV=1,N_CURV
            ND_MAX(I_CURV)=60
         END DO
C
         IARG_R=1
         IARG_Z=0
C                        
         AOSCIL=AOSCIL_PROTON(INUCLI)
         RADCUT=RADIUS_CUTOFF(INUCLI)
C
         IF (IF_PAI.EQ.0) CURLAB='$\\rho^{th}_{\\pi}(r)$'
         IF (IF_PAI.EQ.1) CURLAB='$\\rho^{pair}_{\\pi}(r)$'
C                        
         DO IPOINT=1,ND_MAX(I_CURV)
C           
            RARGUM=0.0001+(IPOINT-1)*0.2 
C           
            X_CURV(IPOINT,1)=RARGUM
            Y_CURV(IPOINT,1)=DENSIT(RARGUM)
            L_CURV(IPOINT,1)=CURLAB
C
            X_CURV(IPOINT,2)=RARGUM
            Y_CURV(IPOINT,2)=DENEXP(RARGUM)
            L_CURV(IPOINT,2)='$\\rho^{exp}_{\\pi}(r)$'
C                        
         END DO
C                     
         MAIN_T='Proton Density Profiles'
         XTITLE='r (fm)'
         YTITLE='Density (N/fm$^3$)'
         ISOSPI=1 
C                     
         CALL DENSIT_OUTPUT(CURNAM,N_CURV,ND_MAX,X_CURV,Y_CURV,L_CURV,
     *                      ISOSPI,IZ_FIX,IN_FIX,MAIN_T,XTITLE,YTITLE,
     *                                           ISPLIT,INUCLI,LDRAND) 
C_______________________________________________________________________
C
C        Total Neutron Density: Theory
C
         ISOSPI=0
C
         N_CURV=1
         ND_MAX(I_CURV)=60
C
         IARG_R=1
         IARG_Z=0
C
         AOSCIL=AOSCIL_NEUTRS(INUCLI)
         IF (IF_PAI.EQ.0) CURLAB='$\\rho^{th}_{\\nu}(r)$'
         IF (IF_PAI.EQ.1) CURLAB='$\\rho^{pair}_{\\nu}(r)$'
C                        
         DO IPOINT=1,ND_MAX(I_CURV)
C           
            RARGUM=0.0001+(IPOINT-1)*0.2 
C           
            X_CURV(IPOINT,1)=RARGUM
            Y_CURV(IPOINT,1)=DENSIT(RARGUM)
            L_CURV(IPOINT,1)=CURLAB
C                        
         END DO
C                     
         MAIN_T='Neutron Density Profile'
         XTITLE='r (fm)'
         YTITLE='Density (N/fm$^3$)'
         ISOSPI=0 
C                     
         CALL DENSIT_OUTPUT(CURNAM,N_CURV,ND_MAX,X_CURV,Y_CURV,L_CURV,
     *                      ISOSPI,IZ_FIX,IN_FIX,MAIN_T,XTITLE,YTITLE,
     *                                           ISPLIT,INUCLI,LDRAND)  
C
C=======================================================================
C
C        Level densities summed one after the other
C        First protons, then neutrons
C_______________________________________________________________________
C
         ISPLIT=1                
         CURNAM='RhoS-'
         ND_MAX_AUXIL=60
C_______________________________________________________________________
C                    
         ISOSPI=1
C                     
         DO IPOINT=1,ND_MAX_AUXIL
C                        
            XPOINT=0.0001+(IPOINT-1)*0.2
C                        
            ZARGUM=(XPOINT/AOSCIL_PROTON(INUCLI))**2
C
            CALL RHONLJ_SUMMED(INUCLI,ISOSPI,ZARGUM,
     *                         IPOINT,N_CURV,Y_CURV,L_CURV)
C     
            DO I_CURV=1,N_CURV
C                           
               X_CURV(IPOINT,I_CURV)=XPOINT
               ND_MAX(I_CURV)=ND_MAX_AUXIL
C                           
            END DO
C     
         END DO
                     
         WRITE(MAIN_T,'(''Calculated Proton Density Profiles'')')
         XTITLE='r (fm)'
         YTITLE='Density (N/fm$^3$)'
C                     
         CALL DENSIT_OUTPUT(CURNAM,N_CURV,ND_MAX,X_CURV,Y_CURV,L_CURV,
     *                      ISOSPI,IZ_FIX,IN_FIX,MAIN_T,XTITLE,YTITLE,
     *                                           ISPLIT,INUCLI,LDRAND)
C_______________________________________________________________________
C                     
         ISOSPI=0
C                     
         DO IPOINT=1,ND_MAX_AUXIL
C                        
            XPOINT=0.0001+(IPOINT-1)*0.2
C                        
            ZARGUM=(XPOINT/AOSCIL_NEUTRS(INUCLI))**2
C
            CALL RHONLJ_SUMMED(INUCLI,ISOSPI,ZARGUM,
     *                         IPOINT,N_CURV,Y_CURV,L_CURV)
C     
            DO I_CURV=1,N_CURV
C                           
               X_CURV(IPOINT,I_CURV)=XPOINT
               ND_MAX(I_CURV)=ND_MAX_AUXIL
C                           
            END DO
C     
         END DO
                     
         WRITE(MAIN_T,'(''Calculated Neutron Density Profiles'')')
         XTITLE='r (fm)'
         YTITLE='Density (N/fm$^3$)'
C                     
         CALL DENSIT_OUTPUT(CURNAM,N_CURV,ND_MAX,X_CURV,Y_CURV,L_CURV,
     *                      ISOSPI,IZ_FIX,IN_FIX,MAIN_T,XTITLE,YTITLE,
     *                                           ISPLIT,INUCLI,LDRAND)
C
C=======================================================================
C       
      END DO  !INUCLI
C
C=======================================================================
C 
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(12X,''Exiting FINISH_LMMINI'')')
      END IF
C
C=======================================================================
C
      RETURN
      END           
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE MESHIN_MAPING(LDRAND)
C
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/NDPARS.f'
      INCLUDE  'MATDIM/NDTITL.f'
      INCLUDE  'MATDIM/NDIM_M.f'
      INCLUDE  'MATDIM/NDMESH.f'
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDLEXP.f'
      INCLUDE  'MATDIM/NDLAST.f'
C
      PARAMETER
     *         (NDMES2=NDMESH*NDMESH)
C
      CHARACTER
     *          INPSYM*6,TYPCHI*6,TAKCHI*3,NUCSYM*6
      CHARACTER
     *          TITPAR*13,TITMSH*8,TITLES*12,TITAUX*7,TAKPAR*3,
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010
C
      DIMENSION
     *          ARGMNT(1:NDPARS)
      DIMENSION
     *          INDEXI(1:NDIM_M),MCOUNT(1:NDIM_M),
     *          STPMSH(1:NDIM_M),MAXMSH(1:NDPARS)
      DIMENSION
     *          PARMSH(1:NDIM_M,1:NDMESH),
     *          AXSMAP(1:NDMESH,1:NDMESH)
      DIMENSION
     *          TITPAR(1:NDPARS),TITMSH(1:NDPARS),
     *          TAKCHI(1:NDNUCL),TITAUX(1:NDIM_M),
     *                           TAKPAR(1:NDIM_M)
      DIMENSION
     *          CHITOT_OFMESH(1:NDMESH,1:NDMESH),
     *          CHIPRO_OFMESH(1:NDMESH,1:NDMESH),
     *          CHINEU_OFMESH(1:NDMESH,1:NDMESH)
      DIMENSION
     *          PARPOT_OFMESH(1:NDMESH,1:NDMESH,1:NDPARS),
     *          PARPOT_PRINTI(1:NDPARS,1:NDMES2)
      DIMENSION
     *          RMSMAP_PRONUC(1:NDMESH,1:NDMESH,1:NDNUCL),
     *          RMSMAP_NEUNUC(1:NDMESH,1:NDMESH,1:NDNUCL)
      DIMENSION
     *          RMSMAP_PROGLO(1:NDMESH,1:NDMESH,1:NDNUCL),
     *          RMSMAP_NEUGLO(1:NDMESH,1:NDMESH,1:NDNUCL)
C
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /ARGINI/ XINITS(1:NDPARS)
      COMMON
     *       /MESHIN/ I_MESH(1:NDPARS),
     *                XMIN_I(1:NDPARS),
     *                XMAX_I(1:NDPARS),
     *                MAXPAR(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /VLIMIT/ VMISTR(1:NDPARS),
     *                VMIMIN(1:NDPARS),
     *                VMIMAX(1:NDPARS),
     *                VMISTP(1:NDPARS)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI  
      COMMON
     *       /DENSTR/ IFDENS
     *       /TENSOR/ IFTENS  
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON
     *       /FEVALS/ IFUNCT_EVALUS
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                              LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                              LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR    
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS 
      COMMON
     *       /NUCWEI/ WEINUC_PROTON(1:NDNUCL),
     *                WEINUC_NEUTRS(1:NDNUCL),
     *                WEIRAD_PROTON(1:NDNUCL),
     *                WEIRAD_NEUTRS(1:NDNUCL)
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================     
C
      IDEFCN=1
C
C=======================================================================
C         Over which parameters we are going to minimise --> ARGMNT(I)
C=======================================================================
C        
      ICOUNT_OFPARS=0
C
      IFPROT=0
      IFNEUT=0
      IFBOTH=0
C
      DO I=1,NDPARS
         IF (IFTAKE(I).EQ.1) THEN
C
             ICOUNT_OFPARS=ICOUNT_OFPARS+1
             ARGMNT(ICOUNT_OFPARS)=VMISTR(I)
             TITPAR(ICOUNT_OFPARS)=TITLES(I)(3:10)
C
             IF (I.LE.20 .AND. IFDENS.EQ.0) THEN
                 IFPROT=1
             END IF
             IF (I.GT.20 .AND. IFDENS.EQ.0) THEN
                 IFNEUT=1
             END IF
             IF (I.GE.51 .AND. IFDENS.EQ.0) THEN
                 IFPROT=0
                 IFNEUT=0
                 IFBOTH=1
             END IF
C
         END IF
      END DO
C
C=======================================================================     
C         Which parameters stay 'fixed' --> p_i and p_j --> PARMSH(N,M)
C=======================================================================
C          
      ICOUNT_OFMESH=0
C
      DO IPARAM=1,NDPARS
C
         IF (I_MESH(IPARAM).EQ.1) THEN
C
             IF (ICOUNT_OFPARS.EQ.0) THEN
                 IF (IPARAM.LE.20 .AND. IFDENS.EQ.0) IFPROT=1
                 IF (IPARAM.GT.20 .AND. IFDENS.EQ.0) IFNEUT=1
                 IF (IPARAM.GE.51 .AND. IFDENS.EQ.0) THEN
                     IFPROT=0
                     IFNEUT=0
                     IFBOTH=1
                 END IF
             END IF
C
             ICOUNT_OFMESH=ICOUNT_OFMESH+1
C
             STPMSH(IPARAM)=(XMAX_I(IPARAM)-XMIN_I(IPARAM))
     *                     /(MAXPAR(IPARAM)-1)
C
             MAXMSH(ICOUNT_OFMESH)=MAXPAR(IPARAM)
C
             INDEXI(ICOUNT_OFMESH)=IPARAM
C
             WRITE(TITMSH(ICOUNT_OFMESH),'(A8)')TITLES(IPARAM)(3:10)
C
             DO K=1,MAXPAR(IPARAM)
                AXSMAP(ICOUNT_OFMESH,K)=XMIN_I(IPARAM)
     *                                 +(K-1)*STPMSH(IPARAM)
                IF (MAXPAR(IPARAM).EQ.1) THEN
                    AXSMAP(ICOUNT_OFMESH,K)=XMIN_I(IPARAM)
                END IF
             END DO
C
         END IF
C
      END DO
C
      IF (ICOUNT_OFMESH.NE.2) THEN
C
          WRITE(LSCREN,'(''ALARM from MESHIN_MAPING: '',
     *                   ''ICOUNT_OFMESH='',I2,''when it has to be '',
     *                   ''equal to 2!! - Change the input file '')')
     *                    ICOUNT_OFMESH
          STOP 'Stop - Change the input file in MESH option'
C
      END IF
C
      ICMESH=ICOUNT_OFMESH
C
C=======================================================================     
C         
      NTOTAL_OFMESH=MAXMSH(1)*MAXMSH(2)
      NCOUNT_OFMESH=0
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(''Entering OPENIN_MESHPM from Main'')')
      END IF
CID      CALL OPENIN_MESHPM(LDRAND,TITMSH,ICOUNT_OFPARS,NTOTAL_OFMESH,
CID     *                                                      MAXMSH)
C
C=======================================================================     
C
      RMSPRO_MAXIMA=-1E+10
      RMSPRO_MINIMI=+1E+10
C
      RMSNEU_MAXIMA=-1E+10
      RMSNEU_MINIMI=+1E+10
C
C=======================================================================     
C         
      IPARA1=INDEXI(1)
      IPARA2=INDEXI(2)
C
      DO INDEX1=1,MAXMSH(1)
C
         MCOUNT(1)=INDEX1
C
         XINITS(IPARA1)=XMIN_I(IPARA1)+(INDEX1-1)*STPMSH(IPARA1)
C
         IF (MAXMSH(1).EQ.1) XINITS(IPARA1)=XMIN_I(IPARA1)
C
         DO INDEX2=1,MAXMSH(2)
C
            MCOUNT(2)=INDEX2
C
            XINITS(IPARA2)=XMIN_I(IPARA2)+(INDEX2-1)*STPMSH(IPARA2)
C
            IF (MAXMSH(2).EQ.1) XINITS(IPARA2)=XMIN_I(IPARA2)
C
            NCOUNT_OFMESH=NCOUNT_OFMESH+1
C
C=======================================================================
C 
C           Calling the minimisation subroutine. 
C           We are inside the INDEX1 and INDEX2 do-loops.
C
            IF (ICOUNT_OFPARS.GT.0) THEN  ! Tabulating and Minimisation
C
                CALL LMMESH(NEWSED,ARGMNT,I_SEED,LDRAND,LEVNUM,
     *                      NTOTAL_OFMESH,NCOUNT_OFMESH,TITMSH,
     *                      ICMESH,ICOUNT_OFPARS,CHITOT_MINAUX,
     *                             CHISQU_PROAUX,CHISQU_NEUAUX,
     *                                    PARPOT_PRINTI,NDLAST)
C
                DO KPARAM=1,NDPARS
                   PARPOT(KPARAM)=PARPOT_PRINTI(KPARAM,NCOUNT_OFMESH)
                END DO
C_______________________________________________________________________
C
C              Once we have the vector of parameters, we enter to 
C              WS_RUN to calculate the RMSEnergy values that will
C                                                       be Mapped
C
               IDEG_P=0
               IDEG_N=0
               RMSGLO_TAKPRO=0.
               RMSGLO_TAKNEU=0.
C
               DO INUCLI=1,LDNUCL
                  IF (ITAKNU(INUCLI).EQ.1) THEN 
                      IZ_FIX=NUMB_Z(INUCLI)
                      IN_FIX=NUMB_N(INUCLI)
C
                      IF (LOGWRI.GT.4) THEN
                          WRITE(LOGFIL,'(12X,''Entering WS_RUN from '',
     *                                       ''MESHIN_MAPING '',
     *                                       ''INUCLI='',I2)') INUCLI
                      END IF
C
                      I_MODE=0
                      I_FLAG=1
C
                      CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,
     *                            I_FLAG,CHISQU_PROTON,CHISQU_NEUTRS)
C 
                      RMSMAP_PRONUC(INDEX1,INDEX2,INUCLI)
     *               =
     *                SQRT(CHIWEI_PROTON)
C
                      RMSMAP_NEUNUC(INDEX1,INDEX2,INUCLI)
     *               =
     *                SQRT(CHIWEI_NEUTRS)
C
C_______________________________________________________________________
C
C          Calculating the TOTAL degenerancy of the active nuclei
C
                      DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                         IDEG_P=IDEG_P+IDEGEX_PROTON(INUCLI,IEXPER)
                      END DO
C
                      DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                         IDEG_N=IDEG_N+IDEGEX_NEUTRS(INUCLI,IEXPER)
                      END DO
C
                      RMSGLO_TAKPRO=RMSGLO_TAKPRO+CHIDEG_PROTON
                      RMSGLO_TAKNEU=RMSGLO_TAKNEU+CHIDEG_NEUTRS
C
C=======================================================================
C
C                     Searching the RMSMAP maximum/minimum values
C
                      IF (RMSPRO_MAXIMA.LT.
     *                    RMSMAP_PRONUC(INDEX1,INDEX2,INUCLI)) THEN
                          RMSPRO_MAXIMA
     *                   =
     *                    RMSMAP_PRONUC(INDEX1,INDEX2,INUCLI)
                      END IF
C
                      IF (RMSPRO_MINIMI.GT.
     *                    RMSMAP_PRONUC(INDEX1,INDEX2,INUCLI)) THEN
                          RMSPRO_MINIMI
     *                   =
     *                    RMSMAP_PRONUC(INDEX1,INDEX2,INUCLI)
                      END IF
C
                      IF (RMSNEU_MAXIMA.LT.
     *                    RMSMAP_NEUNUC(INDEX1,INDEX2,INUCLI)) THEN
                          RMSNEU_MAXIMA
     *                   =
     *                    RMSMAP_NEUNUC(INDEX1,INDEX2,INUCLI)
                      END IF
C
                      IF (RMSNEU_MINIMI.GT.
     *                    RMSMAP_NEUNUC(INDEX1,INDEX2,INUCLI)) THEN
                          RMSNEU_MINIMI
     *                   =
     *                    RMSMAP_NEUNUC(INDEX1,INDEX2,INUCLI)
                      END IF
C
                  END IF
C
               END DO 
C
               RMSMAP_PROGLO(INDEX1,INDEX2,LDNUCL+1)
     *        =
     *         SQRT(RMSGLO_TAKPRO/IDEG_P)
C
               RMSMAP_NEUGLO(INDEX1,INDEX2,LDNUCL+1)
     *        =
     *         SQRT(RMSGLO_TAKNEU/IDEG_N)
C            
               DO IPARAM=1,NDPARS
                  PARPOT_OFMESH(INDEX1,INDEX2,IPARAM)
     *           =
     *            PARPOT_PRINTI(IPARAM,NCOUNT_OFMESH)
C
               END DO
C
            END IF
C
C=======================================================================
C
            IF (ICOUNT_OFPARS.EQ.0) THEN ! Only Tabulating,
C                                          NO Minimisation

                CALL TBMESH(IPARA1,IPARA2,INDEX1,INDEX2,LEVNUM,
     *                             CHITOT_MINAUX,CHISQU_PROAUX,
     *                             CHISQU_NEUAUX,PARPOT_PRINTI,
     *                             RMSMAP_PRONUC,RMSMAP_NEUNUC,
     *                             RMSMAP_PROGLO,RMSMAP_NEUGLO,
     *                             RMSPRO_MAXIMA,RMSPRO_MINIMI,
     *                             RMSNEU_MAXIMA,RMSNEU_MINIMI)
C
                DO IPARAM=1,NDPARS
                   PARPOT_OFMESH(INDEX1,INDEX2,IPARAM)
     *            =
     *             PARPOT(IPARAM)
                END DO
C                
            END IF
C
C=======================================================================
C            
         END DO !INDEX2
C        
      END DO !INDEX1
C
C=======================================================================
C         Writing MAP results in a file  
C=======================================================================
C
C     First, each nucleus individually
C
      DO INUCLI=1,LDNUCL
         IF(ITAKNU(INUCLI).EQ.1) THEN 
C
            WRITE(LOGFIL,'(''Entering WRITIN_CHIMAP with INUCLI= '',
     *                        I3,''from MESHIN_MAPING'')') INUCLI
C
            IZ_FIX=NUMB_Z(INUCLI)
            IN_FIX=NUMB_N(INUCLI)
C
            ISOSPI=1
            CALL WRITIN_CHIMAP(NDMESH,LDRAND,ICOUNT_OFPARS,
     *                         TITPAR,TITMSH,RMSPRO_MINIMI,
     *                         RMSPRO_MAXIMA,RMSNEU_MINIMI,
     *                         RMSNEU_MAXIMA,MAXMSH,AXSMAP,
     *                         RMSMAP_PRONUC,RMSMAP_NEUNUC,
     *                         PARPOT_OFMESH,INDEXI,INUCLI)
C
            ISOSPI=0
            CALL WRITIN_CHIMAP(NDMESH,LDRAND,ICOUNT_OFPARS,
     *                         TITPAR,TITMSH,RMSPRO_MINIMI,
     *                         RMSPRO_MAXIMA,RMSNEU_MINIMI,
     *                         RMSNEU_MAXIMA,MAXMSH,AXSMAP,
     *                         RMSMAP_PRONUC,RMSMAP_NEUNUC,
     *                         PARPOT_OFMESH,INDEXI,INUCLI)
         END IF
      END DO
C
C     Then, the global results
C
      INUCLI=LDNUCL+1
      IZ_FIX=000
      IN_FIX=000
C
      ISOSPI=11
      CALL WRITIN_CHIMAP(NDMESH,LDRAND,ICOUNT_OFPARS,
     *                   TITPAR,TITMSH,RMSPRO_MINIMI,
     *                   RMSPRO_MAXIMA,RMSNEU_MINIMI,
     *                   RMSNEU_MAXIMA,MAXMSH,AXSMAP,
     *                   RMSMAP_PROGLO,RMSMAP_NEUGLO,
     *                   PARPOT_OFMESH,INDEXI,INUCLI)
C
      ISOSPI=10
      CALL WRITIN_CHIMAP(NDMESH,LDRAND,ICOUNT_OFPARS,
     *                   TITPAR,TITMSH,RMSPRO_MINIMI,
     *                   RMSPRO_MAXIMA,RMSNEU_MINIMI,
     *                   RMSNEU_MAXIMA,MAXMSH,AXSMAP,
     *                   RMSMAP_PROGLO,RMSMAP_NEUGLO,
     *                   PARPOT_OFMESH,INDEXI,INUCLI)
C
C=======================================================================
C
      RETURN
      END     
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE LMMESH(NEWSED,ARGPAR,I_SEED,LDRAND,LEVNUM,
     *                  NTOTAL_OFMESH,NCOUNT_OFMESH,TITMSH,
     *                  ICMESH,ICOUNT_OFPARS,CHITOT_MINAUX,
     *                         CHISQU_PROAUX,CHISQU_NEUAUX,
     *                                PARPOT_PRINTI,NDLAST)
C
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDIM_M.f'
      INCLUDE   'MATDIM/NDMESH.f'
      INCLUDE   'MATDIM/MAXFEV.f'
      INCLUDE   'MATDIM/NDTITL.f'
C      
      PARAMETER 
     *         (NDMES2=NDMESH*NDMESH,INMODE=1,NPRINT=-1)
C
      EXTERNAL 
     *          FUNMIN
C
      CHARACTER
     *          DIRNAM*256,GENAME*256,STRING*126
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          ACTION*1,CALLED*6,TYPCHI*6
      CHARACTER
     *          INPSYM*6,TEXTRA*256,NUCSYM*6
      CHARACTER
     *          TITMSH*8,FILNAM_ENDING*1,FILNAM*256,TITLES*12
      CHARACTER
     *          FILNA2*256,FITNUC*2,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*30,FILNA3*256,TITLES_NOTFIT*256,
     *          FILNAM_NOTTIT*256,TEXLAM*20,VERSIO*3,
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010
C    
      DIMENSION 
     *          ARGPAR(1:NDPARS),FUNVEC(1:NDIM_M),
     *          SCALFC(1:NDPARS),QTFARR(1:NDPARS)
      DIMENSION
     *          WORKA1(1:NDPARS),WORKA2(1:NDPARS),
     *          WORKA3(1:NDPARS),WORKA4(1:NDIM_M)
      DIMENSION 
     *          FUNJAC(1:NDIM_M,1:NDPARS)
      DIMENSION 
     *          IPIVOT(1:NDPARS)
      DIMENSION
     *          TITMSH(1:NDPARS),
     *          IAUXIL(1:NDPARS)
      DIMENSION
     *          PARPOT_PRINTI(1:NDPARS,1:NDMES2)
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL),
     *          TITLES_NOTFIT(1:NDPARS)
C
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /CHICHO/ VALCHI
      COMMON
     *       /CHI_PN/ CHISQU_PROTON,CHISQU_NEUTRS
      COMMON
     *       /CHIGRD/ CHISQU_GRDNRM,
     *                CHISQU_GRADIE(1:NDPARS)
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /MESHIN/ I_MESH(1:NDPARS),
     *                XMIN_I(1:NDPARS),
     *                XMAX_I(1:NDPARS),
     *                MAXPAR(1:NDPARS)
      COMMON
     *       /MSHPRI/ INFOER_PRINTI,
     *                IDEFCN_PRINTI,
     *                CHISQU_PRINTI(1:NDMES2),
     *                CHIGRD_NRMPRI(1:NDMES2),
     *                CHIGRD_COMPRI(1:NDPARS,1:NDMES2)     
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /FEVALS/ IFUNCT_EVALUS
      COMMON
     *       /STOPAR/ EPSLAS,LDLAST
      COMMON
     *       /STOPIN/ HIAUXI(1:MAXFEV)
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
      COMMON
     *       /TOLERS/ TOLERF,TOLERX,TOLERG,FACTOR   
      COMMON  
     *       /VERSIN/ VERSIO   
C
      DATA 
     *     NpUNIT / 80 / 
      DATA 
     *     NnUNIT / 81 /
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' / 
C
C=======================================================================
C     Levenberg-Marquardt minimisation routine ??
C=======================================================================
C
C     ILEVEL - Number of functions
C     NDPARS - Number of parameters (not greater than ILEVEL)
C
C            chi=sum_m(FUNJAC_m)^2 
C
C     Testing case setting ILEVEL=1
C     NDIM_M leading dimension (ILEVEL)
C
C=======================================================================
C 
      CALL CPUTIM('LMMESH',1)
C
C=======================================================================
C      
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,''Entering LMMESH'')')
      END IF
C
C=======================================================================
C
      IFIRST=1
      IFPROT=0
      IFNEUT=0
      IFBOTH=0
      IACTIV=0
C
      DO IPARAM=1,NDPARS ! Fixed as NDPARS=48
C
         IF (IFTAKE(IPARAM).EQ.1) THEN
C
             IACTIV=IACTIV+1
C  @@@ IRENE? CHECK THE PRIVILEGED ROLE OF 20
             IF (IPARAM.LE.20 .AND. IFDENS.EQ.0) THEN
                 IFPROT=1
             END IF
C
             IF (IPARAM.GT.20 .AND. IFDENS.EQ.0) THEN
                 IFNEUT=1
             END IF
C
             IF (IPARAM.GE.51 .AND. IFDENS.EQ.0) THEN
                 IFPROT=0
                 IFNEUT=0
                 IFBOTH=1
             END IF
C
         END IF
C
      END DO
C_______________________________________________________________________
C
      IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1).AND.(IFPROT.EQ.1)) THEN
C  
           IFPROT=0
           IFNEUT=0
           IFBOTH=1
C
          WRITE(0,'(/,''ALERT in LMMESH!! Density is NOT activated'',1X,
     *                ''and IFNEUT and IFPROT are equal to 1 !!!!'',/)')
C
C          STOP 'Chose proton OR neutron parameters, stop FROM LMMINI'
C
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(/,9X,''Number of active parameters '',
     *                        ''IACTIV='',I2)') IACTIV
C
          IF (IFPROT.EQ.1) THEN
              WRITE(LOGFIL,'(9X,''Minimisation for  protons'')')
          END IF
C
          IF (IFNEUT.EQ.1) THEN
              WRITE(LOGFIL,'(9X,''Minimisation for neutrons'')')
          END IF
C
          IF (IFBOTH.EQ.1) THEN
              WRITE(LOGFIL,'(9X,''Minimisation for protons '',
     *                          ''and neutrons'')')
          END IF
C
      END IF
C
C=======================================================================
C
      INDEXP=0
C      
      IF (IFDENS.EQ.0.AND.IFPROT.EQ.1) THEN
          DO IPARAM=1,6
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C      
      IF (IFDENS.EQ.0.AND.IFNEUT.EQ.1) THEN
          DO IPARAM=21,26
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C
      IF (IFDENS.EQ.0.AND.IFBOTH.EQ.1) THEN
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          IF (IFK_VS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=57   ! V_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=58   ! kappa V_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=4    ! V_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=24   ! V_o pure WS-SO neutrons
          END IF
C
          IF (IFK_RS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=59   ! r_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=60   ! kappa r_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=5    ! r_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=25   ! r_o pure WS-SO neutrons
          END IF
C
          IF (IFK_AS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=61   ! a_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=62   ! kappa a_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=6    ! a_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=26   ! a_o pure WS-SO neutrons
          END IF
C
      END IF
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.1) THEN
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          DO IPARAM=39,42         !lambdas Density-SO
             INDEXP=INDEXP+1
             IAUXIL(INDEXP)=IPARAM
          END DO
C
          IF (IFTENS.EQ.1.AND.ISORBT.EQ.1) THEN
              DO IPARAM=43,46     !lambdas Tensor-SO
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
          IF (IFTENS.EQ.1.AND.ICENTT.EQ.1) THEN
              DO IPARAM=47,50     !lambdas Tensor-central
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) FILNAM_ENDING='P'
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) FILNAM_ENDING='N'
      IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) FILNAM_ENDING='B'
C
      IF (IFDENS.EQ.1) THEN
C              
          FILNAM_ENDING='B'
C              
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                               IFPAR1,IFPAR2,IFPAR3,IFPAR4
C          
      END IF
C_______________________________________________________________________
C 
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
C      
      I1=3*KACTIV-1
C      
      WRITE(FILNAM_NUCFIT,'(<NUCACT>(A2,''-''))')
     *                      (FITNUC_AUXILI(I),I=1,NUCACT)
C
C=======================================================================
C      
      MACTIV=0
      ICENTR_NOTFIT=0
      ISORBI_NOTFIT=0
      IDENSI_NOTFIT=0
C
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (IFTAKE(IPARAM).EQ.0 .AND. I_MESH(IPARAM).EQ.0) THEN
C
             MACTIV=MACTIV+1
             TITLES_NOTFIT(MACTIV)=TITLES(IPARAM)(3:10)
C
             IF (TITLES_NOTFIT(MACTIV)(3:6).EQ.'CENT') THEN
                 ICENTR_NOTFIT=ICENTR_NOTFIT+1
             END IF
             IF (TITLES_NOTFIT(MACTIV)(3:6).EQ.'SORB') THEN
                 ISORBI_NOTFIT=ISORBI_NOTFIT+1
             END IF
             IF (TITLES_NOTFIT(MACTIV)(1:5).EQ.'XLAMB') THEN
                 IDENSI_NOTFIT=IDENSI_NOTFIT+1
             END IF
C
         END IF
      END DO
C
      I2=9*MACTIV-1
C
      WRITE(FILNAM_NOTTIT,'(<MACTIV>(A8,''-''))')
     *                      (TITLES_NOTFIT(I),I=1,MACTIV)
C
      IF (IFDENS.EQ.1 .AND. ICENTR_NOTFIT.GT.0) THEN
          WRITE(FILNAM_NOTTIT,'(I1,''CentrPot-const'')')ICENTR_NOTFIT
          I2=15
          IF (IDENSI_NOTFIT.GT.0) THEN
              WRITE(FILNAM_NOTTIT,'(I1,''CentrPot-const_'',
     *                              I1,''SODenPot-const'')')
     *                                      ICENTR_NOTFIT,IDENSI_NOTFIT
              I2=31
          END IF
      END IF
C
C=======================================================================
C
      WRITE(0,'(<ICMESH>(''_'',A8))')(TITMSH(I),I=1,ICMESH)
C
      IF (IFDENS.EQ.0) THEN
C      
          IF (MACTIV.EQ.0) 
     *        WRITE(FILNAM,'(''LogFMesh/IFDENS-0/'',A,''_'',A1,
     *                   <ICMESH>(''_'',A8),
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A3,''.log'')') 
     *
     *                   FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   (TITMSH(I),I=1,ICMESH),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                               VERSIO
C
          IF (MACTIV.GT.0) 
     *        WRITE(FILNAM,'(''LogFMesh/IFDENS-0/'',A,''_'',A1,
     *                   <ICMESH>(''_'',A8),
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A,''_'',A3,''.log'')') 
     *
     *                   FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   (TITMSH(I),I=1,ICMESH),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                   FILNAM_NOTTIT(1:I2),VERSIO
      END IF
C
C=======================================================================
C     
      IF (IFDENS.EQ.1) THEN
C      
          IF (MACTIV.EQ.0) 
     *        WRITE(FILNAM,'(''LogFMesh/IFDENS-1_IFTENS-'',I1,''/'',
     *                      A,''_'',A1,<ICMESH>(''_'',A8),
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')') 
     *
     *                   IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   (TITMSH(I),I=1,ICMESH),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,TEXLAM,
     *                                                      VERSIO
C
          IF (MACTIV.GT.0) 
     *        WRITE(FILNAM,'(''LogFMesh/IFDENS-1_IFTENS-'',I1,''/'',
     *                      A,''_'',A1,<ICMESH>(''_'',A8),
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A,A15,''_'',A3,
     *                                                 ''.log'')') 
     *
     *                   IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   (TITMSH(I),I=1,ICMESH),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                   FILNAM_NOTTIT(1:I2),TEXLAM,VERSIO
C
          IF (IFTENS.EQ.1) THEN
C      
              IF (MACTIV.EQ.0) 
     *            WRITE(FILNAM,'(''LogFMesh/IFDENS-1_IFTENS-'',I1,''/'',
     *                      A,''_'',A1,<ICMESH>(''_'',A8),
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')') 
     *
     *                   IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   (TITMSH(I),I=1,ICMESH),
     *                   IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                   IF_RAD,IF_INV,IF_RHO,IFDEEP,IFPRON,IFK_VC,
     *                   IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                               TEXLAM,VERSIO
C
              IF (MACTIV.GT.0) 
     *            WRITE(FILNAM,'(''LogFMesh/IFDENS-1_IFTENS-'',I1,''/'',
     *                      A,''_'',A1,<ICMESH>(''_'',A8),
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A,A15,''_'',A3,
     *                                                 ''.log'')') 
     *
     *                   IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   (TITMSH(I),I=1,ICMESH),
     *                   IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                   IF_RAD,IF_INV,IF_RHO,IFDEEP,IFPRON,IFK_VC,
     *                   IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                   FILNAM_NOTTIT(1:I2),TEXLAM,VERSIO
C
          END IF
C
      END IF       
C
C=======================================================================
C
      OPEN(LOGAUX,FILE=FILNAM,STATUS='UNKNOWN',FORM='FORMATTED')
C
C=======================================================================
C
C     Defining the dimension of the vector-function to be minimised
C
      LEVNUM=0
C
      IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
          DO INUCLI=1,LDNUCL
C
             IF (ITAKNU(INUCLI).EQ.1) THEN
C
                 IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_PROTON(INUCLI)
     *                                         +LEVEXP_NEUTRS(INUCLI)
     
                 IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+2 ! Two radii for each 
C                                                       nucleus, (P+N)
C                                                              
                 IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+2 ! Two Gap Energies 
C                                                   for each nucleus
C                                                                (P+N)
C                                                     
                 IF (IF_FER.EQ.1) LEVNUM=LEVNUM+2 ! Two Fermi Energies 
C                                                   for  each  nucleus
C                                                                (P+N)
C
                 IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+4 ! Four densities for 
C                                                   each nucleus: 
C                                                   below and above the 
C                                                   shell closure (P+N)
                 IF (IF_RHO.EQ.1) THEN
C             
c                     NRHOEX=0
C             
c                     CALL COUNTI_RHOEXP(INUCLI,NRHOEX)
C             
c                     LEVNUM=LEVNUM+NRHOEX
C             
                 END IF
C            
             END IF
C        
          END DO ! of LDNUCL
C       
       END IF ! IFDENS=1
C
C=======================================================================
C       
       IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN 
C           
           DO INUCLI=1,LDNUCL
C        
              IF (ITAKNU(INUCLI).EQ.1) THEN
C         
                  IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_PROTON(INUCLI)
C     
                  IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+1 ! Proton radius
C                                                              
                  IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+1 ! Proton Gap energy
C                                                     
                  IF (IF_FER.EQ.1) LEVNUM=LEVNUM+1 ! Proton Fermi energy
C        
                  IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+2 ! Proton up and down 
C                                                    density energies
C
                  IF (IF_RHO.EQ.1) THEN
*C             
*                      NRHOEX=0
*C             
*                      CALL COUNTI_RHOEXP(INUCLI,NRHOEX)
*C             
*                      LEVNUM=LEVNUM+NRHOEX
C             
                  END IF
C            
              END IF
C        
           END DO
C       
       END IF
C
C=======================================================================
C       
       IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1)) THEN 
C
           DO INUCLI=1,LDNUCL
C
              IF (ITAKNU(INUCLI).EQ.1) THEN
C
                  IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_NEUTRS(INUCLI)
     
                  IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+1 ! Neutron radius
C                                                              
                  IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+1 ! Neutron Gap energy
C                                                     
                  IF (IF_FER.EQ.1) LEVNUM=LEVNUM+1 ! Neutron Fermi 
C                                                                energy
C
                  IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+2 ! Neutron up and 
C                                                    down density 
C                                                              energies
C                 IF (IF_RHO.EQ.1)
C                 IF (IF_INV.EQ.1)
            
              END IF
         
           END DO
       
       END IF             
C
C=======================================================================
C
       IF (LEVNUM.GT.NDIM_M) THEN
           WRITE(0,'(/,''LEVNUM= '',I4,''and NDIM_M= '',I4,
     *               ''--> LEVNUM should be .LT. NDIM_M!!'',/)')
           STOP 'STOP in LMMINI: LEVNUM.GT.NDIM_M!!'
       END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C 
          WRITE(LOGFIL,'(9X,''LEVNUM='',I2,'' including: '')') LEVNUM
C
          IF (IF_SPE.EQ.1) WRITE(LOGFIL,'(30X,''Single Particle'',
     *                                        '' Energies'')')
C
          IF (IF_RAD.EQ.1) WRITE(LOGFIL,'(30X,''RMS Radii'')')
C
          IF (IF_GAP.EQ.1) WRITE(LOGFIL,'(30X,''Gap Energy'')')   
C       
          IF (IF_FER.EQ.1) WRITE(LOGFIL,'(30X,''Fermi Energy'')')  
       
          IF (IF_DEN.EQ.1) WRITE(LOGFIL,'(''Densities below and '',
     *                                    ''above the shell closure'')') 
C         IF (IF_RHO.EQ.1)
C         IF (IF_INV.EQ.1)      
C 
      END IF
C
      NUMPAR=IACTIV
      INFOER=111
C
C=======================================================================
C    
CID      NEWSED=0

      IF (ISCREN.EQ.1) THEN
          WRITE(LSCREN,'(/,101(''=''),/,101(''=''),/,
     *                     ''Point No.'',i4,''/'',i4,/,101(''=''))')
     *                                   NCOUNT_OFMESH,NTOTAL_OFMESH
      END IF
      
CID      IF (LOGWRI.GT.0) THEN
          WRITE(LOGAUX,'(/,101(''=''),/,101(''=''),/,
     *                     ''Point No.'',i4,''/'',i4,/,101(''=''))')
     *                                   NCOUNT_OFMESH,NTOTAL_OFMESH
CID      END IF
C      
C=======================================================================
C
      ITRMAX=30
CID      LDRAND=ITRMAX
      TESTGR=3.00
C
      CHITOT_MINAUX=1.0E+10
C
      IRANDO=0
      
CID      DO IRANDO=1,LDRAND
C
  100 CONTINUE
C
      IRANDO=IRANDO+1
C     
      IFUNCT_EVALUS=0
         
      IDEFCN=1
C      
C=======================================================================
C
      DO I=1,MAXFEV
         HIAUXI(I)=0.0
      END DO
C      
C=======================================================================
C
      IF (ISCREN.EQ.1) THEN
          WRITE(LSCREN,'(/,58X,''New run: NEWSED='',i14,3x,
     *                         ''No.'',i4,''/'',i4,/,101(''=''),/)')
     *                              NEWSED,IRANDO,ITRMAX
      END IF
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(//,9X,''Entering NEWRAN loop with IRANDO='',
     *                      I3,1X,''LDRAND='',I3,'' from LMMESH'')')
     *                              IRANDO,ITRMAX
      END IF
C
      WRITE(LOGAUX,'(/,58X,''New run: NEWSED='',i14,3x,
     *                     ''No.'',i4,''/'',i4,/,101(''=''),/)')
     *                              NEWSED,IRANDO,ITRMAX
C      
C=======================================================================
C                  
      CALL NEWRAN(NEWSED,IZ_FIX,IN_FIX,ISOSPI,ARGPAR,DIRNAM,
     *                                 GENAME,IFIRST,I_SEED)
C      
C=======================================================================
C        Calling the principal minimisation routine based on the
C        Levenberg-Marquardt algorithm (Argonne MINPACK project)  
C=======================================================================
C
      NDFUNC=NDIM_M    ! NDIM_M
      LDFUNC=LEVNUM    ! Actual number of functions, here: levels
C     NDPARS=NDPARS=48 ! ARGPAR(1:NDPARS)
      LDPARS=IACTIV
C 
C     MAXFEV=900       ! MAXFEV
      IFMODE=INMODE
C     NPRINT=-1        ! NPRINT
      INFRUN=INFOER    ! In any case output variable
      NFCALL=0         !NFUNEV    ! In any case output variable
      NJCALL=0         !NJACEV    ! In any case output variable
C
C     I_PERM=IPIVOT    ! In any case output vector
C
C                        
C     FJACOB(1:NDFUNC,1:NDPARS) <<=>> FUNJAC(1:NDIM_M,1:NDPARS)
C     FARGUN(1:NDFUNC)          <<=>> FUNVEC(1:NDIM_M)
C     DIAGSC(1:NDPARS)          <<=>> SCALFC(1:NDPARS)
C     I_PERM(1:NDPARS)          <<=>> IPIVOT(1:NDPARS)
C                        
      CALL LEVMAR(FUNMIN,NDFUNC,LDFUNC,NDPARS,LDPARS,ARGPAR,
     *            FUNVEC,FUNJAC,TOLERF,TOLERX,TOLERG,MAXFEV,
     *            SCALFC,IFMODE,FACTOR,NPRINT,INFRUN,NFCALL,
     *            NJCALL,IPIVOT,QTFARR,WORKA1,WORKA2,WORKA3,
     *                                        WORKA4,NDLAST)
C
      INFOER=INFRUN
C
      JACTIV=0
      DO IPARAM=1,NDPARS
         IF (IFTAKE(IPARAM).EQ.1) THEN
             JACTIV=JACTIV+1
             PARPOT(IPARAM)=ARGPAR(JACTIV)
         END IF
      END DO
C
C=======================================================================
C         
      WRITE(LOGAUX,'(/,''Number of WS_RUN Evaluations: '',I5,/)')
     *                      IFUNCT_EVALUS
C
C=======================================================================
C      
      CALL TELLIT(INFOER,TOLERF,TOLERX,TOLERG,MAXFEV,LDLAST,EPSLAS)
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(9X,''Entering JMATRX from LMMESH'')')
      END IF
C
cid   CALL JMATRX(LDFUNC,ARGPAR)
C
C=======================================================================
C
      IF (CHITOT_MINAUX.GT.VALCHI) THEN
C
          CHITOT_MINAUX=VALCHI
          CHISQU_PROAUX=CHISQU_PROTON
          CHISQU_NEUAUX=CHISQU_NEUTRS
C
          IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
              CHISQU_PRINTI(NCOUNT_OFMESH)=CHISQU_PROTON
          END IF
C
          IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
              CHISQU_PRINTI(NCOUNT_OFMESH)=CHISQU_NEUTRS
          END IF
C
          IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
              CHISQU_PRINTI(NCOUNT_OFMESH)=VALCHI
          END IF
C
          CHIGRD_NRMPRI(NCOUNT_OFMESH)=CHISQU_GRDNRM
C
          DO IPARAM=1,NDPARS
C
             PARPOT_PRINTI(IPARAM,NCOUNT_OFMESH)=PARPOT(IPARAM)
C
             CHIGRD_COMPRI(IPARAM,NCOUNT_OFMESH)
     *      =CHISQU_GRADIE(IPARAM)
C
          END DO
C
          IDEFCN_PRINTI=IDEFCN
C
          INFOER_PRINTI=INFOER
C
      END IF
C
C=======================================================================
C
      IF (IRANDO.LT.ITRMAX .AND. CHISQU_GRDNRM.GT.(3*TESTGR)) THEN
          I_SEED=NEWSED
          GO TO 100
      END IF
C
CID      END DO !IRANDO
C      
C=======================================================================
C      
      IF (LOGWRI.GT.4) WRITE(LOGFIL,'(''Entering WRITIN_MESHPM '',
     *                                                ''from LMMESH'')')
      CALL WRITIN_MESHPM(NCOUNT_OFMESH,PARPOT_PRINTI)
C      
C=======================================================================
C 
      REWIND LOGPRO    
C
   10 CONTINUE
C   
      READ (LOGPRO,'(A120)',END=11) STRING
      IF (LOGWRI.GT.4) WRITE(NpUNIT,'(A80)'       ) STRING
C      
      GO TO 10
   11 CONTINUE  ! Ready with the copy for the protons      
C      
C=======================================================================
C 
      REWIND LOGNEU    
C
   20 CONTINUE
C   
      READ (LOGNEU,'(A120)',END=21) STRING
      IF (LOGWRI.GT.4) WRITE(NnUNIT,'(A80)'       ) STRING
C      
      GO TO 20
   21 CONTINUE  ! Ready with the copy for the neutrons     
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,18X,''Exiting  LMMESH'')')
      END IF   
C
C=======================================================================
C 
      CALL CPUTIM('LMMESH',0)
C
C=======================================================================
C      
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE TBMESH(IPARA1,IPARA2,INDEX1,INDEX2,LEVNUM,
     *                         CHITOT_MINAUX,CHISQU_PROAUX,
     *                         CHISQU_NEUAUX,PARPOT_PRINTI,
     *                         RMSMAP_PRONUC,RMSMAP_NEUNUC,
     *                         RMSMAP_PROGLO,RMSMAP_NEUGLO,
     *                         RMSPRO_MAXIMA,RMSPRO_MINIMI,
     *                         RMSNEU_MAXIMA,RMSNEU_MINIMI)
          
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDIM_P.f'
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDMESH.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      
      PARAMETER
     *          (NDMES2=NDMESH*NDMESH)
      CHARACTER  
     *          INPSYM*6,NUCSYM*6,TYPCHI*6
      DIMENSION
     *          PARPOT_PRINTI(1:NDPARS,1:NDMES2)
      DIMENSION
     *          RMSMAP_PRONUC(1:NDMESH,1:NDMESH,1:NDNUCL),
     *          RMSMAP_NEUNUC(1:NDMESH,1:NDMESH,1:NDNUCL)
      DIMENSION
     *          RMSMAP_PROGLO(1:NDMESH,1:NDMESH,1:NDNUCL),
     *          RMSMAP_NEUGLO(1:NDMESH,1:NDMESH,1:NDNUCL)
      COMMON
     *       /TESFIT/ IFTEST,IFFITS,IFMESH
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON
     *       /POTPOT/ PARPOT(1:NDIM_P)
      COMMON
     *       /ARGINI/ XINITS(1:NDIM_P)
      COMMON
     *       /MESHIN/ I_MESH(1:NDIM_P),
     *                XMIN_I(1:NDIM_P),
     *                XMAX_I(1:NDIM_P),
     *                MAXPAR(1:NDIM_P)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
C=======================================================================
C @@@
C     This SUBROUTINE what exactly???
C
C=======================================================================
C
      LEVNUM=0
       
      IF (IFDENS.EQ.1) THEN
       
          DO INUCLI=1,LDNUCL
        
             IF (ITAKNU(INUCLI).EQ.1) THEN
            
        
         IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_PROTON(INUCLI)
     *                                 +LEVEXP_NEUTRS(INUCLI)
     
         IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+2 !Two radii for each nucleus (P+N)
C                                                              
         IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+2 !Two Gap Energies for each nucleus
                                          !                            (P+N)
C                                                     
         IF (IF_FER.EQ.1) LEVNUM=LEVNUM+2 !Two Fermi Energies for each nucleus
                                          !                              (P+N)
        
         IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+4 !Four densities for each nucleus: 
                                          !below and above the shell closure
                                          !                            (P+N)
C        IF (IF_RHO.EQ.1)
C        IF (IF_INV.EQ.1)
            
         END IF
        
        END DO
       
       END IF
C_______________________________________________________________________
C       
       IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN 
           
        DO INUCLI=1,LDNUCL
        
         IF (ITAKNU(INUCLI).EQ.1) THEN
         
          IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_PROTON(INUCLI)
     
          IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+1 !Proton radius
C                                                              
          IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+1 !Proton Gap energy
C                                                     
          IF (IF_FER.EQ.1) LEVNUM=LEVNUM+1 !Proton Fermi energy
        
          IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+2 !Proton up and down density energies

C         IF (IF_RHO.EQ.1)
C         IF (IF_INV.EQ.1)
            
         END IF
        
        END DO
       
       END IF
C_______________________________________________________________________
C       
       IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1)) THEN 
       
        DO INUCLI=1,LDNUCL
        
         IF (ITAKNU(INUCLI).EQ.1) THEN
         
          IF (IF_SPE.EQ.1) LEVNUM=LEVNUM+LEVEXP_NEUTRS(INUCLI)
     
          IF (IF_RAD.EQ.1) LEVNUM=LEVNUM+1 !Neutron radius
C                                                              
          IF (IF_GAP.EQ.1) LEVNUM=LEVNUM+1 !Neutron Gap energy
C                                                     
          IF (IF_FER.EQ.1) LEVNUM=LEVNUM+1 !Neutron Fermi energy
        
          IF (IF_DEN.EQ.1) LEVNUM=LEVNUM+2 !Neutron up and down density energies

C         IF (IF_RHO.EQ.1)
C         IF (IF_INV.EQ.1)
            
         END IF
         
        END DO
       
       END IF       
C_______________________________________________________________________
C                
       DO IPARAM=1,NDPARS
          IF (IFMESH.EQ.1) THEN
              IF (I_MESH(IPARAM).EQ.1) THEN
                  PARPOT(IPARAM)=XINITS(IPARAM)
              END IF
          END IF
       END DO
                
       WRITE(0,'(''XINITS(1)= '',F9.3,'' ;XINITS(2)= '',F9.3)')
     *             XINITS(IPARA1),XINITS(IPARA2)
C                
       CHISQU_PROTON=0.
       CHISQU_NEUTRS=0.
       CHISQU_TOTALS=0.
C
       IDEG_P=0
       IDEG_N=0
       RMSGLO_TAKPRO=0.
       RMSGLO_TAKNEU=0.
C
       DO INUCLI=1,LDNUCL
C                    
          IF (ITAKNU(INUCLI).EQ.1) THEN
C           
              IZ_FIX=NUMB_Z(INUCLI)
              IN_FIX=NUMB_N(INUCLI)
C                    
              IDEFCN=0
              I_MODE=0
              I_FLAG=1
C_______________________________________________________________________
C
              IF (LOGWRI.GT.4) THEN
                  WRITE(LOGFIL,'(12X,''Entering WS_RUN from TBMESH '',
     *                               ''INUCLI='',I1,1X,
     *                               ''IZ_FIX='',I3,'' IN_FIX='',I3)')
     *                                 INUCLI,         IZ_FIX,IN_FIX
              END IF
C                     
              CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,
     *                    I_FLAG,CHISQU_AUXIL1,CHISQU_AUXIL2)
C     
              CHISQU_PROTON=CHISQU_PROTON+CHISQU_AUXIL1
              CHISQU_NEUTRS=CHISQU_NEUTRS+CHISQU_AUXIL2
              CHISQU_TOTALS=CHISQU_TOTALS+CHISQU_PROTON
     *                                   +CHISQU_NEUTRS
C
C             Storing the rms values of single nucleus
C
              RMSMAP_PRONUC(INDEX1,INDEX2,INUCLI)
     *       =
     *        SQRT(CHIWEI_PROTON)
C
              RMSMAP_NEUNUC(INDEX1,INDEX2,INUCLI)
     *       =
     *        SQRT(CHIWEI_NEUTRS)
C
C             Total degenerancy of the active nuclei (for the global)
C
              DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                 IDEG_P=IDEG_P+IDEGEX_PROTON(INUCLI,IEXPER)
              END DO
C
              DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                 IDEG_N=IDEG_N+IDEGEX_NEUTRS(INUCLI,IEXPER)
              END DO
C
              RMSGLO_TAKPRO=RMSGLO_TAKPRO+CHIDEG_PROTON
              RMSGLO_TAKNEU=RMSGLO_TAKNEU+CHIDEG_NEUTRS
C
C             Searching the RMSMAP maximum/minimum values
C
              IF (RMSPRO_MAXIMA.LT.
     *            RMSMAP_PRONUC(INDEX1,INDEX2,INUCLI)) THEN
                  RMSPRO_MAXIMA=RMSMAP_PRONUC(INDEX1,INDEX2,INUCLI)
              END IF
C
              IF (RMSPRO_MINIMI.GT.
     *            RMSMAP_PRONUC(INDEX1,INDEX2,INUCLI)) THEN
                  RMSPRO_MINIMI=RMSMAP_PRONUC(INDEX1,INDEX2,INUCLI)
              END IF
C
              IF (RMSNEU_MAXIMA.LT.
     *            RMSMAP_NEUNUC(INDEX1,INDEX2,INUCLI)) THEN
                  RMSNEU_MAXIMA=RMSMAP_NEUNUC(INDEX1,INDEX2,INUCLI)
              END IF
C
              IF (RMSNEU_MINIMI.GT.
     *            RMSMAP_NEUNUC(INDEX1,INDEX2,INUCLI)) THEN
                  RMSNEU_MINIMI=RMSMAP_NEUNUC(INDEX1,INDEX2,INUCLI)
              END IF
C
          END IF
C
       END DO
C
       RMSMAP_PROGLO(INDEX1,INDEX2,LDNUCL+1)=SQRT(RMSGLO_TAKPRO/IDEG_P)
       RMSMAP_NEUGLO(INDEX1,INDEX2,LDNUCL+1)=SQRT(RMSGLO_TAKNEU/IDEG_N)
C
       CHITOT_MINAUX=CHISQU_TOTALS
       CHISQU_PROAUX=CHISQU_PROTON
       CHISQU_NEUAUX=CHISQU_NEUTRS
C
C=======================================================================
C           
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE LMMINI_MONTEC(IMONTE,LDMONT,IACTIV,ARGPAR,
     *                         LEVNUM,NDLAST,NEWSED,I_SEED)
C
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/NDIM_M.f'
      INCLUDE   'MATDIM/MAXFEV.f'
C
      EXTERNAL 
     *          FUNMIN
C      
      PARAMETER 
     *         (LENGTH=256,INMODE=1,NPRINT=-1)
C
      CHARACTER
     *          LABPRO*6,LABNEU*6,LABPRO_PRINTG*006,LABNEU_PRINTG*6
      CHARACTER
     *          DIRNAM*256,GENAME*256,STRING*126
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6,
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          ACTION*1,CALLED*6,TYPCHI*6
      CHARACTER
     *          FILNAM*256,FILNAM_ENDING*13,INPSYM*6,
     *          LABTHE*006,LABTHE_PRINTG*06,TEXLAM*20,
     *          FILNA2*256,NUCSYM*6,FITNUC*2,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*30,FILNA3*256,VERSIO*3
C    
      DIMENSION 
     *          ARGPAR(1:NDPARS),FUNVEC(1:NDIM_M),
     *          SCALFC(1:NDPARS),QTFARR(1:NDPARS)
      DIMENSION
     *          WORKA1(1:NDPARS),WORKA2(1:NDPARS),
     *          WORKA3(1:NDPARS),WORKA4(1:NDIM_M)
      DIMENSION 
     *          FUNJAC(1:NDIM_M,1:NDPARS)
      DIMENSION 
     *          IPIVOT(1:NDPARS)
      DIMENSION
     *          ENETHE(1:NDSPEC),LABTHE(1:NDSPEC)
      DIMENSION
     *          ENEPRO_PRINTG(1:NDSPEC),LABPRO_PRINTG(1:NDSPEC),
     *          ENENEU_PRINTG(1:NDSPEC),LABNEU_PRINTG(1:NDSPEC),
     *          ENETHE_PRINTG(1:NDSPEC),LABTHE_PRINTG(1:NDSPEC),
     *                                  PARPOT_PRINTG(1:NDPARS)
      DIMENSION
     *          ENEPRO(1:NDSPEC),LABPRO(1:NDSPEC),
     *          ENENEU(1:NDSPEC),LABNEU(1:NDSPEC)
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL)
C
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                              LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                              LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /CHI_PN/ CHISQU_PROTON,CHISQU_NEUTRS
      COMMON
     *       /CHICHO/ VALCHI
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)    
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /CHIGRD/ CHISQU_GRDNRM,
     *                CHISQU_GRADIE(1:NDPARS)
      COMMON
     *       /STOPIN/ HIAUXI(1:MAXFEV)
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
     *       /FEVALS/ IFUNCT_EVALUS
      COMMON
     *       /STOPAR/ EPSLAS,LDLAST
     *       /MASSIV/ IMASIV_PRODUC
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /DENSTR/ IFDENS
     *       /TENSOR/ IFTENS
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS    
      COMMON
     *       /TOLERS/ TOLERF,TOLERX,TOLERG,FACTOR  
      COMMON  
     *       /VERSIN/ VERSIO
C
C=======================================================================
C     This subroutine minimizes the \chi^2 over an external do-loop
C     od IMONTE=1,LDMONT
C=======================================================================
C
      NUMPAR=IACTIV
      INFOER=111
C
      IRANDO=IMONTE
C
C=======================================================================
C    
      IFUNCT_EVALUS=0
C     
      IDEFCN=1
C
      DO I=1,MAXFEV
         HIAUXI(I)=0.0
      END DO
C         
      IF (ISCREN.EQ.1) THEN
C
          WRITE(LSCREN,'(/,58X,''New run: NEWSED='',i14,3x,
     *                         ''No.'',i6,''/'',i6,/,101(''=''),/)') 
     *                                     NEWSED,IMONTE,LDMONT
      END IF
C
      WRITE(LOGAUX,'(/,58X,''New run: NEWSED='',i14,3x,
     *                     ''No.'',i6,''/'',i6,/,101(''=''),/)') 
     *                                     NEWSED,IMONTE,LDMONT
C         
      IF (LOGWRI.GT.0) THEN
C             
          WRITE(LOGENE,'(/,58X,''New run: NEWSED='',i14,3x,
     *                            ''No.'',i6,''/'',i6,/,101(''=''),/)') 
     *                                     NEWSED,IMONTE,LDMONT
C             
          WRITE(LOGRAD,'(/,58X,''New run: NEWSED='',i14,3x,
     *                            ''No.'',i6,''/'',i6,/,101(''=''),/)') 
     *                                     NEWSED,IMONTE,LDMONT
      END IF
C
      WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *                  ''#'',5X,''IMONTE= '',I6,T80,''#'',/,
     *                  ''#'',T80,''#'',/,80(''#''))') IMONTE
C      
C=======================================================================
C
C     Generating random restarts
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(//,9X,''Entering NEWRAN with IRANDO='',I3,
     *                      1X,''LDRAND='',I6,'' from LMMINI'')')
     *                              IMONTE,LDMONT
      END IF
C         
      CALL NEWRAN(NEWSED,IZ_FIX,IN_FIX,ISOSPI,ARGPAR,DIRNAM,
     *                                 GENAME,IFIRST,I_SEED)
C      
C=======================================================================
C     Calling the principal minimisation routine based on the
C     Levenberg-Marquardt algorithm (Argonne MINPACK project)  
C=======================================================================
C
      NDFUNC=NDIM_M    ! NDIM_M
      LDFUNC=LEVNUM    ! Actual number of functions, here: levels
C IRENE? NDPARS=NDPARS=48 ! ARGPAR(1:NDPARS)
      LDPARS=IACTIV
C 
C        MAXFEV=900       ! MAXFEV
C @@@ ??
      IFMODE=INMODE
C     NPRINT=-1        ! NPRINT
C @@@ WHAT DOES THIS MEAN???
      INFRUN=INFOER    ! In any case output variable
      NFCALL=0         ! NFUNEV    ! In any case output variable
      NJCALL=0         ! NJACEV    ! In any case output variable
C
C     I_PERM=IPIVOT    ! In any case output vector ?????????????
C                     
C     FJACOB(1:NDFUNC,1:NDPARS) <<=>> FUNJAC(1:NDIM_M,1:NDPARS)
C     FARGUN(1:NDFUNC) <<=>> FUNVEC(1:NDIM_M)
C     DIAGSC(1:NDPARS) <<=>> SCALFC(1:NDPARS)       
C     I_PERM(1:NDPARS) <<=>> IPIVOT(1:NDPARS)       
C
C     Calling the Levenberg-Marquardt LAPACK minimisation routine 
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,6X,''Entering LEVMAR from LMMINI      '',
     *                   5(3x,''IMONTE='',I2))')
     *                          IMONTE,IMONTE,IMONTE,IMONTE,IMONTE
      END IF
C
      CALL LEVMAR(FUNMIN,NDFUNC,LDFUNC,NDPARS,LDPARS,ARGPAR,
     *            FUNVEC,FUNJAC,TOLERF,TOLERX,TOLERG,MAXFEV,
     *            SCALFC,IFMODE,FACTOR,NPRINT,INFRUN,NFCALL,
     *            NJCALL,IPIVOT,QTFARR,WORKA1,WORKA2,WORKA3,
     *                                        WORKA4,NDLAST)
C
      INFOER=INFRUN 
C
      KK=0
      DO KPARAM=1,NDPARS
         IF (IFTAKE(KPARAM).EQ.1) THEN
             KK=KK+1
             PARPOT(KPARAM)=ARGPAR(KK)
         END IF
      END DO     
C
C=======================================================================
C
      WRITE(LOGAUX,'(/,''Number of WS_RUN Evaluations: '',I5,/)')
     *                      IFUNCT_EVALUS
C
C=======================================================================
C      
      CALL TELLIT(INFOER,TOLERF,TOLERX,TOLERG,MAXFEV,LDLAST,EPSLAS)
C
C=======================================================================
C
      CALL RADINF(IFPROT,IFNEUT)
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(9X,''Entering JMATRX from LMMINI'')')
      END IF
C
      CALL JMATRX(LDFUNC,ARGPAR)
C
C=======================================================================
C           
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C 
      SUBROUTINE NEWRAN(NEWSED,IZ_FIX,IN_FIX,ISOSPI,ARGPAR,DIRNAM,
     *                                       GENAME,IFIRST,I_SEED)
      INCLUDE  'MATDIM/NDPARS.f'
      INCLUDE  'MATDIM/NDRAND.f'
C
      CHARACTER
     *          FILKEE*256,WHATEX*6
      CHARACTER
     *          DIRNAM*256,GENAME*256,STRAUX*256
C
      DIMENSION
     *          ARGPAR(1:NDPARS)
C
      COMMON
     *       /OLDVAL/ OVCENT,OXSORB,OXEFFM,ORCENT,ORSORB,OREFFM,
     *                                     OACENT,OASORB,OAEFFM,
     *                                                   O0COUL
      COMMON
     *       /EXTREM/ V0CMAX,V0CMIN,XL_MAX,XL_MIN,XEFMAX,XEFMIN,
     *                R0CMAX,R0CMIN,R0SMAX,R0SMIN,REFMAX,REFMIN,
     *                A0CMAX,A0CMIN,A0SMAX,A0SMIN,AEFMAX,AEFMIN,
     *                                            CouMAX,CouMIN,
     *                              XPPMAX,XPPMIN,XPNMAX,XPNMIN,
     *                              XNPMAX,XNPMIN,XNNMAX,XNNMIN,
     *                              YPPMAX,YPPMIN,YPNMAX,YPNMIN,
     *                              YNPMAX,YNPMIN,YNNMAX,YNNMIN,
     *                              CPPMAX,CPPMIN,CPNMAX,CPNMIN,
     *                              CNPMAX,CNPMIN,CNNMAX,CNNMIN,
     *
     *                                            UPFACT,DWFACT
      COMMON
     *       /KAPPAS/ XKCMIN,XKCMAX,XACMIN,XACMAX,XRCMIN,XRCMAX,
     *                XKSMIN,XKSMAX,XASMIN,XASMAX,XRSMIN,XRSMAX,
     *                XKEMIN,XKEMAX,XAEMIN,XAEMAX,XREMIN,XREMAX,
     *                                            XCoMIN,XCoMAX
      COMMON
     *       /EXTKAP/ V0CMIN_KAPPAR,V0CMAX_KAPPAR,XKCMIN_KAPPAR,
     *                XKCMAX_KAPPAR,A0CMIN_KAPPAR,A0CMAX_KAPPAR,
     *                XACMIN_KAPPAR,XACMAX_KAPPAR,R0CMIN_KAPPAR,
     *                R0CMAX_KAPPAR,XRCMIN_KAPPAR,XRCMAX_KAPPAR,
     *                XL_MIN_KAPPAR,XL_MAX_KAPPAR,XKSMIN_KAPPAR,
     *                XKSMAX_KAPPAR,A0SMIN_KAPPAR,A0SMAX_KAPPAR,
     *                XASMIN_KAPPAR,XASMAX_KAPPAR,R0SMIN_KAPPAR,
     *                R0SMAX_KAPPAR,XRSMIN_KAPPAR,XRSMAX_KAPPAR
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS
      COMMON
     *       /CHIMIN/ HIWMIN,HICMIN,ERRMIN,SHEMIN,SHWMIN
      COMMON
     *       /CNTROL/ PARAMT(1:NDPARS),DPARAM(1:NDPARS)     
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /RANDSR/ ARANDO(1:NDPARS)
      COMMON
     *       /VLIMIT/ VMISTR(1:NDPARS),
     *                VMIMIN(1:NDPARS),
     *                VMIMAX(1:NDPARS),
     *                VMISTP(1:NDPARS)
      COMMON
     *       /VSTART/ STARTV(1:NDPARS)
      COMMON
     *       /SIZMIN/ LDSEAR
      COMMON
     *       /PRINAL/ IMTALK
      COMMON                
     *       /INPSEL/ WHATEX
C
C=======================================================================
C     This subroutine defines a complete set of random parameters;
C     It should be called at the beginning of one minimisation run 
C=======================================================================
C
      DIRNAM='Results'
C
C=======================================================================
C     Initialising the chi^2 functions for minimum calculations
C=======================================================================
C
      HIWMIN=1.0E+10
      HICMIN=1.0E+10
      ERRMIN=1.0E+10
      SHEMIN=1.0E+10
      SHWMIN=1.0E+10
C
C=======================================================================
C=======================================================================
C     Defining the filename that will contain the results for a
C     given initial (eventually) random set of Dirac parameters
C=======================================================================
C=======================================================================
C
      GENAME='ResFile' ! Write unit is called IRESUL  
C
      CALL STRLNG(DIRNAM,LENGTH,STRAUX)
C
      WRITE(FILKEE(1:LENGTH),'(A)') DIRNAM(1:LENGTH)
C
      LENGTH=LENGTH+1
C
C=======================================================================
C
      IF (ISOSPI.EQ.0) THEN
C
          WRITE(FILKEE(LENGTH:LENGTH+15),'(''/WS_Z'',
     *          I3.3,''_N'',I3.3,''_n_'')') IZ_FIX,IN_FIX
      END IF
C
      IF (ISOSPI.EQ.1) THEN
C
          WRITE(FILKEE(LENGTH:LENGTH+15),'(''/WS_Z'',
     *          I3.3,''_N'',I3.3,''_p_'')') IZ_FIX,IN_FIX
      END IF
C
C=======================================================================
C
      LENGTH=LENGTH+16
C
      IF (I_RAND.EQ.1) THEN
C
          WRITE(FILKEE(LENGTH:LENGTH+9),'(''rand'',I4.4,''_'')') IRANDO
C
          LENGTH=LENGTH+9
C
          CALL STRLNG(GENAME,LNGGEN,STRAUX)
C
          WRITE(FILKEE(LENGTH:LENGTH+LNGGEN),'(A)') GENAME(1:LNGGEN)
          WRITE(FILKEE(LENGTH+LNGGEN:LENGTH+LNGGEN+4),'(''.out'')')
C
      ELSE
C
          CALL STRLNG(GENAME,LNGGEN,STRAUX)
C
          WRITE(FILKEE(LENGTH:LENGTH+LNGGEN),'(A)') GENAME(1:LNGGEN)
          WRITE(FILKEE(LENGTH+LNGGEN:LENGTH+LNGGEN+4),'(''.out'')')
C
      END IF
C
      LENGTH=LENGTH+LNGGEN+4
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(18X,''Opening UNIT=IRESUL='',I2,1X,
     *                       ''File:'',A)') IRESUL,FILKEE(1:LENGTH)
      END IF 
C
CID      OPEN (IRESUL,FILE=FILKEE(1:LENGTH),STATUS='UNKNOWN',
CID     *                                   FORM='FORMATTED')
C
C=======================================================================
C=======================================================================
C     Defining the filename that will contain the logfile of the
C     minimisation series  (these are useful at the begin stage)
C=======================================================================
C=======================================================================
C
      GENAME='ConvRep' ! Write unit is called LOGFIL   
C
      CALL STRLNG(DIRNAM,LENGTH,STRAUX)
C
      WRITE(FILKEE(1:LENGTH),'(A)') DIRNAM(1:LENGTH)
C
      LENGTH=LENGTH+1
C
C=======================================================================
C
      IF (ISOSPI.EQ.0) THEN
C
          WRITE(FILKEE(LENGTH:LENGTH+15),'(''/WS_Z'',
     *          I3.3,''_N'',I3.3,''_n_'')') IZ_FIX,IN_FIX
      END IF
C
      IF (ISOSPI.EQ.1) THEN
C
          WRITE(FILKEE(LENGTH:LENGTH+15),'(''/WS_Z'',
     *          I3.3,''_N'',I3.3,''_p_'')') IZ_FIX,IN_FIX
      END IF
C
C=======================================================================
C
      LENGTH=LENGTH+16
C
      IF (I_RAND.EQ.1) THEN
C
          WRITE(FILKEE(LENGTH:LENGTH+9),'(''rand'',I4.4,''_'')') IRANDO
C
          LENGTH=LENGTH+9
C
          CALL STRLNG(GENAME,LNGGEN,STRAUX)
C
          WRITE(FILKEE(LENGTH:LENGTH+LNGGEN),'(A)') GENAME(1:LNGGEN)
          WRITE(FILKEE(LENGTH+LNGGEN:LENGTH+LNGGEN+4),'(''.dat'')')
C
      ELSE
C
          CALL STRLNG(GENAME,LNGGEN,STRAUX)
C
          WRITE(FILKEE(LENGTH:LENGTH+LNGGEN),'(A)') GENAME(1:LNGGEN)
          WRITE(FILKEE(LENGTH+LNGGEN:LENGTH+LNGGEN+4),'(''.dat'')')
C
      END IF
C
      LENGTH=LENGTH+LNGGEN+4
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(18X,''Opening UNIT=ICONVE='',I2,1X,
     *                       ''File:'',A)') ICONVE,FILKEE(1:LENGTH)
      END IF 
C
CID      OPEN (ICONVE,FILE=FILKEE(1:LENGTH),STATUS='UNKNOWN',
CID     *                                   FORM='FORMATTED')
C
      IF (ISCREN.GT.0) 
     *    WRITE(LSCREN,'(''Opening UNIT='',i2,'' File: '',A)')
     *                 ICONVE,            FILKEE(1:LENGTH)
C
      IF (LOGWRI.GT.0)
     *    WRITE(ICONVE,'(''Opening File: '',A)') FILKEE(1:LENGTH)
C
C=======================================================================
C
      CALL WARNIN(LOGFIL,WHATEX) ! Warning in case of the use
C                                  of 'not experimental' info
C
C=======================================================================
C
      IF (I_RAND.NE.1)  THEN
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(''Exiting  NEWRAN - no action required'')')
          END IF 
          RETURN
      END IF 
C
C=======================================================================
C
      CALL RANDIN(I_SEED)        ! Initialize the seed
C
      CALL ZUFALL(NDPARS,ARANDO) ! Generates NDPARS random numbers 
C
C=======================================================================
C     First, determine the range of variation of each of the
C     parameters - then, select at RANDOM the starting point
C     variable. Each variable must be selected independently
C     of the other.                            =============
C=======================================================================
C
C     ... beginning with the central potential well, INDEX=1
C
C     The extremum (input) values of the parameters are kept
C     in the COMMON /EXTREM/
C
C     The random numbers in the range [0,1] are contained in
C     the COMMON /RANDSR/
C
      PARAMT(1)=V0CMIN+ARANDO(1)*(V0CMAX-V0CMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(1) ='',F20.16,'' PARAMT(1) ='',F20.14,
     *                                         '' (OVCENT)'')')
     *                     ARANDO(1),              PARAMT(1)
      END IF
C
      IF (IFTAKE(1).EQ.1) OVCENT=PARAMT(1)
C_______________________________________________________________________
C
      PARAMT(11)=XKCMIN+ARANDO(11)*(XKCMAX-XKCMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(11)='',F20.16,'' PARAMT(11)='',F20.14,
     *                                         '' (XK_V0C)'')')
     *                     ARANDO(11),             PARAMT(11)
      END IF
C @@@ CHECK CORRECTNESS
      IF (IFTAKE(11).EQ.1) OK_V0C=PARAMT(1)
C
C=======================================================================
C     Selecting STRENGTHS. The index values 4 and 7
C=======================================================================
C
      PARAMT(4)=XL_MIN+ARANDO(4)*(XL_MAX-XL_MIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(4) ='',F20.16,'' PARAMT(4) ='',F20.14,
     *                                         '' (OXSORB)'')')
     *                     ARANDO(4),              PARAMT(4)
      END IF
C
      IF (IFTAKE(4).EQ.1) OXSORB=PARAMT(4)
C_______________________________________________________________________
C
      PARAMT(14)=XKSMIN+ARANDO(14)*(XKSMAX-XKSMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(14)='',F20.16,'' PARAMT(14)='',F20.14,
     *                                         '' (XK_LAM)'')')
     *                     ARANDO(14),              PARAMT(14)
      END IF
C  @@@ CHECK CORRECTNESS 
CID: OK!
      IF (IFTAKE(14).EQ.1) OK_XLM=PARAMT(14)
C
C=======================================================================
C
      PARAMT(7)=XEFMIN+ARANDO(7)*(XEFMAX-XEFMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(7)=PARAMT(4)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(7) ='',F20.16,'' PARAMT(7) ='',F20.14,
     *                                         '' (OXEFFM)'')')
     *                     ARANDO(7),              PARAMT(7)
      END IF
C      
      IF (IFTAKE(7).EQ.1) OXEFFM=PARAMT(7)
C_______________________________________________________________________
C
      PARAMT(17)=XKEMIN+ARANDO(17)*(XKEMAX-XKEMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(17)=PARAMT(14)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(17)='',F20.16,'' PARAMT(17)='',F20.14,
     *                                         '' (V0EFFM)'')')
     *                     ARANDO(17),              PARAMT(17)
      END IF
C      
      IF (IFTAKE(17).EQ.1) OEFMAS=PARAMT(17)
C
C=======================================================================
C     Selecting the RADII. The index values 2, 5 and 8
C=======================================================================
C
      PARAMT(2)=R0CMIN+ARANDO(2)*(R0CMAX-R0CMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(2) ='',F20.16,'' PARAMT(2) ='',F20.14,
     *                                         '' (ORCENT)'')')
     *                     ARANDO(2),              PARAMT(2)
      END IF
C
      IF (IFTAKE(2).EQ.1) ORCENT=PARAMT(2)
C_______________________________________________________________________
C
      PARAMT(12)=XRCMIN+ARANDO(12)*(XRCMAX-XRCMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(12)='',F20.16,'' PARAMT(12)='',F20.14,
     *                                         '' (XK_R0C)'')')
     *                     ARANDO(12),             PARAMT(12)
      END IF
C
      IF (IFTAKE(12).EQ.1) OK_R0C=PARAMT(12)
C
C=======================================================================
C
      PARAMT(5)=R0SMIN+ARANDO(5)*(R0SMAX-R0SMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(5) ='',F20.16,'' PARAMT(5) ='',F20.14,
     *                                         '' (ORSORB)'')')
     *                     ARANDO(5),              PARAMT(5)
      END IF
C
      IF (IFTAKE(5).EQ.1) ORSORB=PARAMT(5)
C_______________________________________________________________________
C
      PARAMT(15)=XRSMIN+ARANDO(15)*(XRSMAX-XRSMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(15)='',F20.16,'' PARAMT(15)='',F20.14,
     *                                         '' (XK_RSO)'')')
     *                     ARANDO(15),             PARAMT(15)
      END IF
C
      IF (IFTAKE(15).EQ.1) OK_RSO=PARAMT(15)
C
C=======================================================================
C
      PARAMT(8)=REFMIN+ARANDO(8)*(REFMAX-REFMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(8)=PARAMT(5)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(8) ='',F20.16,'' PARAMT(8) ='',F20.14,
     *                                         '' (OREFFM)'')')
     *                     ARANDO(8),              PARAMT(8)
      END IF
C
      IF (IFTAKE(8).EQ.1) OREFFM=PARAMT(8)
C_______________________________________________________________________
C
      PARAMT(18)=XREMIN+ARANDO(18)*(XREMAX-XREMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(18)=PARAMT(15)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(18)='',F20.16,'' PARAMT(18)='',F20.14,
     *                                         '' (XK_REF)'')')
     *                     ARANDO(18),             PARAMT(18)
      END IF
C
      IF (IFTAKE(18).EQ.1) OK_REF=PARAMT(18)
C
C=======================================================================
C     Selecting DIFFUSENESS; The index values 3, 6 and 9
C=======================================================================
C
      PARAMT(3)=A0CMIN+ARANDO(3)*(A0CMAX-A0CMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(3) ='',F20.16,'' PARAMT(3) ='',F20.14,
     *                                         '' (OACENT)'')')
     *                     ARANDO(3),              PARAMT(3)
      END IF
C
      IF (IFTAKE(3).EQ.1) OACENT=PARAMT(3)
C_______________________________________________________________________
C
      PARAMT(13)=XACMIN+ARANDO(13)*(XACMAX-XACMIN)
C 
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(13)='',F20.16,'' PARAMT(13)='',F20.14,
     *                                         '' (XK_A0C)'')')
     *                     ARANDO(13),             PARAMT(13)
      END IF
C
      IF (IFTAKE(13).EQ.1) OK_A0C=PARAMT(13)
C
C=======================================================================
C
      PARAMT(6)=A0SMIN+ARANDO(6)*(A0SMAX-A0SMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(6) ='',F20.16,'' PARAMT(6) ='',F20.14,
     *                                         '' (OASORB)'')')
     *                     ARANDO(6),              PARAMT(6)
      END IF
C
      IF (IFTAKE(6).EQ.1) OASORB=PARAMT(6)
C_______________________________________________________________________
C
      PARAMT(16)=XASMIN+ARANDO(16)*(XASMAX-XASMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(16)='',F20.16,'' PARAMT(16)='',F20.14,
     *                                         '' (XK_ASO)'')')
     *                     ARANDO(16),             PARAMT(16)
      END IF
C
      IF (IFTAKE(16).EQ.1) OK_ASO=PARAMT(16)
C
C=======================================================================
C
      PARAMT(9)=AEFMIN+ARANDO(9)*(AEFMAX-AEFMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(9)=PARAMT(6)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(9) ='',F20.16,'' PARAMT(9) ='',F20.14,
     *                                         '' (OAEFFM)'')')
     *                     ARANDO(9),              PARAMT(9)
      END IF
C
      IF (IFTAKE(9).EQ.1) OAEFFM=PARAMT(9)
C_______________________________________________________________________
C
      PARAMT(19)=XAEMIN+ARANDO(19)*(XAEMAX-XAEMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(19)=PARAMT(16)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(19)='',F20.16,'' PARAMT(19)='',F20.14,
     *                                         '' (XK_LEF)'')')
     *                     ARANDO(19),             PARAMT(19)
      END IF
C
      IF (IFTAKE(19).EQ.1) OK_XEF=PARAMT(19)
C
C=======================================================================
C         Selecting Coulomb radius; The index value 10
C=======================================================================
C
      PARAMT(10)=CouMIN+ARANDO(10)*(CouMAX-CouMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(10)='',F20.16,'' PARAMT(10)='',F20.14,
     *                                         '' (O0COUL)'')')
     *                     ARANDO(10),             PARAMT(10)
      END IF
C
      IF (IFTAKE(10).EQ.1) O0COUL=PARAMT(10)
C_______________________________________________________________________
C
      PARAMT(20)=XCoMIN+ARANDO(20)*(XCoMAX-XCoMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(20)='',F20.16,'' PARAMT(20)='',F20.14,
     *                                         '' (XK_COU)'')')
     *                     ARANDO(20),             PARAMT(20)
      END IF
C
      IF (IFTAKE(20).EQ.1) OK_COU=PARAMT(20)
C
C=======================================================================
C     Indices 21-37 are for neutrons...
C=======================================================================
C
      PARAMT(21)=V0CMIN+ARANDO(21)*(V0CMAX-V0CMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(21)='',F20.16,'' PARAMT(21)='',F20.14,
     *                                         '' (OVCENT)'')')
     *                     ARANDO(21),              PARAMT(21)
      END IF
C @@@ WHY COMMENTED?
C      IF (IFTAKE(21).EQ.1) OVCENT=PARAMT(21)
C_______________________________________________________________________
C
      PARAMT(30)=XKCMIN+ARANDO(30)*(XKCMAX-XKCMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(30)='',F20.16,'' PARAMT(30)='',F20.14,
     *                                         '' (XK_V0C)'')')
     *                     ARANDO(30),             PARAMT(30)
      END IF
C @@@ WHY COMMENTED???
      IF (IFTAKE(30).EQ.1) OK_V0C=PARAMT(30)
C
C=======================================================================
C     
C=======================================================================
C
      PARAMT(24)=XL_MIN+ARANDO(24)*(XL_MAX-XL_MIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(24)='',F20.16,'' PARAMT(24)='',F20.14,
     *                                          '' (OXSORB)'')')
     *                     ARANDO(24),              PARAMT(24)
      END IF
C
      IF (IFTAKE(24).EQ.1) OXSORB=PARAMT(24)
C_______________________________________________________________________
C
      PARAMT(33)=XKSMIN+ARANDO(33)*(XKSMAX-XKSMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(33)='',F20.16,'' PARAMT(33)='',F20.14,
     *                                          '' (XK_LAM)'')')
     *                     ARANDO(33),              PARAMT(33)
      END IF
C @@@ VERIFY CORRECTNESS
CID: OK!
      IF (IFTAKE(33).EQ.1) OK_XLM=PARAMT(33)
C
C=======================================================================
C
      PARAMT(27)=XEFMIN+ARANDO(27)*(XEFMAX-XEFMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(27)=PARAMT(24)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(27)='',F20.16,'' PARAMT(27)='',F20.14,
     *                                         '' (OXEFFM)'')')
     *                     ARANDO(27),              PARAMT(27)
      END IF
C      
      IF (IFTAKE(27).EQ.1) OXEFFM=PARAMT(27)
C_______________________________________________________________________
C
      PARAMT(36)=XKEMIN+ARANDO(36)*(XKEMAX-XKEMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(36)=PARAMT(33)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(36)='',F20.16,'' PARAMT(36)='',F20.14,
     *                                         '' (V0EFFM)'')')
     *                     ARANDO(36),              PARAMT(36)
      END IF
C      
      IF (IFTAKE(36).EQ.1) OEFMAS=PARAMT(36)
C
C=======================================================================
C     Selecting the RADII. The index values 22, 5 and 8
C=======================================================================
C
      PARAMT(22)=R0CMIN+ARANDO(22)*(R0CMAX-R0CMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(22)='',F20.16,'' PARAMT(22)='',F20.14,
     *                                         '' (ORCENT)'')')
     *                     ARANDO(22),              PARAMT(22)
      END IF
C
      IF (IFTAKE(22).EQ.1) ORCENT=PARAMT(22)
C_______________________________________________________________________
C
      PARAMT(31)=XRCMIN+ARANDO(31)*(XRCMAX-XRCMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(31)='',F20.16,'' PARAMT(31)='',F20.14,
     *                                         '' (XK_R0C)'')')
     *                     ARANDO(31),             PARAMT(31)
      END IF
C
      IF (IFTAKE(31).EQ.1) OK_R0C=PARAMT(31)
C
C=======================================================================
C
      PARAMT(25)=R0SMIN+ARANDO(25)*(R0SMAX-R0SMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(25)='',F20.16,'' PARAMT(25)='',F20.14,
     *                                         '' (ORSORB)'')')
     *                     ARANDO(25),              PARAMT(25)
      END IF
C
      IF (IFTAKE(25).EQ.1) ORSORB=PARAMT(25)
C_______________________________________________________________________
C
      PARAMT(34)=XRSMIN+ARANDO(34)*(XRSMAX-XRSMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(34)='',F20.16,'' PARAMT(34)='',F20.14,
     *                                         '' (XK_RSO)'')')
     *                     ARANDO(34),             PARAMT(34)
      END IF
C
      IF (IFTAKE(34).EQ.1) OK_RSO=PARAMT(34)
C
C=======================================================================
C
      PARAMT(28)=REFMIN+ARANDO(28)*(REFMAX-REFMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(28)=PARAMT(25)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(28)='',F20.16,'' PARAMT(28)='',F20.14,
     *                                         '' (OREFFM)'')')
     *                     ARANDO(28),              PARAMT(28)
      END IF
C
      IF (IFTAKE(28).EQ.1) OREFFM=PARAMT(28)
C_______________________________________________________________________
C
      PARAMT(37)=XREMIN+ARANDO(37)*(XREMAX-XREMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(37)=PARAMT(34)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(37)='',F20.16,'' PARAMT(37)='',F20.14,
     *                                         '' (XK_REF)'')')
     *                     ARANDO(37),             PARAMT(37)
      END IF
C
      IF (IFTAKE(37).EQ.1) OK_REF=PARAMT(37)
C
C=======================================================================
C     
C=======================================================================
C
      PARAMT(23)=A0CMIN+ARANDO(23)*(A0CMAX-A0CMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(23)='',F20.16,'' PARAMT(23)='',F20.14,
     *                                         '' (OACENT)'')')
     *                     ARANDO(23),              PARAMT(23)
      END IF
C
      IF (IFTAKE(23).EQ.1) OACENT=PARAMT(23)
C_______________________________________________________________________
C
      PARAMT(32)=XACMIN+ARANDO(32)*(XACMAX-XACMIN)
C 
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(32)='',F20.16,'' PARAMT(32)='',F20.14,
     *                                         '' (XK_A0C)'')')
     *                     ARANDO(32),             PARAMT(32)
      END IF
C
      IF (IFTAKE(32).EQ.1) OK_A0C=PARAMT(32)
C
C=======================================================================
C
      PARAMT(26)=A0SMIN+ARANDO(26)*(A0SMAX-A0SMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(26)='',F20.16,'' PARAMT(26)='',F20.14,
     *                                         '' (OASORB)'')')
     *                     ARANDO(26),              PARAMT(26)
      END IF
C
      IF (IFTAKE(26).EQ.1) OASORB=PARAMT(26)
C_______________________________________________________________________
C
      PARAMT(35)=XASMIN+ARANDO(35)*(XASMAX-XASMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(35)='',F20.16,'' PARAMT(35)='',F20.14,
     *                                         '' (XK_ASO)'')')
     *                     ARANDO(35),             PARAMT(35)
      END IF
C
      IF (IFTAKE(35).EQ.1) OK_ASO=PARAMT(35)
C
C=======================================================================
C
      PARAMT(29)=AEFMIN+ARANDO(29)*(AEFMAX-AEFMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(29)=PARAMT(26)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(29)='',F20.16,'' PARAMT(29)='',F20.14,
     *                                         '' (OAEFFM)'')')
     *                     ARANDO(29),              PARAMT(29)
      END IF
C
      IF (IFTAKE(29).EQ.1) OAEFFM=PARAMT(29)
C_______________________________________________________________________
C
      PARAMT(38)=XAEMIN+ARANDO(38)*(XAEMAX-XAEMIN)
C
      IF (IRMFST.EQ.1) THEN
          PARAMT(38)=PARAMT(35)
      END IF
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(38)='',F20.16,'' PARAMT(38)='',F20.14,
     *                                         '' (XK_LEF)'')')
     *                     ARANDO(38),             PARAMT(38)
      END IF
C
      IF (IFTAKE(38).EQ.1) OK_XEF=PARAMT(38)
C
C=======================================================================
C         Selecting the lambda values for density-dependent SO
C ###     and alpha_so and beta_so for the spin-current part
C=======================================================================
C
      PARAMT(39)=XPPMIN+ARANDO(39)*(XPPMAX-XPPMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(39)='',F20.16,'' PARAMT(39)='',F20.14,
     *                                         '' (OLDXPP)'')')
     *                     ARANDO(39),             PARAMT(39)
      END IF
C
      IF (IFTAKE(39).EQ.1) OLDXPP=PARAMT(39)
C_______________________________________________________________________
C
      PARAMT(40)=XPNMIN+ARANDO(40)*(XPNMAX-XPNMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(40)='',F20.16,'' PARAMT(40)='',F20.14,
     *                                         '' (OLDXPN)'')')
     *                     ARANDO(40),             PARAMT(40)
      END IF
C
      IF (IFTAKE(40).EQ.1) OLDXPN=PARAMT(40)
C
C=======================================================================
C
      PARAMT(41)=XNPMIN+ARANDO(41)*(XNPMAX-XNPMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(41)='',F20.16,'' PARAMT(41)='',F20.14,
     *                                         '' (OLDXNP)'')')
     *                     ARANDO(41),             PARAMT(41)
      END IF
C
      IF (IFTAKE(41).EQ.1) OLDXNP=PARAMT(41)
C_______________________________________________________________________
C
      PARAMT(42)=XNNMIN+ARANDO(42)*(XNNMAX-XNNMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(42)='',F20.16,'' PARAMT(42)='',F20.14,
     *                                         '' (OLDXNN)'')')
     *                     ARANDO(42),             PARAMT(42)
      END IF
C
      IF (IFTAKE(42).EQ.1) OLDXNN=PARAMT(42)
C
C=======================================================================
C     Selecting the lambda values for tensor part
C=======================================================================
C
      PARAMT(43)=YPPMIN+ARANDO(43)*(YPPMAX-YPPMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(43)='',F20.16,'' PARAMT(43)='',F20.14,
     *                                         '' (OLDYPP)'')')
     *                     ARANDO(43),             PARAMT(43)
      END IF
C
      IF (IFTAKE(43).EQ.1) OLDYPP=PARAMT(43)
C_______________________________________________________________________
C
      PARAMT(44)=YPNMIN+ARANDO(44)*(YPNMAX-YPNMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(44)='',F20.16,'' PARAMT(44)='',F20.14,
     *                                         '' (OLDYPN)'')')
     *                     ARANDO(44),             PARAMT(44)
      END IF
C
      IF (IFTAKE(44).EQ.1) OLDYPN=PARAMT(44)
C
C=======================================================================
C
      PARAMT(45)=YNPMIN+ARANDO(45)*(YNPMAX-YNPMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(45)='',F20.16,'' PARAMT(45)='',F20.14,
     *                                         '' (OLDYNP)'')')
     *                     ARANDO(45),             PARAMT(45)
      END IF
C
      IF (IFTAKE(45).EQ.1) OLDYNP=PARAMT(45)
C_______________________________________________________________________
C
      PARAMT(46)=YNNMIN+ARANDO(46)*(YNNMAX-YNNMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(46)='',F20.16,'' PARAMT(46)='',F20.14,
     *                                         '' (OLDYNN)'')')
     *                     ARANDO(46),             PARAMT(46)
      END IF
C
      IF (IFTAKE(46).EQ.1) OLDYNN=PARAMT(46)
C
C=======================================================================
C     Selecting the lambda values for tensor part
C=======================================================================
C
      PARAMT(47)=CPPMIN+ARANDO(47)*(CPPMAX-CPPMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(47)='',F20.16,'' PARAMT(47)='',F20.14,
     *                                         '' (OLDCPP)'')')
     *                     ARANDO(47),             PARAMT(47)
      END IF
C
      IF (IFTAKE(47).EQ.1) OLDCPP=PARAMT(47)
C_______________________________________________________________________
C
      PARAMT(48)=CPNMIN+ARANDO(48)*(CPNMAX-CPNMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(48)='',F20.16,'' PARAMT(48)='',F20.14,
     *                                         '' (OLDCPN)'')')
     *                     ARANDO(48),             PARAMT(48)
      END IF
C
      IF (IFTAKE(48).EQ.1) OLDCPN=PARAMT(48)
C
C=======================================================================
C
      PARAMT(49)=CNPMIN+ARANDO(49)*(CNPMAX-CNPMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(49)='',F20.16,'' PARAMT(49)='',F20.14,
     *                                         '' (OLDCNP)'')')
     *                     ARANDO(49),             PARAMT(49)
      END IF
C
      IF (IFTAKE(49).EQ.1) OLDCNP=PARAMT(49)
C_______________________________________________________________________
C
      PARAMT(50)=CNNMIN+ARANDO(50)*(CNNMAX-CNNMIN)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(50)='',F20.16,'' PARAMT(50)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(50),             PARAMT(50)
      END IF
C
      IF (IFTAKE(50).EQ.1) OLDCNN=PARAMT(50)
C
C=======================================================================
C=======================================================================
C
C     Real kappa parametrization
C
      PARAMT(51)=V0CMIN_KAPPAR+ARANDO(51)*(V0CMAX_KAPPAR-V0CMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(51)='',F20.16,'' PARAMT(51)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(51),             PARAMT(51)
      END IF
C
      IF (IFTAKE(51).EQ.1) OLDV0C_KAPPAR=PARAMT(51)
C_______________________________________________________________________
C
      PARAMT(52)=XKCMIN_KAPPAR+ARANDO(52)*(XKCMAX_KAPPAR-XKCMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(52)='',F20.16,'' PARAMT(52)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(52),             PARAMT(52)
      END IF
C
      IF (IFTAKE(52).EQ.1) OLDKVC_KAPPAR=PARAMT(52)
C_______________________________________________________________________
C
      PARAMT(53)=R0CMIN_KAPPAR+ARANDO(53)*(R0CMAX_KAPPAR-R0CMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(53)='',F20.16,'' PARAMT(53)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(53),             PARAMT(53)
      END IF
C
      IF (IFTAKE(53).EQ.1) OLDR0C_KAPPAR=PARAMT(53)
C_______________________________________________________________________
C
      PARAMT(54)=XRCMIN_KAPPAR+ARANDO(54)*(XRCMAX_KAPPAR-XRCMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(54)='',F20.16,'' PARAMT(54)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(54),             PARAMT(54)
      END IF
C
      IF (IFTAKE(54).EQ.1) OLDXRC_KAPPAR=PARAMT(54)
C_______________________________________________________________________
C
      PARAMT(55)=A0CMIN_KAPPAR+ARANDO(55)*(A0CMAX_KAPPAR-A0CMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(55)='',F20.16,'' PARAMT(55)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(55),             PARAMT(55)
      END IF
C
      IF (IFTAKE(55).EQ.1) OLDA0C_KAPPAR=PARAMT(55)
C_______________________________________________________________________
C
      PARAMT(56)=XACMIN_KAPPAR+ARANDO(56)*(XACMAX_KAPPAR-XACMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(56)='',F20.16,'' PARAMT(56)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(56),             PARAMT(56)
      END IF
C
      IF (IFTAKE(56).EQ.1) OLDXAC_KAPPAR=PARAMT(56)
C_______________________________________________________________________
C
      PARAMT(57)=XL_MIN_KAPPAR+ARANDO(57)*(XL_MAX_KAPPAR-XL_MIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(57)='',F20.16,'' PARAMT(57)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(57),             PARAMT(57)
      END IF
C
      IF (IFTAKE(57).EQ.1) OLD_XL_KAPPAR=PARAMT(57)
C_______________________________________________________________________
C
      PARAMT(58)=XKSMIN_KAPPAR+ARANDO(58)*(XKSMAX_KAPPAR-XKSMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(58)='',F20.16,'' PARAMT(58)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(58),             PARAMT(58)
      END IF
C
      IF (IFTAKE(58).EQ.1) OLDXKS_KAPPAR=PARAMT(58)
C_______________________________________________________________________
C
      PARAMT(59)=R0SMIN_KAPPAR+ARANDO(59)*(R0SMAX_KAPPAR-R0SMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(59)='',F20.16,'' PARAMT(59)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(59),             PARAMT(59)
      END IF
C
      IF (IFTAKE(59).EQ.1) OLDR0S_KAPPAR=PARAMT(59)
C_______________________________________________________________________
C
      PARAMT(60)=XRSMIN_KAPPAR+ARANDO(60)*(XRSMAX_KAPPAR-XRSMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(60)='',F20.16,'' PARAMT(60)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(60),             PARAMT(60)
      END IF
C
      IF (IFTAKE(60).EQ.1) OLDXRS_KAPPAR=PARAMT(60)
C_______________________________________________________________________
C
      PARAMT(61)=A0SMIN_KAPPAR+ARANDO(61)*(A0SMAX_KAPPAR-A0SMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(61)='',F20.16,'' PARAMT(61)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(61),             PARAMT(61)
      END IF
C
      IF (IFTAKE(61).EQ.1) OLDA0S_KAPPAR=PARAMT(61)
C_______________________________________________________________________
C
      PARAMT(62)=XASMIN_KAPPAR+ARANDO(62)*(XASMAX_KAPPAR-XASMIN_KAPPAR)
C
      IF (IMTALK.EQ.1) THEN
C
          WRITE(IRESUL,'(''ARANDO(62)='',F20.16,'' PARAMT(62)='',F20.14,
     *                                         '' (OLDCNN)'')')
     *                     ARANDO(62),             PARAMT(62)
      END IF
C
      IF (IFTAKE(62).EQ.1) OLDXAS_KAPPAR=PARAMT(62)
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          IF (ISOSPI.EQ.0) THEN
C      
              WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *            ''#                     Starting Parameter '',
     *            ''Values (Neutrons)                     #'',/,
     *            ''#'',T80,''#'',/,
     *            ''#    Central Potential         Spin-Orbit '',
     *            ''Potential        Effective Mass      #'',/,
     *            ''#'',T80,''#'',/,
     *            ''#    Vo      Ro      a       Lambda    Ro      '',
     *            ''a       Lambda     Ro     a     #'',/,
     *            ''# '',F7.3,2F8.4,3X,F7.3,2F8.4,3X,F7.3,2F8.4,''  #'',
     *            /,''#'',T80,''#'',/,80(''#''))')
     *
     *            PARAMT(1),PARAMT(2),PARAMT(3),
     *            PARAMT(4),PARAMT(5),PARAMT(6),
     *            PARAMT(7),PARAMT(8),PARAMT(9) 
C
          ELSE
C
              WRITE(NOUTPT,'(/,80(''#''),/,''#'',T80,''#'',/,
     *            ''#                     Starting Parameter '',
     *            ''Values (Protons)                      #'',/,
     *            ''#'',T80,''#'',/,
     *            ''#    Central Potential         Spin-Orbit '',
     *            ''Potential        Effective Mass      #'',/,
     *            ''#'',T80,''#'',/,
     *            ''#    Vo      Ro      a       Lambda    Ro      '',
     *            ''a       Lambda     Ro     a     #'',/,
     *            ''# '',F7.3,2F8.4,3X,F7.3,2F8.4,3X,F7.3,2F8.4,''  #'',
     *            /,''#'',T80,''#'',/,80(''#''))')
     *
     *            PARAMT(1),PARAMT(2),PARAMT(3),
     *            PARAMT(4),PARAMT(5),PARAMT(6),
     *            PARAMT(7),PARAMT(8),PARAMT(9) 
C
          END IF
C
      END IF      
C
C=======================================================================
C
      DO I=1,NDPARS
         STARTV(I)=PARAMT(I)
      END DO
C
C=======================================================================
C     Filtering the parameters which will be varied by the minimisation
C                                                           subroutine
C=======================================================================
C
      LDSEAR=0
C
C=======================================================================
C     Beginning with the central potential depth...
C=======================================================================
C
      DO I=1,NDPARS
         IF (IFTAKE(I).EQ.1) THEN
             LDSEAR=LDSEAR+1
             ARGPAR(LDSEAR)=PARAMT(I)
         END IF
      END DO
C  
C     In principle, the parameters of the spin-orbit term
C     and those related to the effective mass term should
C     be equal. On the phenomenological basis,  it may be 
C     of interest to let varying the three effective mass
C     parameters independently. For that reason we select
C     the control IRMFST (reduced mass fixed)  equal to 0
C
C     IF (IRMFST.EQ.0) THEN
C          
C         IF (LAMEFF.EQ.'YES') THEN
C             LDSEAR=LDSEAR+1             
C             ARGPAR(LDSEAR)=PARAMT(3)
C         END IF
C
C     END IF
C
C     IF (IRMFST.EQ.0) THEN
C          
C         See comments just above              
C          
C         IF (RADEFF.EQ.'YES') THEN
C             LDSEAR=LDSEAR+1             
C             ARGPAR(LDSEAR)=PARAMT(6)
C         END IF
C
C     END IF
C
C     IF (IRMFST.EQ.0) THEN
C          
C         See comments just above              
C          
C         IF (DIFEFF.EQ.'YES') THEN
C             LDSEAR=LDSEAR+1             
C             ARGPAR(LDSEAR)=PARAMT(9)
C         END IF
C
C     END IF
C
C=======================================================================
C
      LDSEAR=0
C
      DO I=1,NDPARS
C
         IF ((IFTAKE(I).EQ.1).AND.(IFIRST.NE.1)) THEN
C
             PARAMT(I)=VMIMIN(I)+ARANDO(I)*(VMIMAX(I)-VMIMIN(I))
             LDSEAR=LDSEAR+1
             ARGPAR(LDSEAR)=PARAMT(I)
C
         ELSE
             PARAMT(I)=VMISTR(I)
         END IF
C
      END DO
C
C=======================================================================
C     Reinitializing the random number generator to a new value
C=======================================================================
C
      PIOVE2=2.0*ATAN(1.0)
C
      NEWSED=NINT(10000.*ABS(COS(PIOVE2*ARANDO(1))))
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(9X,''Exiting  NEWRAN'')')
      END IF 
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE FUNMIN(NDFUNC,LDFUNC,NDPARS,LDPARS,ARGPAR,FUNVEC,
     *                                              FUNJAC,I_FLAG)
      INCLUDE   'MATDIM/NDSPEC.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDLEXP.f'
      INCLUDE   'MATDIM/MAXFEV.f'
      INCLUDE   'MATDIM/NDIM_M.f'
      INCLUDE   'MATDIM/NDIM_P.f'
      INCLUDE   'MATDIM/ND_RHO.f'
      INCLUDE   'MATDIM/N_NOYX.f'
      INCLUDE   'MATDIM/NDTITL.f'
C_______________________________________________________________________
C      
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      CHARACTER
     *          TITLES_EXPORT*12
      CHARACTER
     *          ACTION*1,TYPCHI*6
      CHARACTER
     *          BLANCK*1
      CHARACTER
     *          INPSYM*6,NUCSYM*6,SYMBNU*5
C_______________________________________________________________________
C      
      DIMENSION
     *          FUNCT0(1:NDIM_M),FUNCT1(1:NDIM_M),FUNEXP(1:NDIM_M),
     *          LEVELS(1:NDIM_M),LEXPLS(1:NDIM_M),DERIVF(1:NDIM_M)
      DIMENSION 
     *          ARGPAR(1:NDPARS),FUNVEC(1:NDFUNC)
      DIMENSION
     *          WEIGHT_FUNVEC(1:NDIM_M)
      DIMENSION 
     *          FUNJAC(1:NDFUNC,1:NDPARS)
      DIMENSION
     *          DEGENE(1:NDIM_M)
      DIMENSION
     *          WEISQR_FUNVEC(1:NDIM_M)
      DIMENSION
     *          CHISQU_AUXILP(1:NDPARS,1:NDNUCL),
     *          CHISQU_AUXILN(1:NDPARS,1:NDNUCL),
     *          CHISQU_GRADNT(1:NDPARS)
      DIMENSION
     *          FUNAUX(1:NDIM_M),
     *          IVECTR(1:NDIM_M)
      DIMENSION
     *          CHIWEI_NUCLEU(1:NDNUCL),
     *          CHIWEI_NUCPRO(1:NDNUCL),
     *          CHIWEI_NUCNEU(1:NDNUCL)
      DIMENSION        
     *          CHIRAD_NUCLEU(1:NDNUCL),
     *          CHIRAD_NUCPRO(1:NDNUCL),
     *          CHIRAD_NUCNEU(1:NDNUCL)
      DIMENSION
     *          DEGSUM_NUCPRO(1:NDNUCL),
     *          DEGSUM_NUCNEU(1:NDNUCL)
      DIMENSION
     *          IACTIV_VECTOR(1:NDPARS)
C_______________________________________________________________________
C      
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS
      COMMON
     *       /NOWEIG/ CHIENE_PROTON(1:NDNUCL),CHIENE_NEUTRS(1:NDNUCL),
     *                CHIENE_TOTALS(1:NDNUCL),
     *                CHIRAD_PROTON(1:NDNUCL),CHIRAD_NEUTRS(1:NDNUCL),
     *                CHIRAD_TOTALS(1:NDNUCL)
      COMMON
     *       /NUCWEI/ WEINUC_PROTON(1:NDNUCL),
     *                WEINUC_NEUTRS(1:NDNUCL),
     *                WEIRAD_PROTON(1:NDNUCL),
     *                WEIRAD_NEUTRS(1:NDNUCL)
      COMMON
     *       /TITEXP/ TITLES_EXPORT(1:NDTITL)
      COMMON
     *       /WEIGHT/ WEIGHT_CORREL,WEIGHT_RADIUS,WEIGHT_INVERT,
     *                WEIGHT_EFERMI,WEIGHT_ENEGAP,WEIWEI,
     *                WEIGHT_ERRABS,WEIGHT_EABSAV,WEIGHT_ERRMAX,
     *                WEIGHT_DENSUP,WEIGHT_DENSDW,WEIGHT_RHODEN
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THEORF/ FERTHE_PROTON,GAPTHE_PROTON,
     *                DENUPP_PROTON,DENLOW_PROTON,
     *
     *                FERTHE_NEUTRS,GAPTHE_NEUTRS,
     *                DENUPP_NEUTRS,DENLOW_NEUTRS 
      COMMON
     *       /FERGPS/ FERMEX_PROTON(1:NDNUCL),GAPEXP_PROTON(1:NDNUCL),
     *                DENSUP_PROTON(1:NDNUCL),DENSDW_PROTON(1:NDNUCL),
     *
     *                FERMEX_NEUTRS(1:NDNUCL),GAPEXP_NEUTRS(1:NDNUCL),
     *                DENSUP_NEUTRS(1:NDNUCL),DENSDW_NEUTRS(1:NDNUCL) 
      COMMON
     *       /SEARCH/ IFTAKE(1:NDIM_P)
      COMMON
     *       /CNTROL/ PARAMT(1:NDIM_P),
     *                DPARAM(1:NDIM_P)  
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /MESHIN/ I_MESH(1:NDIM_P),
     *                XMIN_I(1:NDIM_P),
     *                XMAX_I(1:NDIM_P),
     *                MAXPAR(1:NDIM_P)
      COMMON
     *       /TESFIT/ IFTEST,IFFITS,IFMESH,ISPE_P,IFMOCA
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)   
      COMMON
     *       /ACTACT/ ACTION(1:NDIM_P)
      COMMON
     *       /POTPOT/ PARPOT(1:NDIM_P)
      COMMON
     *       /ARGINI/ XINITS(1:NDIM_P)
      COMMON
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /CHI_PN/ CHISQU_PROTON,CHISQU_NEUTRS
      COMMON
     *       /CHICHO/ VALCHI
      COMMON
     *       /CHIGRD/ CHISQU_GRDNRM,
     *                CHISQU_GRADIE(1:NDIM_P)
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /STOPIN/ HIAUXI(1:MAXFEV)
      COMMON
     *       /THEDEN/ N_NUCL,I_NUCL(1:N_NOYX),
     *                RHOTHE(1:ND_RHO,1:N_NOYX)
      COMMON
     *       /EXPDEN/ LABELN(1:N_NOYX,1:2),
     *                R_MESH(1:ND_RHO,1:N_NOYX),
     *                RHOEXP(1:ND_RHO,1:N_NOYX)
     *
     *       /EXPSYM/ SYMBNU(1:N_NOYX)
      COMMON
     *       /CNTCNT/ ICOUNT_DENGRD,ICOUNT_FUNMIN,ICOUNT_HAMMAT,
     *                ICOUNT_EXPTHE,ICOUNT_CHOICE,ICOUNT_DIAMAT
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS            
C
C=======================================================================
C
C     This subroutine constructs function FUNVEC, as the difference
C     between the experimental and theoretical data sets the latter
C     composed of, e.g., single particle energies, radii, densities
C     etc. FUNVEC is then used by Levenberg - Marquard minimisation
C     subroutine LEVMAR.
C 
C     This subroutine also constructs the Jacobian matrix FUNJAC by
C     using the method of finite differences.
C
C     If I_FLAG = 1, calculating the functions at ARGMNT and return
C     the function-vector in FUNVEC. Here we do not alter Jacobian.
C
C     If I_FLAG = 2, calculating the Jacobian at ARGMNT, and return
C     the corresponding matrix in FUNJAC.  Here not altering FUNVEC.
C
C     If IFMESH = 1, we prepare a map by minimising the chi^2, over 
C                                       a square-set of mesh points.
C
C=======================================================================
C
C     How we have defined the \chi^2 with the corresponding weights
C     and normalization factors:
C
C     w_k(e) - energy weight for nucleus k
C     w_k(r) - radius weight for nucleus k
C
C     \chi^2_k = w_k(e) \sum_i [ e_i(th) - e_i(exp) ]^2 * (2j_i+1)
C              + w_k(r) [ r_k(th)-r_k(exp) ]^2
C
C     N = \sum_k [ w_k(e) \sum_i (2j_i+1) + w_k(r) ] 
C
C     The total \chi^2 is:
C                          \chi^2 = [\sum_k (\chi^2_k)] / N
C
C=======================================================================
C
      CALL CPUTIM('FUNMIN',1)
C
      ICOUNT_FUNMIN=ICOUNT_FUNMIN+1
C
C=======================================================================
C
      IF (NDIM_P.NE.NDPARS) THEN
          WRITE(LSCREN,'(/,''Alarm in FUNMIN: NDIM_P= '',I3,1X,
     *                     ''and NDPARS= '',I3,''are not equal!!'',/)')
     *                           NDIM_P,NDPARS
          STOP 'STOP in FUNMIN: NDIM_P.NE.NDPARS'
      END IF
C
C=======================================================================
C
      IF (IFPROT.EQ.1) ISOSPI_MINIMI=1
      IF (IFNEUT.EQ.1) ISOSPI_MINIMI=0
C
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(12X,''Entering VERIFY from FUNMIN, '',
     *                       ''IDEFCN='',I3)')
     *                         IDEFCN           
      END IF
C  @@@ IRENE - WHAT IS ABORTED AND WHY? MEANING OF THIS VARIABLE?     
      CALL VERIFY(ARGPAR,IABORT)
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(12X,''After VERIFY in FUNMIN, IABORT= '',I1)') 
     *                                                 IABORT
      END IF
C
C=======================================================================
C
C     Here we collect the active (varying) parameters which are stored
C     in PARPOT(1), PARPOT(2), â€¦ PARPOT(MAX) whereas ARGPAR correspond
C     to a fixed storage in which active and non-active parameters are
C                                                                mixed
      IACTIV=0 ! IACTIV will count, how many active parameters we have
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(12X,''Parameters in FUNMIN'',
     *                       ''(IDEFCN,IPARAM,IACTIV,'',
     *                       ''ARGPAR(IACTIV),PARPOT(IACTIV))'')')
      END IF
C
      DO IPARAM=1,NDPARS  
C                  
         ACTION(IPARAM)=' '
C
         IF (IFTAKE(IPARAM).EQ.1) THEN
C
             IACTIV=IACTIV+1
             PARPOT(IPARAM)=ARGPAR(IACTIV)
C
             IACTIV_VECTOR(IPARAM)=IACTIV
C
             IF (LOGWRI.GT.0) THEN
                 WRITE(LOGFIL,'(T13,''PARAM ='',A,T31,3I7,2F15.4)') 
     *                          TITLES_EXPORT(IPARAM),
     *                          IDEFCN,IPARAM,IACTIV,ARGPAR(IACTIV),
     *                                               PARPOT(IPARAM)
             END IF
         END IF
C         
         IF (IFMESH.EQ.1) THEN
             IF (I_MESH(IPARAM).EQ.1) THEN
                 PARPOT(IPARAM)=XINITS(IPARAM)
             END IF
         END IF
C                  
      END DO  
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'()')
C
C=======================================================================
C
C     Below: Setting to zero the future total chi^2 functions which
C            will include the individual, physicist-defined weight- 
C                                                           factors
C
      DO INUCLI=1,LDNUCL
C          
         CHIWEI_NUCLEU(INUCLI)=0.0
         CHIWEI_NUCPRO(INUCLI)=0.0
         CHIWEI_NUCNEU(INUCLI)=0.0
C                                 Similar for the radius chi^2 only
         CHIRAD_NUCLEU(INUCLI)=0.0
         CHIRAD_NUCPRO(INUCLI)=0.0
         CHIRAD_NUCNEU(INUCLI)=0.0
C       
      END DO
C
C=======================================================================
C
      ILEVEL=0
      LEVPRO=0
      LEVNEU=0
C
      INITI1=0
      INITI2=0
C
      IAUXIL=0 ! Counting the number of differences (exp-th) we have
C                                 (used in the Jacobian construction)
C
C     The meaning of the variables below:
C
C     CHISQU_PROTON and CHISQU_NEUTRS =>> total chi^2 summed on all
C                                         the components and nuclei
C
      CHISQU_PROTON=0.0 ! As above, for protons
      CHISQU_NEUTRS=0.0 ! As above, for neutrons
      CHISQU_TOTALS=0.0 ! As above, protons and neutrons together
C
      
C
      CHIRAD_WEIPRO=0.0
      CHIRAD_WEINEU=0.0
      CHIRHO_WEIPRO=0.0
C
C=======================================================================
C
C     First, calculating the total weights (protons and neutrons)
C     that will be used as the normalizing constants of the \chi^2
C
      WEIGHT_PROTON=0.0
      WEIGHT_NEUTRS=0.0
C
      DEGPRO_NOWEIG=0.0
      DEGNEU_NOWEIG=0.0
C
      SUMWEI_PROTON=0.0
      SUMWEI_NEUTRS=0.0
C
      DO INUCLI=1,LDNUCL
         DEGSUM_NUCPRO(INUCLI)=0.0
         DEGSUM_NUCNEU(INUCLI)=0.0
      END DO
C
      DO INUCLI=1,LDNUCL
         IF (ITAKNU(INUCLI).EQ.1) THEN
C_______________________________________________________________________
C
             IF (IF_SPE.EQ.1) THEN
C
                 DEGSUM_PROTON=0.0
C
                 DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                    DEGAUX=REAL(IDEGEX_PROTON(INUCLI,IEXPER))
                    DEGSUM_PROTON=DEGSUM_PROTON+DEGAUX
                 END DO
C
                 DEGSUM_NUCPRO(INUCLI)=DEGSUM_PROTON
C
                 DEGPRO_NOWEIG=DEGPRO_NOWEIG+DEGSUM_PROTON
C
                 WEIGHT_PROTON=WEIGHT_PROTON+DEGSUM_PROTON
     *                                      *WEINUC_PROTON(INUCLI)
C
                 DEGSUM_NEUTRS=0.0
C
                 DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                    DEGAUX=REAL(IDEGEX_NEUTRS(INUCLI,IEXPER))
                    DEGSUM_NEUTRS=DEGSUM_NEUTRS+DEGAUX
                 END DO
C
                 DEGSUM_NUCNEU(INUCLI)=DEGSUM_NEUTRS
C
                 DEGNEU_NOWEIG=DEGNEU_NOWEIG+DEGSUM_NEUTRS
C
                 WEIGHT_NEUTRS=WEIGHT_NEUTRS+DEGSUM_NEUTRS
     *                                      *WEINUC_NEUTRS(INUCLI)
C
             END IF
C_______________________________________________________________________
C
             IF (IF_RAD.EQ.1) THEN
C
                 WEIGHT_PROTON=WEIGHT_PROTON+WEIRAD_PROTON(INUCLI)
                 WEIGHT_NEUTRS=WEIGHT_NEUTRS+WEIRAD_NEUTRS(INUCLI)
C
             END IF
C_______________________________________________________________________
C
             SUMWEI_PROTON=SUMWEI_PROTON+WEINUC_PROTON(INUCLI)
             SUMWEI_NEUTRS=SUMWEI_NEUTRS+WEINUC_NEUTRS(INUCLI)
C
         END IF
      END DO
C
C=======================================================================
C
C     Starting the do-loop over the active nuclei
C
      CHIENE_WEIPRO=0.0 ! As above but including the s.p. energies only
      CHIENE_WEINEU=0.0 ! As above but including the s.p. energies only         
C
      DO INUCLI=1,LDNUCL
C     
         IF (ITAKNU(INUCLI).EQ.1) THEN
C
             IZ_FIX=NUMB_Z(INUCLI)
             IN_FIX=NUMB_N(INUCLI)
C
             IF (LOGWRI.GT.4) THEN
                 WRITE(LOGFIL,'(12X,''Entering WS_RUN from FUNMIN '',
     *                              ''[1] with IZ_FIX='',I3, 
     *                                      '' IN_FIX='',I3,
     *                                      '' INUCLI='',I1)')
     *                                         IZ_FIX,IN_FIX,INUCLI
c                WRITE(LOGFIL,'()')
             END IF
C
                                                     I_MODE=0
             CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,I_FLAG,
     *                                 CHISQU_AUXIL1,CHISQU_AUXIL2)
C_______________________________________________________________________
C
C            The following quantities contain ALL \chi^2 contributions 
C            They already contain their corresponding weight factors
C
C            These quantites are the ones printed in the LOGAUX files
C        
             CHISQU_PROTON=CHISQU_PROTON+(CHISQU_AUXIL1/SUMWEI_PROTON)
C
             CHISQU_NEUTRS=CHISQU_NEUTRS+(CHISQU_AUXIL2/SUMWEI_NEUTRS)
C
             CHISQU_TOTALS=CHISQU_TOTALS+(CHISQU_AUXIL1/SUMWEI_PROTON)
     *                                  +(CHISQU_AUXIL2/SUMWEI_NEUTRS)
C_______________________________________________________________________
C 
C            The following quantities are calculated SEPARATELY for
C            each nucleus; the \chi^2 contributions contain the weights
C
             CHIWEI_NUCPRO(INUCLI)=CHIWEI_PROTON*WEINUC_PROTON(INUCLI)
             CHIWEI_NUCNEU(INUCLI)=CHIWEI_NEUTRS*WEINUC_NEUTRS(INUCLI)
             CHIWEI_NUCLEU(INUCLI)=CHIWEI_NUCPRO(INUCLI)
     *                            +CHIWEI_NUCNEU(INUCLI)
C        
             CHIRAD_NUCPRO(INUCLI)=RADDIF_PROTON*WEIRAD_PROTON(INUCLI)
             CHIRAD_NUCNEU(INUCLI)=RADDIF_NEUTRS*WEIRAD_NEUTRS(INUCLI)
             CHIRAD_NUCLEU(INUCLI)=CHIRAD_NUCPRO(INUCLI)
     *                            +CHIRAD_NUCNEU(INUCLI)
C_______________________________________________________________________
C
C            These quantites are the ones printed in the LOGAUX files
C
             CHIENE_WEIPRO=CHIENE_WEIPRO+CHIDEG_PROTON
             CHIENE_WEINEU=CHIENE_WEINEU+CHIDEG_NEUTRS
C
             CHIRAD_WEIPRO=CHIRAD_WEIPRO+RADDIF_PROTON
     *                                  *WEIRAD_PROTON(INUCLI)
             CHIRAD_WEINEU=CHIRAD_WEINEU+RADDIF_NEUTRS
     *                                  *WEIRAD_NEUTRS(INUCLI)
C
             CHIRHO_WEIPRO=CHIRHO_WEIPRO+CHIRHO_PROTON*WEIGHT_RHODEN
C_______________________________________________________________________
C
C            The following quantities are calculated SEPARATELY for
C            each nucleus; the \chi^2 contributions do not contain 
C            any weights
C            These quantities are then pinted in LOGENE and LOGRAD
C        
             CHIENE_PROTON(INUCLI)=SQRT(CHIDEG_PROTON
     *                            /     DEGSUM_NUCPRO(INUCLI))
             CHIENE_NEUTRS(INUCLI)=SQRT(CHIDEG_NEUTRS
     *                            /     DEGSUM_NUCNEU(INUCLI))
             CHIENE_TOTALS(INUCLI)=CHIENE_PROTON(INUCLI)
     *                            +CHIENE_NEUTRS(INUCLI)
C
             CHIRAD_PROTON(INUCLI)=RMSTHE_PROTON-RMSEXP_PROTON(INUCLI)
             CHIRAD_NEUTRS(INUCLI)=RMSTHE_NEUTRS-RMSEXP_NEUTRS(INUCLI)
             CHIRAD_TOTALS(INUCLI)=RMSTHE_PROTON-RMSEXP_PROTON(INUCLI)
     *                            +RMSTHE_NEUTRS-RMSEXP_NEUTRS(INUCLI)
C
C=======================================================================                 
C=======================================================================                 
C
C            Option 01: Density-dependent spin-orbit
C
             IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C
C                Item No. 01: The single particle energies
C         
                 IF (IF_SPE.EQ.1) THEN ! The single-particle energy
C                                                      contribution
C                    PROTONS
C
                     DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                        DO ITHEOR=1,LEVTHE_PROTON
C
                           IF (LABEXP_PROTON(INUCLI,IEXPER).EQ.
     *                         LABTHE_PROTON(ITHEOR)) THEN
C
                               ILEVEL=ILEVEL+1
                               LEVPRO=LEVPRO+1
                               LEVPRO=ILEVEL
C
                               IF (IEXPER.EQ.1) INITI1=ILEVEL
C
                               FUNCT0(ILEVEL)=ENETHE_PROTON(ITHEOR)
                               FUNEXP(ILEVEL)=EXPEXP_PROTON(INUCLI,
     *                                                      IEXPER)
                               LEVELS(ILEVEL)=ITHEOR
                               LEXPLS(ILEVEL)=IEXPER
C
                               DEGENE(ILEVEL)
     *                        =
     *                         REAL(IDEGEX_PROTON(INUCLI,IEXPER))
C
                               WEISQR_FUNVEC(ILEVEL)
     *                        =
     *                         SQRT(DEGENE(ILEVEL)*WEINUC_PROTON(INUCLI)
     *                                            /SUMWEI_PROTON)           
C
                           END IF
C
                        END DO ! ITHEOR
                     END DO ! IEXPER
C_______________________________________________________________________
C
C                    NEUTRONS
C
                     DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                        DO ITHEOR=1,LEVTHE_NEUTRS
                   
                           IF (LABEXP_NEUTRS(INUCLI,IEXPER).EQ.
     *                         LABTHE_NEUTRS(ITHEOR))      THEN
C
                               ILEVEL=ILEVEL+1
                               LEVNEU=LEVNEU+1
                               LEVNEU=ILEVEL
C
                               IF (IEXPER.EQ.1) INITI2=ILEVEL
C
                               FUNCT0(ILEVEL)=ENETHE_NEUTRS(ITHEOR)
                               FUNEXP(ILEVEL)=EXPEXP_NEUTRS(INUCLI,
     *                                                      IEXPER)
                               LEVELS(ILEVEL)=ITHEOR
                               LEXPLS(ILEVEL)=IEXPER
C
                               DEGENE(ILEVEL)
     *                        =
     *                         REAL(IDEGEX_NEUTRS(INUCLI,IEXPER))
C
                               WEISQR_FUNVEC(ILEVEL)
     *                        =
     *                         SQRT(DEGENE(ILEVEL)*WEINUC_NEUTRS(INUCLI)
     *                                            /SUMWEI_NEUTRS)
                           END IF
C
                        END DO
                     END DO
C         
                 END IF ! IF_SPE=1
C         
C            IF (IFDENS.EQ.1) THEN  ==>>>  ==>>>
C 
C=======================================================================
C
C                Item No. 02: The proton and neutron r.m.s. radii
C          
                 IF (IF_RAD.EQ.1) THEN
C
                     ILEVEL=ILEVEL+1
C                    INITI3=ILEVEL
C
                     FUNCT0(ILEVEL)=RMSTHE_PROTON
                     FUNEXP(ILEVEL)=RMSEXP_PROTON(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIRAD_PROTON(INUCLI)
     *                                    *     WEINUC_PROTON(INUCLI)
     *                                    /     SUMWEI_PROTON) 
C
                     ILEVEL=ILEVEL+1
C
                     FUNCT0(ILEVEL)=RMSTHE_NEUTRS
                     FUNEXP(ILEVEL)=RMSEXP_NEUTRS(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIRAD_NEUTRS(INUCLI)
     *                                    *     WEINUC_NEUTRS(INUCLI)
     *                                    /     SUMWEI_NEUTRS) 
C
                 END IF ! IF_RAD=1
C
C=======================================================================
C         
C            IF (IFDENS.EQ.1) THEN  ==>>>  ==>>>
C
C                Item No. 03: The proton and neutron main gaps
C          
                 IF (IF_GAP.EQ.1) THEN
C
                     ILEVEL=ILEVEL+1
C                    INITI4=ILEVEL
C
                     FUNCT0(ILEVEL)=GAPTHE_PROTON
                     FUNEXP(ILEVEL)=GAPEXP_PROTON(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_ENEGAP
     *                                    /     SUMWEI_PROTON) 
C
                     ILEVEL=ILEVEL+1
C
                     FUNCT0(ILEVEL)=GAPTHE_NEUTRS
                     FUNEXP(ILEVEL)=GAPEXP_NEUTRS(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_ENEGAP
     *                                    /     SUMWEI_NEUTRS) 
C
                 END IF ! IF_GAP=1
C         
C======================================================================= 
C         
C            IF (IFDENS.EQ.1) THEN ==>>> ==>>>
C
C                Item No. 04: The proton and neutron "Fermi energies"
C         
                 IF (IF_FER.EQ.1) THEN
             
                     ILEVEL=ILEVEL+1
C                    INITI5=ILEVEL
C
                     FUNCT0(ILEVEL)=FERTHE_PROTON
                     FUNEXP(ILEVEL)=FERMEX_PROTON(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_EFERMI
     *                                    /     SUMWEI_PROTON) 
C
                     ILEVEL=ILEVEL+1
C
                     FUNCT0(ILEVEL)=FERTHE_NEUTRS
                     FUNEXP(ILEVEL)=FERMEX_NEUTRS(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_EFERMI
     *                                    /     SUMWEI_NEUTRS) 
C             
                 END IF ! IF_FER=1
C         
C=======================================================================
C         
C            IF (IFDENS.EQ.1) THEN ==>>> ==>>>
C
C                Item No. 05: The proton and neutron densities defined
C                                        separately below-, and above
                 IF (IF_DEN.EQ.1) THEN !                 the main gaps
             
                     ILEVEL=ILEVEL+1
C                    INITI6=ILEVEL
C     PROTONS
C
                     FUNCT0(ILEVEL)=DENLOW_PROTON
                     FUNEXP(ILEVEL)=DENSDW_PROTON(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_DENSDW
     *                                    /     SUMWEI_PROTON) 
C_______________________________________________________________________
C             
                     ILEVEL=ILEVEL+1
C
                     FUNCT0(ILEVEL)=DENUPP_PROTON
                     FUNEXP(ILEVEL)=DENSUP_PROTON(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_DENSUP
     *                                    /     SUMWEI_PROTON) 
C_______________________________________________________________________
C
C     NEUTRONS
C
                     ILEVEL=ILEVEL+1
C
                     FUNCT0(ILEVEL)=DENLOW_NEUTRS
                     FUNEXP(ILEVEL)=DENSDW_NEUTRS(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_DENSDW
     *                                    /     SUMWEI_NEUTRS) 
C_______________________________________________________________________
C 
                     ILEVEL=ILEVEL+1
C
                     FUNCT0(ILEVEL)=DENUPP_NEUTRS
                     FUNEXP(ILEVEL)=DENSUP_NEUTRS(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_DENSUP
     *                                    /     SUMWEI_NEUTRS) 
C                  
                 END IF ! IF_DEN=1
C
C=======================================================================
C         
C            IF (IFDENS.EQ.1) THEN ==>>> ==>>>
C
C                Item No. 06: The proton charge densities as functions
C                                               of the radial variable
                 IF (IF_RHO.EQ.1) THEN
*C            
*                     CALL RHOTHE_DENSIT(INUCLI,IZ_FIX,IN_FIX)
*C
*                     DO K_NOYX=1,N_NUCL
*C
*                        I_NOYX=I_NUCL(K_NOYX)
*C
*                        DO ID_RHO=1,ND_RHO
*C
*                           ILEVEL=ILEVEL+1
                   
*                           FUNCT0(ILEVEL)=RHOTHE(ID_RHO,I_NOYX)
                   
*                           FUNEXP(ILEVEL)=RHOEXP(ID_RHO,I_NOYX)
                   
*                           WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_RHODEN)
*C
*                        END DO
*                     END DO
C         
                 END IF ! IF_RHO=1
C
C======================================================================= 
C         
C            IF (IFDENS.EQ.1) THEN ==>>> ==>>>
C        
C                Item No. 07: The proton level order as criterion
C                                        Not tested, Neutrons missing
C                IF (IF_INV.EQ.1) THEN
C             
C                    LEVTOT=LEVPRO+LEVNEU
C             
C                    DO I=1,LEVPRO
C               
C                       IF (I.LT.LEVPRO) THEN
C               
C                           ILWEXP=LEXPLS(I)       !Experimental
C                           IUPEXP=LEXPLS(I+1)
C                           DIFEXP=EXPEXP_PROTON(INUCLI,IUPEXP)
C     *                           -EXPEXP_PROTON(ILWEXP)
C
C                           ILWTHE=LEVELS(I)       !Theoretical
C                           IUPTHE=LEVELS(I+1)               
C                           DIFTHE=ENETHE_PROTON(INUCLI,IUPTHE)
C     *                           -ENETHE_PROTON(ILWTHE)
C             
C                           IF (((DIFEXP.LT.0.).AND.(DIFTHE.GT.0.)).OR.
C     *                         ((DIFEXP.GT.0.).AND.(DIFTHE.LT.0.))) 
C                                                                 THEN  
C                               â€¦ incorrect order of the levels
C             
C                               ILEVEL=ILEVEL+1
C                  
C                               AUXIL1=ENETHE_PROTON(ILWTHE)*DEGENE(I)
C                               AUXIL2=ENETHE_PROTON(IUPTHE)*DEGENE(I+1)
C                 
C                               FUNVEC(ILEVEL)
C     *                        =
C     *                        (AUXIL2-AUXIL1)*WEIGHT_INVERT
C                  
C                           END IF
C
C                       END IF ! LEVPRO
C             
C                    END DO
C         
C                END IF ! IF_INV=1
C         
C=======================================================================
C=======================================================================                 
C         
C            IF (IFDENS.EQ.1) THEN ==>>> ==>>>
C  
             END IF ! IFDENS=1
C         
C=======================================================================
C=======================================================================
C
C            Option 02: Traditional Woods-Saxon, here for protons
C    
             IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN
C         
C=======================================================================
C        
C                Item No. 01: The single particle energies
C
                 IF (IF_SPE.EQ.1) THEN 
C
                     DO IEXPER=1,LEVEXP_PROTON(INUCLI)
                        DO ITHEOR=1,LEVTHE_PROTON
C
                           IF (LABEXP_PROTON(INUCLI,IEXPER).EQ.
     *                         LABTHE_PROTON(ITHEOR))     THEN
C
                               ILEVEL=ILEVEL+1
                               LEVPRO=ILEVEL
C
                               IF (IEXPER.EQ.1) INITI1=ILEVEL
C
                               FUNCT0(ILEVEL)=ENETHE_PROTON(ITHEOR)
                               FUNEXP(ILEVEL)=EXPEXP_PROTON(INUCLI,
     *                                                      IEXPER)
                               LEVELS(ILEVEL)=ITHEOR
                               LEXPLS(ILEVEL)=IEXPER
C
                               DEGENE(ILEVEL)
     *                        =REAL(IDEGEX_PROTON(INUCLI,IEXPER))
C
                               WEIGHT_FUNVEC(ILEVEL)
     *                        =DEGENE(ILEVEL)*WEIWEI
C
                               WEISQR_FUNVEC(ILEVEL)
     *                        =
     *                         SQRT(DEGENE(ILEVEL)*WEINUC_PROTON(INUCLI)
     *                                            /SUMWEI_PROTON)
C
                           END IF
C
                        END DO ! ITHEOR
                     END DO ! IEXPER
C
                 END IF ! IF_SPE=1
C
C=======================================================================
C        
C            IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN ==>>> ==>>>
C
C                Item No. 02: The proton r.m.s. radii
C 
                 IF (IF_RAD.EQ.1) THEN
C             
                     ILEVEL=ILEVEL+1
C                    INITI3=ILEVEL
             
                     FUNCT0(ILEVEL)=RMSTHE_PROTON
                     FUNEXP(ILEVEL)=RMSEXP_PROTON(INUCLI)
C             
                     WEISQR_FUNVEC(ILEVEL)
     *              =SQRT(WEIRAD_PROTON(INUCLI)
     *              *     WEINUC_PROTON(INUCLI)/SUMWEI_PROTON)
C             
                 END IF ! IF_RAD=1
C
C=======================================================================
C        
C            IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN ==>>> ==>>>
C
C                Item No. 03: The proton main gap
C          
                 IF (IF_GAP.EQ.1) THEN
C
                     ILEVEL=ILEVEL+1
C                    INITI4=ILEVEL
             
                     FUNCT0(ILEVEL)=GAPTHE_PROTON
                     FUNEXP(ILEVEL)=GAPEXP_PROTON(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_ENEGAP
     *                                    /     SUMWEI_PROTON)
C
                 END IF ! IF_GAP=1
C         
C=======================================================================
C        
C            IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN ==>>> ==>>>
C
C                Item No. 04: The proton "Fermi energy"
C         
                 IF (IF_FER.EQ.1) THEN
C
                     ILEVEL=ILEVEL+1
C                    INITI5=ILEVEL
C
                     FUNCT0(ILEVEL)=FERTHE_PROTON
                     FUNEXP(ILEVEL)=FERMEX_PROTON(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_EFERMI
     *                                    /     SUMWEI_PROTON)
C
                 END IF ! IF_FER=1
C         
C=======================================================================
C        
C            IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN ==>>> ==>>>
C
C                Item No. 05: The proton level densities defined
C                                        separately below-, and above
C          
                 IF (IF_DEN.EQ.1) THEN
C
                     ILEVEL=ILEVEL+1
C                    INITI6=ILEVEL
C
                     FUNCT0(ILEVEL)=DENLOW_PROTON
                     FUNEXP(ILEVEL)=DENSDW_PROTON(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_DENSDW
     *                                    /     SUMWEI_PROTON)
C_______________________________________________________________________
C             
                     ILEVEL=ILEVEL+1
C
                     FUNCT0(ILEVEL)=DENUPP_PROTON
                     FUNEXP(ILEVEL)=DENSUP_PROTON(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_DENSUP
     *                                    /     SUMWEI_PROTON)
C
                 END IF ! IF_DEN=1
C
C=======================================================================
C        
C            IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN ==>>> ==>>>
C
C                Item No. 06: The proton charge densities as functions
C                                               of the radial variable
C         
                 IF (IF_RHO.EQ.1) THEN
*C            
*                     CALL RHOTHE_DENSIT(INUCLI,IZ_FIX,IN_FIX)
*C
*                     DO K_NOYX=1,N_NUCL
*C
*                        I_NOYX=I_NUCL(K_NOYX)
*C
*                        DO ID_RHO=1,ND_RHO
*C
*                           ILEVEL=ILEVEL+1
*C
*                           FUNCT0(ILEVEL)=RHOTHE(ID_RHO,I_NOYX)
*C
*                           FUNEXP(ILEVEL)=RHOEXP(ID_RHO,I_NOYX)
*C
*                           WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_RHODEN)
*C
*                        END DO
*                     END DO
C
                 END IF ! IF_RHO=1
C
C======================================================================= 
C        
C            IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN ==>>> ==>>>
C        
C                Item No. 07: The proton level order as criterion
C                                        Not tested
C        
C                IF (IF_INV.EQ.1) THEN
C             
C                    LEVTOT=LEVPRO+LEVNEU
C             
C                    DO I=1,LEVPRO
C               
C                       IF (I.LT.LEVPRO) THEN
C               
C                           ILWEXP=LEXPLS(I)       !Experimental
C                           IUPEXP=LEXPLS(I+1)
C                           DIFEXP=EXPEXP_PROTON(INUCLI,IUPEXP)
C     *                           -EXPEXP_PROTON(ILWEXP)
C
C                           ILWTHE=LEVELS(I)       !Theoretical
C                           IUPTHE=LEVELS(I+1)               
C                           DIFTHE=ENETHE_PROTON(INUCLI,IUPTHE)
C     *                           -ENETHE_PROTON(ILWTHE)
C             
C                           IF (((DIFEXP.LT.0.).AND.(DIFTHE.GT.0.)).OR.
C     *                         ((DIFEXP.GT.0.).AND.(DIFTHE.LT.0.)))
C                                                                  THEN  
C                               Incorrect order of the levels
C             
C                               ILEVEL=ILEVEL+1
C                  
C                               AUXIL1=ENETHE_PROTON(ILWTHE)*DEGENE(I)
C                               AUXIL2=ENETHE_PROTON(IUPTHE)*DEGENE(I+1)
C                 
C                               FUNVEC(ILEVEL)
C     *                        =
C     *                        (AUXIL2-AUXIL1)*WEIGHT_INVERT
C                  
C                           END IF
C                  
C                       END IF
C             
C                    END DO
C         
C                END IF ! IF_INV=1
C         
C=======================================================================
C=======================================================================
C        
C            IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN ==>>> ==>>>
C
             END IF ! IFDENS=0 & IFPROT=1
C         
C=======================================================================
C
C            Option 03: Traditional Woods-Saxon, here for neutrons
C    
             IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1)) THEN
C         
C=======================================================================
C
C                Item No. 01: The single particle energies, neutrons
C
                 IF (IF_SPE.EQ.1) THEN 
C
                     DO IEXPER=1,LEVEXP_NEUTRS(INUCLI)
                        DO ITHEOR=1,LEVTHE_NEUTRS
C
                           IF (LABEXP_NEUTRS(INUCLI,IEXPER).EQ.
     *                         LABTHE_NEUTRS(ITHEOR))     THEN
C
                               ILEVEL=ILEVEL+1
C                              LEVNEU=LEVNEU+1
                               LEVNEU=ILEVEL
C
                               IF (IEXPER.EQ.1) INITI1=ILEVEL
C
                               FUNCT0(ILEVEL)=ENETHE_NEUTRS(ITHEOR)
                               FUNEXP(ILEVEL)
     *                        =EXPEXP_NEUTRS(INUCLI,IEXPER)
C
                               LEVELS(ILEVEL)=ITHEOR
                               LEXPLS(ILEVEL)=IEXPER
C
                               DEGENE(ILEVEL)
     *                        =REAL(IDEGEX_NEUTRS(INUCLI,IEXPER))
C
                               WEISQR_FUNVEC(ILEVEL)
     *                        =SQRT(DEGENE(ILEVEL)
     *                        *WEINUC_NEUTRS(INUCLI)/SUMWEI_NEUTRS)
                 
                           END IF
C
                        END DO
                     END DO
C
                 END IF
C
C=======================================================================
C
C                Item No. 02: The neutron r.m.s. radii
C          
                 IF (IF_RAD.EQ.1) THEN
C
                     ILEVEL=ILEVEL+1
C                    INITI3=ILEVEL
C
                     FUNCT0(ILEVEL)=RMSTHE_NEUTRS
                     FUNEXP(ILEVEL)=RMSEXP_NEUTRS(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)
     *              =SQRT(WEIRAD_NEUTRS(INUCLI)
     *              *     WEINUC_NEUTRS(INUCLI)/SUMWEI_NEUTRS)
C
                 END IF ! IF_RAD=1
C
C=======================================================================
C
C                Item No. 03: The neutron main gaps
C          
                 IF (IF_GAP.EQ.1) THEN
C
                     ILEVEL=ILEVEL+1
C                    INITI4=ILEVEL
C
                     FUNCT0(ILEVEL)=GAPTHE_NEUTRS
                     FUNEXP(ILEVEL)=GAPEXP_NEUTRS(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_ENEGAP
     *                                         /SUMWEI_NEUTRS)
C
                 END IF !IF_GAP=1
C         
C======================================================================= 
C
C                Item No. 04: The neutron "Fermi energies"
C         
                 IF (IF_FER.EQ.1) THEN
C
                     ILEVEL=ILEVEL+1
C                    INITI5=ILEVEL

                     FUNCT0(ILEVEL)=FERTHE_NEUTRS
                     FUNEXP(ILEVEL)=FERMEX_NEUTRS(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_EFERMI
     *                                         /SUMWEI_NEUTRS)
C
                 END IF ! IF_FER=1
C         
C=======================================================================
C
C                Item No. 05: The neutron densities defined
C                                        separately below-, and above
C          
                 IF (IF_DEN.EQ.1) THEN
C
                     ILEVEL=ILEVEL+1
C                    INITI6=ILEVEL
C
                     FUNCT0(ILEVEL)=DENLOW_NEUTRS
                     FUNEXP(ILEVEL)=DENSDW_NEUTRS(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_DENSDW
     *                                         /SUMWEI_NEUTRS)
C_______________________________________________________________________
C             
                     ILEVEL=ILEVEL+1
C
                     FUNCT0(ILEVEL)=DENUPP_NEUTRS
                     FUNEXP(ILEVEL)=DENSUP_NEUTRS(INUCLI)
C
                     WEISQR_FUNVEC(ILEVEL)=SQRT(WEIGHT_DENSUP
     *                                         /SUMWEI_NEUTRS)
C
                 END IF ! IF_DEN=1
C
C=======================================================================
C
C                Item No. 06: The neutron charge densities as functions
C                             of the radial variable not available from
C                                                            experiment         
C                IF (IF_RHO.EQ.1) THEN
C         
C                END IF !IF_RHO=1
C
C======================================================================= 
C        
C                Item No. 07: The neutron level order as criterion
C                                        Not tested, Neutrons missing
C        
C                IF (IF_INV.EQ.1) THEN
C             
C                    LEVTOT=LEVPRO+LEVNEU
C             
C                    DO I=1,LEVPRO
C               
C                       IF (I.LT.LEVPRO) THEN
C               
C                           ILWEXP=LEXPLS(I)       !Experimental
C                           IUPEXP=LEXPLS(I+1)
C                           DIFEXP=EXPEXP_PROTON(INUCLI,IUPEXP)
C     *                           -EXPEXP_PROTON(ILWEXP)
C
C                           ILWTHE=LEVELS(I)       !Theoretical
C                           IUPTHE=LEVELS(I+1)               
C                           DIFTHE=ENETHE_PROTON(INUCLI,IUPTHE)
C     *                           -ENETHE_PROTON(ILWTHE)
C             
C                           IF (((DIFEXP.LT.0.) .AND. 
C     *                          (DIFTHE.GT.0.))    .OR.
C     *                         ((DIFEXP.GT.0.) .AND.
C     *                          (DIFTHE.LT.0.)))   THEN 
C
C                               Incorrect order of levels
C             
C                               ILEVEL=ILEVEL+1
C                  
C                               AUXIL1
C     *                        =ENETHE_PROTON(ILWTHE)*DEGENE(I)
C                               AUXIL2
C     *                        =ENETHE_PROTON(IUPTHE)*DEGENE(I+1)
C                 
C                               FUNVEC(ILEVEL)
C     *                        =
C     *                        (AUXIL2-AUXIL1)*WEIGHT_INVERT
C                  
C                           END IF
C             
C                       END IF
C             
C                    END DO
C         
C                END IF ! IF_INV=1
C         
C=======================================================================
C=======================================================================
C        
C            IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1)) THEN ==>>> ==>>>
C
             END IF ! IFDENS=0 & IFNEUT=1
C
             IF (LOGWRI.GT.0)
     *
     *       WRITE(LOGFIL,'(12X,''In FUNMIN - Finished I_FLAG=1 '',
     *                          ''option '',
     *                          ''single-function run, INUCLI= '',I2)')
     *                                                 INUCLI
C         
C=======================================================================
C        
             IPARTL=ILEVEL ! Partial dimension of FUNCT0, 
C                                                 FUNEXP and FUNVEC
C
C=======================================================================       
C============================ J A C O B I A N ========================== 
C============================ J A C O B I A N ========================== 
C============================ J A C O B I A N ========================== 
C============================ J A C O B I A N ========================== 
C=======================================================================
C         
C     DO INUCLI=1,LDNUCL  ==>>>  ==>>>
C     
C        IF (ITAKNU(INUCLI).EQ.1) THEN  ==>>>  ==>>>
C
             IF (I_FLAG.EQ.2) THEN ! I_FLAG=2 =>> Jacobian
C
C=======================================================================
C          
                 DO IPARAM=1,NDPARS
                    DERIVF(IPARAM)=0.0
                    DO INDEXX=INITI1,IPARTL
                       FUNJAC(INDEXX,IPARAM)=0.
                    END DO
                 END DO
C
C=======================================================================
C        
                 IACTIV=0  !Running over the number of parameters
C
                 DO IPARAM=1,NDPARS
         
                    IF (IFTAKE(IPARAM).EQ.1) THEN
C
                        PARPOT(IPARAM)=PARPOT(IPARAM)+DPARAM(IPARAM)
C
                        IF (LOGWRI.GT.4) THEN
C
                            WRITE(LOGFIL,'(12X,''Entering WS_RUN '',
     *                                         ''from FUNMIN [2] '',
     *                                         ''p+dp='',f10.5,1X,
     *                                         ''p='',f10.5,6X,
     *                                         ''IPARAM='',I2,1X,
     *                                         ''PARAM='',A)')
     *                                   PARPOT(IPARAM),PARPOT(IPARAM)
     *                                                 -DPARAM(IPARAM),
     *                                                         IPARAM,
     *                                           TITLES_EXPORT(IPARAM)
c                           WRITE(LOGFIL,'()')
                        END IF
C
C
C                       Below - I_MODE=1 means: Calculate the derivatives
                                                                I_MODE=1
                        CALL WS_RUN(INUCLI,CHISQU_CHOICE,IABORT,I_MODE,
     *                              I_FLAG,CHISQU_AUXIL3,CHISQU_AUXIL4)
C
                        IACTIV=IACTIV+1
C_______________________________________________________________________
C               
                        CHISQU_AUXILP(IPARAM,INUCLI)=CHISQU_AUXIL3 ! P
                        CHISQU_AUXILN(IPARAM,INUCLI)=CHISQU_AUXIL4 ! N
C_______________________________________________________________________
C    
                        ACTION(IPARAM)='*'
C
C=======================================================================
C
C                       Option 01: Density-dependent spin-orbit
C                      
                        IF (IFDENS.EQ.1 .OR.
     *                     (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN 
C
C=======================================================================
C
C                           Item No. 01: The single particle energies
C           
                            IF (IF_SPE.EQ.1) THEN
C
                                IAUXIL=LEVNEU
C	       
                                DO INDEXX=INITI1,LEVPRO
C	       
                                   IWHICH=LEVELS(INDEXX)
C  
                                   FUNCT1(INDEXX)=ENETHE_PROTON(IWHICH)
C
                                   DERIVF(IACTIV)
     *                            =
     *                            (FUNCT1(INDEXX)-FUNCT0(INDEXX))
     *                            /DPARAM(IPARAM)
C
                                   FUNJAC(INDEXX,IACTIV)=DERIVF(IACTIV)
C
                                END DO
C_______________________________________________________________________
C
                                DO INDEXX=INITI2,LEVNEU
C
                                   IWHICH=LEVELS(INDEXX)
C
                                   FUNCT1(INDEXX)=ENETHE_NEUTRS(IWHICH)
C
                                   DERIVF(IACTIV)
     *                            =
     *                            (FUNCT1(INDEXX)-FUNCT0(INDEXX))                      
     *                            /DPARAM(IPARAM)
C
                                   FUNJAC(INDEXX,IACTIV)=DERIVF(IACTIV)
C                   
                                END DO
C
                            END IF ! IF_SPE=1
C
C=======================================================================
C
C                           Item No. 02: The proton and neutron
C                                                  r.m.s. radii
                            IF (IF_RAD.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=RMSTHE_PROTON
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C_______________________________________________________________________
C            
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=RMSTHE_NEUTRS
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)  
C
                            END IF ! IF_RAD=1  
C
C=======================================================================
C
C                           Item No. 03: The proton and neutron
C                                                     main gaps
                            IF (IF_GAP.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=GAPTHE_PROTON
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C_______________________________________________________________________
C           
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=GAPTHE_NEUTRS
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C
                            END IF ! IF_GAP=1   
C
C=======================================================================
C
C                           Item No. 04: The proton and neutron 
C                                              "Fermi energies"
C          
                            IF (IF_FER.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=FERTHE_PROTON
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C_______________________________________________________________________
C          
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=FERTHE_NEUTRS
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C
                            END IF  ! IF_FER=1 
C
C=======================================================================
C
C                           Item No. 05: The proton and neutron 
C                                        densities defined separately
C                                        below-, and above the main gaps
C           
                            IF (IF_DEN.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=DENLOW_PROTON
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C_______________________________________________________________________
C          
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=DENUPP_PROTON
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)               
C_______________________________________________________________________
C          
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=DENLOW_NEUTRS
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C_______________________________________________________________________
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=DENUPP_NEUTRS
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C
                            END IF  ! IF_DEN=1 
C
C=======================================================================
C 
                        END IF ! IFDENS=1
C
C=======================================================================
C
C                       Option 02: Traditional Woods-Saxon, 
C                                                    here for protons
C
                        IF ((IFDENS.EQ.0).AND.(IFPROT.EQ.1)) THEN
C
C=======================================================================
C
C                           Item No. 01: The single particle energies
C                     
                            IF (IF_SPE.EQ.1) THEN
C
                                IAUXIL=LEVPRO
C	       
                                DO INDEXX=INITI1,LEVPRO
C	       
                                   IWHICH=LEVELS(INDEXX)
C  
                                   FUNCT1(INDEXX)=ENETHE_PROTON(IWHICH)
C
                                   DERIVF(IACTIV)
     *                            =
     *                            (FUNCT1(INDEXX)-FUNCT0(INDEXX))
     *                            /DPARAM(IPARAM)
C
                                   FUNJAC(INDEXX,IACTIV)=DERIVF(IACTIV)
C
                                END DO
C
                            END IF ! IF_SPE=1
C
C=======================================================================
C
C                           Item No. 02: The proton r.m.s. radii
C           
                            IF (IF_RAD.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=RMSTHE_PROTON
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)               
C
                            END IF ! IF_RAD=1  
C
C=======================================================================
C
C                           Item No. 03: The proton main gaps
C           
                            IF (IF_GAP.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=GAPTHE_PROTON
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C
                            END IF ! IF_GAP=1   
C
C=======================================================================
C
C                           Item No. 04: The proton "Fermi energies"
C          
                            IF (IF_FER.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=FERTHE_PROTON
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C
                            END IF ! IF_FER=1 
C 
C=======================================================================
C
C                           Item No. 05: The proton densities defined
C                                        separately below-, and above
C           
                            IF (IF_DEN.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=DENLOW_PROTON
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C_______________________________________________________________________
C         
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=DENUPP_PROTON
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)              
C
                            END IF ! IF_DEN=1 
C
C=======================================================================
C
C                           Item No. 06: The proton charge densities 
C                                        as functions of the radial 
C                                                           variable
                            IF (IF_RHO.EQ.1) THEN
C            
*                                CALL RHOTHE_DENSIT(INUCLI,IZ_FIX,IN_FIX)
*C
*                                DO K_NOYX=1,N_NUCL
*C
*                                   I_NOYX=I_NUCL(K_NOYX)
*C
*                                   DO ID_RHO=1,ND_RHO
*C
*                                      IAUXIL=IAUXIL+1
                   
*                                      FUNCT1(IAUXIL)=RHOTHE(ID_RHO,
*     *                                                      I_NOYX)
*C
*                                      FUNJAC(IAUXIL,IACTIV)
*     *                               =
*     *                               (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
*     *                               /DPARAM(IPARAM)   
*C                   
*                                   END DO
*                                END DO
C
                            END IF
C
C=======================================================================
C
                        END IF ! IFDENS=0 & IFPROT=1
C
C=======================================================================
C=======================================================================
C=======================================================================
C
C                       Option 03: Traditional Woods-Saxon, for neutrons
C 
                        IF ((IFDENS.EQ.0) .AND. (IFNEUT.EQ.1)) THEN   
C
C                           Item No. 01: The single particle energies
C                                                   
                            IF (IF_SPE.EQ.1) THEN
C
                                IAUXIL=LEVNEU
C	       
                                DO INDEXX=INITI1,LEVNEU
C	       
                                   IWHICH=LEVELS(INDEXX)
C  
                                   FUNCT1(INDEXX)=ENETHE_NEUTRS(IWHICH)
C
                                   DERIVF(IACTIV)
     *                            =
     *                            (FUNCT1(INDEXX)-FUNCT0(INDEXX))
     *                            /DPARAM(IPARAM)
C
                                   FUNJAC(INDEXX,IACTIV)=DERIVF(IACTIV)
C
                                END DO
C
                            END IF ! IF_SPE=1
C
C=======================================================================
C
C                           Item No. 02: The neutron r.m.s. radii
C           
                            IF (IF_RAD.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=RMSTHE_NEUTRS
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)             
C
                            END IF  ! IF_RAD=1  
C
C=======================================================================
C
C                           Item No. 03: The neutron main gaps
C           
                            IF (IF_GAP.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=GAPTHE_NEUTRS
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C
                            END IF  ! IF_GAP=1   
C
C======================================================================= 
C
C                           Item No. 04: The neutron "Fermi energies"
C          
                            IF (IF_FER.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C
                                FUNCT1(IAUXIL)=FERTHE_NEUTRS
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C
                            END IF  ! IF_FER=1 
C
C=======================================================================
C
C                           Item No. 05: The neutron densities defined
C                                         separately below-, and above
C           
                            IF (IF_DEN.EQ.1) THEN 
C
                                IAUXIL=IAUXIL+1
C 
                                FUNCT1(IAUXIL)=DENLOW_NEUTRS
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)
C_______________________________________________________________________
C          
                                IAUXIL=IAUXIL+1
C 
                                FUNCT1(IAUXIL)=DENUPP_NEUTRS
C
                                FUNJAC(IAUXIL,IACTIV)
     *                         =
     *                         (FUNCT1(IAUXIL)-FUNCT0(IAUXIL))
     *                         /DPARAM(IPARAM)              
C
                            END IF  ! IF_DEN=1 
C
C=======================================================================
C
                        END IF ! IFDENS=0 & IFNEUT=1
C
C=======================================================================
C
                        ACTION(IPARAM)=' '
C
                        PARPOT(IPARAM)=PARPOT(IPARAM)-DPARAM(IPARAM)
C        
C=======================================================================
C            
                    END IF ! (IFTAKE(IPARAM).EQ.1)
C 
                 END DO ! IPARAM=1,NDPARS
C        
C=======================================================================
C         
                 IF (IPARTL.NE.IAUXIL) THEN
C
                     WRITE(NOUTPT,'(''Something went wrong in FUNMIN:'',
     *                              ''IPARTL='',I3,1X,
     *                              ''is different from IAUXIL='',I3,
     *                              '' -> They should be equal'')') 
     *                                IPARTL,IAUXIL
C
                     STOP 'STOP: Something went wrong in FUNMIN (I)'
C
                 END IF
C
C========================================================================         
C       
                 IF (LOGWRI.GT.0)
     *
     *           WRITE(LOGFIL,'(/,12x,''In FUNMIN - Finished I_FLAG=2'',
     *                                '' OPTION, '',
     *                                ''Jacobian run, INUCLI= '',I2)') 
     *                                                INUCLI
C
             END IF ! I_FLAG=2 ==> End of the Jacobian Storing
C
C========================================================================         
C
         END IF ! For active nuclei ITAKNU(INUCLI).EQ.1
      
      END DO ! Over all nuclei INUCLI
C
C========================================================================
C========================================================================
C========================================================================
C
      ITOTAL=ILEVEL ! Total dimension of FUNVEC and FUNJAC
C                     Should be equal to LDFUNC
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(12X,''Out of the do-loop over INUCLI '',
     *                       ''in FUNMIN with number of active '',
     *                       ''parameters= '',I3)') ITOTAL
      END IF
C
C========================================================================
C       
      IF (ITOTAL.NE.LDFUNC) THEN
C
          WRITE(NOUTPT,'(''Something went wrong in FUNMIN: ITOTAL='',I3,
     *                   '' is different from LDFUNC='',I3,
     *                   '' -> They should be equal!!'')') ITOTAL,LDFUNC
C
          STOP 'STOP: Something went wrong in FUNMIN (II)'
C
      END IF
C________________________________________________________________________
C       
      IF (I_FLAG.EQ.2 .AND. IAUXIL.NE.LDFUNC) THEN
C
          WRITE(NOUTPT,'(''Something went wrong in FUNMIN: IAUXIL='',I3,
     *                   '' is different from LDFUNC='',I3,
     *                   '' -> They should be equal!!'')') IAUXIL,LDFUNC
C
          STOP 'STOP: Something went wrong in FUNMIN (III)'
C
      END IF
C
C=======================================================================
C      
      IF (I_FLAG.EQ.1) THEN
C
C         Storing FUNVEC(1:LDFUNC), which enters to LEVMAR routine
C           
          DO INDEXZ=1,LDFUNC
C
             FUNVEC(INDEXZ)=(FUNCT0(INDEXZ)-FUNEXP(INDEXZ))
     *                     * WEISQR_FUNVEC(INDEXZ)
          END DO
C
C=======================================================================
C         Printing actual parameters and corresponding Chi^2 (AS ORIG.)
C=======================================================================
C        
          VALCHI=CHISQU_TOTALS  ! chi^2=chi^(p)
C
          IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) 
     *                          HIAUXI(IDEFCN)=CHISQU_PROTON
          IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) 
     *                          HIAUXI(IDEFCN)=CHISQU_NEUTRS
C
          IF (IFDENS.EQ.1 .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
              HIAUXI(IDEFCN)=VALCHI
          END IF
C
                                    I_MODE=0
          CALL INPRIN(IDEFCN,IACTIV,I_MODE,CHISQU_PROTON,
     *                                     CHISQU_NEUTRS,
     *                       CHIENE_WEIPRO,CHIENE_WEINEU,
     *                       CHIRAD_WEIPRO,CHIRAD_WEINEU,
     *                                     CHIRHO_WEIPRO)
          IF (NUCACT.GT.1) THEN
                                               I_MODE=0
              CALL INPRIN_GLOFIT(IDEFCN,IACTIV,I_MODE,CHIENE_PROTON,
     *                                  CHIENE_NEUTRS,CHIRAD_PROTON,
     *                                                CHIRAD_NEUTRS)
          END IF
C_______________________________________________________________________ 
C        
          IDEFCN=IDEFCN+1
C_______________________________________________________________________ 
C 
      END IF ! I_FLAG=1
C
C=======================================================================
C
      IF (I_FLAG.EQ.2) THEN 
C
C=======================================================================
C         Introducing weights to Jacobian FUNJAC(ifunc,ipars)
C=======================================================================
C           
          DO INDEXP=1,IACTIV
             DO INDEXF=1,LDFUNC
                FUNJAC(INDEXF,INDEXP)=FUNJAC(INDEXF,INDEXP)
     *                               *WEISQR_FUNVEC(INDEXF)
             END DO
          END DO
C
C=======================================================================
C
           INDEXP_AUXILI=0
      
           IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
               DO IPARAM=1,6
                  INDEXP_AUXILI=INDEXP_AUXILI+1
                  IVECTR(INDEXP_AUXILI)=IPARAM
               END DO
           END IF
C
           IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
               DO IPARAM=21,26
                  INDEXP_AUXILI=INDEXP_AUXILI+1
                  IVECTR(INDEXP_AUXILI)=IPARAM
               END DO
           END IF
C
           IF (IFDENS.EQ.0.AND.IFBOTH.EQ.1) THEN
C
               IF (IFK_VC.EQ.1) THEN
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=51   ! V_o central
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=52   ! kappa V_o central
               ELSE
                   INDEXP_AUXILI=INDEXP_AUXILI+1 
                   IVECTR(INDEXP_AUXILI)=1    ! V_o central protons
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=21   ! V_o central neutrons
               END IF
C
               IF (IFK_RC.EQ.1) THEN
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=53   ! r_o central
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=54   ! kappa r_o central
               ELSE
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=2    ! r_o central protons
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=22   ! r_o central neutron
               END IF
C
               IF (IFK_AC.EQ.1) THEN
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=55   ! a_o central
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=56   ! kappa a_o central
               ELSE
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=3    ! a_o central protons
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=23   ! a_o central neutrons
               END IF
C
               IF (IFK_VS.EQ.1) THEN
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=57   ! V_o pure WS-SO
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=58   ! kappa V_o pure WS-SO
               ELSE
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=4    ! V_o pure WS-SO protons
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=24   ! V_o pure WS-SO neutrons
               END IF
C
               IF (IFK_RS.EQ.1) THEN
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=59   ! r_o pure WS-SO
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=60   ! kappa r_o pure WS-SO
               ELSE
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=5    ! r_o pure WS-SO protons
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=25   ! r_o pure WS-SO neutrons
               END IF
C
               IF (IFK_AS.EQ.1) THEN
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=61   ! a_o pure WS-SO
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=62   ! kappa a_o pure WS-SO
               ELSE
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=6    ! a_o pure WS-SO protons
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=26   ! a_o pure WS-SO neutrons
               END IF
C
           END IF
C
C=======================================================================
C      
           IF (IFDENS.EQ.1) THEN
C
               IF (IFK_VC.EQ.1) THEN
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=51   ! V_o central
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=52   ! kappa V_o central
               ELSE
                   INDEXP_AUXILI=INDEXP_AUXILI+1 
                   IVECTR(INDEXP_AUXILI)=1    ! V_o central protons
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=21   ! V_o central neutrons
               END IF
C
               IF (IFK_RC.EQ.1) THEN
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=53   ! r_o central
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=54   ! kappa r_o central
               ELSE
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=2    ! r_o central protons
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=22   ! r_o central neutron
               END IF
C
               IF (IFK_AC.EQ.1) THEN
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=55   ! a_o central
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=56   ! kappa a_o central
               ELSE
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=3    ! a_o central protons
                   INDEXP_AUXILI=INDEXP_AUXILI+1
                   IVECTR(INDEXP_AUXILI)=23   ! a_o central neutrons
               END IF
C
               DO IPARAM=39,42
                  INDEXP_AUXILI=INDEXP_AUXILI+1
                  IVECTR(INDEXP_AUXILI)=IPARAM
               END DO
C          
               IF (IFTENS.EQ.1 .AND. ISORBT.EQ.1) THEN
                   DO IPARAM=43,46
                      INDEXP_AUXILI=INDEXP_AUXILI+1
                      IVECTR(INDEXP_AUXILI)=IPARAM
                   END DO
               END IF
C          
               IF (IFTENS.EQ.1 .AND. ICENTT.EQ.1) THEN
                   DO IPARAM=47,50
                      INDEXP_AUXILI=INDEXP_AUXILI+1
                      IVECTR(INDEXP_AUXILI)=IPARAM
                   END DO
               END IF
C          
           END IF
C
C=======================================================================
C          Calculating the chi^2 gradient
C=======================================================================
C   
           CHISQU_GRDNRM=0.0 ! \chi^2 gradient norm
C
           DO INDEXP=1,IACTIV
               CHISQU_GRADNT(INDEXP)=0.0
           END DO
C________________________________________________________________________
C        
           DO INDEXP=1,IACTIV ! parameters
C        
              DO INDEXF=1,LDFUNC ! functions
C            
                 FUNAUX(INDEXF)=(FUNCT0(INDEXF)-FUNEXP(INDEXF))
     *                         * WEISQR_FUNVEC(INDEXF)
C
                 CHISQU_GRADNT(INDEXP)=CHISQU_GRADNT(INDEXP)
     *                                +FUNAUX(INDEXF)
     *                                *FUNJAC(INDEXF,INDEXP)
C
             END DO
C         
             CHISQU_GRADNT(INDEXP)=2*CHISQU_GRADNT(INDEXP)
             CHISQU_GRDNRM=CHISQU_GRDNRM+(CHISQU_GRADNT(INDEXP))**2
C         
          END DO
C________________________________________________________________________
C        
          CHISQU_GRDNRM=SQRT(CHISQU_GRDNRM)
C        
CID          IF (LOGWRI.GT.0) THEN
C            
              JACTIV=0
C                
              IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.0) THEN
                  WRITE(LOGAUX,'(3x,''G:'',148X,''  '',$)')
              END IF
C
              IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) THEN
                  WRITE(LOGAUX,'(3x,''G:'',242X,''  '',$)')
              END IF
C
              IF (IFDENS.EQ.1 .AND. IFTENS.EQ.0) THEN 
                  WRITE(LOGAUX,'(3x,''G:'',220X,''  '',$)')
              END IF
C
              IF (IFDENS.EQ.1 .AND. IFTENS.EQ.1) THEN 
                  WRITE(LOGAUX,'(3x,''G:'',264X,''  '',$)')
              END IF
C                
              DO I=1,INDEXP_AUXILI
C
                 IPARAM=IVECTR(I)
C
                 IF (IFTAKE(IPARAM).EQ.1) THEN
                     JACTIV=IACTIV_VECTOR(IPARAM)
                     WRITE(LOGAUX,'(E11.3,$)') CHISQU_GRADNT(JACTIV)
                     CHISQU_GRADIE(IPARAM)=CHISQU_GRADNT(JACTIV)
                 ELSE
                     CHISQU_CNSTNT=0.0
                     WRITE(LOGAUX,'(E11.3,$)') CHISQU_CNSTNT
                     CHISQU_GRADIE(IPARAM)=CHISQU_CNSTNT
                 END IF
C
              END DO
C                
              WRITE(LOGAUX,'(F18.4)') CHISQU_GRDNRM
C            
CID          END IF
C        
          IF (ISCREN.NE.1) GO TO 1
C        
          WRITE(0,'(3X,''g:'',2X,<IACTIV>(E10.3,1X),F15.4)')
     *                        (CHISQU_GRADNT(I),I=1,IACTIV),
     *                         CHISQU_GRDNRM
     
   1      CONTINUE
C       
      END IF
C
C=======================================================================
C
c     IF (LOGWRI.GT.0) THEN
C
c         WRITE(LOGFIL,'(12X,''ACTIVE Parameters in FUNMIN'',
c    *                       ''(IDEFCN,IPARAM,IACTIV,'',
c    *                       ''ARGPAR(IACTIV),PARPOT(IACTIV))'')')
C       
c         KK=0
C       
c         DO IPARAM=1,NDPARS  
C               
c            IF (IFTAKE(IPARAM).EQ.1) THEN
c                KK=KK+1           
c                WRITE(LOGFIL,'(T20,''PARAM ='',A,
c    *                          T38,3I7,2F15.4)') 
c    *                          TITLES_EXPORT(IPARAM),IDEFCN,IPARAM,KK,
c    *                                        ARGPAR(KK),PARPOT(IPARAM)
c            END IF
C                  
c         END DO
C
c     END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,9X,''Exiting  FUNMIN'')')
      END IF 
C
C=======================================================================
C        
      CALL CPUTIM('FUNMIN',0)
C
C=======================================================================
C                          
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE VERIFY(ARGMNT,IABORT)
C      
      INCLUDE   'MATDIM/NDPARS.f'
C
      CHARACTER
     *          ACTION*1,CALLED*6     
C
      DIMENSION
     *          ARGMNT(1:NDPARS)
C
      COMMON
     *       /EXTREM/ V0CMAX,V0CMIN,XL_MAX,XL_MIN,XEFMAX,XEFMIN,
     *                R0CMAX,R0CMIN,R0SMAX,R0SMIN,REFMAX,REFMIN,
     *                A0CMAX,A0CMIN,A0SMAX,A0SMIN,AEFMAX,AEFMIN,
     *                                            CouMAX,CouMIN,
     *                              XPPMAX,XPPMIN,XPNMAX,XPNMIN,
     *                              XNPMAX,XNPMIN,XNNMAX,XNNMIN,
     *                              YPPMAX,YPPMIN,YPNMAX,YPNMIN,
     *                              YNPMAX,YNPMIN,YNNMAX,YNNMIN,
     *                              CPPMAX,CPPMIN,CPNMAX,CPNMIN,
     *                              CNPMAX,CNPMIN,CNNMAX,CNNMIN,
     *
     *                                            UPFACT,DWFACT
      COMMON
     *       /EXTKAP/ V0CMIN_KAPPAR,V0CMAX_KAPPAR,XKCMIN_KAPPAR,
     *                XKCMAX_KAPPAR,A0CMIN_KAPPAR,A0CMAX_KAPPAR,
     *                XACMIN_KAPPAR,XACMAX_KAPPAR,R0CMIN_KAPPAR,
     *                R0CMAX_KAPPAR,XRCMIN_KAPPAR,XRCMAX_KAPPAR,
     *                XL_MIN_KAPPAR,XL_MAX_KAPPAR,XKSMIN_KAPPAR,
     *                XKSMAX_KAPPAR,A0SMIN_KAPPAR,A0SMAX_KAPPAR,
     *                XASMIN_KAPPAR,XASMAX_KAPPAR,R0SMIN_KAPPAR,
     *                R0SMAX_KAPPAR,XRSMIN_KAPPAR,XRSMAX_KAPPAR
      COMMON
     *       /VLIMIT/ VMISTR(1:NDPARS),
     *                VMIMIN(1:NDPARS),
     *                VMIMAX(1:NDPARS),
     *                VMISTP(1:NDPARS)
      COMMON
     *       /MEMORS/ MEMORY(1:NDPARS)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /ACTACT/ ACTION(1:NDPARS)
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS            
C
      DATA
     *        MAXMEM  / 150 /
C
C=======================================================================
C
C     This subroutine checks that all the values of the Hamiltonian 
C     parameters are not totally stupid (such as a negative radius, 
C     or a positive central well ... )
C  @@@ ???
C     LDSEAR: The actual number of the parameters searched
C


C @@@ DISCUSS THE USE OF THE PARAMETERS AND DELIMITERS




C=======================================================================
C
      IABORT=0
C
C=======================================================================
C 
      IF (IDEFCN.LE.1) THEN
C 
          IF (LOGWRI.GT.5) THEN
              WRITE(LOGFIL,
     *            '(27X,''IDEFCN.LE.1 => setting MEMORY to zero'')')
          END IF
C 
          DO I=1,NDPARS
             MEMORY(I)=0
          END DO
C 
      END IF     
C @@@    IS THE CHECK-UP BELOW TOTALLY USELESS?   ??? 
C=======================================================================
C     Below, we define an auxiliary vector that will allow
C     to keep all the parameters within given ranges
C=======================================================================
C
C     IACTIV=0
C
C     DO I=1,NDPARS/2
C
C        IF (IFTAKE(I).EQ.1) THEN
C
C            IACTIV=IACTIV+1
C
C            IF (ARGMNT(IACTIV).LT.0.0) THEN 
C 
C                IF (LOGWRI.GT.0) THEN
C                    WRITE(0,'(''Subroutine VERIFY: IACTIV='',I2,
C    *                         ''   OLD ARGMNT='',F12.6,
C    *                         ''   NEW ARGMNT='',F12.6)')
C    *               IACTIV,ARGMNT(IACTIV),0.5*STARTV(I) 
C                END IF
C             
C                ARGMNT(IACTIV)=0.5*STARTV(I)
C
C                ACTION(I)='#'
C
C                MEMORY(I)=MEMORY(I)+1                 
C                 
C            END IF 
C        END IF
C         
C     END DO
C
C=======================================================================
C
      IACTIV=0
C
      DO I=1,NDPARS
C
C=======================================================================
C        I=1 =>> Central potential depth
C=======================================================================
C
         IF ((I.EQ.1).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.V0CMAX) THEN
C
                 FACTOR=ABS(V0CMAX/ARGMNT(IACTIV))
C
                 IF (LOGWRI.GT.0) THEN                
C                 
                     WRITE(LOGFIL,'(18X,''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Central Potential (P)'')')
     *                               I,IACTIV,ARGMNT(IACTIV),V0CMAX,
     *                                                FACTOR*V0CMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*V0CMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.V0CMIN) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+10)
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(18X,''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' < '',F12.6,
     *               '' NEWARG ='',F12.6,'' Central potential (P)'')')
     *                  I,IACTIV,ARGMNT(IACTIV),V0CMIN,
     *                                          FACTOR*V0CMIN
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*V0CMIN
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!(P)Central potential depth out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IF (LOGWRI.GT.0)
     *
     *           WRITE(LOGFIL,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!(P)Central potential depth out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=4 =>> Spin-orbit strength coefficient Lambda
C=======================================================================
C
         IF (I.EQ.4.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XL_MAX*UPFACT) THEN
C
                 FACTOR=XL_MAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(18X,''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda s-o (P))'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XL_MAX*UPFACT,
     *                                                    FACTOR*XL_MAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XL_MAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XL_MIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(18X,''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda s-o (P))'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XL_MIN*DWFACT,
     *                                                    XL_MIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=XL_MIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (P) Lambda S-O parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IF (LOGWRI.GT.0)
     *
     *           WRITE(LOGFIL,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (P) Lambda S-O parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=7 =>> Effective-mass strength coefficient Lambda
C=======================================================================
C @@@ DO WE HAVE EFFECTIVE MASS AND IN WHICH FORM?
         IF (I.EQ.7.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XEFMAX*UPFACT) THEN
C
                 FACTOR=XEFMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(18X,''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda eff-mass (P))'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XEFMAX*UPFACT,
     *                                                    XEFMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=XEFMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XEFMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(18X,''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,
     *                            ''<'',E12.6,'', NEWARG ='',F12.6,
     *                            '' (Lambda eff-mass (P))'')')
     *                            IACTIV,ARGMNT(IACTIV),XEFMIN*DWFACT,
     *                                                  XEFMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=XEFMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!(P)Lambda EffMass paramtr was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IF (LOGWRI.GT.0)
     *
     *           WRITE(LOGFIL,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!(P)Lambda EffMass paramtr was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
C=======================================================================
C
         END IF
C
C=======================================================================
C        I=2 =>> Central-potential radius
C=======================================================================
C
         IF ((I.EQ.2).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.R0CMAX*UPFACT) THEN
C
                 FACTOR=R0CMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(18X,''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,
     *                            '' > '',E12.6, '' NEWARG ='',F12.6,
     *                            '' Central radius (P)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),R0CMAX*UPFACT,
     *                                                    R0CMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=R0CMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.R0CMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(18X,''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,
     *                            '' < '',E12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Central radius (P)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),R0CMIN*DWFACT,
     *                                                    R0CMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=R0CMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (P)Central potential r_0 was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IF (LOGWRI.GT.0)
     *
     *           WRITE(LOGFIL,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (P)Central potential r_0 was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=5 =>> Spin-orbit radius 
C=======================================================================
C
         IF ((I.EQ.5).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.R0SMAX*UPFACT) THEN
C
                 FACTOR=R0SMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(18X,''I='',I2,'' IACTIV ='',I3,
     *                              '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                              '' NEWARG ='',F12.6,
     *                              '' S-O radius (P)'')')
     *                     I,IACTIV,ARGMNT(IACTIV),R0SMAX*UPFACT,
     *                                             R0SMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=R0SMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.R0SMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(18X,''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' S-O radius (P)'')')
     *                     I,IACTIV,ARGMNT(IACTIV),R0SMIN*DWFACT,
     *                                             R0SMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=R0SMIN/FACTOR
C
                 MEMORY(I)=MEMORY(I)+1                 
C
                 ACTION(I)='#'
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (P)Spin-Orbit radius r_0 was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=8 =>> Effective mass radius
C=======================================================================
C
         IF ((I.EQ.8).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.REFMAX*UPFACT) THEN
C
                 FACTOR=REFMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Eff mass radius (P)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),REFMAX*UPFACT,
     *                                                    REFMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=REFMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.REFMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Eff mass radius(P)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),REFMIN*DWFACT,
     *                                                    REFMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=REFMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (P)Effective Mass radius was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C        Diffuseness parameters ...
C
         IF (I.EQ.3.AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.A0CMAX*UPFACT) THEN
C
                 FACTOR=A0CMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Centr. diffuseness (P)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),A0CMAX*UPFACT,
     *                                                    A0CMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=A0CMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.A0CMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Centr. diffuseness (P)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),A0CMIN*DWFACT,
     *                                                    A0CMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=A0CMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (P)Central potential a_0 was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C
         IF ((I.EQ.6).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.A0SMAX*UPFACT) THEN
C
                 FACTOR=A0SMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' S-O diffuseness (P)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),A0SMAX*UPFACT,
     *                                                    A0SMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=1.1*VMISTR(I)
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.A0SMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' S-O diffuseness (P)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),A0SMIN*DWFACT,
     *                                                    A0SMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=A0SMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (P)Spin-Orbit diffss a_0 was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C
         IF ((I.EQ.9).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.AEFMAX*UPFACT) THEN
C
                 FACTOR=AEFMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Meff diffuseness (P)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),AEFMAX*UPFACT,
     *                                                    AEFMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=AEFMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.AEFMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Meff diffuseness (P)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),AEFMIN*DWFACT,
     *                                                    AEFMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=AEFMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!  (P)Eff-Mass diffuseness was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C
         IF ((I.EQ.10).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.CouMAX*UPFACT) THEN
C
                 FACTOR=CouMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Coulomb radius'')')
     *                            I,IACTIV,ARGMNT(IACTIV),CouMAX*UPFACT,
     *                                                    CouMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=CouMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.CouMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Coulomb radius'')')
     *                            I,IACTIV,ARGMNT(IACTIV),CouMIN*DWFACT,
     *                                                    CouMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=CouMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!   Coulomb potential r_0  was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=21 =>> Central potential depth
C=======================================================================
C
         IF ((I.EQ.21).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.V0CMAX) THEN
C
                 FACTOR=ABS(V0CMAX/ARGMNT(IACTIV))
C
                 IF (LOGWRI.GT.0) THEN                
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Central Potential (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),V0CMAX,
     *                                             FACTOR*V0CMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*V0CMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.V0CMIN) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+10)
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' <  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Central potential (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),V0CMIN,
     *                                             FACTOR*V0CMIN
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*V0CMIN
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!(N)Cental potential depth was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=24 =>> Spin-orbit     strength coefficient Lambda
C=======================================================================
C
         IF (I.EQ.24.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XL_MAX*UPFACT) THEN
C
                 FACTOR=XL_MAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda s-o (N))'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XL_MAX*UPFACT,
     *                                                    FACTOR*XL_MAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XL_MAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XL_MIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda s-o (N))'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XL_MIN*DWFACT,
     *                                                    XL_MIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=XL_MIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (N) Lambda S-O parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=27 =>> Effective-mass strength coefficient Lambda
C=======================================================================
C
         IF (I.EQ.27.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XEFMAX*UPFACT) THEN
C
                 FACTOR=XEFMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda eff-mass (N))'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XEFMAX*UPFACT,
     *                                                    XEFMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=XEFMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XEFMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,
     *                            ''<'',E12.6,'', NEWARG ='',F12.6,
     *                            '' (Lambda eff-mass (N))'')')
     *                            IACTIV,ARGMNT(IACTIV),XEFMIN*DWFACT,
     *                                                  XEFMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=XEFMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!(N)Lambda EffMass paramtr was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
C=======================================================================
C
         END IF
C
C=======================================================================
C        I=22 =>> Central-potential radius
C=======================================================================
C
         IF ((I.EQ.22).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.R0CMAX*UPFACT) THEN
C
                 FACTOR=R0CMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,
     *                            '' > '',E12.6, '' NEWARG ='',F12.6,
     *                            '' Central radius (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),R0CMAX*UPFACT,
     *                                                    R0CMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=R0CMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.R0CMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,
     *                            '' < '',E12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Central radius (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),R0CMIN*DWFACT,
     *                                                    R0CMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=R0CMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (N)Central potential r_0 was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=25 =>> Spin-orbit radius 
C=======================================================================
C
         IF ((I.EQ.25).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.R0SMAX*UPFACT) THEN
C
                 FACTOR=R0SMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' S-O radius (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),R0SMAX*UPFACT,
     *                                                    R0SMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=R0SMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.R0SMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' S-O radius (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),R0SMIN*DWFACT,
     *                                                    R0SMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=R0SMIN/FACTOR
C
                 MEMORY(I)=MEMORY(I)+1                 
C
                 ACTION(I)='#'
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (N)Spin-Orbit radius r_0 was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=28 =>> Effective mass radius
C=======================================================================
C
         IF ((I.EQ.28).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.REFMAX*UPFACT) THEN
C
                 FACTOR=REFMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Eff mass radius (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),REFMAX*UPFACT,
     *                                                    REFMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=REFMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.REFMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Eff mass radius (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),REFMIN*DWFACT,
     *                                                    REFMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=REFMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (N)Effective Mass radius was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C        Diffuseness parameters ...
C
         IF (I.EQ.23.AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.A0CMAX*UPFACT) THEN
C
                 FACTOR=A0CMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Centr. diffuseness (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),A0CMAX*UPFACT,
     *                                                    A0CMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=A0CMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.A0CMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Centr. diffuseness (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),A0CMIN*DWFACT,
     *                                                    A0CMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=A0CMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (N)Central potential a_0 was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C
         IF ((I.EQ.26).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.A0SMAX*UPFACT) THEN
C
                 FACTOR=A0SMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' S-O diffuseness (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),A0SMAX*UPFACT,
     *                                                    A0SMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=1.1*VMISTR(I)
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.A0SMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' S-O diffuseness (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),A0SMIN*DWFACT,
     *                                                    A0SMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=A0SMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! (N)Spin-Orbit diffss a_0 was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C
         IF ((I.EQ.29).AND.(IFTAKE(I).EQ.1)) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.AEFMAX*UPFACT) THEN
C
                 FACTOR=AEFMAX/ARGMNT(IACTIV)             
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' > '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Meff diffuseness (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),AEFMAX*UPFACT,
     *                                                    AEFMAX*FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=AEFMAX*FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.AEFMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+0.1)                 
C
                 IF (LOGWRI.GT.0) THEN
C
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' Meff diffuseness (N)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),AEFMIN*DWFACT,
     *                                                    AEFMIN/FACTOR
                 END IF
C
                 ARGMNT(IACTIV)=AEFMIN/FACTOR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!  (N)Eff-Mass diffuseness was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=39 =>> Spin-orbit with density strength coefficient LambdaPP
C=======================================================================
C
         IF (I.EQ.39.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XPPMAX*UPFACT) THEN
C
                 FACTOR=XPPMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda PP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XPPMAX*UPFACT,
     *                                                    FACTOR*XPPMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XPPMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XPPMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda PP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XPPMIN*DWFACT,
     *                                                    XPPMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XPPMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XPPMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Lambda PP  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=40 =>> Spin-orbit with density strength coefficient LambdaPN
C=======================================================================
C
         IF (I.EQ.40.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XPNMAX*UPFACT) THEN
C
                 FACTOR=XPNMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda PN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XPNMAX*UPFACT,
     *                                                    FACTOR*XPNMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XPNMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XPNMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda PN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XPNMIN*DWFACT,
     *                                                    XPNMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XPNMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XPNMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Lambda PN  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=41 =>> Spin-orbit with density strength coefficient LambdaNP
C=======================================================================
C
         IF (I.EQ.41.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XNPMAX*UPFACT) THEN
C
                 FACTOR=XNPMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda NP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XNPMAX*UPFACT,
     *                                                    FACTOR*XNPMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XNPMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XNPMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda NP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XNPMIN*DWFACT,
     *                                                    XNPMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XNPMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XNPMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Lambda NP  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=42 =>> Spin-orbit with density strength coefficient LambdaNN
C=======================================================================
C
         IF (I.EQ.42.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XNNMAX*UPFACT) THEN
C
                 FACTOR=XNNMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda NN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XNNMAX*UPFACT,
     *                                                    FACTOR*XNNMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XNNMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XNNMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda NN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),XNNMIN*DWFACT,
     *                                                    XNNMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XNNMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XNNMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Lambda NN  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=43 =>> Tensor part strength coefficient LambdaPP
C=======================================================================
C
         IF (I.EQ.43.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.YPPMAX*UPFACT) THEN
C
                 FACTOR=YPPMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Ylambd PP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),YPPMAX*UPFACT,
     *                                                    FACTOR*YPPMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*YPPMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.YPPMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Ylambd PP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),YPPMIN*DWFACT,
     *                                                    YPPMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=YPPMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=YPPMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Ylambd PP  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=44 =>> Tensor part strength coefficient LambdaPN
C=======================================================================
C
         IF (I.EQ.44.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.YPNMAX*UPFACT) THEN
C
                 FACTOR=YPNMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Ylambd PN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),YPNMAX*UPFACT,
     *                                                    FACTOR*YPNMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*YPNMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.YPNMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Lambda PN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),YPNMIN*DWFACT,
     *                                                    YPNMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=YPNMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=YPNMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Ylambd PN  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=45 =>> Tensor part strength coefficient LambdaNP
C=======================================================================
C
         IF (I.EQ.45.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.YNPMAX*UPFACT) THEN
C
                 FACTOR=YNPMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Ylambd NP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),YNPMAX*UPFACT,
     *                                                    FACTOR*YNPMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*YNPMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.YNPMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Ylambd NP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),YNPMIN*DWFACT,
     *                                                    YNPMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=YNPMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=YNPMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Ylambd NP  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=46 =>> Tensor part strength coefficient LambdaNN
C=======================================================================
C
         IF (I.EQ.46.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.YNNMAX*UPFACT) THEN
C
                 FACTOR=YNNMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Ylambd NN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),YNNMAX*UPFACT,
     *                                                    FACTOR*YNNMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*YNNMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.YNNMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Ylambd NN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),YNNMIN*DWFACT,
     *                                                    YNNMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=YNNMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=YNNMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Ylambd NN  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=47 =>> Central Tensor part strength coefficient LambdaPP
C=======================================================================
C
         IF (I.EQ.47.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.CPPMAX*UPFACT) THEN
C
                 FACTOR=CPPMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Clambd PP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),CPPMAX*UPFACT,
     *                                                    FACTOR*CPPMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*CPPMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.CPPMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Clambd PP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),CPPMIN*DWFACT,
     *                                                    CPPMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=CPPMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=CPPMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Clambd PP  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=48 =>> Central Tensor part strength coefficient LambdaPN
C=======================================================================
C
         IF (I.EQ.48.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.CPNMAX*UPFACT) THEN
C
                 FACTOR=CPNMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Clambd PN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),CPNMAX*UPFACT,
     *                                                    FACTOR*CPNMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*CPNMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.CPNMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Clambd PN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),CPNMIN*DWFACT,
     *                                                    CPNMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=CPNMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=CPNMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Clambd PN  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=49 =>> Tensor part strength coefficient LambdaNP
C=======================================================================
C
         IF (I.EQ.49.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.CNPMAX*UPFACT) THEN
C
                 FACTOR=CNPMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Clambd NP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),CNPMAX*UPFACT,
     *                                                    FACTOR*CNPMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*CNPMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.CNPMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Clambd NP)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),CNPMIN*DWFACT,
     *                                                    CNPMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=CNPMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=CNPMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Clambd NP  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=50 =>> Tensor part strength coefficient LambdaNN
C=======================================================================
C
         IF (I.EQ.50.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.CNNMAX*UPFACT) THEN
C
                 FACTOR=CNNMAX/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Clambd NN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),CNNMAX*UPFACT,
     *                                                    FACTOR*CNNMAX
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*CNNMAX
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.CNNMIN*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Clambd NN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),CNNMIN*DWFACT,
     *                                                    CNNMIN/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=CNNMIN*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=CNNMIN/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''!     Clambd NN  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=51 =>> V_o central (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.51.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.V0CMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=V0CMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (V0CENT_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              V0CMAX_KAPPAR*UPFACT,
     *                              FACTOR*V0CMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*V0CMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.V0CMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (Clambd NN)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              V0CMIN_KAPPAR*DWFACT,
     *                              V0CMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=V0CMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=V0CMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! V0CENT_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=52 =>> kappa V_o central (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.52.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XKCMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=XKCMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (V0CENT_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XKCMAX_KAPPAR*UPFACT,
     *                              FACTOR*XKCMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XKCMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XKCMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_V0C_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XKCMIN_KAPPAR*DWFACT,
     *                              XKCMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XKCMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XKCMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(IRESUL,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! XK_V0C_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=53 =>> r_o central (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.53.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.R0CMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=R0CMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (R0CENT_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              R0CMAX_KAPPAR*UPFACT,
     *                              FACTOR*R0CMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*R0CMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.R0CMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (R0CENT_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              R0CMIN_KAPPAR*DWFACT,
     *                              R0CMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=R0CMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=R0CMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! R0CENT_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=54 =>> kappa r_o central (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.54.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XRCMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=XRCMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_R0C_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XRCMAX_KAPPAR*UPFACT,
     *                              FACTOR*XRCMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XRCMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XRCMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_R0C_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XRCMIN_KAPPAR*DWFACT,
     *                              XRCMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XRCMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XRCMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! XK_R0C_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=55 =>> a_o central (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.55.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.A0CMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=A0CMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (A0CENT_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              A0CMAX_KAPPAR*UPFACT,
     *                              FACTOR*A0CMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*A0CMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.A0CMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (A0CENT_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              A0CMIN_KAPPAR*DWFACT,
     *                              A0CMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=A0CMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=A0CMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! A0CENT_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=56 =>> kappa a_o central (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.56.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XACMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=XACMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_A0C_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XACMAX_KAPPAR*UPFACT,
     *                              FACTOR*XACMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XACMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XACMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_A0C_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XACMIN_KAPPAR*DWFACT,
     *                              XACMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XACMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XACMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! XK_A0C_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=57 =>> lambda_so pure WS (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.57.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XL_MAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=XL_MAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (V0SORB_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XL_MAX_KAPPAR*UPFACT,
     *                              FACTOR*XL_MAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XL_MAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XL_MIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (V0SORB_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XL_MIN_KAPPAR*DWFACT,
     *                              XL_MIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XL_MIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XL_MIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! V0SORB_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=58 =>> kappa lambda_so pure WS (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.58.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XKSMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=XKSMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_V0S_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XKSMAX_KAPPAR*UPFACT,
     *                              FACTOR*XKSMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XKSMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XKSMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_V0S_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XKSMIN_KAPPAR*DWFACT,
     *                              XKSMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XKSMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XKSMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! XK_V0S_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=59 =>> r_so pure WS (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.59.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.R0SMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=R0SMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (R0SORB_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              R0SMAX_KAPPAR*UPFACT,
     *                              FACTOR*R0SMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*R0SMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.R0SMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (R0SORB_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              R0SMIN_KAPPAR*DWFACT,
     *                              R0SMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=R0SMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=R0SMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! R0SORB_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=60 =>> kappa r_so pure WS (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.60.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XRSMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=XRSMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_R0S_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XRSMAX_KAPPAR*UPFACT,
     *                              FACTOR*XRSMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XRSMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XRSMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_R0S_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XRSMIN_KAPPAR*DWFACT,
     *                              XRSMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XRSMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XRSMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! XK_R0S_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=61 =>> a_so pure WS (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.61.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.A0SMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=A0SMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (A0SORB_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              A0SMAX_KAPPAR*UPFACT,
     *                              FACTOR*A0SMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*A0SMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.A0SMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)                 
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (A0SORB_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              A0SMIN_KAPPAR*DWFACT,
     *                              A0SMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=A0SMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=A0SMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! A0SORB_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C        I=62 =>> kappa a_so pure WS (kappa parametrization)
C=======================================================================
C
         IF (I.EQ.62.AND.IFTAKE(I).EQ.1) THEN
C
             IACTIV=IACTIV+1
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).GT.XASMAX_KAPPAR*UPFACT) THEN
C
                 FACTOR=XASMAX_KAPPAR/ARGMNT(IACTIV)             
C             
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT='',E12.6,'' >  '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_A0S_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XASMAX_KAPPAR*UPFACT,
     *                              FACTOR*XASMAX_KAPPAR
                 END IF
C
                 ARGMNT(IACTIV)=FACTOR*XASMAX_KAPPAR
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (ARGMNT(IACTIV).LT.XASMIN_KAPPAR*DWFACT) THEN
C
                 FACTOR=ABS(ARGMNT(IACTIV))/(ABS(ARGMNT(IACTIV))+5)
C                 
                 IF (LOGWRI.GT.0) THEN
C                 
                     WRITE(LOGFIL,'(''I='',I2,'' IACTIV ='',I3,
     *                            '' ARGMNT ='',E12.6,'' < '',F12.6,
     *                            '' NEWARG ='',F12.6,
     *                            '' (XK_A0S_KAPPAR)'')')
     *                            I,IACTIV,ARGMNT(IACTIV),
     *                              XASMIN_KAPPAR*DWFACT,
     *                              XASMIN_KAPPAR/FACTOR
                 END IF
C
                 IF (ARGMNT(IACTIV).LT.0.0) THEN
                     ARGMNT(IACTIV)=XASMIN_KAPPAR*FACTOR
                 ELSE
                     ARGMNT(IACTIV)=XASMIN_KAPPAR/FACTOR
                 END IF
C
                 ACTION(I)='#'
C
                 MEMORY(I)=MEMORY(I)+1                 
C
             END IF
C_______________________________________________________________________
C
             IF (MEMORY(I).GT.MAXMEM) THEN
C
                 WRITE(NOUTPT,'(/,80(''!''),/,''!'',78X,''!'',/,
     *                 ''! XK_A0S_KAPPAR  parameter was out of range '',
     *                 ''more than MAXMEM='',I2,'' times. ABORT   !'',/,
     *                 ''!'',78X,''!'',/,80(''!''))')     MAXMEM
C
                 IABORT=1
C
                 RETURN
C
             END IF
C
         END IF
C
C=======================================================================
C
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(12X,''Exiting  VERIFY'')')
      END IF 
C
C=======================================================================
C
      RETURN
      END           
C
C=======================================================================
C=======================================================================
C
C FILE NAME = wspher12_minpac_15.f ! Keep this symbol:    $ident@string$
C
C=======================================================================
C=======================================================================
C             LEVENBERG-MARQUARDT MINIMISATION ROUTINE PACKAGE   
C=======================================================================
C=======================================================================
C
      SUBROUTINE LEVMAR(FUNMIN,NDFUNC,LDFUNC,NDPARS,LDPARS,XARGUM,
     *                  FARGUM,FJACOB,TOLERF,TOLERX,TOLERG,MAXFEV,
     *                  DIAGSC,IFMODE,FACTOR,NPRINT,INFRUN,NFCALL,
     *                  NJCALL,I_PERM,QTRANF,WORKA1,WORKA2,WORKA3,
     *                                              WORKA4,NDLAST)
C
      INCLUDE   'MATDIM/MAXFEV_AUXILI.f'
      INCLUDE   'MATDIM/NDPARS_STORAG.f'
      INCLUDE   'MATDIM/NDRAND.f'
C      
      DIMENSION 
     *          XARGUM(1:NDPARS),FARGUM(1:NDFUNC),
     *          DIAGSC(1:NDPARS),QTRANF(1:NDPARS) 
      DIMENSION 
     *          WORKA1(1:NDPARS),WORKA2(1:NDPARS),
     *          WORKA3(1:NDPARS),WORKA4(1:NDFUNC)
      DIMENSION
     *          FJACOB(1:NDFUNC,1:NDPARS) 
      DIMENSION 
     *          I_PERM(1:NDPARS)
C
      COMMON
     *       /STOPAR/ EPSLAS,LDLAST
CID      COMMON
C     *      /COLECT_GRADMI/ GRADMI_ITERAT(1:MAXFEV_AUXILI,1:NDRAND)
C     *      /COLECT_PARSMI/ PARSMI_ITERAT(1:MAXFEV_AUXILI,1:NDRAND,
C     *                                    1:NDPARS_STORAG)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
      COMMON
     *       /RANRAN/ IRMFST,I_RAND,IRANDO
      COMMON 
     *       /LAST_G/ GRAD_N                                                 
C
      DATA 
     *       R_UNIT, CONST1, CONST5, CONS25, CONS75, CN0001, R_ZERO
     *     / 1.0000, 1.0E-1, 5.0E-1, 2.5E-1, 7.5E-1, 1.0E-4, 0.0000/
C
C=======================================================================
C
C     The purpose of LEVMAR is to minimise the sum of the squares of
C     LDFUNC nonlinear functions of LDPARS variables  by employing a
C     modification  of the standard Levenberg-Marquardt method.  The 
C     user must provide a subroutine, which calculates the functions 
C     and the Jacobian.
C
C     The subroutine statement is
C
C     SUBROUTINE LEVMAR(FUNMIN,MDFUNC,LDFUNC,NDPARS,LDPARS,XARGUM,
C                       FARGUM,FJACOB,TOLERF,TOLERX,TOLERG,MAXFEV,
C                       DIAGSC,IFMODE,FACTOR,NPRINT,INFRUN,NFCALL,
C                       NJCALL,I_PERM,QTRANF,WORKA1,WORKA2,WORKA3,
C                                                          WORKA4)
C
C     where
C
C     FUNMIN - the name of the user-supplied subroutine calculating 
C              the functions and the Jacobian.  It must be declared 
C              in an external statement in the user calling program, 
C              and should be written as follows.
C
C              SUBROUTINE FUNMIN(NDFUNC,LDFUNC,NDPARS,LDPARS,XARGUM,
C                                              FARGUM,FJACOB,I_FLAG)
C
C              DIMENSION 
C                        XARGUM(1:NDPARS),FARGUM(1:NDFUNC),
C                        FJACOB(1:NDFUNC,1:NDPARS)
C              ---------
C              IF I_FLAG = 1 calculate the functions at XARGUM, and
C                          return this vector in FARGUM. 
C                          Do not alter FJACOB.
C              IF I_FLAG = 2 calculate  the corresponding  Jacobian 
C                          at XARGUM,  return this matrix in FJACOB. 
C                          Do not alter FARGUM.
C              ---------
C              RETURN
C              END
C
C     The value of I_FLAG should not be changed by FUNMIN unless the
C     user wants to terminate execution of LEVMAR.  In this case set 
C     I_FLAG to a negative integer.
C
C     LDFUNC - a positive integer input variable;  set to the number
C              of functions.
C
C     LDPARS - a positive integer input variable;  set to the number
C              of variables.  LDPARS must not exceed NDPARS, and the 
C              latter must not exceed LDFUNC.
C
C     XARGUM - a vector of length NDPARS.  On input, it must contain
C              an initial estimate of the solution vector. On output 
C              XARGUM will contain the final result for the solution 
C                                                             vector.
C
C     FARGUM - an output array of length NDFUNC,  which contains the 
C              functions evaluated at the output XARGUM.
C
C     FJACOB - an output NDFUNC by NDPARS array. The upper LDPARS by 
C              LDPARS submatrix of the square matrix FJACOB contains 
C              an upper-triangular matrix  RUPTRI;  it has  diagonal 
C              elements of non-increasing magnitude such that
C
C                        T          T                T
C                       P *(Jacobian *Jacobian)*P = R *R,
C
C              where P is a permutation matrix, and Jacobian  is the 
C              final calculated Jacobian.  Column `J' of P is column 
C              I_PERM(J), (below), of the identity matrix. The lower 
C              trapezoidal part of FJACOB contains information gene-
C              rated during the computation of RUPTRI.
C
C     NDFUNC - the maximum number of the functions, that can be used
C              for the minimisation algorithm
C
C     LDFUNC - a positive integer, that must not exceed NDFUNC,  the 
C              actual number of functions, and the leading dimension 
C              of the array FJACOB
C
C     TOLERF - a nonnegative input variable. Termination occurs when 
C              both the actual, and predicted relative reductions in 
C              the sum of squares are at most TOLERF. Therefore, the
C              latter measures the relative error desired in the sum 
C              of squares.
C
C     TOLERX - a nonnegative input variable. Termination occurs when 
C              the relative error  between  two consecutive iterates 
C              is at most TOLERX. Therefore, the latter measures the
C              relative error desired in the approximate solution.
C
C     TOLERG - a nonnegative input variable. Termination occurs when 
C              the cosine of the angle between FARGUM and any column 
C              of the Jacobian is at most  TOLERG  in absolute value. 
C              Therefore, TOLERG  measures the orthogonality desired 
C              between the function vector and the resulting columns 
C              of the Jacobian.
C
C     MAXFEV - a positive integer input variable. Termination occurs 
C              when the number of calls to FUNMIN  with I_FLAG=1 has
C              reached MAXFEV.
C
C     DIAGSC - a vector of length NDPARS. If IFMODE = 1  (see below), 
C              DIAGSC is internally set.  If IFMODE = 2, DIAGSC must 
C              contain positive entries that serve as multiplicative 
C              scale factors for the variables
C
C     IFMODE - an integer input variable. If IFMODE = 1,   variables 
C              will be scaled internally. If IFMODE = 2, the scaling 
C              is specified by the input DIAGSC. Other values of pa-
C              rameter IFMODE are equivalent to IFMODE = 1.
C
C     FACTOR - a positive input variable that determines the initial 
C              step bound.  This bound is defined as  the product of
C              FACTOR and the Euclidean norm of DIAGSC*XARGUM if non-
C              zero, or else to FACTOR itself.  In most cases FACTOR 
C              should lie in the interval  [0.1, 100.0]. This  upper 
C              value (100.0) is a generally recommended.
C
C     NPRINT - an integer input variable that is used to control the
C              printing of iterates if it is positive.  In this case,
C              FUNMIN is called with I_FLAG = 0  at the beginning of 
C              the first iteration and every NPRINT iterations there-
C              after - and immediately prior to return,  with XARGUM, 
C              FARGUM, and FJACOB available for printing. FARGUM and
C              FJACOB should not be altered. If  NPRINT  is negative, 
C              no special calls of FUNMIN with I_FLAG = 0 are made.
C
C     INFRUN - an integer output variable.  If the user  has stopped 
C              execution,  INFRUN is set  to the (negative) value of 
C              I_FLAG. see description of FUNMIN.  Otherwise, INFRUN 
C              is set as follows:
C
C              INFRUN = 0  Improper input parameters
C
C              INFRUN = 1  Both the actual  and  predicted  relative  
C                          reductions  in the sum  of squares are at 
C                          most TOLERF
C
C              INFRUN = 2  Relative error  between  two  consecutive 
C                          iterates is at most TOLERX
C
C              INFRUN = 3  Conditions for INFRUN=1 and INFRUN=2 both 
C                                                               hold
C
C              INFRUN = 4  The cosine  of the angle  between  FARGUM 
C                          and any column of the Jacobian is at most 
C                          TOLERG in absolute value
C
C              INFRUN = 5  Number of calls to FUNMIN with I_FLAG = 1 
C                          has reached MAXFEV
C
C              INFRUN = 6  TOLERF is too small. No further reduction 
C                          in the sum of squares is possible
C
C              INFRUN = 7  TOLERX is too small.  In such  a case  no 
C                          further  improvement  in  the approximate 
C                          solution XARGUM is possible
C
C              INFRUN = 8  TOLERG is too small. FARGUM is orthogonal 
C                          to the columns of the Jacobian to machine 
C                          precision
C
C     The following ones are introduced by JD and ID:
C
C              INFRUN = 9  The difference between  the  last  LDLAST
C                          chi^2 is less than EPSLAS
C
C              INFRUN = 10 The norm of the real gradien is less than
C                          TOLERG
C
C     NFCALL - an integer output variable set to the number of calls 
C              to FUNMIN with I_FLAG = 1
C
C     NJCALL - an integer output variable set to the number of calls 
C              to FUNMIN with I_FLAG = 2
C
C     I_PERM - an integer output array of length NDPARS.  It defines 
C              a permutation matrix P such that Jacobian * P = Q * R,
C              where  "Jacobian"  stands for  the finally calculated 
C              Jacobian, Q is orthogonal (not stored), and R denoted
C              RUPTRI in the code is upper triangular, with diagonal 
C              elements of nonincreasing magnitude. Column J of P is 
C              column I_PERM(J) of the identity matrix.
C
C     QTRANF - an output array of length NDPARS,  which contains the 
C              first LDPARS elements  of the vector  obtained as the
C              result of multiplication (Q Transpose)*FARGUM.
C
C     WORKA1,  WORKA2, and WORKA3 are auxiliary work arrays of length 
C              NDPARS
C
C     WORKA4 - a work array of length NDFUNC.
C
C     Subprograms called:
C
C              User-supplied ...... FUNMIN
C
C              MINPACK-supplied ... DPMPAR,EUNORM,LM_PAR,QRFACT
C
C              FORTRAN-supplied ... ABS,MAX,MIN,SQRT,MOD
C
C     Argonne National Laboratory. MINPACK PROJECT. March 1980.
C     Burton S. Garbow, Kenneth E. Hillstrom and Jorge J. More
C
C=======================================================================
C
      CALL CPUTIM('LEVMAR',1)
C
C=======================================================================
C
      IF (NDPARS.NE.NDPARS_STORAG) THEN
          WRITE(NOUTPT,'(''Please make NDPARS='',I3,'' coincide with '',
     *                   ''NDPARS_STORAG='',I3)') NDPARS,
     *                     NDPARS_STORAG
          STOP 'NDPARS must be equal to NDPARS_STORAG, STOP from LEVMAR'
      END IF
C
C=======================================================================
C
      IF (MAXFEV.NE.MAXFEV_AUXILI) THEN
          WRITE(0,'(/,''Alarm in LEVMAR: MAXFEV= '',I4,
     *              '' and MAXFEV_AUXILI= '',I4,'' are not equal!'',/)')
     *                 MAXFEV,MAXFEV_AUXILI
          STOP 'STOP in LEVMAR: MAXFEV.NE.MAXFEV_AUXILI'
      END IF
C
C=======================================================================
C
CID      DO I=1,MAXFEV
CID         DO J=1,NDRAND
CID            GRADMI_ITERAT(I,J)=999999.999
CID            DO K=1, NDPARS
CID               PARSMI_ITERAT(I,J,K)=99999.999
CID            END DO
CID         END DO
CID      END DO
C
C=======================================================================
C
      EPSMCH=DPMPAR(1) !  EPSMCH is the machine precision
C
      I_STEP_GRAD_F=0
C
      I_ZERO=0
      INFRUN=0
      I_FLAG=0
C
      NFCALL=0 ! Number of function evaluations
      NJCALL=0 ! Number of Jacobian evaluations
C
C     Check the input parameters for inconsistency/errors
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(/,09X,''Inside LEVMAR: Verification of '',
     *                         ''the input'',
     *                   /,09X,''We should have '',6x,
     *                             ''   Actually we have'')')
C_______________________________________________________________________
C
          WRITE(LOGFIL,'(09X,''LDPARS .GT. I_ZERO:'',9x,I3,
     *                                     '' and'',I3,'' ?'')')
     *                         LDPARS,     I_ZERO
C
          WRITE(LOGFIL,'(09X,''LDFUNC .GE. LDPARS:'',9x,I3,
     *                                     '' and'',I3,'' ?'')')
     *                         LDFUNC,     LDPARS
C
          WRITE(LOGFIL,'(09X,''MAXFEV .GT. I_ZERO:'',9x,I3,
     *                                   '' and'',I3,'' ?'',/)')
     *                         MAXFEV,     I_ZERO
C_______________________________________________________________________
C
          WRITE(LOGFIL,'(09X,''TOLERF .GE. R_ZERO: '',3x,E8.2,
     *                                     '' and '',E8.2,'' ?'')')
     *                         TOLERF,     R_ZERO
C
          WRITE(LOGFIL,'(09X,''TOLERX .GE. R_ZERO: '',3x,E8.2,
     *                                     '' and '',E8.2,'' ?'')')
     *                         TOLERX,     R_ZERO
C
          WRITE(LOGFIL,'(09X,''TOLERG .GE. R_ZERO: '',3x,E8.2,
     *                                     '' and '',E8.2,'' ?'')')
     *                         TOLERG,     R_ZERO
C
          WRITE(LOGFIL,'(09X,''FACTOR .GT. R_ZERO: '',3x,E8.2,
     *                                     '' and '',E8.2,'' ?'')')
     *                         FACTOR,     R_ZERO
      END IF
C
C @@@ WHAT IS THIS FORM OF DANGEROUS PROGRAMMING?
C @@@ IRENE - PLEASE INTRODUCE STOP STOP STOP IN THE CASE OF COMMENTED IF
C
C     IF (LDFUNC.LT.LDPARS) THEN
C
C         WRITE(NOUTPT,'(''Nonsense request: Number of parameters '',
C    *                   ''exceeds the number of data points'',/)')
C
C         STOP 'Number of parameters > number of data points, in LEVMAR'
C
C     END IF
C
CID:  We have 'silenced' on of the conditions in the followinf IF
C     in order to be able to fit all the cases without the radius
C     We know that this will probably mean the appearance of over
C     fitting in our results. And this is what we want to show and
C     we will show how to fix it.
C
      IF (LDPARS.LE.I_ZERO .OR. !LDFUNC.LT.LDPARS.OR.
     *    TOLERF.LT.R_ZERO .OR. TOLERX.LT.R_ZERO.OR.
     *    TOLERG.LT.R_ZERO .OR. MAXFEV.LE.I_ZERO.OR.
     *                          FACTOR.LE.R_ZERO) THEN
C_______________________________________________________________________
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(9X,''One of the above conditions was '',
     *                          ''true =>> terminating and exiting'')')
          END IF
C
          GO TO 300
C
      END IF
C
C=======================================================================
C
      IF (IFMODE.EQ.2) THEN
          DO J=1,LDPARS
             IF (DIAGSC(J).LE.R_ZERO) GO TO 300
          END DO
      END IF
C
C     We evaluate the function at the starting point and calculate 
C                                                        its norm.
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,9X,''Entering FUNMIN from LEVMAR [1] '',
     *                        '' starting point'')')
      END IF 
C 
      I_FLAG=1
C
      CALL FUNMIN(NDFUNC,LDFUNC,NDPARS,LDPARS,XARGUM,FARGUM,
     *                                        FJACOB,I_FLAG)
C
C=======================================================================
C
      NFCALL=1
C
      IF (I_FLAG.LT.0) GO TO 300
C
      F_NORM=EUNORM(NDFUNC,LDFUNC,FARGUM)
C
C     Initialise Levenberg-Marquardt parameter and iteration counter
C
      PARAUX=R_ZERO
      ITERAT=1
C
C     Beginning of the outer loop <<<== jumping here from below ...
C
   30 CONTINUE
C
      I_FLAG=2 !  Calculate the Jacobian matrix
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,9X,''Entering FUNMIN from LEVMAR [2] '',
     *                        ''to calculate the Jacobian'')')
      END IF 
C
      CALL FUNMIN(NDFUNC,LDFUNC,NDPARS,LDPARS,XARGUM,FARGUM,
     *                                        FJACOB,I_FLAG)
C
C=======================================================================
C
C     Calculating the 'real' \chi^2 gradient norm, namely:
C
C     \chi^2 = \sum_j [ f_j(x) - y_j ] ^ 2
C
C     d\chi^2/dx_i = 2 * \sum_j ( f_j(x) - y_j ) * df_j(x_i)/dx_i
C
C     norm = sqrt[ \sum_i (d\chi^2/dx_i) ^ 2 ]
C
C     From FUNMIN we have:
C
C     ( f_j(x) - y_j ) = FARGUM(J_FUNC)
C
C     df_j(x_i)/dx_i = FJACOB(J_FUNC,I_PARS)
C
      GRAD_N=0.0
C
      DO I_PARS=1,LDPARS
C
         GRAD_V=0.0
C
         DO I_FUNC=1,LDFUNC
            GRAD_V=GRAD_V+FARGUM(I_FUNC)*FJACOB(I_FUNC,I_PARS)
         END DO
C
         GRAD_V=2*GRAD_V
         GRAD_N=GRAD_N+GRAD_V**2
C
      END DO
C
      GRAD_N=SQRT(GRAD_N)
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
C
          I_STEP_GRAD_F=I_STEP_GRAD_F+1
C
CID          GRADMI_ITERAT(I_STEP_GRAD_F,IRANDO)=GRAD_N
C
          WRITE(LOGFIL,'()')
C
          DO I=1,3
             WRITE(LOGFIL,'(9X,39(''#''),''   Evaluation number='',i3,
     *                                         1X,''for IRANDO='',I2)')
     *                                        I_STEP_GRAD_F,IRANDO
          END DO
C
CID          WRITE(LOGFIL,'(/,9X,''In LEVMAR: GRAD_N= '',f20.13,/,20x,
CID     *                        ''TOLERG= '',f20.13,/)') GRAD_N,TOLERG
          DO I=1,3
             WRITE(LOGFIL,'(9X,39(''#''),''   Evaluation number='',i3,
     *                                         1X,''for IRANDO='',I2)')
     *                                        I_STEP_GRAD_F,IRANDO
          END DO
C
      END IF
C
C=======================================================================
C
C     Checking if the gradient is less than our tolerance
C
      IF (GRAD_N.LT.TOLERG) INFRUN=10
C
      IF (INFRUN.NE.0) GO TO 300
C
C=======================================================================
C
      NJCALL=NJCALL+1
C
      IF (I_FLAG.LT.0) GO TO 300
C
C=======================================================================
C
C     If requested, call FUNMIN to enable printing of iterates
C
      IF (NPRINT.GT.0) THEN
C
          I_FLAG=0
C
          IF (MOD(ITERAT-1,NPRINT).EQ.0) THEN
C
              IF (LOGWRI.GT.0) THEN
                  WRITE(LOGFIL,'(9X,''Entering FUNMIN from LEVMAR [3]'',
     *                          '' to enable printing iterates, '',
     *                          ''as they say...'')')
              END IF 
C
              CALL FUNMIN(NDFUNC,LDFUNC,NDPARS,LDPARS,XARGUM,FARGUM,
     *                                                FJACOB,I_FLAG)
          END IF
C      
          IF (I_FLAG.LT.0) GO TO 300
C
      END IF
C
C=======================================================================
C
C     Compute the QR factorisation of the Jacobian
C
      CALL QRFACT(NDFUNC,LDFUNC,NDPARS,LDPARS,FJACOB,.TRUE.,
     *                          I_PERM,WORKA1,WORKA2,WORKA3)
C
C=======================================================================
C
C     On the first iteration and if IFMODE=1, scale according
C     to the norms of the columns of the initial Jacobian.
C
      IF (ITERAT.EQ.1) THEN
C
          IF (IFMODE.NE.2) THEN
C
              DO J=1,LDPARS
                                          DIAGSC(J)=WORKA2(J)
                 IF (WORKA2(J).EQ.R_ZERO) DIAGSC(J)=R_UNIT
              END DO
C
          END IF
C
C         On the first iteration, calculate the norm of the scaled 
C         XARGUM and initialise the step bound DELTAB
C
          DO J=1,LDPARS
             WORKA3(J)=DIAGSC(J)*XARGUM(J)
          END DO
C 
          XNORM=EUNORM(NDPARS,LDPARS,WORKA3)
          DELTAB=FACTOR*XNORM
C 
          IF (DELTAB.EQ.R_ZERO) DELTAB=FACTOR
C 
      END IF
C
C=======================================================================
C
C     Form (Q TRANSPOSE)*FARGUM and store the first LDPARS components 
C                                                           in QTRANF 
      DO I=1,LDFUNC
         WORKA4(I)=FARGUM(I)
      END DO
C
      DO J=1,LDPARS
C
         IF (FJACOB(J,J).NE.R_ZERO) THEN
C
             SUMAUX=R_ZERO
C
             DO I=J,LDFUNC
                SUMAUX=SUMAUX+FJACOB(I,J)*WORKA4(I)
             END DO
C
             TEMPOR=-SUMAUX/FJACOB(J,J)
C
             DO I=J,LDFUNC
                WORKA4(I)=WORKA4(I)+FJACOB(I,J)*TEMPOR
             END DO
C
         END IF
C
         FJACOB(J,J)=WORKA1(J)
         QTRANF(J)=WORKA4(J)
C
      END DO
C
C=======================================================================
C
C     Compute the norm of the scaled gradient
C
      G_NORM=R_ZERO
C
      IF (F_NORM.NE.R_ZERO) THEN
C
          DO J=1,LDPARS
C
             L=I_PERM(J)
C
             IF (WORKA2(L).NE.R_ZERO) THEN
C
                 SUMAUX=R_ZERO
                 DO I=1,J
                    SUMAUX=SUMAUX+FJACOB(I,J)*(QTRANF(I)/F_NORM)
                 END DO
C
                 G_NORM=MAX(G_NORM,ABS(SUMAUX/WORKA2(L)))
C
             END IF
C
          END DO
C
      END IF

      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,9X,''In LEVMAR: G_NORM= '',f20.13,/,20x,
     *                        ''TOLERG= '',f20.13,/)') G_NORM,TOLERG
      END IF
C
C=======================================================================
C
C     Test for convergence of the gradient norm
C
      IF (G_NORM.LE.TOLERG) INFRUN=4
C
      IF (INFRUN.NE.0) GO TO 300
C
C
C=======================================================================
C
C     Rescale if necessary
C
      IF (IFMODE.NE.2) THEN
          DO J=1,LDPARS
             DIAGSC(J) =MAX(DIAGSC(J),WORKA2(J))
          END DO
      END IF
C
C=======================================================================
C
C     Beginning of the inner loop
C
  200 CONTINUE
C
C=======================================================================
C
C     Determine the Levenberg-Marquardt parameter
C
      CALL LM_PAR(NDFUNC,LDFUNC,NDPARS,LDPARS,FJACOB,I_PERM,
     *            DIAGSC,QTRANF,DELTAB,PARAUX,WORKA1,WORKA2,
     *                                        WORKA3,WORKA4)
C
C=======================================================================
C
C     Store the direction P and XARGUM+P. Calculate the norm of P.
C
      DO J=1,LDPARS
         WORKA1(J)=-WORKA1(J)
         WORKA2(J)=XARGUM(J)+WORKA1(J)
         WORKA3(J)=DIAGSC(J)*WORKA1(J)
      END DO
C
      P_NORM=EUNORM(NDPARS,LDPARS,WORKA3)
C
C=======================================================================
C
C     On the first iteration, adjust the initial step bound
C
      IF (ITERAT.EQ.1) DELTAB=MIN(DELTAB,P_NORM)
C
      I_FLAG=1 !  Evaluate the function at XARGUM + P
C                              and calculate its norm
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(9X,''Entering FUNMIN from LEVMAR [4] '',
     *                      ''to evaluate the functions at p+dp'')')
      END IF 
C
      CALL FUNMIN(NDFUNC,LDFUNC,NDPARS,LDPARS,WORKA2,WORKA4,
     *                                        FJACOB,I_FLAG)
C
      NFCALL=NFCALL+1
C
      IF (I_FLAG.LT.0) GO TO 300
C
      FNORM1=EUNORM(NDFUNC,LDFUNC,WORKA4)
C
C=======================================================================
C
C     Compute the scaled actual reduction
C
      ACTRED=-R_UNIT
C
      IF (CONST1*FNORM1.LT.F_NORM) THEN
          ACTRED=R_UNIT-(FNORM1/F_NORM)**2
      END IF
C
C=======================================================================
C
C     Compute the scaled predicted reduction and the scaled 
C                                    directional derivative
      DO J=1,LDPARS
         WORKA3(J)=R_ZERO
         L=I_PERM(J)
         TEMPOR=WORKA1(L)
         DO I=1,J
            WORKA3(I)=WORKA3(I)+FJACOB(I,J)*TEMPOR
         END DO
      END DO
C
      TEMP_1=EUNORM(NDPARS,LDPARS,WORKA3)/F_NORM
      TEMP_2=(SQRT(PARAUX)*P_NORM)/F_NORM
C
      PRERED=TEMP_1**2+TEMP_2**2/CONST5
      DIRDER=-(TEMP_1**2+TEMP_2**2)
C
C=======================================================================
C
C     Compute the ratio of the actual to the predicted reduction
C
                            RATIO=R_ZERO
      IF (PRERED.NE.R_ZERO) RATIO=ACTRED/PRERED
C
C=======================================================================
C
C     Update the step bound
C
      IF (RATIO.LE.CONS25) THEN
C
          IF (ACTRED.GE.R_ZERO) TEMPOR=CONST5
C
          IF (ACTRED.LT.R_ZERO) THEN
              TEMPOR=CONST5*DIRDER/(DIRDER+CONST5*ACTRED)
          END IF
C
          IF (CONST1*FNORM1.GE.F_NORM .OR. TEMPOR.LT.CONST1) THEN
              TEMPOR=CONST1
          END IF
C
          DELTAB=TEMPOR*MIN(DELTAB,P_NORM/CONST1)
          PARAUX=PARAUX/TEMPOR
C
          GO TO 260
C
      END IF
C
      IF (.NOT.(PARAUX.NE.R_ZERO.AND.RATIO.LT.CONS75)) THEN
          DELTAB=P_NORM/CONST5
          PARAUX=CONST5*PARAUX
      END IF
C
  260 CONTINUE
C
C=======================================================================
C
C     Test for successful iteration
C
      IF (RATIO.GE.CN0001) THEN
C
C         Successful iteration. update XARGUM, FARGUM
C                                     and their norms
          DO J=1,LDPARS
             XARGUM(J)=WORKA2(J)
             WORKA2(J)=DIAGSC(J)*XARGUM(J)
          END DO
C
          DO I=1,LDFUNC
             FARGUM(I)=WORKA4(I)
          END DO
C
          XNORM=EUNORM(NDPARS,LDPARS,WORKA2)
          F_NORM=FNORM1
          ITERAT=ITERAT+1
C
      END IF
C
C=======================================================================
C
C     Tests for convergence
C
      IF (ABS(ACTRED).LE.TOLERF .AND. PRERED.LE.TOLERF
     *                          .AND. CONST5*RATIO.LE.R_UNIT) INFRUN=1
C
      IF (DELTAB.LE.TOLERX*XNORM) INFRUN=2
C
      IF (ABS(ACTRED).LE.TOLERF .AND. PRERED.LE.TOLERF .AND.
     *              CONST5*RATIO.LE.R_UNIT .AND. INFRUN.EQ.2) INFRUN=3
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,9X,''Entering VERIFY_STOPIN from LEVMAR'')')
      END IF
C
      CALL VERIFY_STOPIN(NDLAST,I_STOP)
      
      IF (I_STOP.EQ.LDLAST-1) INFRUN=9
C
      IF (INFRUN.NE.0) GO TO 300
C
C=======================================================================
C
C     Tests for termination and stringent tolerances
C
      IF (NFCALL.GE.MAXFEV) INFRUN=5
C 
      IF (ABS(ACTRED).LE.EPSMCH .AND. PRERED.LE.EPSMCH.AND.
     *                          CONST5*RATIO.LE.R_UNIT) INFRUN=6
C
      IF (DELTAB.LE.EPSMCH*XNORM) INFRUN=7
C
      IF (G_NORM.LE.EPSMCH) INFRUN=8
C
      IF (INFRUN.NE.0) GO TO 300
C
C         End of the inner loop. Repeat if iteration unsuccessful
C                                                   (go up to 200)
          IF (RATIO.LT.CN0001) GO TO 200
C
C         End of the outer loop
C
      GO TO 30
C
  300 CONTINUE
C
C=======================================================================
C
C     Termination, either normal or user imposed.
C
      IF (I_FLAG.LT.0) THEN 
          INFRUN=I_FLAG
      END IF
C
      I_FLAG=0
C
      IF (NPRINT.GT.0) THEN
C
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(9X,''Entering FUNMIN from LEVMAR [5] '',
     *                           '' for final print reasons'')')
          END IF 
C
          CALL FUNMIN(NDFUNC,LDFUNC,NDPARS,LDPARS,XARGUM,FARGUM,
     *                                            FJACOB,I_FLAG)
      END IF
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,9X,''Exiting  LEVMAR'')')
      END IF
C
C=======================================================================
C      
      CALL CPUTIM('LEVMAR',0)
C
C=======================================================================
C
      RETURN
      END     
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE VERIFY_STOPIN(NDLAST,ICOUNT)
C      
      INCLUDE  'MATDIM/MAXFEV.f'
C
      DIMENSION
     *          HILAST(1:NDLAST),
     *          DIFLAS(1:NDLAST)
C_______________________________________________________________________
C      
      COMMON
     *       /STOPAR/ EPSLAS,LDLAST
      COMMON
     *       /STOPIN/ HIAUXI(1:MAXFEV)
      COMMON
     *       /MINITE/ IDEFCN,ITECHI
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C @@@ IRENE, PLEASE ADD COMMENTS - WHAT IS THIS ROUTINE SUPPOSED TO DO ???     
C @@@ IRENE, WHAT IS EPSLAS??? HOW MUCH? WHY?
C=======================================================================
C      
      I_LAST=IDEFCN-1
C
      IF (I_LAST.LT.LDLAST) THEN
          IF (LOGWRI.GT.0) THEN
              WRITE(LOGFIL,'(12X,''I_LAST='',I3,'' < LDLAST='',I3)')
     *                             I_LAST,           LDLAST
              WRITE(LOGFIL,'(09X,''Exiting  VERIFY_STOPIN with no '',
     *                           ''action'')')
          END IF
          RETURN
      END IF
C
C=======================================================================
C          
      CALL CPUTIM('VERSTP',1)
C
C=======================================================================
C      
      IF (NDLAST.LT.LDLAST) THEN
          WRITE(0,'(/,''Alarm in VERIFY_STOPIN!! NDLAST= '',I2,
     *              '' and LDLAST= '',I2,/)')NDLAST,LDLAST
          STOP 'STOP in VERIFY_SOTPIN: NDLAST.LT.LDLAST'
      END IF
C
C=======================================================================
C      
      DO I=1,LDLAST
          HILAST(I)=0.0
      END DO
C
      HILAST(1)=HIAUXI(I_LAST)
C
      DO I=2,LDLAST
         J=I-1
         HILAST(I)=HIAUXI(I_LAST-J)
      END DO
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(12X,''Differences: '',$)')
      END IF
C
      DO I=2,LDLAST
          DIFLAS(I-1)=ABS(HILAST(I-1)-HILAST(I))
          IF (LOGWRI.GT.0) THEN
              IF (I.EQ.2) WRITE(LOGFIL,'(    I3,F8.4)')I-1,DIFLAS(I-1)
              IF (I.GT.2) WRITE(LOGFIL,'(15X,I1,F8.4)')I-1,DIFLAS(I-1)
          END IF
      END DO
C
      ICOUNT=0
      DO I=1,LDLAST-1
          IF (DIFLAS(I).LT.EPSLAS) THEN
              ICOUNT=ICOUNT+1
          END IF
      END DO
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(9X,''Exiting  VERIFY_STOPIN with ICOUNT='',
     *                                              I2)') ICOUNT 
      END IF
C
C=======================================================================
C                          
      CALL CPUTIM('VERSTP',0)
C
C=======================================================================
C      
      RETURN
      END
C
C=======================================================================
C=======================================================================
C 
      SUBROUTINE TELLIT(INFOER,TOLERF,TOLERX,TOLERG,MAXFEV,
     *                                       LDLAST,EPSLAS) 
C
      COMMON 
     *       /LAST_G/ GRAD_N                                   
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS  
C
C=======================================================================
C     Routine printing the interpretation of the minimisation result
C=======================================================================
C
C     Printing the information on screen
C
      IF (ISCREN.GT.0) THEN
C      
          WRITE(LSCREN,'()')
C
          IF (INFOER.EQ.0) 
     *    WRITE(LSCREN,'(''INFOER=0 ==>> Minimisation failed -'',
     *                   '' improper input parameters'')')
C
          IF (INFOER.EQ.1) 
     *    WRITE(LSCREN,'(''INFOER=1 ==>> Minimisation finished - both'',
     *                 '' actual and predicted relative reductions'',
     *                 '' in the sum of squares are at most ftol'',
     *                 '' (FTOL='',E12.5,'')'',
     *                 '' The gradient norm is GRAD_N= '',f10.4,
     *                 '' TOLERG= '',es12.5)') TOLERF,GRAD_N,TOLERG
C
          IF (INFOER.EQ.2) 
     *    WRITE(LSCREN,'(''INFOER=2 ==>> Minimisation finished -'',
     *    '' relative error between two consecutive iterates is at'',
     *    '' most xtol (XTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f10.4,
     *    '' TOLERG= '',es12.5)') TOLERX,GRAD_N,TOLERG
C
          IF (INFOER.EQ.3) 
     *    WRITE(LSCREN,'(''INFOER=3 ==>> Minimisation finished - both'',
     *    '' actual and predicted relative reductions'',
     *    '' in the sum of squares are at most ftol AND relative'',
     *    '' error between two consecutive iterates is at most xtol'',
     *    '' (FTOL='',ES12.5,'')'','' (XTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f10.4,
     *    '' TOLERG= '',es12.5)')TOLERF,TOLERX,GRAD_N,TOLERG
C
          IF (INFOER.EQ.4) 
     *    WRITE(LSCREN,'(''INFOER=4 ==>> Minimisation finished - the'',
     *    '' cosine of the angle between fvec and any column of the'',
     *    '' jacobian is at most gtol in absolute value'',
     *    '' (GTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f10.4,
     *    '' TOLERG= '',es12.5)')TOLERG,GRAD_N,TOLERG
C
          IF (INFOER.EQ.5) 
     *    WRITE(LSCREN,'(''INFOER=5 ==>> Minimisation finished -'',
     *    '' number of calls to fcn with iflag = 1 has reached maxfev'',
     *    '' (MAXFEV='',I6,'')'',
     *    '' The gradient norm is GRAD_N= '',f10.4,
     *    '' TOLERG= '',es12.5)')MAXFEV,GRAD_N,TOLERG
C
          IF (INFOER.EQ.6) 
     *    WRITE(LSCREN,'(''INFOER=6 ==>> Minimisation finished - ftol'',
     *    '' is too small. no further reduction in the sum of'',
     *    '' squares is possible'','' (FTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f10.4,
     *    '' TOLERG= '',es12.5)')TOLERF,GRAD_N,TOLERG
C
          IF (INFOER.EQ.7) 
     *    WRITE(LSCREN,'(''INFOER=7 ==>> Minimisation finished - xtol'',
     *    '' is too small. No further improvement in the approximate'',
     *    '' solution x is possible'','' (XTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f10.4,
     *    '' TOLERG= '',es12.5)')TOLERX,GRAD_N,TOLERG
C
          IF (INFOER.EQ.8) 
     *    WRITE(LSCREN,'(''INFOER=8 ==>> Minimisation finished - gtol'',
     *    '' is too small. fvec is orthogonal to the columns of the'',
     *    '' jacobian to machine precision'',
     *    '' (GTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f10.4,
     *    '' TOLERG= '',es12.5)')TOLERG,GRAD_N,TOLERG
C
          IF (INFOER.EQ.9) 
     *    WRITE(LSCREN,'(''INFOER=9 ==>> Minimisation finished - the'',
     *           '' difference between the last '',I2,'' chi^2 is'',
     *           '' less than EPSLAS= '',ES8.2,
     *           '' The gradient norm is GRAD_N= '',f10.4,
     *           '' TOLERG= '',es12.5)')
     *              LDLAST,EPSLAS,GRAD_N,TOLERG
C
          IF (INFOER.EQ.10) 
     *    WRITE(LSCREN,'(''INFOER=10 ==>> Minimisation finished - the'',
     *           '' \chi^2 gradient is less than TOLERG= '',ES12.5,
     *           '' The gradient norm is GRAD_N= '',f10.4)')
     *             TOLERG,GRAD_N
      
          WRITE(LSCREN,'()')
C      
      END IF
C
C=======================================================================
C
C     Printing the information in the logfile with the minimisation
C                                                             steps
CID      IF (LOGWRI.GT.0) THEN
C      
          WRITE(LOGAUX,'()')
C
          IF (INFOER.EQ.0) 
     *    WRITE(LOGAUX,'(''INFOER=0 ==>> Minimisation failed -'',
     *                   '' improper input parameters'')')
C
          IF (INFOER.EQ.1) 
     *    WRITE(LOGAUX,'(''INFOER=1 ==>> Minimisation finished - both'',
     *                 '' actual and predicted relative reductions'',
     *                 '' in the sum of squares are at most ftol'',
     *                 '' (FTOL='',E12.5,'')'',
     *                 '' The gradient norm is GRAD_N= '',f10.4,
     *                 '' TOLERG= '',es12.5)') TOLERF,GRAD_N,TOLERG
C
          IF (INFOER.EQ.2) 
     *    WRITE(LOGAUX,'(''INFOER=2 ==>> Minimisation finished -'',
     *    '' relative error between two consecutive iterates is at'',
     *    '' most xtol (XTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f10.4,
     *    '' TOLERG= '',es12.5)') TOLERX,GRAD_N,TOLERG
C
          IF (INFOER.EQ.3) 
     *    WRITE(LOGAUX,'(''INFOER=3 ==>> Minimisation finished - both'',
     *    '' actual and predicted relative reductions'',
     *    '' in the sum of squares are at most ftol AND relative'',
     *    '' error between two consecutive iterates is at most xtol'',
     *    '' (FTOL='',ES12.5,'')'','' (XTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')TOLERF,TOLERX,GRAD_N,TOLERG
C
          IF (INFOER.EQ.4) 
     *    WRITE(LOGAUX,'(''INFOER=4 ==>> Minimisation finished - the'',
     *    '' cosine of the angle between fvec and any column of the'',
     *    '' jacobian is at most gtol in absolute value'',
     *    '' (GTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')TOLERG,GRAD_N,TOLERG
C
          IF (INFOER.EQ.5) 
     *    WRITE(LOGAUX,'(''INFOER=5 ==>> Minimisation finished -'',
     *    '' number of calls to fcn with iflag = 1 has reached maxfev'',
     *    '' (MAXFEV='',I6,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')MAXFEV,GRAD_N,TOLERG
C
          IF (INFOER.EQ.6) 
     *    WRITE(LOGAUX,'(''INFOER=6 ==>> Minimisation finished - ftol'',
     *    '' is too small. no further reduction in the sum of'',
     *    '' squares is possible'','' (FTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')TOLERF,GRAD_N,TOLERG
C
          IF (INFOER.EQ.7) 
     *    WRITE(LOGAUX,'(''INFOER=7 ==>> Minimisation finished - xtol'',
     *    '' is too small. No further improvement in the approximate'',
     *    '' solution x is possible'','' (XTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')TOLERX,GRAD_N,TOLERG
C
          IF (INFOER.EQ.8) 
     *    WRITE(LOGAUX,'(''INFOER=8 ==>> Minimisation finished - gtol'',
     *    '' is too small. fvec is orthogonal to the columns of the'',
     *    '' jacobian to machine precision'',
     *    '' (GTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')TOLERG,GRAD_N,TOLERG
C
          IF (INFOER.EQ.9) 
     *    WRITE(LOGAUX,'(''INFOER=9 ==>> Minimisation finished - the'',
     *           '' difference between the last '',I2,'' chi^2 is'',
     *           '' less than EPSLAS= '',ES8.2,
     *           '' The gradient norm is GRAD_N= '',f20.13,
     *           '' TOLERG= '',es12.5)')
     *              LDLAST,EPSLAS,GRAD_N,TOLERG
C
          IF (INFOER.EQ.10) 
     *    WRITE(LOGAUX,'(''INFOER=10 ==>> Minimisation finished - the'',
     *           '' \chi^2 gradient is less than TOLERG= '',ES12.5,
     *           '' The gradient norm is GRAD_N= '',f20.13)')
     *             TOLERG,GRAD_N
      
          WRITE(LOGAUX,'()')
C      
CID      END IF
C
C=======================================================================
C
C     Printing the information in the main logfile
C
      IF (LOGWRI.GT.0) THEN
C      
          WRITE(LOGFIL,'()')
C
          IF (INFOER.EQ.0) 
     *    WRITE(LOGFIL,'(''INFOER=0 ==>> Minimisation failed -'',
     *                   '' improper input parameters'')')
C
          IF (INFOER.EQ.1) 
     *    WRITE(LOGFIL,'(''INFOER=1 ==>> Minimisation finished - both'',
     *                 '' actual and predicted relative reductions'',
     *                 '' in the sum of squares are at most ftol'',
     *                 '' (FTOL='',E12.5,'')'',
     *                 '' The gradient norm is GRAD_N= '',f20.13,
     *                 '' TOLERG= '',es12.5)') TOLERF,GRAD_N,TOLERG
C
          IF (INFOER.EQ.2) 
     *    WRITE(LOGFIL,'(''INFOER=2 ==>> Minimisation finished -'',
     *    '' relative error between two consecutive iterates is at'',
     *    '' most xtol (XTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)') TOLERX,GRAD_N,TOLERG
C
          IF (INFOER.EQ.3) 
     *    WRITE(LOGFIL,'(''INFOER=3 ==>> Minimisation finished - both'',
     *    '' actual and predicted relative reductions'',
     *    '' in the sum of squares are at most ftol AND relative'',
     *    '' error between two consecutive iterates is at most xtol'',
     *    '' (FTOL='',ES12.5,'')'','' (XTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')TOLERF,TOLERX,GRAD_N,TOLERG
C
          IF (INFOER.EQ.4) 
     *    WRITE(LOGFIL,'(''INFOER=4 ==>> Minimisation finished - the'',
     *    '' cosine of the angle between fvec and any column of the'',
     *    '' jacobian is at most gtol in absolute value'',
     *    '' (GTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')TOLERG,GRAD_N,TOLERG
C
          IF (INFOER.EQ.5) 
     *    WRITE(LOGFIL,'(''INFOER=5 ==>> Minimisation finished -'',
     *    '' number of calls to fcn with iflag = 1 has reached maxfev'',
     *    '' (MAXFEV='',I6,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')MAXFEV,GRAD_N,TOLERG
C
          IF (INFOER.EQ.6) 
     *    WRITE(LOGFIL,'(''INFOER=6 ==>> Minimisation finished - ftol'',
     *    '' is too small. no further reduction in the sum of'',
     *    '' squares is possible'','' (FTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')TOLERF,GRAD_N,TOLERG
C
          IF (INFOER.EQ.7) 
     *    WRITE(LOGFIL,'(''INFOER=7 ==>> Minimisation finished - xtol'',
     *    '' is too small. No further improvement in the approximate'',
     *    '' solution x is possible'','' (XTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')TOLERX,GRAD_N,TOLERG
C
          IF (INFOER.EQ.8) 
     *    WRITE(LOGFIL,'(''INFOER=8 ==>> Minimisation finished - gtol'',
     *    '' is too small. fvec is orthogonal to the columns of the'',
     *    '' jacobian to machine precision'',
     *    '' (GTOL='',ES12.5,'')'',
     *    '' The gradient norm is GRAD_N= '',f20.13,
     *    '' TOLERG= '',es12.5)')TOLERG,GRAD_N,TOLERG
C
          IF (INFOER.EQ.9) 
     *    WRITE(LOGFIL,'(''INFOER=9 ==>> Minimisation finished - the'',
     *           '' difference between the last '',I2,'' chi^2 is'',
     *           '' less than EPSLAS= '',ES8.2,
     *           '' The gradient norm is GRAD_N= '',f20.13,
     *           '' TOLERG= '',es12.5)')
     *              LDLAST,EPSLAS,GRAD_N,TOLERG
C
          IF (INFOER.EQ.10) 
     *    WRITE(LOGFIL,'(''INFOER=10 ==>> Minimisation finished - the'',
     *           '' \chi^2 gradient is less than TOLERG= '',ES12.5,
     *           '' The gradient norm is GRAD_N= '',f20.13)')
     *             TOLERG,GRAD_N
      
          WRITE(LOGFIL,'()')
C      
      END IF
C
C=======================================================================
C
      RETURN
      END    
C
C=======================================================================      
C=======================================================================      
C
      FUNCTION EUNORM(NDPARS,LDPARS,XARGUM)
C
      DIMENSION 
     *          XARGUM(1:NDPARS)
C
      DATA 
     *       R_UNIT,R_ZERO, RDWARF  , RGIANT 
     *     / 1.0000,0.0000,3.834E-20,1.304E19 /
C
C=======================================================================
C
C     Given an (n=LDPARS)-vector XARGUM -> this function calculates 
C     the Euclidean norm of XARGUM.
C
C     We introduce the definitions of small, intermediate and large 
C     components depend on two constants, RDWARF and RGIANT.  There
C     are restrictions on these constants, such that RDWARF**2  not
C     underflow and RGIANT**2 not overflow. The values of constants 
C     given here are suitable for every known computer.
C
C     The Euclidean norm is then computed  by collecting the sum of
C     squares in three different sums.  The sums of squares for the
C     small and large components  are scaled, so that no  overflows
C     occur.  Non-destructive underflows are permitted.  Underflows
C     and overflows do not occur in the computation of the unscaled
C     sum of squares for the intermediate components.
C
C     The function statement is
C
C                  FUNCTION EUNORM(NDPARS,LDPARS,XARGUM)
C
C     where
C
C     LDPARS - a positive integer input variable, the actual number
C              of parameters (dimension of the problem)
C
C     XARGUM - an input array of length  LDPARS  that is not larger 
C              than NDPARS
C
C=======================================================================
C
C     SUBPROGRAMS CALLED
C
C                 FORTRAN-SUPPLIED ... ABS, SQRT
C
C     Argonne National Laboratory. MINPACK PROJECT, March 1980
C     Burton S. Garbow, Kenneth E. Hillstrom and Jorge J. More
C
C=======================================================================
C 
      CALL CPUTIM('EUNORM',1)
C
C=======================================================================
C
      S1TERM=R_ZERO
      S2TERM=R_ZERO
      S3TERM=R_ZERO
C
      X1_MAX=R_ZERO
      X3_MAX=R_ZERO
C
      FLOATN=LDPARS
      AGIANT=RGIANT/FLOATN
C
      DO I=1,LDPARS
C
         XARABS=ABS(XARGUM(I))
C
         IF (.NOT.(XARABS.GT.RDWARF.AND.XARABS.LT.AGIANT)) THEN
C
             IF (XARABS.GT.RDWARF) THEN
C
C                Sum for large components
C
                 IF (XARABS.GT.X1_MAX) THEN
C
                     S1TERM=R_UNIT+S1TERM*(X1_MAX/XARABS)**2
                     X1_MAX=XARABS
C
                     GO TO 20
C
                 END IF
C
                 S1TERM=S1TERM+(XARABS/X1_MAX)**2
C
   20            CONTINUE
                 GO TO 60
             END IF
C
C            Sum for small components
C
             IF (XARABS.GT.X3_MAX) THEN
                 S3TERM=R_UNIT+S3TERM*(X3_MAX/XARABS)**2
                 X3_MAX=XARABS
                 GO TO 50
             END IF
C
             IF (XARABS.NE.R_ZERO) S3TERM=S3TERM+(XARABS/X3_MAX)**2
C
   50        CONTINUE
   60        CONTINUE
C
             GO TO 80
C
         END IF
C
C        Sum for intermediate components
C
         S2TERM=S2TERM+XARABS**2
C
   80    CONTINUE
C
      END DO
C
C     Calculation of norm
C
      IF (S1TERM.NE.R_ZERO) THEN
          EUNORM=X1_MAX*SQRT(S1TERM+(S2TERM/X1_MAX)/X1_MAX)
          GO TO 130
      END IF
C
      IF (S2TERM.NE.R_ZERO) THEN
C
          IF (S2TERM.GE.X3_MAX) THEN
              EUNORM=SQRT(S2TERM*(R_UNIT+(X3_MAX/S2TERM)
     *                          *(X3_MAX*S3TERM)))
          END IF
C
          IF (S2TERM.LT.X3_MAX) THEN
              EUNORM=SQRT(X3_MAX*((S2TERM/X3_MAX)+(X3_MAX*S3TERM)))
          END IF
C
          GO TO 120
C
      END IF
C
      EUNORM=X3_MAX*SQRT(S3TERM)
C
  120 CONTINUE
  130 CONTINUE
C
C=======================================================================
C 
      CALL CPUTIM('EUNORM',0)
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C         
      SUBROUTINE LM_PAR(NDFUNC,LDFUNC,NDPARS,LDPARS,RUPTRI,I_PERM,
     *                  DIAGSC,QTRANB,DELTAB,PARLEV,XARGUM,S_DIAG,
     *                                              WORKA1,WORKA2)
C 
      DIMENSION 
     *          DIAGSC(1:NDPARS),QTRANB(1:NDPARS),
     *          XARGUM(1:NDPARS),S_DIAG(1:NDPARS),
     *          WORKA1(1:NDPARS),WORKA2(1:NDPARS)
      DIMENSION 
     *          RUPTRI(1:NDFUNC,1:NDPARS)
      DIMENSION 
     *          I_PERM(1:NDPARS)
C
      DATA 
     *      CONST1,P001,R_ZERO 
     *     /1.0D-1,1.0D-3,0.0D0/
C
C=======================================================================
C
C     Given an m by NDPARS matrix A, an NDPARS by NDPARS nonsingular 
C     diagonal matrix D, an m-vector B, and a positive number DELTAB,
C     The problem is to determine  a value for the parameter  PARLEV 
C     such that if XARGUM solves the system
C
C               D*XARGUM = D   and   sqrt(PARLEV)*D*XARGUM = 0,
C
C     in the least squares sense and DXNORM is the Euclidean norm of 
C     D*XARGUM, then either PARLEV is zero and
C
C                     (DXNORM-DELTAB).LE.0.1*DELTAB,
C
C     or PARLEV is positive and
C
C                   abs(DXNORM-DELTAB).LE.0.1*DELTAB 
C
C     This subroutine completes the solution of the problem if it is 
C     provided with the necessary information from  QR factorization, 
C     with column pivoting, of A,  that is, if A*P = Q*RUPTRI, where 
C     P is a permutation matrix, Q has orthogonal columns and RUPTRI 
C     is an upper triangular matrix  with diagonal elements that are 
C     of nonincreasing magnitude, then LM_PAR expects the full upper 
C     triangle of  RUPTRI,  the permutation matrix P,  and the first 
C     LDPARS components of (Q Transpose) * B. On output, LM_PAR also 
C     provides an upper triangular matrix s such that
C
C                     t   t                   t
C                    P *(A *A + PARLEV*D*D)*P = S *S .
C
C     S is employed within LM_PAR ->> it may be of separate interest
C
C     Only a few iterations  are generally needed for convergence of 
C     the algorithm.  If the limit of 10 iterations is reached, then 
C     the output  PARLEV will contain the best value obtained so far.
C
C     The subroutine statement is
C
C     SUBROUTINE LM_PAR(NDFUNC,LDFUNC,NDPARS,LDPARS,RUPTRI,I_PERM,
C                       DIAGSC,QTRANB,DELTAB,PARLEV,XARGUM,S_DIAG,
C                                                   WORKA1,WORKA2)
C
C     where
C
C     LDPARS - a positive integer input variable set to the order of 
C                                                             RUPTRI
C
C     RUPTRI - a square  NDPARS by NDPARS  array.  On input the full 
C              upper triangle  must contain  the full upper triangle 
C              of the matrix RUPTRI;  then on output, the full upper 
C              triangle is unaltered,  and the strict lower triangle 
C              contains the strict  upper triangle  (transposed)  of 
C              the upper triangular matrix S.
C
C     NDFUNC - a positive,  integer input variable  not smaller than 
C              NDPARS, which specifies  the leading dimension of the 
C              array RUPTRI.
C
C     I_PERM - an integer input array of length NDPARS which defines 
C              the permutation matrix p such that A * P = Q * RUPTRI. 
C              Column J of P is column I_PERM(j) of identity matrix.
C
C     DIAGSC - an input array of length NDPARS which must contain the
C              diagonal elements of the matrix D
C
C     QTRANB - an input array of length NDPARS which must contain the 
C              first LDPARS elements of the vector (Q Transpose) * B.
C
C     DELTAB - a positive input variable, it specifies an upper bound 
C              on the Euclidean norm of D*XARGUM
C
C     PARLEV - a nonnegative variable. containing on input an initial 
C              estimate of the Levenberg-Marquardt parameter.  On the 
C              output PARLEV contains the final estimate.
C
C     XARGUM - an output array of length  LDPARS,  which contains the 
C              least squares solution of the system 
C
C                  A*XARGUM = B   and   sqrt(PARLEV)*d*XARGUM = 0,
C
C              for the output PARLEV.
C
C     S_DIAG - an output array of length LDPARS.  It contains all the
C              diagonal elements of the upper triangular matrix S.
C
C              WORKA1 and WORKA2 are work vectors of length NDPARS.
C
C=======================================================================
C
C     SUBPROGRAMS CALLED
C
C                 MINPACK-SUPPLIED ... DPMPAR, EUNORM, QRSOLV
C
C                 FORTRAN-SUPPLIED ... ABS, MAX, MIN, SQRT
C
C     Argonne National Laboratory. MINPACK PROJECT, March 1980
C     Burton S. Garbow, Kenneth E. Hillstrom and Jorge J. More
C
C=======================================================================
C 
      CALL CPUTIM('LM_PAR',1)
C
C=======================================================================
C
C     DWARF is the smallest positive magnitude.
C
      DWARF=DPMPAR(2)
C
C     Compute and store in XARGUM the Gauss-Newton direction. If the
C     Jacobian is rank-deficient, obtain a least squares solution.
C
      N_SING=LDPARS
C
      DO J=1,LDPARS
         WORKA1(J)=QTRANB(J)
         IF (RUPTRI(J,J).EQ.R_ZERO.AND.N_SING.EQ.LDPARS) N_SING=J-1
         IF (N_SING.LT.LDPARS) WORKA1(J)=R_ZERO
      END DO
C
      IF (N_SING.GE.1) THEN
C
          DO K=1,N_SING
C
             J=N_SING-K+1
             WORKA1(J)=WORKA1(J)/RUPTRI(J,J)
             TEMPOR=WORKA1(J)
             JMIN_1=J-1
C
             IF (JMIN_1.GE.1) THEN
                 DO I=1,JMIN_1
                    WORKA1(I)=WORKA1(I)-RUPTRI(I,J)*TEMPOR
                 END DO
             END IF
C
          END DO
C
      END IF
C
      DO J=1,LDPARS
         L=I_PERM(J)
         XARGUM(L)=WORKA1(J)
      END DO
C
C=======================================================================
C
C     Initialize the iteration counter. Evaluate the function at
C     the origin,  and test  for acceptance  of the gauss-newton 
C     direction.
C
      ITERAT=0
C
      DO J=1,LDPARS
         WORKA2(J)=DIAGSC(J)*XARGUM(J)
      END DO
C
      DXNORM=EUNORM(NDPARS,LDPARS,WORKA2)
      FP_AUX=DXNORM-DELTAB
C
      IF (FP_AUX.LE.CONST1*DELTAB) GO TO 220
C
C=======================================================================
C
C     If the Jacobian is not rank deficient, the Newton step provides 
C     a lower bound, PARLOW, for the zero of the function.  Otherwise 
C     set this bound to zero.
C
      PARLOW=R_ZERO
C
      IF (N_SING.GE.LDPARS) THEN
C
          DO J=1,LDPARS
             L=I_PERM(J)
             WORKA1(J)=DIAGSC(L)*(WORKA2(L)/DXNORM)
          END DO
C
          DO J=1,LDPARS
C
             SUMAUX=R_ZERO
             JMIN_1=J-1
C
             IF (JMIN_1.GE.1) THEN
                 DO I=1,JMIN_1
                    SUMAUX=SUMAUX+RUPTRI(I,J)*WORKA1(I)
                 END DO
             END IF
C
             WORKA1(J)=(WORKA1(J)-SUMAUX)/RUPTRI(J,J)
C
          END DO
C
          TEMPOR=EUNORM(NDPARS,LDPARS,WORKA1)
          PARLOW=((FP_AUX/DELTAB)/TEMPOR)/TEMPOR
C
      END IF
C
C=======================================================================
C
C     Calculate an upper bound, PARUPP, for the zero of the function
C
      DO J=1,LDPARS
         SUMAUX=R_ZERO
         DO I=1,J
            SUMAUX=SUMAUX+RUPTRI(I,J)*QTRANB(I)
         END DO
         L=I_PERM(J)
         WORKA1(J)=SUMAUX/DIAGSC(L)
      END DO
C
      G_NORM=EUNORM(NDPARS,LDPARS,WORKA1)
      PARUPP=G_NORM/DELTAB
C
      IF (PARUPP.EQ.R_ZERO) PARUPP=DWARF/MIN(DELTAB,CONST1)
C
C=======================================================================
C
C     If the input PARLEV lies outside of the interval (PARLOW,PARUPP)
C     set PARLEV to the closer endpoint
C
      PARLEV=MAX(PARLEV,PARLOW)
      PARLEV=MIN(PARLEV,PARUPP)
C
      IF (PARLEV.EQ.R_ZERO) PARLEV=G_NORM/DXNORM
C
C     Beginning of an iteration
C
  150 CONTINUE
C
      ITERAT=ITERAT+1
C
C=======================================================================
C
C     Evaluate the function at the current value of PARLEV
C
      IF (PARLEV.EQ.R_ZERO) PARLEV=MAX(DWARF,P001*PARUPP)
C
      TEMPOR=SQRT(PARLEV)
C
      DO J=1,LDPARS
         WORKA1(J)=TEMPOR*DIAGSC(J)
      END DO
C  
      CALL QRSOLV(NDFUNC,LDFUNC,NDPARS,LDPARS,RUPTRI,I_PERM,
     *                   WORKA1,QTRANB,XARGUM,S_DIAG,WORKA2)
C  
      DO J=1,LDPARS
         WORKA2(J)=DIAGSC(J)*XARGUM(J)
      END DO
C  
      DXNORM=EUNORM(NDPARS,LDPARS,WORKA2)
      TEMPOR=FP_AUX
      FP_AUX=DXNORM-DELTAB
C
C=======================================================================
C
C     If the function is small enough,  accept the current  value
C     of PARLEV. also test for the exceptional cases where PARLOW
C     is zero or the number of iterations has reached 10
C
      IF (ABS(FP_AUX).LE.CONST1*DELTAB.OR.PARLOW.EQ.R_ZERO.AND.
     *    FP_AUX.LE.TEMPOR.AND.TEMPOR.LT.R_ZERO.OR.ITERAT.EQ.10) 
     *                                                GO TO 220
C
C=======================================================================
C
C     Compute the Newton correction
C
      DO J=1,LDPARS
         L=I_PERM(J)
         WORKA1(J)=DIAGSC(L)*(WORKA2(L)/DXNORM)
      END DO
C
      DO J=1,LDPARS
C
         WORKA1(J)=WORKA1(J)/S_DIAG(J)
         TEMPOR=WORKA1(J)
         JP1=J+1
C
         IF (LDPARS.GE.JP1) THEN
C
             DO I=JP1,LDPARS
                WORKA1(I)=WORKA1(I)-RUPTRI(I,J)*TEMPOR
             END DO
C
          END IF
C
      END DO
C
      TEMPOR=EUNORM(NDPARS,LDPARS,WORKA1)
      PARC=((FP_AUX/DELTAB)/TEMPOR)/TEMPOR
C
C=======================================================================
C
C     Depending on the sign of the function, update PARLOW or PARUPP
C
      IF (FP_AUX.GT.R_ZERO) PARLOW=MAX(PARLOW,PARLEV)
      IF (FP_AUX.LT.R_ZERO) PARUPP=MIN(PARUPP,PARLEV)
C
C=======================================================================
C
C     Compute an improved estimate for PARLEV.
C
      PARLEV=MAX(PARLOW,PARLEV+PARC)
C
C     End of an iteration.
C
      GO TO 150
C
  220 CONTINUE
C
      IF (ITERAT.EQ.0) PARLEV=R_ZERO
C
C=======================================================================
C 
      CALL CPUTIM('LM_PAR',0)
C
C=======================================================================      
C      
      RETURN
      END 
C
C=======================================================================      
C=======================================================================      
C
      SUBROUTINE QRFACT(NDFUNC,LDFUNC,NDPARS,LDPARS,AMATRX,LPIVOT,
     *                                I_PERM,R_DIAG,ACNORM,WORK_A)
C
      LOGICAL 
     *          LPIVOT
      DIMENSION 
     *          R_DIAG(1:NDPARS),ACNORM(1:NDPARS),WORK_A(1:NDPARS)
      DIMENSION 
     *          AMATRX(1:NDFUNC,1:NDPARS)
      DIMENSION 
     *          I_PERM(1:NDPARS)
C
      DATA 
     *     R_UNIT,P05,R_ZERO 
     *    /1.0000,5.0e-2,0.000/
C
C=======================================================================
C
C     This subroutine uses  Householder transformations  with column
C     pivoting to compute a QR factorisation of the LDFUNC by LDPARS 
C     matrix AMATRX. that is, QRFACT determines an orthogonal matrix 
C     Q, a permutation matrix P,  together with an upper trapezoidal 
C     matrix RUPTRI, with diagonal elements  of nonincreasing magni-
C     tude, such that A*P = Q*RUPTRI. The Householder transformation 
C     for column K, K = 1,2, ... ,MIN(LDFUNC,LDPARS), is of the form
C
C                                          t
C                          I - (1/U(K))*U*U
C
C     where U has zeros in the first K-1 positions. the form of this 
C     transformation, and the method of pivoting  has first appeared 
C     in the corresponding LINPACK subroutine.
C
C     The subroutine statement is
C
C       SUBROUTINE QRFACT(NDFUNC,LDFUNC,NDPARS,LDPARS,AMATRX,LPIVOT,
C                                       I_PERM,R_DIAG,ACNORM,WORK_A)
C
C     where
C
C     LDFUNC - a positive integer input variable,  set to the number
C              of rows of AMATRX
C
C     LDPARS - a positive integer input variable,  set to the number
C              of columns of AMATRX
C
C     AMATRX - an LDFUNC by LDPARS array.  On input  AMATRX contains 
C              the matrix,  for which the QR factorization  is to be 
C              computed. On output the strict upper trapezoidal part 
C              of AMATRX  contains the strict upper trapezoidal part 
C              of RUPTRI, and the lower  trapezoidal part  of AMATRX 
C              contains  a factored form of Q  (non-trivial elements 
C              of the U vectors described above).
C
C     LDFUNC - a positive integer input variable;  it  specifies the 
C              leading dimension of the array AMATRX not larger than 
C                                                             NDFUNC
C
C     LPIVOT - a logical input variable. If LPIVOT is set true, then 
C              column pivoting is enforced.  If LPIVOT is set false,
C              then no column pivoting is done.
C
C     I_PERM - an integer output array of length NDPARS;  it defines 
C              the permutation matrix P such that AMATRX*P=Q*RUPTRI.
C              Column  J of P  is column  I_PERM(J)  of the identity 
C              matrix. If LPIVOT is false, I_PERM is not referenced.
C
C     LPIVOT - a positive integer input variable. If LPIVOT is false
C              then LPIVOT may be as small as 1.  If LPIVOT is true, 
C              then LPIVOT must be at least LDPARS.
C
C     R_DIAG - an output array of length LDPARS,  which contains the
C              diagonal elements of RUPTRI.
C
C     ACNORM - an output array of length LDPARS,  which contains the
C              norms  of  the corresponding  columns  of  the  input 
C              matrix AMATRX. If this information is not needed then 
C              ACNORM can coincide with R_DIAG.
C
C     WORK_A - a work  array  of length  LDPARS. If LPIVOT is false, 
C              then WORK_A can coincide with R_DIAG.
C
C     SUBPROGRAMS CALLED
C
C                 MINPACK-SUPPLIED ... DPMPAR, EUNORM
C
C                 FORTRAN-SUPPLIED ... MAX, SQRT, MIN0
C
C=======================================================================
C
C     Argonne National Laboratory. MINPACK PROJECT, March 1980
C     Burton S. Garbow, Kenneth E. Hillstrom and Jorge J. More
C
C=======================================================================
C
      CALL CPUTIM('QRFACT',1)
C
C=======================================================================
C
      EPSMCH=DPMPAR(1) !  EPSMCH is the machine precision
C
C     Compute the initial column norms and initialize several arrays
C
      DO J=1,LDPARS
C
         ACNORM(J)=EUNORM(NDFUNC,LDFUNC,AMATRX(1,J))
         R_DIAG(J)=ACNORM(J)
         WORK_A(J)=R_DIAG(J)
C
         IF (LPIVOT) I_PERM(J)=J
C
      END DO
C
C     Reduce AMATRX to RUPTRI with Householder transformations
C
      MINMN=MIN0(LDFUNC,LDPARS)
C
      DO J=1,MINMN
C
         IF (LPIVOT) THEN
C
C            Bring the column of largest norm into the LPIVOT position
C
             KMAX=J
C
             DO K=J,LDPARS
                IF (R_DIAG(K).GT.R_DIAG(KMAX)) KMAX=K
             END DO
C
             IF (KMAX.NE.J) THEN
C
                 DO I=1,LDFUNC
                    TEMPOR=AMATRX(I,J)
                    AMATRX(I,J)=AMATRX(I,KMAX)
                    AMATRX(I,KMAX)=TEMPOR
                 END DO
C
                 R_DIAG(KMAX)=R_DIAG(J)
                 WORK_A(KMAX)=WORK_A(J)
                 K=I_PERM(J)
                 I_PERM(J)=I_PERM(KMAX)
                 I_PERM(KMAX)=K
C
             END IF
C
         END IF
C
C        Compute the Householder transformation to reduce the
C        J-th column of AMATRX to a multiple of the J-th unit 
C                                                      vector
C
         AJNORM=EUNORM(NDFUNC,LDFUNC-J+1,AMATRX(J,J))
C
         IF (AJNORM.NE.R_ZERO) THEN
C
             IF (AMATRX(J,J).LT.R_ZERO) AJNORM=-AJNORM
C
             DO I=J,LDFUNC
                AMATRX(I,J)=AMATRX(I,J)/AJNORM
             END DO
C
             AMATRX(J,J)=AMATRX(J,J)+R_UNIT
C
C            Apply the transformation to the remaining columns
C                                         and update the norms
             JP1=J+1
C
             IF (LDPARS.GE.JP1) THEN
C
                 DO K=JP1,LDPARS
C
                    SUMAUX=R_ZERO
C
                    DO I=J,LDFUNC
                       SUMAUX=SUMAUX+AMATRX(I,J)*AMATRX(I,K)
                    END DO
C
                    TEMPOR=SUMAUX/AMATRX(J,J)
C
                    DO I=J,LDFUNC
                       AMATRX(I,K)=AMATRX(I,K)-TEMPOR*AMATRX(I,J)
                    END DO
C
                    IF (.NOT.LPIVOT.OR.R_DIAG(K).EQ.R_ZERO) GO TO 80
C
                    TEMPOR=AMATRX(J,K)/R_DIAG(K)
                    R_DIAG(K)
     *             =
     *              R_DIAG(K)*SQRT(MAX(R_ZERO,R_UNIT-TEMPOR**2))
C
                    IF (P05*(R_DIAG(K)/WORK_A(K))**2.GT.EPSMCH) GO TO 80
C
                    R_DIAG(K)=EUNORM(NDFUNC,LDFUNC-J,AMATRX(JP1,K))
                    WORK_A(K)=R_DIAG(K)
C
   80               CONTINUE
C
                 END DO
C
             END IF
C
         END IF
C
         R_DIAG(J)=-AJNORM
C
      END DO
C
C=======================================================================
C
      CALL CPUTIM('QRFACT',0)
      
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C  
      SUBROUTINE QRSOLV(NDFUNC,LDFUNC,NDPARS,LDPARS,RUPTRI,I_PERM,
     *                         DIAGSC,QTRANB,XARGUM,S_DIAG,WAUXIL)
C
      DIMENSION 
     *          DIAGSC(1:NDPARS),QTRANB(1:NDPARS),
     *          XARGUM(1:NDPARS),S_DIAG(1:NDPARS),
     *                           WAUXIL(1:NDPARS)
      DIMENSION 
     *          RUPTRI(1:NDFUNC,1:NDPARS)
      DIMENSION 
     *          I_PERM(1:NDPARS)
C
      DATA 
     *          CONST5,CONS25,R_ZERO 
     *        / 5.0e-1,2.5e-1,0.0000/
C
C=======================================================================
C
C     Given an LDFUNC by LDPARS matrix, say A, an LDPARS by LDPARS 
C     diagonal matrix D,  and an (m=LDFUNC)-vector B;  the problem 
C     is to determine an XARGUM which solves the system
C
C                      A*XARGUM=B,   D*XARGUM=0,
C
C     in the least squares sense.
C
C     This subroutine completes the solution of the problem, if it 
C     is provided with the necessary information from the QR facto-
C     rization, with column pivoting, of A, that is, if
C
C                          A*P = Q*RUPTRI, 
C
C     where P  is a permutation matrix,  Q  has orthogonal columns, 
C     and RUPTRI  is an upper-triangular  matrix  with all diagonal
C     elements of nonincreasing magnitude,  then QRSOLV expects the 
C     full upper triangle of RUPTRI, the permutation matrix P, and 
C     the first LDPARS components of (Q Transpose)*B. The system
C
C                      A*XARGUM = B, D*XARGUM = 0, 
C
C     is then equivalent to
C
C                               t       t
C                 RUPTRI * Z = Q *B ,  P * D * P * Z = 0 ,
C
C     where XARGUM = P*Z.  If this system does  not have full rank,
C     then a least squares solution  is obtained.  On output QRSOLV
C     also provides an upper triangular matrix S such that
C
C                          t   t               t
C                         P *(A *A + D*D)*P = S *S .
C 
C     S is computed within QRSOLV (and may be of separate interest)
C
C     The subroutine statement is
C
C     SUBROUTINE QRSOLV(NDFUNC,LDFUNC,NDPARS,LDPARS,RUPTRI,I_PERM,
C                              DIAGSC,QTRANB,XARGUM,S_DIAG,WAUXIL)
C
C     where
C
C     LDPARS - a positive, integer input variable  set to the order 
C                                                         of RUPTRI
C
C     RUPTRI - an LDPARS by LDPARS array.  On input, the full upper
C              triangle must contain the full upper triangle of the 
C              matrix RUPTRI.  On output the full upper triangle is 
C              unaltered and the strict lower triangle contains the 
C              strict upper triangle transposed of the upper trian-
C              gular matrix S.
C
C     NDFUNC - defines the number of functions not less than NDPARS;
C              at the same time, it specifies the leading dimension 
C              of the array RUPTRI
C
C     I_PERM - an integer input array of length LDPARS;  it defines 
C              the permutation matrix P such that 
C
C                               A*P = Q*RUPTRI
C
C              Column  J of P  is column I_PERM(j)  of the identity 
C                                                            matrix
C
C     DIAGSC - an input array of length LDPARS,  which must contain 
C              the diagonal elements of the matrix D
C
C     QTRANB - an input array of length LDPARS,  which must contain 
C              the first LDPARS elements of vector (Q Transpose)*B.
C
C     XARGUM - an output array of length LDPARS, which contains the 
C              least squares solution of the system 
C
C                          A*XARGUM = B, D*XARGUM = 0
C
C     S_DIAG - an output array of length LDPARS, which contains the
C              diagonal elements of the upper triangular matrix S
C
C     WAUXIL - a work array of length NDPARS.
C
C     SUBPROGRAMS CALLED
C
C                 FORTRAN-SUPPLIED ... ABS,SQRT
C
C=======================================================================
C
C     Argonne National Laboratory. MINPACK PROJECT, March 1980
C     Burton S. Garbow, Kenneth E. Hillstrom and Jorge J. More
C
C=======================================================================
C
C     Copy RUPTRI and (Q Transpose)*B to preserve input and initialize 
C     S. In particular, save the diagonal elements of RUPTRI in XARGUM
C
      DO J=1,LDPARS
         DO I=J,LDPARS
            RUPTRI(I,J)=RUPTRI(J,I)
         END DO
         XARGUM(J)=RUPTRI(J,J)
         WAUXIL(J)=QTRANB(J)
      END DO
C
C     Eliminate the diagonal matrix d using a givens rotation.
C
      DO J=1,LDPARS
C
C        Prepare the row of D to be eliminated, locating the
C        diagonal element using P from the QR factorization.
C
         L=I_PERM(J)
C
         IF (DIAGSC(L).EQ.R_ZERO) GO TO 90
C
         DO K=J,LDPARS
            S_DIAG(K)=R_ZERO
         END DO
C
         S_DIAG(J)=DIAGSC(L)
C
C        The transformations  to eliminate  the row  of D
C        modify only a single element of  (Q Transpose)*B
C        beyond the first LDPARS, which is initially zero.
C
         QTBPJ=R_ZERO
C
         DO K=J,LDPARS
C
C           Determine a Givens rotation which eliminates the
C           appropriate element in the current row of D
C
            IF (S_DIAG(K).NE.R_ZERO) THEN
C
                IF (ABS(RUPTRI(K,K)).LT.ABS(S_DIAG(K))) THEN
                    COTAN=RUPTRI(K,K)/S_DIAG(K)
                    SIN=CONST5/SQRT(CONS25+CONS25*COTAN**2)
                    COS=SIN*COTAN
                    GO TO 50
                END IF
C
                TAN=S_DIAG(K)/RUPTRI(K,K)
                COS=CONST5/SQRT(CONS25+CONS25*TAN**2)
                SIN=COS*TAN
C
   50           CONTINUE
C
C               Compute the modified diagonal element of RUPTRI 
C               and the modified element of ((Q Transpose) * B)
C
                RUPTRI(K,K)=COS*RUPTRI(K,K)+SIN*S_DIAG(K)
C
                TEMPOR=COS*WAUXIL(K)+SIN*QTBPJ
                QTBPJ=-SIN*WAUXIL(K)+COS*QTBPJ
                WAUXIL(K)=TEMPOR
C
C               Accumulate the tranformation in the row of s
C
                KP1=K+1
C
                IF (LDPARS.GE.KP1) THEN
                    DO I=KP1,LDPARS
                       TEMPOR=COS*RUPTRI(I,K)+SIN*S_DIAG(I)
                       S_DIAG(I)=-SIN*RUPTRI(I,K)+COS*S_DIAG(I)
                       RUPTRI(I,K)=TEMPOR
                    END DO
                END IF
            END IF
C
         END DO
   90    CONTINUE
C
C        Store the diagonal element of s and restore
C        the corresponding diagonal element of RUPTRI.
C
         S_DIAG(j)=RUPTRI(j,j)
         RUPTRI(j,j)=XARGUM(j)
C
      END DO
C
C     Solve the triangular system for Z. If the system issingular, 
C     then obtain a least squares solution.
C
      N_SING=LDPARS
C
      DO J=1,LDPARS
         IF (S_DIAG(J).EQ.R_ZERO.AND.N_SING.EQ.LDPARS) N_SING=J-1
         IF (N_SING.LT.LDPARS) WAUXIL(J)=R_ZERO
      END DO
C
      IF (N_SING.GE.1) THEN
C
          DO K=1,N_SING
C
             J=N_SING-K+1
             SUMAUX=R_ZERO
             JP1=J+1
C
             IF (N_SING.GE.JP1) THEN
                 DO I=JP1,N_SING
                    SUMAUX=SUMAUX+RUPTRI(I,J)*WAUXIL(I)
                 END DO
             END IF
C
             WAUXIL(J)=(WAUXIL(J)-SUMAUX)/S_DIAG(J)
C
          END DO
C
      END IF
C
C     Permute the components of z back to components of XARGUM
C
      DO J=1,LDPARS
         L=I_PERM(J)
         XARGUM(L)=WAUXIL(J)
      END DO
C
C=======================================================================                              
C
      RETURN
      END 
C
C=======================================================================                              
C=======================================================================                              
C
      SUBROUTINE CHKDER(NDFUNC,LDFUNC,NDPARS,LDPARS,XARGUM,FARGUM,
     *                         FJACOB,XNEIGH,F_VECP,IFMODE,ERRGRA)
C
      DIMENSION XARGUM(1:NDPARS),FARGUM(1:NDFUNC),
     *          XNEIGH(1:NDPARS),F_VECP(1:NDFUNC),
     *                           ERRGRA(1:NDFUNC)
      DIMENSION 
     *          FJACOB(1:NDFUNC,1:NDPARS)
C
      DATA 
     *      FACTOR,R_UNIT,R_ZERO 
     *     /1.00e2,1.0000,0.0000/
C
C=======================================================================
C
C     This subroutine checks whether the gradients of LDFUNC nonlinear 
C     functions in LDPARS variables, evaluated at a point XARGUM,  are
C     consistent  with the functions  themselves.  The user  must call 
C     CHKDER twice, First with IFMODE = 1 and then with IFMODE = 2.
C
C     IFMODE = 1; On input XARGUM must contain the point of evaluation;
C                 on output, XNEIGH is set to a neighbouring point.
C
C     IFMODE = 2. on input, FARGUM  must contain the functions and the
C                 rows of FJACOB must contain the gradients of the res-
C                 pective functions, each evaluated at XARGUM;  F_VECP
C                 must contain the functions evaluated at XNEIGH. Next,
C                 on output,  ERRGRA contains measures  of correctness 
C                 of the respective gradients.
C
C     The subroutine does not perform reliably  if the cancellation or
C     rounding errors cause a severe loss of significance  in terms of
C     evaluation  of functionS.  Therefore,  none of the components of 
C     XARGUM  should be unusually small  (in particular, zero)  or any
C     other value which may cause loss of significance.
C
C     The subroutine statement is
C
C     SUBROUTINE CHKDER(NDFUNC,LDFUNC,NDPARS,LDPARS,XARGUM,FARGUM,
C                              FJACOB,XNEIGH,F_VECP,IFMODE,ERRGRA)
C
C     where
C
C     LDFUNC - a positive integer input variable, set to the number of 
C                                                            functions
C
C     LDPARS - a positive integer input variable, set to the number of
C                                                            variables
C
C     XARGUM - an input array of maximum length NDPARS
C
C     FARGUM - a vector  of length LDFUNC.  On input, when  IFMODE = 2,
C              FARGUM must contain the functions evaluated at XARGUM
C
C     FJACOB - an LDFUNC by LDPARS array.  On input when IFMODE=2, the
C              the rows of  FJACOB  must contain the gradients  of the 
C              respective functions evaluated at XARGUM.
C
C     NDFUNC - a positive integer input parameter not less than LDFUNC
C              which specifies the maximum  dimension of  array FJACOB
C
C     XNEIGH - a vector of length LDPARS.  On output, when IFMODE = 1,
C              XNEIGH is set to a neighboring point of XARGUM.
C
C     F_VECP - an array of length LDFUNC.  On input, when  IFMODE = 2,
C              F_VECP must contain the functions evaluated at XNEIGH.
C
C     IFMODE - an integer input variable,  set to 1  on the first call
C              and 2 on the second.  Other values of IFMODE  are equi-
C              valent to IFMODE = 1.
C
C     ERRGRA - a vector of length LDFUNC.  On output, when IFMODE = 2,
C              ERRGRA  contains measures of correctness of the respec-
C              tive gradients.  If there is  no severe  loss of signi-
C              ficance,  then if ERRGRA(i) is 1.0 the i-th gradient is 
C              correct, while if ERRGRA(i) is 0.0 the i-th gradient is 
C              incorrect. For values of ERRGRA between 0.0 and 1.0 the 
C              categorization is less certain.  In general, a value of 
C              ERRGRA(i)  greater  than 0.5  indicates  that  the i-th 
C              gradient is probably correct while a value of ERRGRA(i) 
C              less than 0.5 indicates that the i-th gradient is proba-
C              bly incorrect.
C
C     SUBPROGRAMS CALLED
C
C                 MINPACK SUPPLIED ... DPMPAR
C
C                 FORTRAN SUPPLIED ... ABS, LOG10, SQRT
C
C=======================================================================
C
C     Argonne National Laboratory. MINPACK PROJECT, March 1980
C     Burton S. Garbow, Kenneth E. Hillstrom and Jorge J. More
C
C=======================================================================
C
C     epsmch is the machine precision.
C
      EPSMCH=DPMPAR(1) !  EPSMCH is the machine precision
C
      SQREPS=SQRT(EPSMCH)
C
      IF (IFMODE.NE.2) THEN
C
C         IFMODE=1:
C
         DO J=1,LDPARS
            TEMPOR=SQREPS*ABS(XARGUM(J))
            IF (TEMPOR.EQ.R_ZERO) TEMPOR=SQREPS
            XNEIGH(J)=XARGUM(J)+TEMPOR
         END DO
C
         RETURN
C
      END IF
C
C     IFMODE=2:
C
      EPSF=FACTOR*EPSMCH
      EPSLOG=LOG10(EPS)
C
      DO I=1,LDFUNC
         ERRGRA(I)=R_ZERO
      END DO
C
      DO J=1,LDPARS
C
         TEMPOR=ABS(XARGUM(J))
C
         IF (TEMPOR.EQ.R_ZERO) TEMPOR=R_UNIT
C
         DO I=1,LDFUNC
            ERRGRA(I)=ERRGRA(I)+TEMPOR*FJACOB(I,J)
         END DO
C
      END DO
C
      DO I=1,LDFUNC
C
         TEMPOR=R_UNIT
C
         IF (FARGUM(I).NE.R_ZERO.AND.F_VECP(I).NE.R_ZERO.AND.
     *       ABS(F_VECP(I)-FARGUM(I)).GE.EPSF*ABS(FARGUM(I))) THEN
C
             TEMPOR=SQREPS*ABS((F_VECP(I)-FARGUM(I))
     *             /SQREPS-ERRGRA(I))
     *             /(ABS(FARGUM(I))+ABS(F_VECP(I)))
C
         END IF
C
         ERRGRA(I)=R_UNIT
C
         IF (TEMPOR.GT.EPSMCH.AND.TEMPOR.LT.SQREPS) THEN
             ERRGRA(I)=(LOG10(TEMPOR)-EPSLOG)/EPSLOG
         END IF
     
         IF (TEMPOR.GE.SQREPS) ERRGRA(I)=R_ZERO
C
      END DO
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      FUNCTION DPMPAR(I)
C
C     This function provides double precision machine parameters when 
C     the appropriate set of data statements is activated by removing 
C     the c from column 1, and all other data statements are rendered 
C     inactive.  Most of the parameter values  were obtained from the 
C     corresponding Bell Laboratories Port Library function.
C
C     The function statement is
C
C                            FUNCTION DPMPAR(I)
C
C     where
C
C     I - an integer input variable set to 1, 2, or 3,  which selects 
C         the desired machine parameter.  If the machine has t base b 
C         digits, and its smallest and largest exponents are EMIN and 
C         EMAX, respectively, then these parameters are
C
C         DPMPAR(1) = b**(1 - t), the machine precision,
C
C         DPMPAR(2) = b**(emin - 1), the smallest magnitude, and:
C
C         DPMPAR(3) = b**emax*(1 - b**(-t)), the largest magnitude.
C
C     Argonne National Laboratory. MINPACK Project. November 1996.
C     Burton S. Garbow, Kenneth E. Hillstrom and Jorge J. More'
C

      DIMENSION 
     *            MCHEPS(4),MINMAG(4),MAXMAG(4),DMACH(3)
C                 In fact:     double precision DMACH(3)
      EQUIVALENCE 
     *            (DMACH(1),MCHEPS(1))
      EQUIVALENCE 
     *            (DMACH(2),MINMAG(1))
      EQUIVALENCE 
     *            (DMACH(3),MAXMAG(1))
C
C     Machine constants for the IBM 360/370 series,
C     the Amdahl 470/V6, the ICL 2900, the Itel AS/6,
C     the Xerox Sigma 5/7/9 and the Sel systems 85/86.
C
C     data mcheps(1),mcheps(2) / z34100000, z00000000 /
C     data minmag(1),minmag(2) / z00100000, z00000000 /
C     data maxmag(1),maxmag(2) / z7fffffff, zffffffff /
C
C     Machine constants for the Honeywell 600/6000 series.
C
C     data mcheps(1),mcheps(2) / o606400000000, o000000000000 /
C     data minmag(1),minmag(2) / o402400000000, o000000000000 /
C     data maxmag(1),maxmag(2) / o376777777777, o777777777777 /
C
C     Machine constants for the CDC 6000/7000 series.
C
C     data mcheps(1) / 15614000000000000000b /
C     data mcheps(2) / 15010000000000000000b /
C
C     data minmag(1) / 00604000000000000000b /
C     data minmag(2) / 00000000000000000000b /
C
C     data maxmag(1) / 37767777777777777777b /
C     data maxmag(2) / 37167777777777777777b /
C
C     Machine constants for the PDP-10 (KA processor).
C
C     data mcheps(1),mcheps(2) / "114400000000, "000000000000 /
C     data minmag(1),minmag(2) / "033400000000, "000000000000 /
C     data maxmag(1),maxmag(2) / "377777777777, "344777777777 /
C
C     Machine constants for the PDP-10 (KI processor).
C
C     data mcheps(1),mcheps(2) / "104400000000, "000000000000 /
C     data minmag(1),minmag(2) / "000400000000, "000000000000 /
C     data maxmag(1),maxmag(2) / "377777777777, "377777777777 /
C
C     Machine constants for the PDP-11. 
C
C     data mcheps(1),mcheps(2) /   9472,      0 /
C     data mcheps(3),mcheps(4) /      0,      0 /
C
C     data minmag(1),minmag(2) /    128,      0 /
C     data minmag(3),minmag(4) /      0,      0 /
C
C     data maxmag(1),maxmag(2) /  32767,     -1 /
C     data maxmag(3),maxmag(4) /     -1,     -1 /
C
C     Machine constants for the Burroughs 6700/7700 systems.
C
C     data mcheps(1) / o1451000000000000 /
C     data mcheps(2) / o0000000000000000 /
C
C     data minmag(1) / o1771000000000000 /
C     data minmag(2) / o7770000000000000 /
C
C     data maxmag(1) / o0777777777777777 /
C     data maxmag(2) / o7777777777777777 /
C
C     Machine constants for the Burroughs 5700 system.
C
C     data mcheps(1) / o1451000000000000 /
C     data mcheps(2) / o0000000000000000 /
C
C     data minmag(1) / o1771000000000000 /
C     data minmag(2) / o0000000000000000 /
C
C     data maxmag(1) / o0777777777777777 /
C     data maxmag(2) / o0007777777777777 /
C
C     Machine constants for the Burroughs 1700 system.
C
C     data mcheps(1) / zcc6800000 /
C     data mcheps(2) / z000000000 /
C
C     data minmag(1) / zc00800000 /
C     data minmag(2) / z000000000 /
C
C     data maxmag(1) / zdffffffff /
C     data maxmag(2) / zfffffffff /
C
C     Machine constants for the Univac 1100 series.
C
C     data mcheps(1),mcheps(2) / o170640000000, o000000000000 /
C     data minmag(1),minmag(2) / o000040000000, o000000000000 /
C     data maxmag(1),maxmag(2) / o377777777777, o777777777777 /
C
C     Machine constants for the Data General Eclipse S/200.
C
C     Note - it may be appropriate to include the following card -
C     static dmach(3)
C
C     data minmag/20k,3*0/,maxmag/77777k,3*177777k/
C     data mcheps/32020k,3*0/
C
C     Machine constants for the Harris 220.
C
C     data mcheps(1),mcheps(2) / '20000000, '00000334 /
C     data minmag(1),minmag(2) / '20000000, '00000201 /
C     data maxmag(1),maxmag(2) / '37777777, '37777577 /
C
C     Machine constants for the Cray-1.
C
C     data mcheps(1) / 0376424000000000000000b /
C     data mcheps(2) / 0000000000000000000000b /
C
C     data minmag(1) / 0200034000000000000000b /
C     data minmag(2) / 0000000000000000000000b /
C
C     data maxmag(1) / 0577777777777777777777b /
C     data maxmag(2) / 0000007777777777777776b /
C
C     Machine constants for the Prime 400.
C
C     data mcheps(1),mcheps(2) / :10000000000, :00000000123 /
C     data minmag(1),minmag(2) / :10000000000, :00000100000 /
C     data maxmag(1),maxmag(2) / :17777777777, :37777677776 /
C
C     Machine constants for the VAX-11.
C
C     data mcheps(1),mcheps(2) /   9472,  0 /
C     data minmag(1),minmag(2) /    128,  0 /
C     data maxmag(1),maxmag(2) / -32769, -1 /
C
C     Machine constants for IEEE machines.
C
      DATA DMACH(1) /2.22044604926D-016/
      DATA DMACH(2) /2.22507385852D-308/
      DATA DMACH(3) /1.79769313485D+308/
C
C=======================================================================      
C
      DPMPAR=DMACH(I)
C
C=======================================================================      
C
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C
C           WRITINGS FOR GOOD-LOOKING OUTPUTS AND XFIG PLOTTING
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE PRINTI(IDEFCN)
      
      INCLUDE  'MATDIM/NDPARS.f'

      CHARACTER
     *          NUCLEO*8
      DIMENSION
     *          NUCLEO(0:1)
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS                                                  
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI
C
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
C
      DATA      
     *       NUCLEO(0) / 'Neutrons' /         
      DATA
     *       NUCLEO(1) / ' Protons' /         
C
C=======================================================================
C
      V0CENT_PROTON=PARPOT( 1)
      R0CENT_PROTON=PARPOT( 2)
      A0CENT_PROTON=PARPOT( 3)
      V0SORB_PROTON=PARPOT( 4)
      R0SORB_PROTON=PARPOT( 5)
      A0SORB_PROTON=PARPOT( 6)
      V0EFFM_PROTON=PARPOT( 7)
      R0EFFM_PROTON=PARPOT( 8)
      A0EFFM_PROTON=PARPOT( 9)
      R0COUL       =PARPOT(10)
C     
      XK_V0C_PROTON=PARPOT(11)
      XK_R0C_PROTON=PARPOT(12)
      XK_A0C_PROTON=PARPOT(13)
      XK_LAM_PROTON=PARPOT(14)
      XK_RSO_PROTON=PARPOT(15)
      XK_ASO_PROTON=PARPOT(16)
      XK_LEF_PROTON=PARPOT(17)
      XK_REF_PROTON=PARPOT(18)
      XK_AEF_PROTON=PARPOT(19)
      XK_COU	   =PARPOT(20)
C     
      V0CENT_NEUTRS=PARPOT(21)
      R0CENT_NEUTRS=PARPOT(22)
      A0CENT_NEUTRS=PARPOT(23)
      V0SORB_NEUTRS=PARPOT(24)
      R0SORB_NEUTRS=PARPOT(25)
      A0SORB_NEUTRS=PARPOT(26)
      V0EFFM_NEUTRS=PARPOT(27)
      R0EFFM_NEUTRS=PARPOT(28)
      A0EFFM_NEUTRS=PARPOT(29)
C     
      XK_V0C_NEUTRS=PARPOT(30)
      XK_R0C_NEUTRS=PARPOT(31)
      XK_A0C_NEUTRS=PARPOT(32)
      XK_LAM_NEUTRS=PARPOT(33)
      XK_RSO_NEUTRS=PARPOT(34)
      XK_ASO_NEUTRS=PARPOT(35)
      XK_LEF_NEUTRS=PARPOT(36)
      XK_REF_NEUTRS=PARPOT(37)
      XK_AEF_NEUTRS=PARPOT(38)
C     
      ALAMPP       =PARPOT(39)
      ALAMPN       =PARPOT(40)
      ALAMNP       =PARPOT(41)
      ALAMNN       =PARPOT(42)
C
      TLAMPP       =PARPOT(43)
      TLAMPN       =PARPOT(44)
      TLAMNP       =PARPOT(45)
      TLAMNN       =PARPOT(46)
C      
      CLAMPP       =PARPOT(47)
      CLAMPN       =PARPOT(48)
      CLAMNP       =PARPOT(49)
      CLAMNN       =PARPOT(50)
C
      IF (ISOSPI.EQ.1 .AND. LOGWRI.EQ.2) THEN
C      
         WRITE(IRESUL,'(/,80(''#''),//,80(''#''),/,''#'',t80,''#'',/,
     *             ''#   It'',i4,t69,a8,t80,''#'',/,
     *             ''#   V0CENT R0CENT A0CENT'',
     *             ''  V0SORB R0SORB A0SORB'',
     *             ''  V0EFFM R0EFFM A0EFFM  R0COUL   #'')') IDEFCN,
     *                                                NUCLEO(ISOSPI)
C
         WRITE(IRESUL,'(''#'',F9.3,2F7.4,2(F8.3,2F7.4),1x,f7.4,t80,
     *                  ''#'')')
     *               V0CENT_PROTON,R0CENT_PROTON,A0CENT_PROTON,
     *               V0SORB_PROTON,R0SORB_PROTON,A0SORB_PROTON,
     *               V0EFFM_PROTON,R0EFFM_PROTON,A0EFFM_PROTON,R0COUL
C
         WRITE(IRESUL,'(''#   XK_V0C XK_R0C XK_A0C'',
     *                  ''  XK_LAM XK_RSO XK_ASO'',
     *                  ''  XK_LEF XK_REF XK_AEF  XK_COU   #'')')
C
         WRITE(IRESUL,'(''#'',F9.3,2F7.4,2(F8.3,2F7.3),1x,f7.3,t80,
     *                  ''#'')')          
     *               XK_V0C_PROTON,XK_R0C_PROTON,XK_A0C_PROTON,
     *               XK_LAM_PROTON,XK_RSO_PROTON,XK_ASO_PROTON,
     *               XK_LEF_PROTON,XK_REF_PROTON,XK_AEF_PROTON,XK_COU
C
         WRITE(IRESUL,'(''#'',T80,''#'')')     
C
      END IF
      
      IF (ISOSPI.EQ.0 .AND. LOGWRI.EQ.2) THEN
C      
         WRITE(IRESUL,'(/,80(''#''),//,80(''#''),/,''#'',t80,''#'',/,
     *             ''#   It'',i4,t69,a8,t80,''#'',/,
     *             ''#   V0CENT R0CENT A0CENT'',
     *             ''  V0SORB R0SORB A0SORB'',
     *             ''  V0EFFM R0EFFM A0EFFM  R0COUL   #'')') IDEFCN,
     *                                                NUCLEO(ISOSPI)
C
         WRITE(IRESUL,'(''#'',F9.3,2F7.4,2(F8.3,2F7.4),1x,f7.4,t80,
     *                  ''#'')')
     *               V0CENT_NEUTRS,R0CENT_NEUTRS,A0CENT_NEUTRS,
     *               V0SORB_NEUTRS,R0SORB_NEUTRS,A0SORB_NEUTRS,
     *               V0EFFM_NEUTRS,R0EFFM_NEUTRS,A0EFFM_NEUTRS,R0COUL
C
         WRITE(IRESUL,'(''#   XK_V0C XK_R0C XK_A0C'',
     *             ''  XK_LAM XK_RSO XK_ASO'',
     *             ''  XK_LEF XK_REF XK_AEF  XK_COU   #'')')
C
         WRITE(IRESUL,'(''#'',F9.3,2F7.4,2(F8.3,2F7.3),1x,f7.3,t80,
     *                  ''#'')')          
     *               XK_V0C_NEUTRS,XK_R0C_NEUTRS,XK_A0C_NEUTRS,
     *               XK_LAM_NEUTRS,XK_RSO_NEUTRS,XK_ASO_NEUTRS,
     *               XK_LEF_NEUTRS,XK_REF_NEUTRS,XK_AEF_NEUTRS,XK_COU
C
         WRITE(IRESUL,'(''#'',T80,''#'')')
C
      END IF     
C
C=======================================================================
C
      RETURN
      END     
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE INPRIN(IDEFCN,IACTIV,I_MODE,
     *                         CHISQU_PROTON,CHISQU_NEUTRS,
     *                         CHIENE_WEIPRO,CHIENE_WEINEU,
     *                         CHIRAD_WEIPRO,CHIRAD_WEINEU,
     *                                       CHIRHO_WEIPRO)
      
      INCLUDE  'MATDIM/NDPARS.f'
      INCLUDE  'MATDIM/NDTITL.f'
      INCLUDE  'MATDIM/NDNUCL.f'
      
      CHARACTER
     *          FROMXX*1,ACTION*1,TITLES*12,STRING_PROTON*8,
     *                                      STRING_NEUTRS*8
      CHARACTER
     *          TITLES_LATEXS*100,NUCNAM_LATEXS*010
      DIMENSION
     *          FROMXX(0:2)
      DIMENSION
     *          IAUXIL(1:NDPARS)
C
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS                                                  
      COMMON
     *       /OCCREC/ N_ACTU_PROTON,N_CORR_PROTON,
     *                N_ACTU_NEUTRS,N_CORR_NEUTRS
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /ACTACT/ ACTION(1:NDPARS)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
CID      COMMON
CID     *       /GSTORE/ DERPRI(1:NDPARS) 
      COMMON
     *       /CALFRO/ I_FROM
      COMMON
     *       /CHICHO/ VALCHI
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
C
      DATA
     *       FROMXX(00) / ':' /         
      DATA
     *       FROMXX(01) / 'f' /         
      DATA
     *       FROMXX(02) / 'g' / 
C
C=======================================================================
C     This subroutine makes a dynamical construction of the output
C     line on the user screen showing the advancement of the mini-
C     misation in function of the processing iterations 
C=======================================================================
C
      LOGWRI_AUXILI=1
      IF (LOGWRI.EQ.0) THEN
          LOGWRI_AUXILI=LOGWRI
          LOGWRI=1 !Irene says: I want this kind of files always...
      END IF
C
C=======================================================================
C
      IFPROT=0
      IFNEUT=0
      IFBOTH=0
C      
      DO IPARAM=1,NDPARS
         IF (IFTAKE(IPARAM).EQ.1) THEN
             IF (IPARAM.LE.20.AND.IFDENS.EQ.0) THEN
                 IFPROT=1
             END IF
             IF (IPARAM.GT.20.AND.IFDENS.EQ.0) THEN
                 IFNEUT=1
             END IF
             IF (IPARAM.GE.51) THEN
                 IFPROT=0
                 IFNEUT=0
                 IFBOTH=1
             END IF
         END IF
      END DO   
C
      IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1).AND.(IFPROT.EQ.1)) THEN
C  
           IFPROT=0
           IFNEUT=0
           IFBOTH=1
C
      END IF   
C
C=======================================================================
C
      INDEXP=0
C      
      IF (IFDENS.EQ.0.AND.IFPROT.EQ.1) THEN
          DO IPARAM=1,6
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C      
      IF (IFDENS.EQ.0.AND.IFNEUT.EQ.1) THEN
          DO IPARAM=21,26
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C
      IF (IFDENS.EQ.0.AND.IFBOTH.EQ.1) THEN
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          IF (IFK_VS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=57   ! V_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=58   ! kappa V_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=4    ! V_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=24   ! V_o pure WS-SO neutrons
          END IF
C
          IF (IFK_RS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=59   ! r_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=60   ! kappa r_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=5    ! r_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=25   ! r_o pure WS-SO neutrons
          END IF
C
          IF (IFK_AS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=61   ! a_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=62   ! kappa a_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=6    ! a_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=26   ! a_o pure WS-SO neutrons
          END IF
C
      END IF
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.1) THEN
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          DO IPARAM=39,42         !lambdas Density-SO
             INDEXP=INDEXP+1
             IAUXIL(INDEXP)=IPARAM
          END DO
C
          IF (IFTENS.EQ.1.AND.ISORBT.EQ.1) THEN
              DO IPARAM=43,46     !lambdas Tensor-SO
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
          IF (IFTENS.EQ.1.AND.ICENTT.EQ.1) THEN
              DO IPARAM=47,50     !lambdas Tensor-central
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
      END IF
C
C=======================================================================
C
C     Titles of columns are printed every  20  active output lines
C
      IF ((MOD(IDEFCN,20).EQ.1.AND.I_MODE.EQ.0).OR.I_MODE.EQ.2) THEN
C
CID          WRITE(ICONVE,'(/,'' Iter '',$)')
C
CID          DO I=1,NDPARS
C             IF (IFTAKE(I).EQ.1) THEN
C                 WRITE(ICONVE,'(A10,$)') TITLES(I)
C             END IF
C          END DO
C
C          WRITE(ICONVE,'(''   ChiSquar'')')

C_______________________________________________________________________
C
          IF (LOGWRI.GT.0) THEN
              
              WRITE(LOGAUX,'(/,'' Iter   '',$)')
C
              IF (I_MODE.EQ.2) THEN
C
                  IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.0) THEN
                      WRITE(LOGAUX,'(1X,''r.m.s.-final'',6x,
     *                                  ''ChiSquar-final'',6X,
     *                                  ''Chi2-EnerFinal'',6X,
     *                                  ''Chi2-RadiFinal'',6X,
     *                                  '' Chi2-RhoFinal'',''    '',$)')
                  END IF
                  IF (IFDENS.EQ.1 .OR. 
     *               (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN 
                      WRITE(LOGAUX,'(5X,''r.m.s.--{P,N}-final'',9x,
     *                                  ''ChiSquar{P,N}-final'',9X,
     *                                  ''ChiSqrtE{P,N}-final'',9X,
     *                                  ''ChiSqrtR{P,N}-final'',5x,
     *                                                   '' '',$)')
                  END IF
C
              ELSE
C
                  IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
                      WRITE(LOGAUX,'(1X,''r.m.s.-value'',2x,
     *                                  ''ChiSquar'',6X,
     *                                  ''ChiSqrt-Ener'',2X,
     *                                  ''ChiSqrt-Radi'',2X,
     *                                  ''ChiSqrt-Rho'',2X,''   '',$)')
                  END IF
C
                  IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
                      WRITE(LOGAUX,'(1X,''r.m.s.-value'',2x,
     *                              ''ChiSquar'',6X,
     *                              ''ChiSqrt-Ener'',2X,
     *                              ''ChiSqrt-Radi'',2X,''   '',$)')
                  END IF
C
                  IF (IFDENS.EQ.1 .OR. 
     *               (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN 
                      WRITE(LOGAUX,'(7X,''r.m.s.-{P,N}'',2x,
     *                              ''ChiSquar{P,N}'',17X,
     *                              ''ChiSqrtE{P,N}'',17X,
     *                              ''ChiSqrtR{P,N}'',5X,''  '',$)')
                  END IF
C
              END IF
C
              DO I=1,INDEXP
                 IPARAM=IAUXIL(I)
                 WRITE(LOGAUX,'(A11,$)') TITLES(IPARAM)
              END DO
C
              IF (I_MODE.NE.2) THEN
              
                  IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.0) THEN
                      WRITE(LOGAUX,'(''        '',$)')
                  END IF
C
                  IF (IFDENS.EQ.1 .OR. 
     *               (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN  
                      WRITE(LOGAUX,'(18X,''    '',$)')
                  END IF
C
                  DO I=1,INDEXP
                     IPARAM=IAUXIL(I)
                     WRITE(LOGAUX,'(2X,''D'',A8,$)') 
     *                                            TITLES(IPARAM)(3:10)
                  END DO
C
                  WRITE(LOGAUX,'(''     Gradient_Norm'')')
C
              END IF
C
              IF (I_MODE.EQ.2) WRITE(LOGAUX,'()')
C
          END IF
C_______________________________________________________________________
C
          IF (ISCREN.NE.1) GO TO 1
C          
          WRITE(LSCREN,'(/,'' Iter   '',$)')
C
          DO I=1,NDPARS
             IF (IFTAKE(I).EQ.1) THEN
                 WRITE(LSCREN,'(A11,$)') TITLES(I)
             END IF
          END DO
C
          IF (I_MODE.EQ.2) THEN
              WRITE(LSCREN,'(''   ChiSquar{P,N}-final'')')
          ELSE
              WRITE(LSCREN,'(''      ChiSquar{P,N}'',/)')
          END IF
C
   1      CONTINUE          
C
      END IF
C
C=======================================================================
C
      IF (N_ACTU_PROTON.NE.N_CORR_PROTON) THEN
          WRITE(STRING_PROTON,'(I4,'':'',I3)') 
     *          N_ACTU_PROTON,N_CORR_PROTON
      ELSE
          WRITE(STRING_PROTON,'(''        '')') 
      END IF
C
      IF (N_ACTU_NEUTRS.NE.N_CORR_NEUTRS) THEN
          WRITE(STRING_NEUTRS,'(I4,'':'',I3)') 
     *          N_ACTU_NEUTRS,N_CORR_NEUTRS
      ELSE
          WRITE(STRING_NEUTRS,'(''        '')') 
      END IF
C
C=======================================================================
C
CID      WRITE(ICONVE,'(i4,A1,$)') IDEFCN,FROMXX(I_FROM)
C
C      DO I=1,NDPARS
C         IF (IFTAKE(I).EQ.1) THEN
C             WRITE(ICONVE,'(F9.4,A1,$)') PARPOT(I),ACTION(I)
C         END IF
C      END DO
C
C      WRITE(ICONVE,'(F16.4,A8,A8)') VALCHI,STRING_PROTON,STRING_NEUTRS 
C
C=======================================================================
C                            Constructing dynamically the output lines
      IF (LOGWRI.GT.0) THEN
          
        IF (I_MODE.EQ.0) THEN
            
          WRITE(LOGAUX,'(I4,A1,''  '',$)') IDEFCN,FROMXX(I_FROM)
            
          IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
            WRITE(LOGAUX,'(5E14.6,''    '',$)') SQRT(CHIWEI_PROTON),
     *                                          CHISQU_PROTON,
     *                                          CHIENE_WEIPRO,
     *                                          CHIRAD_WEIPRO,
     *                                          CHIRHO_WEIPRO
            GO TO 3
          END IF
C          
          IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
            WRITE(LOGAUX,'(4E14.6,''    '',$)')  SQRT(CHIWEI_NEUTRS),
     *                                           CHISQU_NEUTRS,
     *                                           CHIENE_WEINEU,
     *                                           CHIRAD_WEINEU
            GO TO 3
          END IF
C         
          WRITE(LOGAUX,'(8E14.6,''    '',$)') SQRT(CHIWEI_PROTON),
     *                                        SQRT(CHIWEI_NEUTRS),
     *                                        CHISQU_PROTON,
     *                                        CHISQU_NEUTRS,
     *                                        CHIENE_WEIPRO,
     *                                        CHIENE_WEINEU,
     *                                        CHIRAD_WEIPRO,
     *                                        CHIRAD_WEINEU
          
   3      CONTINUE     
        
        END IF
        
        IF (I_MODE.EQ.2) THEN
            
          WRITE(LOGAUX,'(I4,A1,''  '',$)') IDEFCN,FROMXX(I_FROM)
            
          IF (IFDENS.EQ.0.AND.IFPROT.EQ.1) THEN
              WRITE(LOGAUX,'(2E16.6,3E20.6,''    '',$)')
     *                                             SQRT(CHIWEI_PROTON),
     *                                                   CHISQU_PROTON,
     *                                                   CHIENE_WEIPRO,
     *                                                   CHIRAD_WEIPRO,
     *                                                   CHIRHO_WEIPRO
            GO TO 4
          END IF
C          
          IF (IFDENS.EQ.0.AND.IFNEUT.EQ.1) THEN
            WRITE(LOGAUX,'(2E16.6,2E20.6,''    '',$)')
     *                                           SQRT(CHIWEI_NEUTRS),
     *                                                 CHISQU_NEUTRS,
     *                                                 CHIENE_WEINEU,
     *                                                 CHIRAD_WEINEU
            GO TO 4
          END IF
C         
          WRITE(LOGAUX,'(8E14.6,''    '',$)') SQRT(CHIWEI_PROTON),
     *                                        SQRT(CHIWEI_NEUTRS),
     *                                             CHISQU_PROTON,
     *                                             CHISQU_NEUTRS,
     *                                             CHIENE_WEIPRO,
     *                                             CHIENE_WEINEU,
     *                                             CHIRAD_WEIPRO,
     *                                             CHIRAD_WEINEU
          
   4      CONTINUE     
        
        END IF
C_______________________________________________________________________  
C      
        IF (I_MODE.NE.1) THEN
C
            JSTORE=0
          
            WRITE(LOGAUX,'(7X,$)')
C
             DO I=1,INDEXP
                IPARAM=IAUXIL(I)
                WRITE(LOGAUX,'(F10.5,A1,$)') PARPOT(IPARAM),
     *                                       ACTION(IPARAM)
             END DO
C
        END IF
C_______________________________________________________________________  
C
        IF (I_MODE.NE.1) THEN
            
            IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
                WRITE(LOGAUX,'(A8,A8)') STRING_PROTON,STRING_NEUTRS
                GO TO 5                    
            END IF
C          
            IF (IFDENS.EQ.0.AND.IFNEUT.EQ.1) THEN
                WRITE(LOGAUX,'(A8,A8)') STRING_PROTON,STRING_NEUTRS
                GO TO 5
            END IF
C         
            WRITE(LOGAUX,'(A8,A8)') STRING_PROTON,STRING_NEUTRS
          
   5        CONTINUE     
        
        END IF
      
      END IF
C
C=======================================================================
C
      IF (ISCREN.NE.1) THEN
          GO TO 2
      END IF
C
C=======================================================================
C                            Constructing dynamically the output lines
      IF (I_MODE.NE.1) THEN
C
          WRITE(0,'(I4,A1,''  '',$)') IDEFCN,FROMXX(I_FROM)
C
          JSTORE=0
C
          DO I=1,NDPARS
             IF (IFTAKE(I).EQ.1) THEN
                 WRITE(0,'(F10.4,A1,$)') PARPOT(I),ACTION(I)
             END IF
          END DO
C
      END IF
C_______________________________________________________________________
C
C     IF (IACTIV.NE.0.AND.I_MODE.EQ.1.AND.I_FROM.EQ.2) THEN
C
C         WRITE(0,'(F16.4,F10.4,A8,A8)') 
C    *         VALCHI,DERPRI(IACTIV),STRING_PROTON,STRING_NEUTRS
c      ELSE
c          WRITE(0,'(F16.4,A8,A8)') VALCHI,STRING_PROTON,STRING_NEUTRS
C     END IF  
C
      IF (I_MODE.NE.1) THEN
C         WRITE(0,'(F10.4,A8,A8)') VALCHI,STRING_PROTON,STRING_NEUTRS
          WRITE(0,'(2F10.4,A8,A8)') CHISQU_PROTON,CHISQU_NEUTRS,
     *                              STRING_PROTON,STRING_NEUTRS
      END IF
C
   2  CONTINUE
C
C=======================================================================
C
      IF (LOGWRI_AUXILI.EQ.0) THEN
          LOGWRI=0
      END IF
C
C=======================================================================
C
      RETURN
      END     
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE INPRIN_GLOFIT(IDEFCN,IACTIV,I_MODE,CHIENE_PROTON,
     *                                CHIENE_NEUTRS,CHIRAD_PROTON,
     *                                              CHIRAD_NEUTRS)
C
      INCLUDE  'MATDIM/NDPARS.f'
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/NDTITL.f'
C
      CHARACTER
     *          FROMXX*1,ACTION*1,TITLES*12,STRING_PROTON*8,
     *                                      STRING_NEUTRS*8
      CHARACTER
     *          CHITIT*12,NUCSYM*6,INPSYM*6,RADTIT*12,
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010
C
      DIMENSION
     *          CHITIT(1:010),RADTIT(1:010)
      DIMENSION
     *          FROMXX(0:2)
      DIMENSION
     *          IAUXIL(1:NDPARS)
      DIMENSION
     *          CHIENE_PROTON(1:NDNUCL),
     *          CHIENE_NEUTRS(1:NDNUCL)
      DIMENSION
     *          CHIRAD_PROTON(1:NDNUCL),
     *          CHIRAD_NEUTRS(1:NDNUCL)
C
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /ACTACT/ ACTION(1:NDPARS)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /CALFRO/ I_FROM
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
C
      DATA
     *       FROMXX(00) / ':' /         
      DATA
     *       FROMXX(01) / 'f' /         
      DATA
     *       FROMXX(02) / 'g' / 
      DATA
     *       CHITIT(01) / '  RMSENE_Ox ' /,
     *       CHITIT(02) / '  RMSENE_Ca ' /,
     *       CHITIT(03) / '  RMSENE_Ca ' /,
     *       CHITIT(04) / '  RMSENE_Ni ' /,
     *       CHITIT(05) / '  RMSENE_Zr ' /,
     *       CHITIT(06) / '  RMSENE_Sn ' /,
     *       CHITIT(07) / '  RMSENE_Gd ' /,
     *       CHITIT(08) / '  RMSENE_Pb ' /
      DATA
     *       RADTIT(01) / '  DIFRAD_Ox ' /,
     *       RADTIT(02) / '  DIFRAD_Ca ' /,
     *       RADTIT(03) / '  DIFRAD_Ca ' /,
     *       RADTIT(04) / '  DIFRAD_Ni ' /,
     *       RADTIT(05) / '  DIFRAD_Zr ' /,
     *       RADTIT(06) / '  DIFRAD_Sn ' /,
     *       RADTIT(07) / '  DIFRAD_Gd ' /,
     *       RADTIT(08) / '  DIFRAD_Pb ' /
C
C=======================================================================
C     This subroutine makes a dynamical construction of the output
C     line on the user screen showing the advancement of the mini-
C     misation in function of the processing iterations 
C=======================================================================
C
      LOGWRI_AUXILI=1
      IF (LOGWRI.EQ.0) THEN
          LOGWRI_AUXILI=LOGWRI
          LOGWRI=1 !Irene says: I want this kind of files always...
      END IF
C
C=======================================================================
C
      IFPROT=0
      IFNEUT=0
      IFBOTH=0
C      
      DO IPARAM=1,NDPARS
         IF (IFTAKE(IPARAM).EQ.1) THEN
             IF (IPARAM.LE.20 .AND. IFDENS.EQ.0) THEN
                 IFPROT=1
             END IF
             IF (IPARAM.GT.20 .AND. IFDENS.EQ.0) THEN
                 IFNEUT=1
             END IF
             IF (IPARAM.GE.51 .AND. IFDENS.EQ.0) THEN
                 IFPROT=0
                 IFNEUT=0
                 IFBOTH=1
             END IF
         END IF
      END DO  
C
      IF ((IFDENS.EQ.0).AND.(IFNEUT.EQ.1).AND.(IFPROT.EQ.1)) THEN
           IFPROT=0
           IFNEUT=0
           IFBOTH=1
      END IF    
C
C=======================================================================
C
      INDEXP=0
C      
      IF (IFDENS.EQ.0.AND.IFPROT.EQ.1) THEN
          DO IPARAM=1,6
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C      
      IF (IFDENS.EQ.0.AND.IFNEUT.EQ.1) THEN
          DO IPARAM=21,26
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C
      IF (IFDENS.EQ.0.AND.IFBOTH.EQ.1) THEN
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          IF (IFK_VS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=57   ! V_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=58   ! kappa V_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=4    ! V_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=24   ! V_o pure WS-SO neutrons
          END IF
C
          IF (IFK_RS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=59   ! r_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=60   ! kappa r_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=5    ! r_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=25   ! r_o pure WS-SO neutrons
          END IF
C
          IF (IFK_AS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=61   ! a_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=62   ! kappa a_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=6    ! a_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=26   ! a_o pure WS-SO neutrons
          END IF
C
      END IF
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.1) THEN
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          DO IPARAM=39,42         !lambdas Density-SO
             INDEXP=INDEXP+1
             IAUXIL(INDEXP)=IPARAM
          END DO
C
          IF (IFTENS.EQ.1.AND.ISORBT.EQ.1) THEN
              DO IPARAM=43,46     !lambdas Tensor-SO
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
          IF (IFTENS.EQ.1.AND.ICENTT.EQ.1) THEN
              DO IPARAM=47,50     !lambdas Tensor-central
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
      END IF
C
C=======================================================================
C
C     Titles of columns are printed every  20  active output lines
C
      IF ((MOD(IDEFCN,20).EQ.1.AND.I_MODE.EQ.0).OR.I_MODE.EQ.2) THEN
C
          IF (LOGWRI.GT.0) THEN
              
              WRITE(LOGENE,'(/,/,'' Iter   '',$)')
              WRITE(LOGRAD,'(/,/,'' Iter   '',$)')
C
              DO I=1,INDEXP
                 IPARAM=IAUXIL(I)
                 WRITE(LOGENE,'(A14,$)') TITLES(IPARAM)
                 WRITE(LOGRAD,'(A14,$)') TITLES(IPARAM)
              END DO
            
              DO I=1,LDNUCL
                 IF (ITAKNU(I).EQ.1) THEN
                     IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.0) THEN
                         WRITE(LOGENE,'(A14,$)') CHITIT(I)
                         WRITE(LOGRAD,'(A14,$)') RADTIT(I)
                     END IF
                     IF ((IFDENS.EQ.1) .OR.  
     *                   (IFDENS.EQ.0 .AND. IFBOTH.EQ.1))THEN
                         WRITE(LOGENE,'(8X,A9,''{P,N}'',8X,''  '',$)') 
     *                                            CHITIT(I)(3:11)
                         WRITE(LOGRAD,'(8X,A9,''{P,N}'',8X,''  '',$)') 
     *                                            RADTIT(I)(3:11)
                     END IF
                 END IF
              END DO
C
              IF (I_MODE.NE.2) THEN
C
                  IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.0) THEN
                      WRITE(LOGENE,'(''    '',$)')
                      WRITE(LOGRAD,'(''    '',$)')
                  END IF
C
                  IF ((IFDENS.EQ.1) .OR. 
     *                (IFDENS.EQ.0 .AND. IFBOTH.EQ.1))THEN
                    WRITE(LOGENE,'(18X,''    '',$)')
                    WRITE(LOGRAD,'(18X,''    '',$)')
                  END IF
C
              END IF
C
          END IF          
C
      END IF 
C
      WRITE(LOGENE,'()')
      WRITE(LOGRAD,'()')
C
C=======================================================================
C                            Constructing dynamically the output lines
      IF (LOGWRI.GT.0) THEN
C_______________________________________________________________________  
C          
       IF (I_MODE.NE.1) THEN
           
           WRITE(LOGENE,'(I4,A1,''  '',$)') IDEFCN,FROMXX(I_FROM)
           WRITE(LOGRAD,'(I4,A1,''  '',$)') IDEFCN,FROMXX(I_FROM)
C 
           JSTORE=0
          
C          WRITE(LOGENE,'(7X,$)')
C
           DO I=1,INDEXP
              IPARAM=IAUXIL(I)
              WRITE(LOGENE,'(F13.5,A1,$)') PARPOT(IPARAM),
     *                                     ACTION(IPARAM)
              WRITE(LOGRAD,'(F13.5,A1,$)') PARPOT(IPARAM),
     *                                     ACTION(IPARAM)
           END DO
C
        END IF
C_______________________________________________________________________  
C          
        IF (I_MODE.NE.1) THEN
C
            DO INUCLI=1,LDNUCL
C
               IF (ITAKNU(INUCLI).EQ.1) THEN
C
                   IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
                       WRITE(LOGENE,'(E14.4,$)') CHIENE_PROTON(INUCLI)
                       WRITE(LOGRAD,'(E14.4,$)') CHIRAD_PROTON(INUCLI)
                   END IF
C          
                   IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
                       WRITE(LOGENE,'(E14.4,$)') CHIENE_NEUTRS(INUCLI)
                       WRITE(LOGRAD,'(E14.4,$)') CHIRAD_NEUTRS(INUCLI)
                   END IF
C
                   IF ((IFDENS.EQ.1)
     *            .OR. (IFDENS.EQ.0 .AND. IFBOTH.EQ.1)) THEN
C         
                       WRITE(LOGENE,'(2E14.4,''    '',$)') 
     *                   CHIENE_PROTON(INUCLI),CHIENE_NEUTRS(INUCLI)
C
                      WRITE(LOGRAD,'(2E14.4,''    '',$)') 
     *                   CHIRAD_PROTON(INUCLI),CHIRAD_NEUTRS(INUCLI)
C
                   END IF
C
               END IF
C
            END DO
C
        END IF
C_______________________________________________________________________  
C      
      END IF
C
C=======================================================================
C
      IF (LOGWRI_AUXILI.EQ.0) THEN
          LOGWRI=0
      END IF
C
C=======================================================================
C
      RETURN
      END     
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE RADINF(IFPROT,IFNEUT)
C   
      INCLUDE  'MATDIM/NDNUCL.f'
C
      CHARACTER
     *          NUCSYM*6,INPSYM*6
C
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
C      COMMON
C     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON
     *       /MODIFR/ RMSEXP_PROTON(1:NDNUCL),
     *                RMSEXP_NEUTRS(1:NDNUCL),
     *                RMSTHE_PROTON,RMSTHE_NEUTRS,
     *                RMODIF_PROTON,RMODIF_NEUTRS,
     *                              PUSHIN,DELTAR
      COMMON
     *       /NUCWEI/ WEINUC_PROTON(1:NDNUCL),
     *                WEINUC_NEUTRS(1:NDNUCL),
     *                WEIRAD_PROTON(1:NDNUCL),
     *                WEIRAD_NEUTRS(1:NDNUCL)
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS    
C
C=======================================================================
C      
      DO INUCLI=1,LDNUCL
          
        IF (ITAKNU(INUCLI).EQ.1) THEN
      
        IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
          
          WRITE(LOGAUX,'(/,A6,'' --> Radii Info - Protons:'',
     *                           '' Rex= '',f6.4,'' fm ;  '',
     *                           '' Rth= '',f6.4,'' fm ;  '',
     *                           '' Rwt= '',f6.2,'' ;  '',
     *                           '' Dif= '',e10.4,'' fm'',/)')
     *                                          NUCSYM(INUCLI),
     *                                   RMSEXP_PROTON(INUCLI),
     *                                           RMSTHE_PROTON,
     *                                   WEIRAD_PROTON(INUCLI),
     *                     RMSEXP_PROTON(INUCLI)-RMSTHE_PROTON
        END IF
      
        IF (IFDENS.EQ.0.AND.IFNEUT.EQ.1) THEN
C
          WRITE(LOGAUX,'(/,A6,'' --> Radii Info - Neutrons:'',
     *                            '' Rex= '',f6.4,'' fm ;  '',
     *                            '' Rth= '',f6.4,'' fm ;  '',
     *                            '' Rwt= '',f6.2,'' ;  '',
     *                            '' Dif= '',e10.4,'' fm'',/)')
     *                                          NUCSYM(INUCLI),
     *                                   RMSEXP_NEUTRS(INUCLI),
     *                                           RMSTHE_NEUTRS,
     *                                   WEIRAD_NEUTRS(INUCLI),
     *                     RMSEXP_NEUTRS(INUCLI)-RMSTHE_NEUTRS
        END IF
      
        IF (IFDENS.EQ.1) THEN
C
          WRITE(LOGAUX,'(/,A6,'' --> Radii Info - Protons:'',
     *                           '' Rex= '',f6.4,'' fm ;  '',
     *                           '' Rth= '',f6.4,'' fm ;  '',
     *                           '' Rwt= '',f6.2,'' ;  '',
     *                           '' Dif= '',e10.4,'' fm'',/)')
     *                                          NUCSYM(INUCLI),
     *                                   RMSEXP_PROTON(INUCLI),
     *                                           RMSTHE_PROTON,
     *                                   WEIRAD_PROTON(INUCLI),
     *                     RMSEXP_PROTON(INUCLI)-RMSTHE_PROTON
C
          WRITE(LOGAUX,'(/,A6,'' --> Radii Info - Neutrons:'',
     *                            '' Rex= '',f6.4,'' fm ;  '',
     *                            '' Rth= '',f6.4,'' fm ;  '',
     *                            '' Rwt= '',f6.2,'' ;  '',
     *                            '' Dif= '',e10.4,'' fm'',/)')
     *                                          NUCSYM(INUCLI),
     *                                   RMSEXP_NEUTRS(INUCLI),
     *                                           RMSTHE_NEUTRS,
     *                                   WEIRAD_NEUTRS(INUCLI),
     *                     RMSEXP_NEUTRS(INUCLI)-RMSTHE_NEUTRS
          
        END IF
        
        END IF
      
      END DO
C
C=======================================================================
C
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE WRITIN_ENELEV(ISOSPI,IRANDO_PRINTG,LDRAND,
     *                         IEVALU_PRINTG,PARPOT_PRINTG,
     *                         CHISQU_PRINTG,CHIGRD_PRINTG,
     *                         ERRMAX_PRINTG,RMSVAL_PRINTG,
     *                         RMSGLO_PRINTG,RMSEXP_PRINTG,
     *                         RMSTHE_PRINTG,LEVTHE_PRINTG,
     *                         ENETHE_PRINTG,LABTHE_PRINTG,
     *                                              INUCLI)
c          
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/NDPARS.f'
      INCLUDE  'MATDIM/NDLEXP.f'
      INCLUDE  'MATDIM/NDSPEC.f'
      INCLUDE  'MATDIM/NDIM_M.f'
      INCLUDE  'MATDIM/NDCOLO.f'
      INCLUDE  'MATDIM/NDTITL.f'
c      
      CHARACTER
     *          FILNAM*256,TITPAR*13,AUXLAB*6,LABTEX*11,TITLES*12,
     *          FILNAM_ENDING*7,NUCNAM*256,TEXLAM*20
      CHARACTER
     *          FILNAM_IFITED*14,FITNUC*2,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*2,TITLES_LATEXS*050,
     *          NUCNAM_LATEXS*010
      CHARACTER
     *          INPSYM*6,TYPCHI*6,NUCSYM*6,VERSIO*3
      CHARACTER
     *          LABEXP*6,LABTHE*6,LABTHE_PRINTG*6
      CHARACTER
     *          LABTHE_PROTON*6,LABTHE_NEUTRS*6
      CHARACTER
     *          LABEXP_PROTON*6,LABEXP_NEUTRS*6
      DIMENSION
     *          ENETHE(1:NDSPEC),LABTHE(1:NDSPEC)
      DIMENSION
     *          EXPEXP(1:NDLEXP),IDEGEX(1:NDLEXP)
      DIMENSION
     *          LABEXP(1:NDLEXP)
      DIMENSION
     *          ENETHE_PRINTG(1:NDSPEC),LABTHE_PRINTG(1:NDSPEC),
     *          PARPOT_PRINTG(1:NDPARS)
      DIMENSION
     *          ARGPAR(1:NDPARS)
      DIMENSION
     *          TITPAR(1:NDPARS),
     *          PARPOT_AUXILI(1:NDPARS)
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /SPECTR/ ENETHE_PROTON(1:NDSPEC),
     *                ENETHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /THELAB/ LABTHE_PROTON(1:NDSPEC),
     *                LABTHE_NEUTRS(1:NDSPEC)
      COMMON
     *       /EX_ENE/ EXPEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_PROTON(1:NDNUCL,1:NDLEXP),
     *
     *                EXPEXP_NEUTRS(1:NDNUCL,1:NDLEXP),
     *                IDEGEX_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /EX_LAB/ LABEXP_PROTON(1:NDNUCL,1:NDLEXP),
     *                LABEXP_NEUTRS(1:NDNUCL,1:NDLEXP)
      COMMON
     *       /DIMSPH/ LDSING_PROTON,LEVTHE_PROTON,
     *                LEVEXP_PROTON(1:NDNUCL),
     *                LDSING_NEUTRS,LEVTHE_NEUTRS,
     *                LEVEXP_NEUTRS(1:NDNUCL)
      COMMON
     *       /CHIVAL_PROTON/ CHICOR_PROTON,RADDIF_PROTON,CHIINV_PROTON,
     *                       FERDIF_PROTON,GAPDIF_PROTON,CHIWEI_PROTON,
     *                       EABSWD_PROTON,EABSAV_PROTON,ERRMAX_PROTON,
     *                       DIFFUP_PROTON,DIFFDW_PROTON,CHIRHO_PROTON,
     *                                                   CHIDEG_PROTON
      COMMON
     *       /CHIVAL_NEUTRS/ CHICOR_NEUTRS,RADDIF_NEUTRS,CHIINV_NEUTRS,
     *                       FERDIF_NEUTRS,GAPDIF_NEUTRS,CHIWEI_NEUTRS,
     *                       EABSWD_NEUTRS,EABSAV_NEUTRS,ERRMAX_NEUTRS,
     *                       DIFFUP_NEUTRS,DIFFDW_NEUTRS,CHIDEG_NEUTRS
      COMMON
     *       /NUCWEI/ WEINUC_PROTON(1:NDNUCL),
     *                WEINUC_NEUTRS(1:NDNUCL),
     *                WEIRAD_PROTON(1:NDNUCL),
     *                WEIRAD_NEUTRS(1:NDNUCL)
      COMMON
     *       /ER_RMS/ RMSERR_PROTON(1:NDNUCL),
     *                RMSERR_NEUTRS(1:NDNUCL)
      COMMON 
     *       /RMSVAL/ HINORM_PROTON,HINORM_NEUTRS
      COMMON
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /CHI_PN/ CHISQU_PROTON,CHISQU_NEUTRS
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /XLENGT/ XMIN_T,XMAX_T,XMIN_E,XMAX_E
      COMMON
     *       /ATTRIB/ ISTYLE,I_TYPE,ICOLOR(1:NDCOLO),ITHICK(1:NDCOLO)
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS    
      COMMON
     *       /FITTED/ IFITED
      COMMON
     *       /VPROEF/ V0EFFC
      COMMON
     *       /LAMUNI/ UNITLA
      COMMON
     *       /FACCOU/ COUFAC
      COMMON
     *       /VERSIN/ VERSIO
      COMMON
     *       /CTSHIF/ V0SHIF_PROTON(1:NDNUCL),
     *                V0SHIF_NEUTRS(1:NDNUCL)
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /KAPPAR/ V0CENT_KAPPAR,XK_V0C_KAPPAR,
     *                R0CENT_KAPPAR,XK_R0C_KAPPAR,
     *                A0CENT_KAPPAR,XK_A0C_KAPPAR,
     *                V0SORB_KAPPAR,XK_V0S_KAPPAR,
     *                R0SORB_KAPPAR,XK_R0S_KAPPAR,
     *                A0SORB_KAPPAR,XK_A0S_KAPPAR
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' /
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(/,''Entering WRITING_ENELEV'')')
      
          WRITE(LOGFIL,'(/,''IFITED='',I2,'' IZ= '',I3,'' IN= '',I3,
     *                 '' ISOSPI= '',I1,/)') IFITED,NUMB_Z(INUCLI),
     *                                      NUMB_N(INUCLI),ISOSPI
      END IF
C
C=======================================================================
C
      IACTIV=0
C
C=======================================================================
C      
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
          
          IF (LOGWRI.GT.0) 
     *    WRITE(LOGFIL,'(''Assigning thing for pure WS and protons'',$
     *                                                             )')
          
          ISOSPI=1
          FILNAM_ENDING='-P'
C_______________________________________________________________________
C          
          LEVTHE=LDSING_PROTON 
          LEVEXP=LEVEXP_PROTON(INUCLI)
C
          DO ITHEOR=1,LEVTHE
             LABTHE(ITHEOR)=LABTHE_PROTON(ITHEOR)
             ENETHE(ITHEOR)=ENETHE_PROTON(ITHEOR)
          END DO
C          
          DO IEXPER=1,LEVEXP
             LABEXP(IEXPER)=LABEXP_PROTON(INUCLI,IEXPER)
             EXPEXP(IEXPER)=EXPEXP_PROTON(INUCLI,IEXPER)
          END DO
C_______________________________________________________________________
C          
          IPARAM_AUXILI=0
          
          DO IPARAM=1,6
            IPARAM_AUXILI=IPARAM_AUXILI+1
            TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'PROTON'
            PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT_PRINTG(IPARAM)
          END DO
          
          NINITI=1
          NFINAL=IPARAM_AUXILI
          ITOTAL=IPARAM_AUXILI
          
          NINCNT=1
          NFICNT=NFINAL/2
          
          NIN_SO=NFICNT+1
          NFI_SO=NFINAL
          
          CHISQU=CHISQU_PROTON
          CHICOR=CHICOR_PROTON
          RADDIF=RADDIF_PROTON
          CHIINV=CHIINV_PROTON
          FERDIF=FERDIF_PROTON
          GAPDIF=GAPDIF_PROTON
          CHIWEI=CHIWEI_PROTON
          EABSAV=EABSAV_PROTON
          ERRMAX=ERRMAX_PROTON
          DIFFUP=DIFFUP_PROTON
          DIFFDW=DIFFDW_PROTON
          
          HINORM=HINORM_PROTON
          
          RMSERR=RMSERR_PROTON(INUCLI)
          
          IF (LOGWRI.GT.0) WRITE(LOGFIL,'('' ... OK!'')')
          
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN

          IF (LOGWRI.GT.0) 
     *    WRITE(LOGFIL,'(''Assigning thing for pure WS and neutrons'',$
     *                                                             )')
          
          ISOSPI=0
          FILNAM_ENDING='-N'
C_______________________________________________________________________
C          
          LEVTHE=LDSING_NEUTRS 
          LEVEXP=LEVEXP_NEUTRS(INUCLI)
C
          DO ITHEOR=1,LEVTHE
             LABTHE(ITHEOR)=LABTHE_NEUTRS(ITHEOR)
             ENETHE(ITHEOR)=ENETHE_NEUTRS(ITHEOR)
          END DO
C          
          DO IEXPER=1,LEVEXP
             LABEXP(IEXPER)=LABEXP_NEUTRS(INUCLI,IEXPER)
             EXPEXP(IEXPER)=EXPEXP_NEUTRS(INUCLI,IEXPER)
          END DO
C_______________________________________________________________________
C          
          IPARAM_AUXILI=0
          
          DO IPARAM=21,26
            IPARAM_AUXILI=IPARAM_AUXILI+1
            TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'NEUTRS'
            PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT_PRINTG(IPARAM)
          END DO
          
          NINITI=1
          NFINAL=IPARAM_AUXILI
          ITOTAL=IPARAM_AUXILI
          
          NINCNT=1
          NFICNT=NFINAL/2
          
          NIN_SO=NFICNT+1
          NFI_SO=NFINAL
          
          CHISQU=CHISQU_NEUTRS
          CHICOR=CHICOR_NEUTRS
          RADDIF=RADDIF_NEUTRS
          CHIINV=CHIINV_NEUTRS
          FERDIF=FERDIF_NEUTRS
          GAPDIF=GAPDIF_NEUTRS
          CHIWEI=CHIWEI_NEUTRS
          EABSAV=EABSAV_NEUTRS
          ERRMAX=ERRMAX_NEUTRS
          DIFFUP=DIFFUP_NEUTRS
          DIFFDW=DIFFDW_NEUTRS
          
          HINORM=HINORM_NEUTRS
          
          RMSERR=RMSERR_NEUTRS(INUCLI)
          
          IF (LOGWRI.GT.0) WRITE(LOGFIL,'('' ... OK!'')')
          
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) THEN
C
          IF (ISOSPI.EQ.1) THEN
C
              IF (LOGWRI.GT.0) 
     *        WRITE(LOGFIL,'(''Assigning thing for pure WS '',
     *                                           ''and protons'',$)')
          
              FILNAM_ENDING='-P'
C_______________________________________________________________________
C          
              LEVTHE=LDSING_PROTON 
              LEVEXP=LEVEXP_PROTON(INUCLI)
C
              DO ITHEOR=1,LEVTHE
                 LABTHE(ITHEOR)=LABTHE_PROTON(ITHEOR)
                 ENETHE(ITHEOR)=ENETHE_PROTON(ITHEOR)
              END DO
C          
              DO IEXPER=1,LEVEXP
                 LABEXP(IEXPER)=LABEXP_PROTON(INUCLI,IEXPER)
                 EXPEXP(IEXPER)=EXPEXP_PROTON(INUCLI,IEXPER)
              END DO
C_______________________________________________________________________
C          
              IPARAM_AUXILI=0
          
              DO IPARAM=1,6
                 IPARAM_AUXILI=IPARAM_AUXILI+1
                 TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'PROTON'
                 PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT_PRINTG(IPARAM)
              END DO
          
              NINITI=1
              NFINAL=IPARAM_AUXILI
              ITOTAL=IPARAM_AUXILI
          
              NINCNT=1
              NFICNT=NFINAL/2
          
              NIN_SO=NFICNT+1
              NFI_SO=NFINAL
          
              CHISQU=CHISQU_PROTON
              CHICOR=CHICOR_PROTON
              RADDIF=RADDIF_PROTON
              CHIINV=CHIINV_PROTON
              FERDIF=FERDIF_PROTON
              GAPDIF=GAPDIF_PROTON
              CHIWEI=CHIWEI_PROTON
              EABSAV=EABSAV_PROTON
              ERRMAX=ERRMAX_PROTON
              DIFFUP=DIFFUP_PROTON
              DIFFDW=DIFFDW_PROTON
          
              HINORM=HINORM_PROTON
          
              RMSERR=RMSERR_PROTON(INUCLI)
          
              IF (LOGWRI.GT.0) WRITE(LOGFIL,'('' ... OK!'')')
C
          END IF
C_______________________________________________________________________
C 
          IF (ISOSPI.EQ.0) THEN
              IF (LOGWRI.GT.0) 
     *            WRITE(LOGFIL,'(''Assigning thing for pure WS '',
     *                                           ''and neutrons'',$)')
              ISOSPI=0
              FILNAM_ENDING='-N'
C_______________________________________________________________________
C          
              LEVTHE=LDSING_NEUTRS 
              LEVEXP=LEVEXP_NEUTRS(INUCLI)
C
              DO ITHEOR=1,LEVTHE
                 LABTHE(ITHEOR)=LABTHE_NEUTRS(ITHEOR)
                 ENETHE(ITHEOR)=ENETHE_NEUTRS(ITHEOR)
              END DO
C          
              DO IEXPER=1,LEVEXP
                 LABEXP(IEXPER)=LABEXP_NEUTRS(INUCLI,IEXPER)
                 EXPEXP(IEXPER)=EXPEXP_NEUTRS(INUCLI,IEXPER)
              END DO
C_______________________________________________________________________
C          
              IPARAM_AUXILI=0
          
              DO IPARAM=21,26
                 IPARAM_AUXILI=IPARAM_AUXILI+1
                 TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'NEUTRS'
                 PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT_PRINTG(IPARAM)
              END DO
          
              NINITI=1
              NFINAL=IPARAM_AUXILI
              ITOTAL=IPARAM_AUXILI
          
              NINCNT=1
              NFICNT=NFINAL/2
          
              NIN_SO=NFICNT+1
              NFI_SO=NFINAL
          
              CHISQU=CHISQU_NEUTRS
              CHICOR=CHICOR_NEUTRS
              RADDIF=RADDIF_NEUTRS
              CHIINV=CHIINV_NEUTRS
              FERDIF=FERDIF_NEUTRS
              GAPDIF=GAPDIF_NEUTRS
              CHIWEI=CHIWEI_NEUTRS
              EABSAV=EABSAV_NEUTRS
              ERRMAX=ERRMAX_NEUTRS
              DIFFUP=DIFFUP_NEUTRS
              DIFFDW=DIFFDW_NEUTRS
          
              HINORM=HINORM_NEUTRS
          
              RMSERR=RMSERR_NEUTRS(INUCLI)
          
              IF (LOGWRI.GT.0) WRITE(LOGFIL,'('' ... OK!'')')
          END IF
C
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.1) THEN
          
          IF (ISOSPI.EQ.1) THEN
              
              FILNAM_ENDING='-P'          
              
              LEVEXP=LEVEXP_PROTON(INUCLI)
C          
              DO IEXPER=1,LEVEXP
                 LABEXP(IEXPER)=LABEXP_PROTON(INUCLI,IEXPER)
                 EXPEXP(IEXPER)=EXPEXP_PROTON(INUCLI,IEXPER)
              END DO
              
              RMSERR=RMSERR_PROTON(INUCLI)
          
          END IF
C_______________________________________________________________________
C          
          IF (ISOSPI.EQ.0) THEN
              
              FILNAM_ENDING='-N'          
              
              LEVEXP=LEVEXP_NEUTRS(INUCLI)
C          
              DO IEXPER=1,LEVEXP
                 LABEXP(IEXPER)=LABEXP_NEUTRS(INUCLI,IEXPER)
                 EXPEXP(IEXPER)=EXPEXP_NEUTRS(INUCLI,IEXPER)
              END DO
              
              RMSERR=RMSERR_NEUTRS(INUCLI)
          
          END IF
C_______________________________________________________________________
C          
          IPARAM_AUXILI=0
C          
          DO IPARAM=1,6
             IPARAM_AUXILI=IPARAM_AUXILI+1
             TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'PROTON'
             PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT_PRINTG(IPARAM)
             IF (IPARAM.GE.4) PARPOT_AUXILI(IPARAM_AUXILI)=9999.
          END DO 
C          
          NINCNT_PROTON=1
          NFICNT_PROTON=IPARAM_AUXILI/2
          
          NIN_WS_PROTON=IPARAM_AUXILI/2+1
          NFI_WS_PROTON=IPARAM_AUXILI
C          
          DO IPARAM=21,26
             IPARAM_AUXILI=IPARAM_AUXILI+1
             TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'NEUTRS'
             PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT_PRINTG(IPARAM)
             IF (IPARAM.GE.24) PARPOT_AUXILI(IPARAM_AUXILI)=9999.
          END DO 
C          
          NINCNT_NEUTRS=NFI_WS_PROTON+1
          NFICNT_NEUTRS=NINCNT_NEUTRS+2
          
          NIN_WS_NEUTRS=NFICNT_NEUTRS+1
          NFI_WS_NEUTRS=IPARAM_AUXILI
C          
          DO IPARAM=39,42
             IPARAM_AUXILI=IPARAM_AUXILI+1
             TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:9)
             PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT_PRINTG(IPARAM)/UNITLA
          END DO
C          
          NIN_SO_LAMBDA=NFI_WS_NEUTRS+1
          NFI_SO_LAMBDA=IPARAM_AUXILI
C          
          IF (IFTENS.EQ.1.AND.ISORBT.EQ.1) THEN
              DO IPARAM=43,46
                 IPARAM_AUXILI=IPARAM_AUXILI+1
                 TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:9)
                 PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT_PRINTG(IPARAM)
     *                                       /UNITLA
              END DO
              NIN_SO_TENLAM=IPARAM_AUXILI-3
              NFI_SO_TENLAM=IPARAM_AUXILI
          END IF
C          
          IF (IFTENS.EQ.1.AND.ICENTT.EQ.1) THEN
              DO IPARAM=47,50
                 IPARAM_AUXILI=IPARAM_AUXILI+1
                 TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:9)
                 PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT_PRINTG(IPARAM)
     *                                       /UNITLA
              END DO
              NINCNT_TENLAM=IPARAM_AUXILI-3
              NFICNT_TENLAM=IPARAM_AUXILI
          END IF
C          
          NINITI=1
          NFINAL=IPARAM_AUXILI
          ITOTAL=IPARAM_AUXILI
C          
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                            IFPAR1,IFPAR2,IFPAR3,IFPAR4
C          
      END IF
C
C=======================================================================
C
      YMINIM=1.0E+10
      YMAXIM=-1.0E+10
      
      DO IEXPER=1,LEVEXP
        DO ITHEOR=1,LEVTHE_PRINTG
                
          IF (LABEXP(IEXPER).EQ.LABTHE_PRINTG(ITHEOR)) THEN

              IF (ENETHE_PRINTG(ITHEOR).LT.YMINIM) THEN
              
                  YMINIM=ENETHE_PRINTG(ITHEOR)
              
              END IF
          
              IF (ENETHE_PRINTG(ITHEOR).GT.YMAXIM) THEN
               
                  YMAXIM=ENETHE_PRINTG(ITHEOR)
              
              END IF
              
              IF (EXPEXP(IEXPER).LT.YMINIM) THEN
              
                  YMINIM=EXPEXP(IEXPER)
              
              END IF
          
              IF (EXPEXP(IEXPER).GT.YMAXIM) THEN
              
                  YMAXIM=EXPEXP(IEXPER)
              
              END IF
              
          END IF
                
        END DO
      END DO
C
C=======================================================================
C      
      NRESUL=55+INUCLI
C_______________________________________________________________________
C  
      IF (IFITED.EQ.3) FILNAM_IFITED='WSUniv/WSUniv-' !from WSuniv 
      IF (IFITED.EQ.2) FILNAM_IFITED='OneRun/OneRun-' !from single run
      IF (IFITED.EQ.1) FILNAM_IFITED='Fitted/Fitted-'
      IF (IFITED.EQ.0) FILNAM_IFITED='Predic/Predic-'
C_______________________________________________________________________
C
      I2=1
      DO II=1,6
         IF (NUCSYM(INUCLI)(II:II).EQ.' ') THEN
             I2=II+1
         END IF
      END DO
C_______________________________________________________________________
C
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
      
      I1=3*KACTIV
      
      WRITE(FILNAM_NUCFIT,'(''_'',<NUCACT>(A2,''-''))')
     *                      (FITNUC_AUXILI(I),I=1,NUCACT)
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.0) THEN
C      
          WRITE(FILNAM,'(''EnergyLevels/IFDENS-0/'',A14,A,A2,A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A3,''.dat'')') 
     *                      FILNAM_IFITED,NUCSYM(INUCLI)(I2:6),
     *                      FILNAM_ENDING,FILNAM_NUCFIT(1:I1),
     *                      IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                      IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                                  VERSIO
C      
      END IF
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.1) THEN
C      
          WRITE(FILNAM,'(''EnergyLevels/IFDENS-1_IFTENS-'',I1,''/'',
     *                                       A14,A,A2,A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,A15,''_'',A3,''.dat'')') 
     *                              IFTENS,
     *                              FILNAM_IFITED,NUCSYM(INUCLI)(I2:6),
     *                              FILNAM_ENDING,FILNAM_NUCFIT(1:I1),
     *                              IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                              IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                              IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                              LDRAND,TEXLAM,VERSIO
C
          IF (IFTENS.EQ.1) THEN
C              
              WRITE(FILNAM,'(''EnergyLevels/IFDENS-1_IFTENS-'',I1,''/'',
     *                                       A14,A,A2,A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,A15,''_'',A3,''.dat'')') 
     *                              IFTENS,
     *                              FILNAM_IFITED,NUCSYM(INUCLI)(I2:6),
     *                              FILNAM_ENDING,FILNAM_NUCFIT(1:I1),
     *                              IFDENS,IFTENS,IF_PAI,
     *                              ICENTT,ISORBT,ITENSR,
     *                              IF_RAD,IF_INV,
     *                              IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                              IFK_RC,IFK_RS,IFK_AC,IFK_AS,
     *                              LDRAND,TEXLAM,VERSIO
C
          END IF
C      
      END IF
C
C=======================================================================
C        
      OPEN(NRESUL,FILE=FILNAM,STATUS='UNKNOWN',FORM='FORMATTED')
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<CODEVERSIO>> VERSIO'')')
C
      WRITE(NRESUL,'(16X,A3)') VERSIO
C
C=======================================================================
C          
      WRITE(NRESUL,'(/,''<<MAIN_TITLE>>'')')
          
      WRITE(NRESUL,'(15X,''Comparison Theory-Experiment'',/)')
C
C=======================================================================
C     
      WRITE(NRESUL,'(''<<NUCLIDINFO>>'',1X,''NUMB_Z'',3X,''NUMB_N'')')
C
      WRITE(NRESUL,'(15X,I3,6X,I3,/)')NUMB_Z(INUCLI),NUMB_N(INUCLI)
C_______________________________________________________________________
C
      A_MASS=NUMB_Z(INUCLI)+NUMB_N(INUCLI)
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<NoNUCACTIV>>'',1X,''NUCACT'')')
C      
      WRITE(NRESUL,'(15X,I3,/)') NUCACT
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<NUCLEI_FIT>> '',$)')
      
      JACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             JACTIV=JACTIV+1
             WRITE(NRESUL,'(''Z_No'',i2.2,3X,''N_No'',i2.2,''   '',$)')
     *                        JACTIV,JACTIV
         END IF
      END DO
      WRITE(NRESUL,'()')
      
      WRITE(NRESUL,'(14X,''  '',$)')
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             WRITE(NRESUL,'(I4,5X,I4,2X,''   '',$)')NUMB_Z(JNUCLI),
     *                                              NUMB_N(JNUCLI)
         END IF
      END DO
      WRITE(NRESUL,'()')
      WRITE(NRESUL,'()')
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<EXPER_FILE>>'',1X,''IFDEEP'',3X
     *                                     ''IFPRON'')')
      
      WRITE(NRESUL,'(15X,2(I3,6X),/)') IFDEEP,IFPRON
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<POTEN_INFO>>'',1X,''ISOSPI'',3X
     *                                     ''IFDENS'',3X,''IFTENS'',
     *                                                3X,''IF_PAI'')')
      
      WRITE(NRESUL,'(15X,4(I3,6X),/)') ISOSPI,IFDENS,IFTENS,IF_PAI
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<TENSR_INFO>>'',1X,''ICENTT'',3X
     *                                     ''ISORBT'',3X,''ITENSR'')')
      
      WRITE(NRESUL,'(15X,3(I3,6X),/)') ICENTT,ISORBT,ITENSR
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<TAKEN_CHI2>> IF_SPE   IF_RAD   IF_GAP   '',
     *               ''IF_FER   IF_DEN   IF_RHO   IF_INV'')')
      WRITE(NRESUL,'(15X,7(I3,6X),/)')IF_SPE,IF_RAD,IF_GAP,IF_FER,
     *                                       IF_DEN,IF_RHO,IF_INV
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<IFKAPPAPAR>> IFK_VC   IFK_VS   IFK_RC   '',
     *                              ''IFK_RS   IFK_AC   IFK_AS'')')
      WRITE(NRESUL,'(15X,6(I3,6X),/)') IFK_VC,IFK_VS,IFK_RC,IFK_RS,
     *                                               IFK_AC,IFK_AS
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<RANDOMNESS>> LDRAND   IRANDO'')')
C
      WRITE(NRESUL,'(15X,I6,3X,I6,/)') LDRAND,IRANDO_PRINTG
C
C=======================================================================
C          
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
C
          WRITE(NRESUL,'(''<<CENTRL_PRO>>'',1X,
     *                       ''VCENTR_PROTON  RCENTR_PROTON  '',
     *                       ''ACENTR_PROTON'')')
          WRITE(NRESUL,'(15X,3(F13.9,2X),/)') 
     *                   VKACEN_PROTON,RKACEN_PROTON/A_MASS**(1./3.),
     *                   AKACEN_PROTON
     
          WRITE(NRESUL,'(''<<SOR-WS_PRO>>'',1X,
     *                       ''VSORBT_PROTON  RSORBT_PROTON  '',
     *                       ''ASORBT_PROTON'')')
          WRITE(NRESUL,'(15X,3(F13.9,2X),/)') 
     *                   VKASOR_PROTON,RKASOR_PROTON/A_MASS**(1./3.),
     *                   AKASOR_PROTON
C
      END IF
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
C
          WRITE(NRESUL,'(''<<CENTRL_NEU>>'',1X,
     *                       ''VCENTR_NEUTRS  RCENTR_NEUTRS  '',
     *                       ''ACENTR_NEUTRS'')')
          WRITE(NRESUL,'(15X,3(F13.9,2X),/)') 
     *                   VKACEN_NEUTRS,RKACEN_NEUTRS/A_MASS**(1./3.),
     *                   AKACEN_NEUTRS
     
          WRITE(NRESUL,'(''<<SOR-WS_NEU>>'',1X,
     *                       ''VSORBT_NEUTRS  RSORBT_NEUTRS  '',
     *                       ''ASORBT_NEUTRS'')')
          WRITE(NRESUL,'(15X,3(F13.9,2X),/)') 
     *                   VKASOR_NEUTRS,RKASOR_NEUTRS/A_MASS**(1./3.),
     *                   AKASOR_NEUTRS
C
      END IF
C_______________________________________________________________________
C
      IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) THEN
C
          IF (ISOSPI.EQ.1) THEN

              WRITE(NRESUL,'(''<<CENTRL_PRO>>'',1X,
     *                       ''VCENTR_PROTON  RCENTR_PROTON  '',
     *                       ''ACENTR_PROTON'')')
              WRITE(NRESUL,'(15X,3(F13.9,2X),/)') 
     *                   VKACEN_PROTON,RKACEN_PROTON/A_MASS**(1./3.),
     *                   AKACEN_PROTON
     
              WRITE(NRESUL,'(''<<SOR-WS_PRO>>'',1X,
     *                       ''VSORBT_PROTON  RSORBT_PROTON  '',
     *                       ''ASORBT_PROTON'')')
              WRITE(NRESUL,'(15X,3(F13.9,2X),/)') 
     *                   VKASOR_PROTON,RKASOR_PROTON/A_MASS**(1./3.),
     *                   AKASOR_PROTON
          END IF
C
          IF (ISOSPI.EQ.0) THEN

              WRITE(NRESUL,'(''<<CENTRL_NEU>>'',1X,
     *                       ''VCENTR_NEUTRS  RCENTR_NEUTRS  '',
     *                       ''ACENTR_NEUTRS'')')
              WRITE(NRESUL,'(15X,3(F13.9,2X),/)') 
     *                   VKACEN_NEUTRS,RKACEN_NEUTRS/A_MASS**(1./3.),
     *                   AKACEN_NEUTRS
     
              WRITE(NRESUL,'(''<<SOR-WS_NEU>>'',1X,
     *                       ''VSORBT_NEUTRS  RSORBT_NEUTRS  '',
     *                       ''ASORBT_NEUTRS'')')
              WRITE(NRESUL,'(15X,3(F13.9,2X),/)') 
     *                   VKASOR_NEUTRS,RKASOR_NEUTRS/A_MASS**(1./3.),
     *                   AKASOR_NEUTRS
          END IF
C
      END IF
C_______________________________________________________________________
C     
      IF (IFDENS.EQ.1) THEN
C
          WRITE(NRESUL,'(''<<CENTRL_PRO>>'',1X,
     *                       ''VCENTR_PROTON  RCENTR_PROTON  '',
     *                       ''ACENTR_PROTON'')')
          WRITE(NRESUL,'(15X,3(F13.9,2X),/)') 
     *                 VKACEN_PROTON,RKACEN_PROTON/A_MASS**(1./3.),
     *                 AKACEN_PROTON
C
          WRITE(NRESUL,'(''<<CENTRL_NEU>>'',1X,
     *                       ''VCENTR_NEUTRS  RCENTR_NEUTRS  '',
     *                       ''ACENTR_NEUTRS'')')
          WRITE(NRESUL,'(15X,3(F13.9,2X),/)') 
     *                 VKACEN_NEUTRS,RKACEN_NEUTRS/A_MASS**(1./3.),
     *                 AKACEN_NEUTRS
C          
          WRITE(NRESUL,'(''<<SOR_DENSIT>>'',1X,4(A13,2X))')
     *                 (TITPAR(I),I=NIN_SO_LAMBDA,NFI_SO_LAMBDA)
          WRITE(NRESUL,'(15X,4(F13.6,2X),/)') 
     *                 (PARPOT_AUXILI(I),I=NIN_SO_LAMBDA,NFI_SO_LAMBDA)
C          
          IF (IFTENS.EQ.1 .AND. ISORBT.EQ.1) THEN
              WRITE(NRESUL,'(''<<SOR_TENSOR>>'',1X,4(A13,2X))')
     *                 (TITPAR(I),I=NIN_SO_TENLAM,NFI_SO_TENLAM)
              WRITE(NRESUL,'(15X,4(F13.6,2X),/)') 
     *                 (PARPOT_AUXILI(I),I=NIN_SO_TENLAM,NFI_SO_TENLAM)
          END IF
C          
          IF (IFTENS.EQ.1 .AND. ICENTT.EQ.1) THEN
              WRITE(NRESUL,'(''<<CNT_TENSOR>>'',1X,4(A13,2X))')
     *                 (TITPAR(I),I=NINCNT_TENLAM,NFICNT_TENLAM)
              WRITE(NRESUL,'(15X,4(F13.6,2X),/)') 
     *                 (PARPOT_AUXILI(I),I=NINCNT_TENLAM,NFICNT_TENLAM)
          END IF
C
      END IF
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<KAPPA_CENT>> V0CENT  KAP_V0  '',
     *              ''R0CENT  KAP_R0  A0CENT  KAP_A0'')')
C
      WRITE(NRESUL,'(15X,6(F13.6,2X),/)')V0CENT_KAPPAR,XK_V0C_KAPPAR,
     *                                  R0CENT_KAPPAR,XK_R0C_KAPPAR,
     *                                  A0CENT_KAPPAR,XK_A0C_KAPPAR
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<KAPPA_SORB>> V0SORB  KAP_V0  '',
     *              ''R0SORB  KAP_R0  A0SORB  KAP_A0'')')
C
      WRITE(NRESUL,'(15X,6(F13.6,2X),/)')V0SORB_KAPPAR,XK_V0S_KAPPAR,
     *                                  R0SORB_KAPPAR,XK_R0S_KAPPAR,
     *                                  A0SORB_KAPPAR,XK_A0S_KAPPAR
C
C=======================================================================
C 
      IF (ISOSPI.EQ.1) THEN
C
          WRITE(NRESUL,'(''<<V0P_EFFECT>> V0EFFC'')')
          WRITE(NRESUL,'(15X,F8.4,/)') V0EFFC
C
          WRITE(NRESUL,'(''<<COULOMBFAC>> COUFAC'')')
          WRITE(NRESUL,'(15X,F8.4,/)') COUFAC
C
      END IF
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<UNITLAMBDA>>'',1X,''UNITLA'')')
      WRITE(NRESUL,'(15X,F6.2,/)') UNITLA
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<WEIGHT_NUC>>'',1X,<LDNUCL>(''NUC_'',I2.2,3X))')
     *                                               (I,I=1,LDNUCL)
      WRITE(NRESUL,'(15X,<LDNUCL>(F6.2,3X))') 
     *                                   (WEINUC_PROTON(I),I=1,LDNUCL)
      WRITE(NRESUL,'(15X,<LDNUCL>(F6.2,3X),/)') 
     *                                   (WEINUC_NEUTRS(I),I=1,LDNUCL)
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<WEIGHT_RAD>>'',1X,<LDNUCL>(''NUC_'',I2.2,3X))')
     *                                               (I,I=1,LDNUCL)
      WRITE(NRESUL,'(15X,<LDNUCL>(F6.0,3X))') 
     *                                   (WEIRAD_PROTON(I),I=1,LDNUCL)
      WRITE(NRESUL,'(15X,<LDNUCL>(F6.0,3X),/)') 
     *                                   (WEIRAD_NEUTRS(I),I=1,LDNUCL)
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<RADII_INFO>> RMSEXP  RMSTHE'',
     *                            ''  EXPERR  DIFFER'')')
      
      WRITE(NRESUL,'(15X,F6.4,2X,F6.4,2X,F6.4,2X,E11.4/)')
     *                                             RMSEXP_PRINTG,
     *                                             RMSTHE_PRINTG,
     *                                                    RMSERR,
     *                               RMSTHE_PRINTG-RMSEXP_PRINTG
C
C=======================================================================
C 
      WRITE(NRESUL,'(''<<ERROR_INFO>> MX_ABS  RMSVAL  RMSGLO'')')
      
      WRITE(NRESUL,'(15X,F6.3,2X,F6.3,2X,F6.3,/)')ERRMAX_PRINTG,
     *                                            RMSVAL_PRINTG,
     *                                            RMSGLO_PRINTG
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<XAXIS_TEXT>>'',/,16X,
     *                   ''Spherical Woods-Saxon Hamiltonian'',/)')
          
      WRITE(NRESUL,'(''<<YAXIS_TEXT>>'',/,16X,
     *                   ''Single Particle Energies'',/)')
          
      WRITE(NRESUL,'(''<<SIDE_TEXTS>>'')')
          
      WRITE(NRESUL,'(16X,''Id.:~$N_{\\rm r-rest}='',I4,'',\\,'',
     *                   ''N_{\\rm f-eval}='',I5,'',\\,\\chi^2='',F10.4,
     *                       '',\\,\\nabla\\chi^2='',F10.4,''$'',/)')
     *                         LDRAND,IEVALU_PRINTG,
     *                                CHISQU_PRINTG,CHIGRD_PRINTG
      WRITE(NRESUL,'(16X,''~~~~~${\\rm IFDENS}= '',I1,'',\\,'',
     *                         ''{\\rm IF-RAD}= '',I1,/)')IFDENS,IF_RAD
C
C=======================================================================
C     
      WRITE(NRESUL,'(16X,30(''=''),/)')
          
      WRITE(NRESUL,'(''<<X_AX_PARAM>>  XMINIM_FIG  XMAXIM_FIG  '',
     *                   ''X_STEP_FIG'')')
          
      WRITE(NRESUL,'(16X,3(F10.2,2X),/)')
     *                         XMIN_T,XMAX_E,(XMAX_E-XMIN_E)
     
      WRITE(NRESUL,'(''<<Y_AX_PARAM>>  YMINIM_FIG  YMAXIM_FIG  '',
     *                   ''Y_STEP_FIG'')')
          
      WRITE(NRESUL,'(16X,3(F10.2,2X),/)')
     *                         YMINIM,YMAXIM,(YMAXIM-YMINIM)
     
      WRITE(NRESUL,'(16X,30(''=''),/)')
C
C=======================================================================
C
      NCURVE=LEVEXP*2
      NTESTG=0
      NUMB_POINT=2
          
      WRITE(NRESUL,'(''<<NUM_LEVELS>>'',2X,''LEVNUM'',2X,
     *                   ''NUMB_POINT'')')
          
      WRITE(NRESUL,'(16X,I6,2X,I6/)')LEVEXP,NUMB_POINT
          
      WRITE(NRESUL,'(''<<NO_OF_CURV>>  NUMB_CURVE  IF_BULLETS  '',
     *                   ''IF_HISTOGS  IF_OVERFITING'')')
          
      WRITE(NRESUL,'(16X,4(I6,6X))')NCURVE,NTESTG,NTESTG,NTESTG
C
C=======================================================================
C         
      ICOUNT_CURVES=0
      I_COLO=0
          
      DO IEXPER=1,LEVEXP
        DO ITHEOR=1,LEVTHE_PRINTG
C
          IF (LABEXP(IEXPER).EQ.LABTHE_PRINTG(ITHEOR)) THEN
     
              ICOUNT_CURVES=ICOUNT_CURVES+1
              
              AUXLAB=LABEXP(IEXPER)
                 
              CALL LATEXS_LABELS(AUXLAB,LABTEX)
     
              WRITE(NRESUL,'(''<<>>'')')
          
              WRITE(NRESUL,'(''<<CURVE_'',I4.4,''>>'',2X,
     *                       ''THICK_LINE  STYLE_LINE  '',
     *                       ''COLOR_LINE  TYPE_POINT'')')ICOUNT_CURVES
          
              WRITE(NRESUL,'(16X,4(I6,6X))')ITHICK(ICOUNT_CURVES),
     *                                      ISTYLE,I_COLO,I_TYPE
              
              WRITE(NRESUL,'(15X,F7.3,3X,F7.3,4X,A11)')
     *                  XMIN_T,ENETHE_PRINTG(ITHEOR),LABTEX
              WRITE(NRESUL,'(15X,F7.3,3X,F7.3,4X,A11)')
     *                  XMAX_T,ENETHE_PRINTG(ITHEOR),LABTEX
             
          END IF
                
        END DO
      END DO
         
      DO IEXPER=1,LEVEXP
        DO ITHEOR=1,LEVTHE_PRINTG
                
          IF (LABEXP(IEXPER).EQ.LABTHE_PRINTG(ITHEOR)) THEN
     
              ICOUNT_CURVES=ICOUNT_CURVES+1
              
              AUXLAB=LABEXP(IEXPER)
                 
              CALL LATEXS_LABELS(AUXLAB,LABTEX)
     
              WRITE(NRESUL,'(''<<>>'')')
          
              WRITE(NRESUL,'(''<<CURVE_'',I4.4,''>>'',2X,
     *                       ''THICK_LINE  STYLE_LINE  '',
     *                       ''COLOR_LINE  TYPE_POINT'')')ICOUNT_CURVES
          
              WRITE(NRESUL,'(16X,4(I6,6X))')ITHICK(ICOUNT_CURVES),
     *                                      ISTYLE,I_COLO,I_TYPE
              
              WRITE(NRESUL,'(15X,F7.3,3X,F7.3,4X,A11)')
     *                  XMIN_E,EXPEXP(IEXPER),LABTEX
              WRITE(NRESUL,'(15X,F7.3,3X,F7.3,4X,A11)')
     *                  XMAX_E,EXPEXP(IEXPER),LABTEX
             
          END IF
                
        END DO
      END DO
C
C=======================================================================
C          
      WRITE(NRESUL,'(''<<GO_GETTHEM>>'')')
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(''Exiting WRITING_ENELEV'',/)')
C
C=======================================================================
C      
      RETURN
      END 
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DENSIT_OUTPUT(CURNAM,N_CURV,ND_MAX,X_CURV,Y_CURV,
     *                         L_CURV,ISOSPI,IZ_NUM,IN_NUM,MAIN_T,
     *                         XTITLE,YTITLE,ISPLIT,INUCLI,LDRAND)
      
      INCLUDE 'MATDIM/NDMESH.f'
      INCLUDE 'MATDIM/NDSPEC.f'
      INCLUDE 'MATDIM/NDPARS.f'
      INCLUDE 'MATDIM/NDNUCL.f'
      INCLUDE 'MATDIM/NDCOLO.f'
      INCLUDE 'MATDIM/NDTITL.f'
      
      CHARACTER
     *          NUCSYM*6,INPSYM*6,TYPCHI*6,VERSIO*3
      CHARACTER
     *          FILNAM*256,L_CURV*100,NUCNAM*6,TITLES*12,FITNUC*2,
     *          ISONAM*002,AUXTIT*12,TITTEX*30,TEXLAM*20,TITPAR*13,
     *          CURNAM*020,MAIN_T*256,XTITLE*256,YTITLE*256
      CHARACTER
     *          FILNAM_IFITED*14,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*2,TITLES_LATEXS*050,
     *                          NUCNAM_LATEXS*010
      DIMENSION
     *          ND_MAX(1:NDSPEC),
     *          X_CURV(1:NDMESH,1:NDSPEC),
     *          Y_CURV(1:NDMESH,1:NDSPEC),
     *          L_CURV(1:NDMESH,1:NDSPEC)
      DIMENSION 
     *          TITPAR(1:NDPARS),
     *          PARPOT_AUXILI(1:NDPARS)
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL)
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
      COMMON
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON
     *       /POTPOT/ PARPOT(1:NDPARS)
      COMMON
     *       /MESHIN/ I_MESH(1:NDPARS),
     *                XMIN_I(1:NDPARS),
     *                XMAX_I(1:NDPARS),
     *                MAXPAR(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /DELTAF/ DFACTO(1:NDNUCL,1:2),
     *       /BCSDEL/ DELT_2(1:NDNUCL,1:2)
      COMMON
     *       /BCSLAM/ XLAMBD_PROTON(1:NDNUCL),
     *                XLAMBD_NEUTRS(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
      COMMON
     *       /ATTRIB/ ISTYLE,I_TYPE,ICOLOR(1:NDCOLO),ITHICK(1:NDCOLO)
      COMMON
     *       /VPROEF/ V0EFFC
      COMMON
     *       /LAMUNI/ UNITLA
      COMMON
     *       /FITTED/ IFITED
      COMMON
     *       /CTSHIF/ V0SHIF_PROTON(1:NDNUCL),
     *                V0SHIF_NEUTRS(1:NDNUCL)
      COMMON
     *       /VERSIN/ VERSIO
      COMMON
     *       /AUXPOT/ VKACEN_PROTON,RKACEN_PROTON,AKACEN_PROTON,
     *                VKASOR_PROTON,RKASOR_PROTON,AKASOR_PROTON,
     *                VKAEFM_PROTON,RKAEFM_PROTON,AKAEFM_PROTON,
     *                                            V0UNIT_PROTON,
     *                VKACEN_NEUTRS,RKACEN_NEUTRS,AKACEN_NEUTRS,
     *                VKASOR_NEUTRS,RKASOR_NEUTRS,AKASOR_NEUTRS,
     *                VKAEFM_NEUTRS,RKAEFM_NEUTRS,AKAEFM_NEUTRS,
     *                                            V0UNIT_NEUTRS,
     *                                                   RKACOU,
     *                              ALAMPP,ALAMPN,ALAMNP,ALAMNN,
     *                              TLAMPP,TLAMPN,TLAMNP,TLAMNN,
     *                              CLAMPP,CLAMPN,CLAMNP,CLAMNN
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' /
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(/,''Entering DENSIT_OUTPUT'')')
      
      IF (LOGWRI.GT.0) 
     *    WRITE(LOGFIL,'(/,''IFITED='',I2,'' IZ= '',I3,'' IN= '',I3,/)') 
     *                  IFITED,NUMB_Z(INUCLI),NUMB_N(INUCLI)
C
C=======================================================================
C
      YMINIM=+1.0E+10
      YMAXIM=-1.0E+10
      
      DO I_CURV=1,N_CURV
         DO IPOINT=1,ND_MAX(I_CURV)
            IF (Y_CURV(IPOINT,I_CURV).LT.YMINIM) THEN
                YMINIM=Y_CURV(IPOINT,I_CURV)
            END IF
            IF (Y_CURV(IPOINT,I_CURV).GT.YMAXIM) THEN
                YMAXIM=Y_CURV(IPOINT,I_CURV)
            END IF
         END DO
      END DO
C
C=======================================================================
C
      XMINIM=+1.0E+10
      XMAXIM=-1.0E+10
      
      DO I_CURV=1,N_CURV
         DO IPOINT=1,ND_MAX(I_CURV)
            IF (X_CURV(IPOINT,I_CURV).LT.XMINIM) THEN
                XMINIM=X_CURV(IPOINT,I_CURV)
            END IF
            IF (X_CURV(IPOINT,I_CURV).GT.XMAXIM) THEN
                XMAXIM=X_CURV(IPOINT,I_CURV)
            END IF
         END DO
      END DO
C
C=======================================================================
C
      NRESUL=60
C      
      IF (ISOSPI.EQ.1) ISONAM='-P'
      IF (ISOSPI.EQ.0) ISONAM='-N'
      IF (ISOSPI.EQ.2) ISONAM='-B'
C
C=======================================================================
C          
      IF (IFITED.EQ.2) FILNAM_IFITED='OneRun/OneRun-'  !from single run
      IF (IFITED.EQ.1) FILNAM_IFITED='Fitted/Fitted-'
      IF (IFITED.EQ.0) FILNAM_IFITED='Predic/Predic-'
C
C=======================================================================
C 
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
      
      I1=3*KACTIV
      
      WRITE(FILNAM_NUCFIT,'(''_'',<NUCACT>(A2,''-''))')
     *                      (FITNUC_AUXILI(I),I=1,NUCACT)
C
C=======================================================================
C
      WRITE(NUCNAM,'(A6)') NUCSYM(INUCLI)
      
      J1=1
      J2=6
      IF (NUCNAM(1:1).EQ.' ') J1=2
      IF (NUCNAM(2:2).EQ.' ') J1=3
      IF (NUCNAM(3:3).EQ.' ') J1=4
C
C=======================================================================
C      
      IF (IFDENS.EQ.0) THEN 
C      
          WRITE(FILNAM,'(''DensitCurves/IFDENS-0/'',A14,A5,A,A2,A,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A3,''.dat'')') 
     *                                    FILNAM_IFITED,CURNAM,
     *                                    NUCNAM(J1:J2),ISONAM,
     *                                    FILNAM_NUCFIT(01:I1),
     *                                    IFDENS,IFTENS,IF_PAI,
     *                                    IF_RAD,IF_INV,
     *                                    IFDEEP,IFPRON,LDRAND,
     *                                                  VERSIO
C     
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.1.AND.IFTENS.EQ.0) THEN 
C
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                            IFPAR1,IFPAR2,IFPAR3,IFPAR4
C      
          WRITE(FILNAM,'(''DensitCurves/IFDENS-1_IFTENS-'',I1,''/'',
     *                                           A14,A5,A,A2,A,    
     *                         ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                         ''_IF-PAI-'',I1
     *                         ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                         ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                         ''_LDRAND-'',I5.5,A15,''_'',A3,
     *                                               ''.dat'')') 
     *                      IFTENS,FILNAM_IFITED,CURNAM,NUCNAM(J1:J2),
     *                      ISONAM,FILNAM_NUCFIT(01:I1),
     *                      IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                      IFDEEP,IFPRON,LDRAND,TEXLAM,VERSIO
C     
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.1.AND.IFTENS.EQ.1) THEN 
C          
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                            IFPAR1,IFPAR2,IFPAR3,IFPAR4
C      
          WRITE(FILNAM,'(''DensitCurves/IFDENS-1_IFTENS-'',I1,''/'',
     *                                           A14,A5,A,A2,A,    
     *                         ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                         ''_IF-PAI-'',I1,
     *                         ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                         ''_ITENSR-'',I1,
     *                         ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                         ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                         ''_LDRAND-'',I5.5,A15,''_'',A3,
     *                                               ''.dat'')') 
     *                      IFTENS,FILNAM_IFITED,CURNAM,NUCNAM(J1:J2),
     *                      ISONAM,FILNAM_NUCFIT(01:I1),
     *                                    IFDENS,IFTENS,IF_PAI,
     *                                    ICENTT,ISORBT,ITENSR,
     *                             IF_RAD,IF_INV,IFDEEP,IFPRON,
     *                                           LDRAND,TEXLAM,
     *                                                  VERSIO
C     
      END IF
C
C=======================================================================
C
      OPEN(NRESUL,FILE=FILNAM,STATUS='UNKNOWN')
C
C=======================================================================
C      
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
C                    
          IPARAM_AUXILI=0
          
          DO IPARAM=1,6
             IPARAM_AUXILI=IPARAM_AUXILI+1
             TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'PROTON'
             PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT(IPARAM)
          END DO
          
          NINITI=1
          NFINAL=IPARAM_AUXILI
          ITOTAL=IPARAM_AUXILI

          NINCNT=1
          NFICNT=NFINAL/2
          
          NIN_SO=NFICNT+1
          NFI_SO=NFINAL
          
      END IF
C
C=======================================================================
C      
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
C                    
          IPARAM_AUXILI=0
          
          DO IPARAM=21,26
             IPARAM_AUXILI=IPARAM_AUXILI+1
             TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'NEUTRS'
             PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT(IPARAM)
          END DO
          
          NINITI=1
          NFINAL=IPARAM_AUXILI
          ITOTAL=IPARAM_AUXILI
          
          NINCNT=1
          NFICNT=NFINAL/2
          
          NIN_SO=NFICNT+1
          NFI_SO=NFINAL
          
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.0 .AND. ISOSPI.EQ.2) THEN
C
         IPARAM_AUXILI=0
C          
          DO IPARAM=1,6
             IPARAM_AUXILI=IPARAM_AUXILI+1
             TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'PROTON'
             PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT(IPARAM)
          END DO 
C
          NINCNT_PROTON=1
          NFICNT_PROTON=IPARAM_AUXILI/2
          
          NIN_WS_PROTON=IPARAM_AUXILI/2+1
          NFI_WS_PROTON=IPARAM_AUXILI
C          
          DO IPARAM=21,26
             IPARAM_AUXILI=IPARAM_AUXILI+1
             TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'NEUTRS'
             PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT(IPARAM)
          END DO 
C          
          NINCNT_NEUTRS=NFI_WS_PROTON+1
          NFICNT_NEUTRS=NINCNT_NEUTRS+2
          
          NIN_WS_NEUTRS=NFICNT_NEUTRS+1
          NFI_WS_NEUTRS=IPARAM_AUXILI
C          
          IFNEUT=0
          IFPROT=0
C
      END IF
C
C=======================================================================
C
      IF (IFDENS.EQ.1) THEN   
          
          IPARAM_AUXILI=0
C          
          DO IPARAM=1,6
             IPARAM_AUXILI=IPARAM_AUXILI+1
             TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'PROTON'
             PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT(IPARAM)
             IF (IPARAM.GE.4) PARPOT_AUXILI(IPARAM_AUXILI)=9999.
          END DO 
C
          NINCNT_PROTON=1
          NFICNT_PROTON=IPARAM_AUXILI/2
          
          NIN_WS_PROTON=IPARAM_AUXILI/2+1
          NFI_WS_PROTON=IPARAM_AUXILI
C          
          DO IPARAM=21,26
             IPARAM_AUXILI=IPARAM_AUXILI+1
             TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:8)//'NEUTRS'
             PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT(IPARAM)
             IF (IPARAM.GE.24) PARPOT_AUXILI(IPARAM_AUXILI)=9999.
          END DO 
C          
          NINCNT_NEUTRS=NFI_WS_PROTON+1
          NFICNT_NEUTRS=NINCNT_NEUTRS+2
          
          NIN_WS_NEUTRS=NFICNT_NEUTRS+1
          NFI_WS_NEUTRS=IPARAM_AUXILI
C         
          DO IPARAM=39,42
             IPARAM_AUXILI=IPARAM_AUXILI+1
             TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:9)
             PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT(IPARAM)/UNITLA
          END DO
C          
          NIN_SO_LAMBDA=NFI_WS_NEUTRS+1
          NFI_SO_LAMBDA=IPARAM_AUXILI
C          
          IF (IFTENS.EQ.1.AND.ISORBT.EQ.1) THEN
              DO IPARAM=43,46
                 IPARAM_AUXILI=IPARAM_AUXILI+1
                 TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:9)
                 PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT(IPARAM)/UNITLA
              END DO
              NIN_SO_TENLAM=IPARAM_AUXILI-3
              NFI_SO_TENLAM=IPARAM_AUXILI
          END IF
C          
          IF (IFTENS.EQ.1.AND.ICENTT.EQ.1) THEN
              DO IPARAM=47,50
                 IPARAM_AUXILI=IPARAM_AUXILI+1
                 TITPAR(IPARAM_AUXILI)=TITLES(IPARAM)(2:9)
                 PARPOT_AUXILI(IPARAM_AUXILI)=PARPOT(IPARAM)/UNITLA
              END DO
              NINCNT_TENLAM=IPARAM_AUXILI-3
              NFICNT_TENLAM=IPARAM_AUXILI
          END IF
C          
          NINITI=1
          NFINAL=IPARAM_AUXILI
          ITOTAL=IPARAM_AUXILI
C          
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                            IFPAR1,IFPAR2,IFPAR3,IFPAR4
C          
      END IF   
C
C=======================================================================
C      
      DO I_CURV=1,N_CURV
         DO IPOINT=1,ND_MAX(I_CURV)
            DO K=1,100
               IF (L_CURV(IPOINT,I_CURV)(K:K).EQ.'/') THEN
                   L_CURV(IPOINT,I_CURV)(K:K)='@'
               END IF
            END DO
         END DO
      END DO
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<CODEVERSIO>> VERSIO'')')
C
      WRITE(NRESUL,'(16X,A3)') VERSIO
C
C=======================================================================
C
      WRITE(NRESUL,'(/,''<<MAIN_TITLE>>'')')
C      
      WRITE(NRESUL,'(15X,A,/)') MAIN_T
C_______________________________________________________________________
C     
      WRITE(NRESUL,'(''<<NUCLIDINFO>>'',1X,''NUMB_Z'',2X,''NUMB_N'')')
C
      WRITE(NRESUL,'(15X,I3,6X,I3,/)') IZ_NUM,IN_NUM
C
      A_MASS=IZ_NUM+IN_NUM
C_______________________________________________________________________
C
      WRITE(NRESUL,'(''<<NoNUCACTIV>>'',1X,''NUCACT'')')
C      
      WRITE(NRESUL,'(15X,I3,/)') NUCACT
C_______________________________________________________________________
C
      WRITE(NRESUL,'(''<<EXPER_FILE>>'',1X,''IFDEEP'',2X
     *                                     ''IFPRON'')')
      
      WRITE(NRESUL,'(15X,2(I3,6X),/)') IFDEEP,IFPRON
C_______________________________________________________________________
C
      WRITE(NRESUL,'(''<<POTEN_INFO>>'',1X,''ISOSPI'',2X,''IFDENS'',
     *                                  2X,''IFTENS'',2X,''IF_PAI'')')
C      
      WRITE(NRESUL,'(15X,4(I3,5X),/)') ISOSPI,IFDENS,IFTENS,IF_PAI
C_______________________________________________________________________
C
      WRITE(NRESUL,'(''<<TENSR_INFO>>'',1X,''ICENTT'',2X
     *                                     ''ISORBT'',2X,''ITENSR'')')
C      
      WRITE(NRESUL,'(15X,3(I3,5X),/)') ICENTT,ISORBT,ITENSR
C_______________________________________________________________________
C
      WRITE(NRESUL,'(''<<TAKEN_CHI2>> IF_SPE  IF_RAD  IF_GAP  '',
     *               ''IF_FER  IF_DEN  IF_RHO  IF_INV'')')
      WRITE(NRESUL,'(15X,7(I3,5X),/)')IF_SPE,IF_RAD,IF_GAP,IF_FER,
     *                                       IF_DEN,IF_RHO,IF_INV
C_______________________________________________________________________
C          
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
          
          WRITE(NRESUL,'(''<<CENTRL_PRO>>'',1X,3(A13,2X))')
     *                          (TITPAR(I),I=NINCNT,NFICNT)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                   VKACEN_PROTON,RKACEN_PROTON/A_MASS**(1./3.),
     *                   AKACEN_PROTON
     
          WRITE(NRESUL,'(''<<SOR-WS_PRO>>'',1X,3(A13,2X))')
     *                          (TITPAR(I),I=NIN_SO,NFI_SO)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                   VKASOR_PROTON,RKASOR_PROTON/A_MASS**(1./3.),
     *                   AKASOR_PROTON
          
      END IF
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
          
          WRITE(NRESUL,'(''<<CENTRL_NEU>>'',1X,3(A13,4X))')
     *                          (TITPAR(I),I=NINCNT,NFICNT)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                   VKACEN_NEUTRS,RKACEN_NEUTRS/A_MASS**(1./3.),
     *                   AKACEN_NEUTRS
     
          WRITE(NRESUL,'(''<<SOR-WS_NEU>>'',1X,3(A13,4X))')
     *                          (TITPAR(I),I=NIN_SO,NFI_SO)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                   VKASOR_NEUTRS,RKASOR_NEUTRS/A_MASS**(1./3.),
     *                   AKASOR_NEUTRS
          
      END IF
C_______________________________________________________________________
C
      IF (IFDENS.EQ.0 .AND. ISOSPI.EQ.2) THEN
C
          WRITE(NRESUL,'(''<<CENTRL_PRO>>'',1X,3(A13,2X))')
     *                 (TITPAR(I),I=NINCNT_PROTON,NFICNT_PROTON)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                 VKACEN_PROTON,RKACEN_PROTON/A_MASS**(1./3.),
     *                 AKACEN_PROTON
C
          WRITE(NRESUL,'(''<<CENTRL_NEU>>'',1X,3(A13,2X))')
     *                 (TITPAR(I),I=NINCNT_NEUTRS,NFICNT_NEUTRS)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                   VKACEN_NEUTRS,RKACEN_NEUTRS/A_MASS**(1./3.),
     *                   AKACEN_NEUTRS
C
          WRITE(NRESUL,'(''<<SOR-WS_PRO>>'',1X,3(A13,2X))')
     *                  (TITPAR(I),I=NIN_WS_PROTON,NFI_WS_PROTON)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)')
     *                   VKASOR_PROTON,RKASOR_PROTON/A_MASS**(1./3.),
     *                   AKASOR_PROTON
C
          WRITE(NRESUL,'(''<<SOR-WS_NEU>>'',1X,3(A13,2X))')
     *                 (TITPAR(I),I=NIN_WS_NEUTRS,NFI_WS_NEUTRS)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                   VKASOR_NEUTRS,RKASOR_NEUTRS/A_MASS**(1./3.),
     *                   AKASOR_NEUTRS
C
      END IF
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.1) THEN
C
          WRITE(NRESUL,'(''<<CENTRL_PRO>>'',1X,3(A13,2X))')
     *                 (TITPAR(I),I=NINCNT_PROTON,NFICNT_PROTON)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                 VKACEN_PROTON,RKACEN_PROTON/A_MASS**(1./3.),
     *                 AKACEN_PROTON
C
          WRITE(NRESUL,'(''<<CENTRL_NEU>>'',1X,3(A13,2X))')
     *                 (TITPAR(I),I=NINCNT_NEUTRS,NFICNT_NEUTRS)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                 VKASOR_PROTON,RKASOR_PROTON/A_MASS**(1./3.),
     *                 AKASOR_PROTON
C
          WRITE(NRESUL,'(''<<SOR-WS_PRO>>'',1X,3(A13,2X))')
     *                  (TITPAR(I),I=NIN_WS_PROTON,NFI_WS_PROTON)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                 VKACEN_NEUTRS,RKACEN_NEUTRS/A_MASS**(1./3.),
     *                 AKACEN_NEUTRS
C
          WRITE(NRESUL,'(''<<SOR-WS_NEU>>'',1X,3(A13,4X))')
     *                 (TITPAR(I),I=NIN_WS_NEUTRS,NFI_WS_NEUTRS)
          WRITE(NRESUL,'(15X,3(F13.4,2X),/)') 
     *                 VKASOR_NEUTRS,RKASOR_NEUTRS/A_MASS**(1./3.),
     *                 AKASOR_NEUTRS
          
          WRITE(NRESUL,'(''<<SOR_DENSIT>>'',1X,4(A13,4X))')
     *                 (TITPAR(I),I=NIN_SO_LAMBDA,NFI_SO_LAMBDA)
          WRITE(NRESUL,'(15X,4(F13.4,2X),/)') 
     *                 (PARPOT_AUXILI(I),I=NIN_SO_LAMBDA,NFI_SO_LAMBDA)
          
          IF (IFTENS.EQ.1 .AND. ISORBT.EQ.1) THEN
              WRITE(NRESUL,'(''<<SOR_TENSOR>>'',1X,4(A13,4X))')
     *                 (TITPAR(I),I=NIN_SO_TENLAM,NFI_SO_TENLAM)
              WRITE(NRESUL,'(15X,4(F13.4,2X),/)') 
     *                 (PARPOT_AUXILI(I),I=NIN_SO_TENLAM,NFI_SO_TENLAM)
          END IF
          
          IF (IFTENS.EQ.1 .AND. ICENTT.EQ.1) THEN
              WRITE(NRESUL,'(''<<CNT_TENSOR>>'',1X,4(A13,4X))')
     *                 (TITPAR(I),I=NINCNT_TENLAM,NFICNT_TENLAM)
              WRITE(NRESUL,'(15X,4(F13.4,2X),/)') 
     *                 (PARPOT_AUXILI(I),I=NINCNT_TENLAM,NFICNT_TENLAM)
          END IF
C
      END IF
C
C=======================================================================
C 
      IF (ISOSPI.EQ.1) THEN
          WRITE(NRESUL,'(''<<V0P_EFFECT>>  V0EFFC'')')
          WRITE(NRESUL,'(16X,F8.4,/)') V0EFFC
      END IF
C
C=======================================================================
C
      IF (IFITED.EQ.2) THEN
          WRITE(NRESUL,'(''<<SHIFTCENTR>>'',1X,''V0SHIF_PROTON'',
     *                                      2X,''V0SHIF_NEUTRS'')')
          WRITE(NRESUL,'(15X,F13.4,2X,F13.4,/)')V0SHIF_PROTON(INUCLI),
     *                                          V0SHIF_NEUTRS(INUCLI)
      END IF
C
C=======================================================================
C
      WRITE(NRESUL,'(''<<UNITLAMBDA>>'',2X,''UNITLA'')')
      WRITE(NRESUL,'(16X,F6.2,/)') UNITLA
C
C=======================================================================
C 
      IF (IF_PAI.EQ.1) THEN
C
          WRITE(NRESUL,'(''<<DELTAFACTO>>'',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(3X,A2,''   '',$)') FITNUC(JNUCLI)
             END IF
          END DO
          WRITE(NRESUL,'()')
          WRITE(NRESUL,'(14X,'' '',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(F6.4,''  '',$)') DFACTO(JNUCLI,1)
             END IF
          END DO
          WRITE(NRESUL,'()')
          WRITE(NRESUL,'(14X,'' '',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(F6.4,''  '',$)') DFACTO(JNUCLI,2)
             END IF
          END DO
C_______________________________________________________________________
C
          WRITE(NRESUL,'()')
          WRITE(NRESUL,'(/,''<<BCS_DELTA2>>'',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(3X,A2,''   '',$)') FITNUC(JNUCLI)
             END IF
          END DO
          WRITE(NRESUL,'()')
          WRITE(NRESUL,'(14X,'' '',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(F6.4,''  '',$)') DELT_2(JNUCLI,1)
             END IF
          END DO
          WRITE(NRESUL,'()')
          WRITE(NRESUL,'(14X,'' '',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(F6.4,''  '',$)') DELT_2(JNUCLI,2)
             END IF
          END DO
C_______________________________________________________________________
C
          WRITE(NRESUL,'()')
          WRITE(NRESUL,'(/,''<<BCS_XLAMBD>>'',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(3X,A2,''   '',$)') FITNUC(JNUCLI)
             END IF
          END DO
          WRITE(NRESUL,'()')
          WRITE(NRESUL,'(10X,'' '',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(F10.4,''  '',$)') XLAMBD_PROTON(JNUCLI)
             END IF
          END DO
          WRITE(NRESUL,'()')
          WRITE(NRESUL,'(10X,'' '',$)')
          DO JNUCLI=1,LDNUCL
             IF (ITAKNU(JNUCLI).EQ.1) THEN
                 WRITE(NRESUL,'(F10.4,''  '',$)') XLAMBD_NEUTRS(JNUCLI)
             END IF
          END DO
          WRITE(NRESUL,'()')
          WRITE(NRESUL,'()')
c          
      END IF
C
C=======================================================================
C      
      WRITE(NRESUL,'(''<<XAXIS_TEXT>>'',/,15x,A,/)') XTITLE
C      
      WRITE(NRESUL,'(''<<YAXIS_TEXT>>'',/,15x,A,/)') YTITLE
C      
      WRITE(NRESUL,'(''<<SIDE_TEXTS>>'')')
C      
      WRITE(NRESUL,'(15X,''~~~'',$)')
C
      IF (IFDENS.EQ.1) WRITE(NRESUL,'(''${\\rm DENS}\\,\\vert\\,$'',$)')
      IF (IFTENS.EQ.1) WRITE(NRESUL,'(''${\\rm TENS}\\,\\vert\\,$'',$)')
      IF (IF_PAI.EQ.1) WRITE(NRESUL,'(''${\\rm PAIR}\\,\\vert\\,$'',$)')
      IF (IF_RAD.EQ.1) WRITE(NRESUL,'(''${\\rm RADI}\\,\\vert\\,$'',$)')
      IF (IFPRON.EQ.1) WRITE(NRESUL,'(''${\\rm PRON}\\,\\vert\\,$'',$)')
      IF (IFDEEP.EQ.1) WRITE(NRESUL,'(''${\\rm DEEP}\\,\\vert\\,$'',$)')
C
      WRITE(NRESUL,'(''$\\Delta V_{0,p}^{cent}='',f9.2,''\\,\\vert\\,'',
     *                ''\\Delta V_{0,n}^{cent}='',f0.2,''$'')')
     *                      V0SHIF_PROTON(INUCLI),V0SHIF_NEUTRS(INUCLI)
C     
      IF (IFTENS.EQ.1) THEN
          WRITE(NRESUL,'(15X,''~~~~~~~~'',$)')
          IF (ISORBT.EQ.1) 
     *        WRITE(NRESUL,'(''${\\rm TSOR}\\,\\vert\\,$'',$)')
          IF (ICENTT.EQ.1) 
     *        WRITE(NRESUL,'(''${\\rm TCNT}\\,\\vert\\,$'',$)')
          IF (ITENSR.EQ.1) 
     *        WRITE(NRESUL,'(''${\\rm TTOT}\\,\\vert\\,$'',$)')
          WRITE(NRESUL,'()')
      END IF
C_______________________________________________________________________
C
      IF (IF_PAI.EQ.1) THEN
          WRITE(NRESUL,'(15X,''~~~${\\rm DFACTO_p}='',F6.2,'',\\,'',
     *                   ''\\Delta^2_p='',f6.2,''~{\\rm MeV^2},\\,'',
     *                   ''\\lambda_p= '',f6.2,''~{\\rm MeV}$'')')
     *                       DFACTO(INUCLI,1),DELT_2(INUCLI,1),
     *                                 XLAMBD_PROTON(INUCLI)
C
          WRITE(NRESUL,'(15X,''~~~${\\rm DFACTO_n}='',F6.2,'',\\,'',
     *                   ''\\Delta^2_n='',f6.2,''~{\\rm MeV^2},\\,'',
     *                   ''\\lambda_n= '',f6.2,''~{\\rm MeV}$'')')
     *                       DFACTO(INUCLI,2),DELT_2(INUCLI,2),
     *                                 XLAMBD_NEUTRS(INUCLI)
      END IF  
C
C=======================================================================
C     
      WRITE(NRESUL,'(/,15X,30(''=''),/)')
          
      WRITE(NRESUL,'(''<<X_AX_PARAM>> XMINIM_FIG  XMAXIM_FIG  '',
     *                   ''X_STEP_FIG'')')
          
      WRITE(NRESUL,'(15X,3(F10.2,2X),/)')XMINIM,XMAXIM,(XMAXIM-XMINIM)
     
      WRITE(NRESUL,'(''<<Y_AX_PARAM>> YMINIM_FIG  YMAXIM_FIG  '',
     *                   ''Y_STEP_FIG'')')
          
      WRITE(NRESUL,'(15X,3(F10.2,2X),/)')
     *                         YMINIM,YMAXIM,(YMAXIM-YMINIM)
     
      WRITE(NRESUL,'(15X,30(''=''),/)')
C
C=======================================================================
C
      IF (ISPLIT.EQ.1) THEN
          I_COLM=1
          I_LEFT=0
          I_RIGH=0
      END IF
C
      IF (ISPLIT.EQ.0) THEN
          I_COLM=0
          I_LEFT=1
          I_RIGH=0
      END IF
C      
      WRITE(NRESUL,'(''<<WHATLEGEND>>'',1X,''COLM_LABEL'',2X,
     *               ''LEFT_LABEL'',2X,''RIGH_LABEL'')')
      WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5)')I_COLM,I_LEFT,I_RIGH
C
C=======================================================================
C      
      IFBULL=0
      IFHIST=0
      IFOVER=0
C      
      WRITE(NRESUL,'(/,''<<NO_OF_CURV>>'',1X,''NUMB_CURVE'',2X,
     *                 ''IF_SPLITIN'',2X,''IF_BULLETS'',2X,
     *                 ''IF_HISTOGS'',2X,''IF_OVERFITING'')')
      WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5,7X,I5,7X,I5)')N_CURV,ISPLIT,
     *                                         IFBULL,IFHIST,IFOVER
C
C=======================================================================
C
      ISTYLE=0
      J_TYPE=I_TYPE
      
      DO I_CURV=1,N_CURV
          
         ICOLOR_AUXIL=ICOLOR(I_CURV)
         
         IF (ISPLIT.EQ.1) THEN
         
             ISTYLE=2
         
             IF (MOD(I_CURV+1,3).EQ.0) ISTYLE=1
             IF (MOD(I_CURV,3).EQ.0) ISTYLE=0
         
             IF (I_CURV.EQ.N_CURV) THEN
                 ISTYLE=0
                 ICOLOR(I_CURV)=0
             END IF
         
         END IF
         
         IF (ISPLIT.EQ.0) THEN
             
             ICOLOR(I_CURV)=ICOLOR(I_CURV+2*(I_CURV-1)) !To choose the
C                                                        dark color of
C                                                        of the triplet            
         END IF
         
         WRITE(NRESUL,'(''<<>>'')')
         WRITE(NRESUL,'(''<<CURVE_'',I4.4,''>>'',1X,
     *                  ''THICK_LINE'',2X,''STYLE_LINE'',2X,
     *                  ''COLOR_LINE'',2X,''TYPE_POINT'')')I_CURV
         WRITE(NRESUL,'(15X,I5,7X,I5,7X,I5,7X,I5)')ITHICK(I_CURV),
     *                                             ISTYLE,
     *                                             ICOLOR(I_CURV),
     *                                             J_TYPE
         WRITE(NRESUL,'(15X,''NUMB_POINT'',/,15X,I5)')ND_MAX(I_CURV)
         
         DO IPOINT=1,ND_MAX(I_CURV)
            
            WRITE(NRESUL,'(15X,F10.4,4X,E12.4,4X,A100)') 
     *                           X_CURV(IPOINT,I_CURV),
     *                           Y_CURV(IPOINT,I_CURV),
     *                           L_CURV(IPOINT,I_CURV)
            
         END DO
         
         J_TYPE=J_TYPE+2
C         
         ICOLOR(I_CURV)=ICOLOR_AUXIL
         
      END DO
C
C=======================================================================
C      
      WRITE(NRESUL,'(/,''<<GO_GETTHEM>>'',/)')
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(''Exiting DENSIT_OUTPUT'',/)')
C
C=======================================================================
C      
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE WRITIN_CHIMAP(NDMESH,LDRAND,ICOUNT_OFPARS,
     *                         TITPAR,TITMSH,RMSPRO_MINIMI,
     *                         RMSPRO_MAXIMA,RMSNEU_MINIMI,
     *                         RMSNEU_MAXIMA,MAXMSH,AXSMAP,
     *                         RMSMAP_PRONUC,RMSMAP_NEUNUC,
     *                         PARPOT_OFMESH,INDEXI,INUCLI)
C     
      INCLUDE  'MATDIM/NDNUCL.f'
      INCLUDE  'MATDIM/NDPARS.f'
      INCLUDE  'MATDIM/NDTITL.f'
      INCLUDE  'MATDIM/NDIM_M.f'
C      
      CHARACTER
     *          FILNAM*300,FILNAM_ENDING*3,INPSYM*6,TEXTRA*256
      CHARACTER
     *          TITLES*12,TITPAR*13,TITMSH*8,TITAUX*7
      CHARACTER
     *          FILNA2*256,FITNUC*2,FILNAM_NUCFIT*30,
     *          FITNUC_AUXILI*30,FILNA3*256,TITLES_NOTFIT*256,
     *          FILNAM_NOTTIT*256,TEXLAM*20
      CHARACTER
     *          TITLES_LATEXS*050,NUCNAM_TITLES*010
      CHARACTER
     *          TYPCHI*6,TAKCHI*3
      CHARACTER 
     *          NUCSYM*6,NUCSYM_AUXILI*6
      DIMENSION 
     *          TITPAR(1:NDPARS),
     *          TITMSH(1:NDPARS),
     *          TITAUX(1:NDPARS)
      DIMENSION
     *          TAKPAR(1:NDPARS),
     *          TAKCHI(1:NDNUCL)
      DIMENSION
     *          MAXMSH(1:NDPARS),
     *          AXSMAP(1:NDMESH,1:NDMESH)
      DIMENSION
     *          CHITOT_OFMESH(1:NDMESH,1:NDMESH),
     *          CHIPRO_OFMESH(1:NDMESH,1:NDMESH),
     *          CHINEU_OFMESH(1:NDMESH,1:NDMESH)
      DIMENSION
     *          PARPOT_OFMESH(1:NDMESH,1:NDMESH,1:NDPARS),
     *          PARPOT_AUXILI(1:NDPARS)
      DIMENSION
     *          IAUXIL(1:NDPARS),
     *          INDEXI(1:NDIM_M)
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL),
     *          TITLES_NOTFIT(1:NDPARS)
      DIMENSION
     *          RMSMAP_PRONUC(1:NDMESH,1:NDMESH,1:NDNUCL),
     *          RMSMAP_NEUNUC(1:NDMESH,1:NDMESH,1:NDNUCL)
C
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /MESHIN/ I_MESH(1:NDPARS),
     *                XMIN_I(1:NDPARS),
     *                XMAX_I(1:NDPARS),
     *                MAXPAR(1:NDPARS)
      COMMON
     *       /VLIMIT/ VMISTR(1:NDPARS),
     *                VMIMIN(1:NDPARS),
     *                VMIMAX(1:NDPARS),
     *                VMISTP(1:NDPARS)
      COMMON
     *       /NUCLEU/ IZ_FIX,IN_FIX,ISOSPI 
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR 
      COMMON
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /IFLAMB/ IFPAR1,IFPAR2,IFPAR3,IFPAR4,
     *                IFPAR5,IFPAR6,IFPAR7,IFPAR8,
     *                IFPA09,IFPA10,IFPA11,IFPA12
      COMMON 
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON  
     *       /VERSIN/ VERSIO
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' / 
C
C=======================================================================
C                Writing MAP results in a file  
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(''Entering WRITING_CHIMAP'')')
C
C=======================================================================
C
      INDEXP=0
C      
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
          DO IPARAM=1,6
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C      
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
          DO IPARAM=21,26
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C
      IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) THEN
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          IF (IFK_VS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=57   ! V_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=58   ! kappa V_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=4    ! V_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=24   ! V_o pure WS-SO neutrons
          END IF
C
          IF (IFK_RS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=59   ! r_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=60   ! kappa r_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=5    ! r_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=25   ! r_o pure WS-SO neutrons
          END IF
C
          IF (IFK_AS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=61   ! a_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=62   ! kappa a_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=6    ! a_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=26   ! a_o pure WS-SO neutrons
          END IF
C
      END IF
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.1) THEN
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          DO IPARAM=39,42         !lambdas Density-SO
             INDEXP=INDEXP+1
             IAUXIL(INDEXP)=IPARAM
          END DO
C
          IF (IFTENS.EQ.1 .AND. ISORBT.EQ.1) THEN
              DO IPARAM=43,46     !lambdas Tensor-SO
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
          IF (IFTENS.EQ.1 .AND. ICENTT.EQ.1) THEN
              DO IPARAM=47,50     !lambdas Tensor-central
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
      END IF
C
C=======================================================================
C
      N_UNIT=30
C
C=======================================================================
C      
      IF (ISOSPI.EQ.1 .OR. ISOSPI.EQ.11) FILNAM_ENDING='P'
      IF (ISOSPI.EQ.0 .OR. ISOSPI.EQ.10) FILNAM_ENDING='N'
C
      IF (IFDENS.EQ.1) THEN
C              
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                               IFPAR1,IFPAR2,IFPAR3,IFPAR4
C          
      END IF
C_______________________________________________________________________
C 
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
C      
      I1=3*KACTIV-1
C      
      WRITE(FILNAM_NUCFIT,'(<NUCACT>(A2,''-''))')
     *                      (FITNUC_AUXILI(I),I=1,NUCACT)

C
C=======================================================================
C      
      MACTIV=0
      ICENTR_NOTFIT=0
      ISORBI_NOTFIT=0
      IDENSI_NOTFIT=0
C
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (IFTAKE(IPARAM).EQ.0 .AND. I_MESH(IPARAM).EQ.0) THEN
C
             MACTIV=MACTIV+1
             TITLES_NOTFIT(MACTIV)=TITLES(IPARAM)(3:10)
C
             IF (TITLES_NOTFIT(MACTIV)(3:6).EQ.'CENT') THEN
                 ICENTR_NOTFIT=ICENTR_NOTFIT+1
             END IF
             IF (TITLES_NOTFIT(MACTIV)(3:6).EQ.'SORB') THEN
                 ISORBI_NOTFIT=ISORBI_NOTFIT+1
             END IF
             IF (TITLES_NOTFIT(MACTIV)(1:5).EQ.'XLAMB') THEN
                 IDENSI_NOTFIT=IDENSI_NOTFIT+1
             END IF
C
         END IF
      END DO
C
      I2=9*MACTIV-1
C
      WRITE(FILNAM_NOTTIT,'(<MACTIV>(A8,''-''))')
     *                      (TITLES_NOTFIT(I),I=1,MACTIV)
C
      IF (IFDENS.EQ.1 .AND. ICENTR_NOTFIT.GT.0) THEN
          WRITE(FILNAM_NOTTIT,'(I1,''CentrPot-const'')')ICENTR_NOTFIT
          I2=15
          IF (IDENSI_NOTFIT.GT.0) THEN
              WRITE(FILNAM_NOTTIT,'(I1,''CentrPot-const_'',
     *                              I1,''SODenPot-const'')')
     *                                      ICENTR_NOTFIT,IDENSI_NOTFIT
              I2=31
          END IF
      END IF
C
C=======================================================================
C
      IF (ISOSPI.LE.1) THEN 
          NUCSYM_AUXILI=NUCSYM(INUCLI)
      ELSE
          NUCSYM_AUXILI='Global'
      END IF
C
      I3=6
      I4=1
      IF (NUCSYM_AUXILI(1:1).EQ.' ') I4=2
      IF (NUCSYM_AUXILI(2:2).EQ.' ') I4=3
      IF (NUCSYM_AUXILI(3:3).EQ.' ') I4=4
C
C=======================================================================
C     
      IF (IFDENS.EQ.0) THEN
C      
          IF (MACTIV.EQ.0)
     *        WRITE(FILNAM,'(''Chi2Maps/IFDENS-0/Chi2Map_'',
     *                        A,''_'',A1,''_'',A,''_'',A8,''_'',A8,
     *                      ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                      ''_IF-PAI-'',I1,
     *                      ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                      ''_IF-RHO-'',I1,
     *                      ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                      ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                      ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                      ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                      ''_LDRAND-'',I5.5,''_'',A3,''.dat'')') 
     *
     *                      NUCSYM_AUXILI(I4:I3),
     *                      FILNAM_ENDING,FILNAM_NUCFIT(1:I1),
     *                      TITMSH(1),TITMSH(2),
     *                      IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                      IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                      IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                                  VERSIO
C
          IF (MACTIV.GT.0) 
     *        WRITE(FILNAM,'(''Chi2Maps/IFDENS-0/Chi2Map_'',
     *                     A,''_'',A1,''_'',A,''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A,''_'',A3,''.dat'')') 
     *
     *                   NUCSYM_AUXILI(I4:I3),
     *                   FILNAM_ENDING,FILNAM_NUCFIT(1:I1),
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                   FILNAM_NOTTIT(1:I2),VERSIO
C
      END IF
C
C=======================================================================
C     
      IF (IFDENS.EQ.1) THEN
C      
          IF (MACTIV.EQ.0) 
     *        WRITE(FILNAM,'(''Chi2Maps/IFDENS-1_IFTENS-'',I1,''/'',
     *                   ''Chi2Map_'',A,''_'',A1,''_'',A,
     *                   ''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,A15,''_'',A3,''.dat'')') 
     *
     *                   IFTENS,NUCSYM_AUXILI(I4:I3),
     *                   FILNAM_ENDING,FILNAM_NUCFIT(1:I1),
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                        TEXLAM,VERSIO
C
          IF (MACTIV.GT.0) 
     *        WRITE(FILNAM,'(''Chi2Maps/IFDENS-1_IFTENS-'',I1,''/'',
     *                   ''Chi2Map_'',A,''_'',A1,''_'',A,
     *                   ''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A,A15,''_'',A3,
     *                                                  ''.dat'')') 
     *
     *                   IFTENS,NUCSYM_AUXILI(I4:I3),
     *                   FILNAM_ENDING,FILNAM_NUCFIT(1:I1),
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                   FILNAM_NOTTIT(1:I2),TEXLAM,VERSIO
C
          IF (IFTENS.EQ.1) THEN
C      
              IF (MACTIV.EQ.0) 
     *            WRITE(FILNAM,'(''Chi2Maps/IFDENS-1_IFTENS-'',I1,''/'',
     *                   ''Chi2Map_'',A,''_'',A1,''_'',A,
     *                   ''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,A15,''_'',A3,''.dat'')') 
     *
     *                   IFTENS,NUCSYM_AUXILI(I4:I3),
     *                   FILNAM_ENDING,FILNAM_NUCFIT(1:I1),
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                   IF_RAD,IF_INV,IF_RHO,IFDEEP,IFPRON,IFK_VC,
     *                   IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                               TEXLAM,VERSIO
C
              IF (MACTIV.GT.0) 
     *            WRITE(FILNAM,'(''Chi2Maps/IFDENS-1_IFTENS-'',I1,''/'',
     *                   ''Chi2Map_'',A,''_'',A1,''_'',A,
     *                   ''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A,A15,''_'',A3,
     *                                                 ''.dat'')') 
     *
     *                   IFTENS,NUCSYM_AUXILI(I4:I3),
     *                   FILNAM_ENDING,FILNAM_NUCFIT(1:I1),
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                   IF_RAD,IF_INV,IF_RHO,IFDEEP,IFPRON,IFK_VC,
     *                   IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                   FILNAM_NOTTIT(1:I2),TEXLAM,VERSIO
C
          END IF
C
      END IF       
C
C=======================================================================
C       
      OPEN (N_UNIT,FILE=FILNAM,STATUS='UNKNOWN',FORM='FORMATTED')
C
C=======================================================================
C      
      WRITE(N_UNIT,'(/,''<<Strasbourg Nuclear Inverse Problem Study '',
     *                 ''- Standard Output - WS-SPH>>'',/)')
C
C=======================================================================
C
      WRITE(N_UNIT,'(''<<VersionOfCode>>'',3X,''VERSIO'')')
C
      WRITE(N_UNIT,'(21X,A3,/)') VERSIO
C
C=======================================================================
C     
      WRITE(N_UNIT,'(''<<Nuclid_Inform>>'',3X,''NUMB_Z'',
     *                                     3X,''NUMB_N'')')
C
      WRITE(N_UNIT,'(19X,I3,6X,I3,/)')IZ_FIX,IN_FIX
C
C=======================================================================
C
      WRITE(N_UNIT,'(''<<HowManyNuclei>>'',3X,''NUCACT'')')   
      
      WRITE(N_UNIT,'(19X,I4,/)')NUCACT
C
C=======================================================================
C
      WRITE(N_UNIT,'(''<<Nuclei_Inform>>'',3x,
     *               <NUCACT>(''IZ_No'',i1,3x,
     *               ''IN_No'',i1,5x))')(I,I=1,NUCACT),(J,J=1,NUCACT)
      WRITE(N_UNIT,'(20X,<NUCACT>(I4,5X,I4,7X),/)')
     *                                 (INPUTZ(I),INPUTN(I),I=1,NUCACT)
C
C=======================================================================
C
      WRITE(N_UNIT,'(''<<Experimt_File>>'',3X,''IFDEEP'',2X
     *                                     ''IFPRON'')')
      
      WRITE(N_UNIT,'(19X,2(I6,3X),/)') IFDEEP,IFPRON
C
C=======================================================================
C
      ISOSPI_PRINTI=ISOSPI
      IF (ISOSPI.GT.1) ISOSPI_PRINTI=ISOSPI-10
C
      WRITE(N_UNIT,'(''<<PotentialInfo>>'',3x,
     *               ''ISOSPI   IFDENS   IFTENS   IF_PAI'')')
      
      WRITE(N_UNIT,'(19X,I6,3X,I6,3X,I6,3X,I6,3X,/)')ISOSPI_PRINTI,
     *                                        IFDENS,IFTENS,IF_PAI
C
C=======================================================================
C
      WRITE(N_UNIT,'(''<<TensorialInfo>>'',3X,''ICENTT'',3X
     *                                     ''ISORBT'',3X,''ITENSR'')')
      
      WRITE(N_UNIT,'(19X,3(I6,3X),/)') ICENTT,ISORBT,ITENSR
C
C=======================================================================
C
      WRITE(N_UNIT,'(''<<KappasParamet>>   IFK_VC   IFK_VS   '',
     *                      ''IFK_RC   IFK_RS   IFK_AC   IFK_AS'')')
      WRITE(N_UNIT,'(19X,6(I6,3X),/)') IFK_VC,IFK_VS,IFK_RC,IFK_RS,
     *                                               IFK_AC,IFK_AS
C
C=======================================================================
C      
      WRITE(N_UNIT,'(''<<MinimizedChi2>>'',3X,
     *                     <LDCHI2>(A6,3X))')(TYPCHI(I),I=1,LDCHI2)
     
      WRITE(N_UNIT,'(19X,<LDCHI2>(I6,3X),/)')(ITKCHI(I),I=1,LDCHI2)
C
C=======================================================================
C
      WRITE(N_UNIT,'(''<<HowManyParams>>'',3X,''ICOUNT'',
     *                                     3X,''LDPARS'')')
     
      WRITE(N_UNIT,'(19X,I6,3X,I6,/)')ICOUNT_OFPARS,INDEXP
C
C=======================================================================
C
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (IFTAKE(IPARAM).EQ.0 .AND. I_MESH(IPARAM).EQ.0) THEN
             IFTAKE(IPARAM)=2
         END IF
      END DO
C_______________________________________________________________________
C
      WRITE(N_UNIT,'(''<<MinimizedOver>>'',$)')
      
      DO I=1,INDEXP
          IPARAM=IAUXIL(I)
          WRITE(N_UNIT,'(A11,$)')TITLES(IPARAM)(3:10)
      END DO
      
      WRITE(N_UNIT,'()')
      
      WRITE(N_UNIT,'(16X,'' '',$)')
      
      DO I=1,INDEXP
          IPARAM=IAUXIL(I)
          WRITE(N_UNIT,'(I11,$)') IFTAKE(IPARAM)
      END DO
      
      WRITE(N_UNIT,'()')
      WRITE(N_UNIT,'()')
C
C=======================================================================
C
      IF (MACTIV.NE.0) THEN  !which means that there are fixed parameters
C
          WRITE(N_UNIT,'(''<<Fixed_PValues>>'',$)')
C
          DO I=1,INDEXP
             IPARAM=IAUXIL(I)
             IF (IFTAKE(IPARAM).EQ.2 .AND. I_MESH(IPARAM).EQ.0) THEN
                 WRITE(N_UNIT,'(A11,$)')TITLES(IPARAM)(3:10)
             END IF
          END DO
C
          WRITE(N_UNIT,'()')
C
          WRITE(N_UNIT,'(16X,'' '',$)')
C
          DO I=1,INDEXP
             IPARAM=IAUXIL(I)
             IF (IFTAKE(IPARAM).EQ.2 .AND. I_MESH(IPARAM).EQ.0) THEN
                 WRITE(N_UNIT,'(F11.4,$)')VMISTR(IPARAM)
             END IF
          END DO
C
          WRITE(N_UNIT,'()')
          WRITE(N_UNIT,'()')
C
      END IF
C_______________________________________________________________________
C
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (IFTAKE(IPARAM).EQ.2) THEN
             IFTAKE(IPARAM)=0
         END IF
      END DO
C
C=======================================================================
C
      WRITE(N_UNIT,'(''<<X--Axis--Mult>>'',3X,''ParamI'')')
      
      WRITE(N_UNIT,'(20X,A,3X,/)')TITMSH(1)  
C
C=======================================================================
C
      WRITE(N_UNIT,'(''<<Y--Axis--Mult>>'',3X,''ParamJ'')')
      
      WRITE(N_UNIT,'(20X,A,3X,/)')TITMSH(2)  
C
C=======================================================================
C
      WRITE(N_UNIT,'(''<<ChiSqrt_Extrm>>'',3X,''PROMIN'',4X,''PROMAX'',
     *                                   4X,''NEUMIN'',4X,''NEUMAX'')')
      
      WRITE(N_UNIT,'(20X,4(ES8.2,2X),/)')RMSPRO_MINIMI,RMSPRO_MAXIMA,
     *                                   RMSNEU_MINIMI,RMSNEU_MAXIMA
C
C=======================================================================
C      
      WRITE(N_UNIT,'(''<<Plot--X--axis>>'',3X,''NofPnts'')')
      
      WRITE(N_UNIT,'(21X,I3)')MAXMSH(1)
      
      WRITE(N_UNIT,'(20X,''Values'')')
      
      WRITE(N_UNIT,'(18X,<MAXMSH(1)>F11.4,/)')
     *              (AXSMAP(1,K1),K1=1,MAXMSH(1))
C
C=======================================================================
C     
      WRITE(N_UNIT,'(''<<Plot--Y--axis>>'',3X,''NofPnts'')')
      
      WRITE(N_UNIT,'(21X,I3)')MAXMSH(2)
      
      WRITE(N_UNIT,'(20X,''Values'')')
      
      WRITE(N_UNIT,'(18X,<MAXMSH(2)>F11.4,/)')
     *              (AXSMAP(2,K2),K2=1,MAXMSH(2))
C
C=======================================================================
C
C     Writing the results obtained for the PROTON RMS
C
      IF (ISOSPI.EQ.1 .OR. ISOSPI.EQ.11) THEN
C
          WRITE(N_UNIT,'(''<<RMSDevi_Protn>>'')')
      
          WRITE(N_UNIT,'(10X,<MAXMSH(1)>F12.4)')
     *              (AXSMAP(1,K1),K1=1,MAXMSH(1))
      
          DO K2=1,MAXMSH(2)
        
             WRITE(N_UNIT,'(F10.4,$)')AXSMAP(2,K2)
        
             DO K1=1,MAXMSH(1)
         
                WRITE(N_UNIT,'(ES12.4,$)')RMSMAP_PRONUC(K1,K2,INUCLI)
        
             END DO
        
             WRITE(N_UNIT,'()')
       
          END DO
      
          WRITE(N_UNIT,'()')
C
      END IF
C
C=======================================================================
C
C     Writing the results obtained for the NEUTRON RMS
C
      IF (ISOSPI.EQ.0 .OR. ISOSPI.EQ.10) THEN    
C 
          WRITE(N_UNIT,'(''<<RMSDevi_Neutr>>'')')
      
          WRITE(N_UNIT,'(10X,<MAXMSH(1)>F12.4)')
     *              (AXSMAP(1,K1),K1=1,MAXMSH(1))
      
          DO K2=1,MAXMSH(2)
        
             WRITE(N_UNIT,'(F10.4,$)')AXSMAP(2,K2)
        
             DO K1=1,MAXMSH(1)
         
                WRITE(N_UNIT,'(ES12.4,$)')RMSMAP_NEUNUC(K1,K2,INUCLI)
        
             END DO
        
             WRITE(N_UNIT,'()')
       
          END DO
      
          WRITE(N_UNIT,'()') 
C
      END IF
C
C=======================================================================
C
C     Writing the results obtained for the parameters with ITAKE.EQ.1
C     
      DO IPARAM=1,NDPARS
         IF (IFTAKE(IPARAM).EQ.1) THEN
C
             WRITE(N_UNIT,'(''<<Parm_'',A8,''>>'')')TITLES(IPARAM)(3:10)
C
             WRITE(N_UNIT,'(10X,<MAXMSH(1)>F12.4)')
     *                          (AXSMAP(1,K1),K1=1,MAXMSH(1))
C
             DO K2=1,MAXMSH(2)
C
                WRITE(N_UNIT,'(F10.4,$)')AXSMAP(2,K2)
C
                DO K1=1,MAXMSH(1)
C
                   WRITE(N_UNIT,'(ES12.4,$)')PARPOT_OFMESH(K1,K2,IPARAM)
C
                END DO
C
                WRITE(N_UNIT,'()')
C
             END DO
C
             WRITE(N_UNIT,'()')
C
         END IF
      END DO
C           
C=======================================================================
C 
      WRITE(N_UNIT,'(''<<EXECUTESET_GO>>'')')      
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(''Exiting WRITING_CHIMAP'')')
C
C=======================================================================
C      
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE OPENIN_MESHPM(LDRAND,TITMSH,ICOUNT_OFPARS,
     *                                NTOTAL_OFMESH,MAXMSH)
C
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDMESH.f'
      INCLUDE   'MATDIM/NDTITL.f'
C      
      PARAMETER
     *          (NDMES2=NDMESH*NDMESH)
      CHARACTER
     *          TITLES*12,TITAUX*12,TITMSH*8,TEXTRA*256
      CHARACTER
     *          FILNAM*256,FILNAM_ENDING*1,INPSYM*6,NUCSYM*6,TYPCHI*6
      CHARACTER
     *          FILNAM_NUCFIT*30,FITNUC*2,
     *          FITNUC_AUXILI*30,TITLES_NOTFIT*256,FILNAM_NOTTIT*256,
     *          TEXLAM*20,VERSIO*3
      CHARACTER
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010
      DIMENSION
     *          TITAUX(1:NDPARS),
     *          TITMSH(1:NDPARS)
      DIMENSION
     *          IAUXIL(1:NDPARS)
      DIMENSION
     *          MAXMSH(1:NDPARS)
      DIMENSION
     *          FITNUC(1:NDNUCL),
     *          FITNUC_AUXILI(1:NDNUCL),
     *          TITLES_NOTFIT(1:NDPARS)
      COMMON
     *       /SELNUC/ NUCACT,
     *                ITAKNU(1:NDNUCL),
     *                INPUTZ(1:NDNUCL),
     *                INPUTN(1:NDNUCL),
     *                INPSYM(1:NDNUCL)
      COMMON
     *       /NUCINF/ LDNUCL,
     *                NUCSYM(1:NDNUCL),
     *                NUMB_Z(1:NDNUCL),
     *                NUMB_N(1:NDNUCL)
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /TENOPT/ ICENTT,ISORBT,ITENSR
      COMMON
     *       /IFPAIR/ IF_PAI,IFGPAI,IFDPAI
     *       /DEPPAI/ IFDEEP,IFPRON
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /MESHIN/ I_MESH(1:NDPARS),
     *                XMIN_I(1:NDPARS),
     *                XMAX_I(1:NDPARS),
     *                MAXPAR(1:NDPARS)
      COMMON
     *       /MSHPRI/ INOFER_PRINTI,
     *                IDEFCN_PRINTI,
     *                CHISQU_PRINTI(1:NDMES2),
     *                CHIGRD_NRMPRI(1:NDMES2),
     *                CHIGRD_COMPRI(1:NDPARS,1:NDMES2)
      COMMON
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /CHITAK/ IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,IF_RHO,IF_INV,
     *                LDCHI2,TYPCHI(1:NDNUCL),ITKCHI(1:NDNUCL)
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
      COMMON  
     *       /VERSIN/ VERSIO
      DATA
     *       FITNUC(01) / 'Ox' /,
     *       FITNUC(02) / 'C0' /,
     *       FITNUC(03) / 'C8' /,
     *       FITNUC(04) / 'Ni' /,
     *       FITNUC(05) / 'Zr' /,
     *       FITNUC(06) / 'Sn' /,
     *       FITNUC(07) / 'Gd' /,
     *       FITNUC(08) / 'Pb' / 
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(''Entering OPENIN_MESHP'')')
C
C=======================================================================
C
      INDEXP=0
C      
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
          ISOSPI=1
          DO IPARAM=1,6
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C      
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
          ISOSPI=0
          DO IPARAM=21,26
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C
      IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) THEN
C
          ISOSPI=2
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          IF (IFK_VS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=57   ! V_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=58   ! kappa V_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=4    ! V_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=24   ! V_o pure WS-SO neutrons
          END IF
C
          IF (IFK_RS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=59   ! r_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=60   ! kappa r_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=5    ! r_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=25   ! r_o pure WS-SO neutrons
          END IF
C
          IF (IFK_AS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=61   ! a_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=62   ! kappa a_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=6    ! a_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=26   ! a_o pure WS-SO neutrons
          END IF
C
      END IF
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.1) THEN
C
          ISOSPI=2
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          DO IPARAM=39,42         !lambdas Density-SO
             INDEXP=INDEXP+1
             IAUXIL(INDEXP)=IPARAM
          END DO
C
          IF (IFTENS.EQ.1.AND.ISORBT.EQ.1) THEN
              DO IPARAM=43,46     !lambdas Tensor-SO
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
          IF (IFTENS.EQ.1.AND.ICENTT.EQ.1) THEN
              DO IPARAM=47,50     !lambdas Tensor-central
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
      END IF
C
C=======================================================================
C
      LOGMSH=39
C
C=======================================================================
C      
      IF (IFDENS.EQ.0.AND.IFPROT.EQ.1) FILNAM_ENDING='P'
      IF (IFDENS.EQ.0.AND.IFNEUT.EQ.1) FILNAM_ENDING='N'
      IF (IFDENS.EQ.0.AND.IFBOTH.EQ.1) FILNAM_ENDING='B'
C
      IF (IFDENS.EQ.1) THEN
C              
          FILNAM_ENDING='B'
C              
          WRITE(TEXLAM,'(''_LAMBDA'',SP,I2,I2,I2,I2)')
     *                               IFPAR1,IFPAR2,IFPAR3,IFPAR4
C          
      END IF
C_______________________________________________________________________
C 
      KACTIV=0
      DO JNUCLI=1,LDNUCL
         IF (ITAKNU(JNUCLI).EQ.1) THEN
             KACTIV=KACTIV+1
             FITNUC_AUXILI(KACTIV)=FITNUC(JNUCLI)
         END IF
      END DO
C      
      I1=3*KACTIV-1
C      
      WRITE(FILNAM_NUCFIT,'(<NUCACT>(A2,''-''))')
     *                      (FITNUC_AUXILI(I),I=1,NUCACT)
C
C=======================================================================
C      
      MACTIV=0
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (IFTAKE(IPARAM).EQ.0.AND.I_MESH(IPARAM).EQ.0) THEN
             MACTIV=MACTIV+1
             TITLES_NOTFIT(MACTIV)=TITLES(IPARAM)(3:10)
         END IF
      END DO
C
      I2=9*MACTIV-1
C
      WRITE(FILNAM_NOTTIT,'(<MACTIV>(A8,''-''))')
     *                      (TITLES_NOTFIT(I),I=1,MACTIV)
C
C=======================================================================
C     
      IF (IFDENS.EQ.0) THEN
C      
          IF (MACTIV.EQ.0) 
     *        WRITE(FILNAM,'(''MeshTables/IFDENS-0/'',A,''_'',A1,
     *                   ''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A3,''.log'')') 
     *
     *                   FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                               VERSIO
C
          IF (MACTIV.GT.0) 
     *        WRITE(FILNAM,'(''MeshTables/IFDENS-0/'',A,''_'',A1,
     *                   ''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A,''_'',A3,''.log'')') 
     *
     *                   FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                   FILNAM_NOTTIT(1:I2),VERSIO
      END IF
C
C=======================================================================
C     
      IF (IFDENS.EQ.1) THEN
C      
          IF (MACTIV.EQ.0) 
     *        WRITE(FILNAM,'(''MeshTables/IFDENS-1_IFTENS-'',I1,''/'',
     *                      A,''_'',A1,''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')') 
     *
     *                   IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,TEXLAM,
     *                                                      VERSIO
C
          IF (MACTIV.GT.0) 
     *        WRITE(FILNAM,'(''MeshTables/IFDENS-1_IFTENS-'',I1,
     *                   ''/'',A,''_'',A1,''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A,A15,''_'',A3,
     *                                                 ''.log'')') 
     *
     *                   IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,IF_RAD,IF_INV,
     *                   IF_RHO,IFDEEP,IFPRON,IFK_VC,IFK_VS,
     *                   IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                   FILNAM_NOTTIT(1:I2),TEXLAM,VERSIO
C
          IF (IFTENS.EQ.1) THEN
C      
              IF (MACTIV.EQ.0) 
     *            WRITE(FILNAM,'(''MeshTables/IFDENS-1_IFTENS-'',I1,
     *                   ''/'',A,''_'',A1,''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,A15,''_'',A3,''.log'')') 
     *
     *                   IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                   IF_RAD,IF_INV,IF_RHO,IFDEEP,IFPRON,IFK_VC,
     *                   IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                                               TEXLAM,VERSIO
C
              IF (MACTIV.GT.0) 
     *            WRITE(FILNAM,'(''MeshTables/IFDENS-1_IFTENS-'',I1,
     *                   ''/'',A,''_'',A1,''_'',A8,''_'',A8,
     *                   ''_IFDENS-'',I1,''_IFTENS-'',I1,
     *                   ''_IF-PAI-'',I1,
     *                   ''_ICENTT-'',I1,''_ISORBT-'',I1,
     *                                   ''_ITENSR-'',I1,
     *                   ''_IF-RAD-'',I1,''_IF-ORD-'',I1,
     *                   ''_IF-RHO-'',I1,
     *                   ''_IFDEEP-'',I1,''_IFPRON-'',I1,
     *                   ''_IFK-VC-'',I1,''_IFK-VS-'',I1,
     *                   ''_IFK-RC-'',I1,''_IFK-RS-'',I1,
     *                   ''_IFK-AC-'',I1,''_IFK-AS-'',I1,
     *                   ''_LDRAND-'',I5.5,''_'',A,A15,''_'',A3,
     *                                                 ''.log'')') 
     *
     *                   IFTENS,FILNAM_NUCFIT(1:I1),FILNAM_ENDING,
     *                   TITMSH(1),TITMSH(2),
     *                   IFDENS,IFTENS,IF_PAI,ICENTT,ISORBT,ITENSR,
     *                   IF_RAD,IF_INV,IF_RHO,IFDEEP,IFPRON,IFK_VC,
     *                   IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS,LDRAND,
     *                   FILNAM_NOTTIT(1:I2),TEXLAM,VERSIO
C
          END IF
C
      END IF
C
C=======================================================================
C      
      OPEN (LOGMSH,FILE=FILNAM,STATUS='UNKNOWN',FORM='FORMATTED')
C
C=======================================================================
C
      WRITE(LOGMSH,'(/,''<<HowManyNuclei>>'',3x,''NUCACT'')')
      WRITE(LOGMSH,'(20X,I4)')NUCACT
C_______________________________________________________________________
C
      WRITE(LOGMSH,'(/,''<<Nuclei_Inform>>'',3x,
     *               <NUCACT>(''IZ_No'',i1,3x,
     *               ''IN_No'',i1,5x))')(I,I=1,NUCACT),(J,J=1,NUCACT)
      WRITE(LOGMSH,'(20X,<NUCACT>(I4,5X,I4,7X))')
     *                                 (INPUTZ(I),INPUTN(I),I=1,NUCACT)
C_______________________________________________________________________
C
      WRITE(LOGMSH,'(/,''<<PotentialInfo>>'',3x,''ISOSPI'',
     *              3X,''IFDENS'',3x,''IFTENS'')')
      WRITE(LOGMSH,'(20X,I4,5X,I4,5X,I4)')ISOSPI,IFDENS,IFTENS
C_______________________________________________________________________
C
      WRITE(LOGMSH,'(/,''<<Chi2_Informat>>'',3x,''IF_SPE   IF_RAD   '',
     *               ''IF_GAP   IF_FER   IF_DEN   IF_RHO   IF_INV'')')
      WRITE(LOGMSH,'(20X,7(I4,5X))')IF_SPE,IF_RAD,IF_GAP,IF_FER,IF_DEN,
     *                                                   IF_RHO,IF_INV
C_______________________________________________________________________
C
      WRITE(LOGMSH,'(/,''<<NoOf_Restarts>>'',3x,''LDRAND'')')
      WRITE(LOGMSH,'(20X,I4)') LDRAND
C_______________________________________________________________________
C
      WRITE(LOGMSH,'(/,''<<Dim_MeshPoint>>'',3X,''MESH01'',
     *                                       3X,''MESH02'')')
      WRITE(LOGMSH,'(20X,I4,5X,I4)')MAXMSH(1),MAXMSH(2)
C_______________________________________________________________________
C
      INDAUX=0
C_______________________________________________________________________
C
      WRITE(LOGMSH,'(/,''<<Tabuld_Params>>'',$)')
C      
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (I_MESH(IPARAM).EQ.1) THEN
             WRITE(LOGMSH,'(A11,$)')TITLES(IPARAM)(3:10)
             INDAUX=INDAUX+1
             TITAUX(INDAUX)=TITLES(IPARAM)(3:10)
         END IF
      END DO
C      
      WRITE(LOGMSH,'()')
      WRITE(LOGMSH,'()')
C_______________________________________________________________________
C
      WRITE(LOGMSH,'(''<<Constn_Params>>'',$)')
C      
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (IFTAKE(IPARAM).EQ.0 .AND. I_MESH(IPARAM).EQ.0) THEN
             WRITE(LOGMSH,'(A11,$)')TITLES(IPARAM)(3:10)
             INDAUX=INDAUX+1
             TITAUX(INDAUX)=TITLES(IPARAM)(3:10)
         END IF
      END DO
C      
      WRITE(LOGMSH,'()')
      WRITE(LOGMSH,'()')
C_______________________________________________________________________
C
      WRITE(LOGMSH,'(''<<Fitted_Params>>'',$)')
C      
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (IFTAKE(IPARAM).EQ.1) THEN
             WRITE(LOGMSH,'(A11,$)')TITLES(IPARAM)(3:10)
             INDAUX=INDAUX+1
             TITAUX(INDAUX)=TITLES(IPARAM)(3:10)
         END IF
      END DO
C      
      WRITE(LOGMSH,'()')
      WRITE(LOGMSH,'()')
C_______________________________________________________________________
C
      WRITE(LOGMSH,'(''<<MinimSolution>>'',$)')
C      
      DO I=1,INDAUX
         WRITE(LOGMSH,'(3X,A8,''   '',$)') TITAUX(I)
      END DO
C      
      WRITE(LOGMSH,'(3X,''CHISQURT'',6X,''ITERATIN'',6X,''STOPPING'',
     *               6X,''GRADNORM   '',$)')
C      
      DO I=1,INDAUX
         WRITE(LOGMSH,'(3X,A8,''   '',$)') TITAUX(I)
      END DO
C      
      WRITE(LOGMSH,'()')
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(''Exiting OPENIN_MESHP'')')
C
C=======================================================================
C      
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE WRITIN_MESHPM(NCOUNT_OFMESH,PARPOT_PRINTI)
C
      INCLUDE   'MATDIM/NDPARS.f'
      INCLUDE   'MATDIM/NDNUCL.f'
      INCLUDE   'MATDIM/NDMESH.f'
      INCLUDE   'MATDIM/NDTITL.f'
C      
      PARAMETER
     *          (NDMES2=NDMESH*NDMESH)
      CHARACTER
     *          TITLES*12,TITAUX*12,TITMSH*8,TEXTRA*256
      CHARACTER
     *          FILNAM*256,FILNAM_ENDING*3,INPSYM*6,NUCSYM*6,TYPCHI*6,
     *          TITLES_LATEXS*050,NUCNAM_LATEXS*010
      DIMENSION
     *          TITAUX(1:NDPARS),
     *          TITMSH(1:NDPARS)
      DIMENSION
     *          IAUXIL(1:NDPARS),
     *          PARAUX(1:NDPARS,1:NDMES2),
     *          PARPOT_PRINTI(1:NDPARS,1:NDMES2),
     *          CHIGRD_COMAUX(1:NDPARS,1:NDMES2)
      DIMENSION
     *          MAXMSH(1:NDPARS)
      COMMON
     *       /DENSTR/ IFDENS
      COMMON
     *       /TENSOR/ IFTENS
      COMMON
     *       /SEARCH/ IFTAKE(1:NDPARS)
      COMMON
     *       /MESHIN/ I_MESH(1:NDPARS),
     *                XMIN_I(1:NDPARS),
     *                XMAX_I(1:NDPARS),
     *                MAXPAR(1:NDPARS)
      COMMON
     *       /MSHPRI/ INFOER_PRINTI,
     *                IDEFCN_PRINTI,
     *                CHISQU_PRINTI(1:NDMES2),
     *                CHIGRD_NRMPRI(1:NDMES2),
     *                CHIGRD_COMPRI(1:NDPARS,1:NDMES2)
      COMMON
     *       /P_N_LM/ IFPROT,IFNEUT,IFBOTH
      COMMON
     *       /IFKAPP/ IFK_VC,IFK_VS,IFK_RC,IFK_RS,IFK_AC,IFK_AS
      COMMON
     *       /PARAMT_TITLES/ TITLES(1:NDTITL),
     *                       TITLES_LATEXS(1:NDTITL),
     *                       NUCNAM_LATEXS(1:NDNUCL)
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C
      IF (LOGWRI.GT.0) THEN
          WRITE(LOGFIL,'(''Entering WRITIN_MESHPM with IFDENS= '',I1,
     *                   ''; IFPROT= '',I1,''; IFNEUT= '',I1,
     *                   ''; IFBOTH= '',I1)')IFDENS,IFPROT,
     *                                       IFNEUT,IFBOTH
      END IF
C
C=======================================================================
C
      INDEXP=0
C      
      IF (IFDENS.EQ.0 .AND. IFPROT.EQ.1) THEN
          DO IPARAM=1,6
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C      
      IF (IFDENS.EQ.0 .AND. IFNEUT.EQ.1) THEN
          DO IPARAM=21,26
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=IPARAM
          END DO
      END IF
C
      IF (IFDENS.EQ.0 .AND. IFBOTH.EQ.1) THEN
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          IF (IFK_VS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=57   ! V_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=58   ! kappa V_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=4    ! V_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=24   ! V_o pure WS-SO neutrons
          END IF
C
          IF (IFK_RS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=59   ! r_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=60   ! kappa r_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=5    ! r_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=25   ! r_o pure WS-SO neutrons
          END IF
C
          IF (IFK_AS.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=61   ! a_o pure WS-SO
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=62   ! kappa a_o pure WS-SO
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=6    ! a_o pure WS-SO protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=26   ! a_o pure WS-SO neutrons
          END IF
C
      END IF
C_______________________________________________________________________
C      
      IF (IFDENS.EQ.1) THEN
C
          IF (IFK_VC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=51   ! V_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=52   ! kappa V_o central
          ELSE
              INDEXP=INDEXP+1 
              IAUXIL(INDEXP)=1    ! V_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=21   ! V_o central neutrons
          END IF
C
          IF (IFK_RC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=53   ! r_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=54   ! kappa r_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=2    ! r_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=22   ! r_o central neutron
          END IF
C
          IF (IFK_AC.EQ.1) THEN
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=55   ! a_o central
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=56   ! kappa a_o central
          ELSE
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=3    ! a_o central protons
              INDEXP=INDEXP+1
              IAUXIL(INDEXP)=23   ! a_o central neutrons
          END IF
C
          DO IPARAM=39,42         !lambdas Density-SO
             INDEXP=INDEXP+1
             IAUXIL(INDEXP)=IPARAM
          END DO
C
          IF (IFTENS.EQ.1 .AND. ISORBT.EQ.1) THEN
              DO IPARAM=43,46     !lambdas Tensor-SO
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
          IF (IFTENS.EQ.1 .AND. ICENTT.EQ.1) THEN
              DO IPARAM=47,50     !lambdas Tensor-central
                 INDEXP=INDEXP+1
                 IAUXIL(INDEXP)=IPARAM
              END DO
          END IF
C
      END IF
C
C=======================================================================
C
      WRITE(LOGMSH,'(10X,''    '',$)')
      
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (I_MESH(IPARAM).EQ.1) THEN
             WRITE(LOGMSH,'(E14.4,$)') 
     *             PARPOT_PRINTI(IPARAM,NCOUNT_OFMESH)
         END IF
      END DO
      
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (I_MESH(IPARAM).EQ.0 .AND. IFTAKE(IPARAM).EQ.0) THEN
             WRITE(LOGMSH,'(E14.4,$)')  
     *             PARPOT_PRINTI(IPARAM,NCOUNT_OFMESH)
         END IF
      END DO
      
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         IF (IFTAKE(IPARAM).EQ.1) THEN
             WRITE(LOGMSH,'(E14.4,$)')  
     *             PARPOT_PRINTI(IPARAM,NCOUNT_OFMESH)
         END IF
      END DO
      
      WRITE(LOGMSH,'(E14.4,6X,I4,10X,I4,4X,E14.4,$)') 
     *                                    CHISQU_PRINTI(NCOUNT_OFMESH),
     *                                    IDEFCN_PRINTI,INFOER_PRINTI,
     *                                    CHIGRD_NRMPRI(NCOUNT_OFMESH)
      
      DO I=1,INDEXP
         IPARAM=IAUXIL(I)
         WRITE(LOGMSH,'(E14.4,$)') CHIGRD_COMPRI(IPARAM,NCOUNT_OFMESH)
      END DO
      
      WRITE(LOGMSH,'()')
C
C=======================================================================
C
      IF (LOGWRI.GT.0) WRITE(LOGFIL,'(''Exiting WRITIN_MESHPM'')')
C
C=======================================================================
C      
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      FUNCTION DENEXP_INTEGR(XARGUM)
C
      COMMON
     *       /ARGUMN/ IARG_R,IARG_Z
      COMMON
     *       /SIMUSE/ AOSCIL,RADCUT,INUCLI
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C     Expression for the function of the volume integral of the 
C     experimental density. Then, the integral is done via SIMPSON
C=======================================================================
C
C     IARG_R and IARG_Z are used in order to choose if we want to 
C     integrate over small r or over z.
C
C     IARG_R=1 - the integration will be done over r
C
C     IARG_Z=1 - the integration will be done over z
C
C=======================================================================
C
      PINUMB=4*ATAN(1.0)
C
C=======================================================================
C
      IF (IARG_R.EQ.1) THEN
          DENEXP_INTEGR=4*PINUMB*DENEXP(XARGUM)*XARGUM**2
      END IF
C
      IF (IARG_Z.EQ.1) THEN
          DENEXP_INTEGR=2*PINUMB*AOSCIL**3*DENEXP(XARGUM)*SQRT(XARGUM)
      END IF
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      FUNCTION DENTHE_INTEGR(XARGUM)
C
      COMMON
     *       /ARGUMN/ IARG_R,IARG_Z
      COMMON
     *       /SIMUSE/ AOSCIL,RADCUT,INUCLI
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C     Expression for the function of the volume integral of the 
C     theoretical density. Then, the integral is done via SIMPSON
C=======================================================================
C
C     IARG_R and IARG_Z are used in order to choose if we want to 
C     integrate over small r or over z.
C
C     IARG_R=1 - the integration will be done over r
C
C     IARG_Z=1 - the integration will be done over z
C
C=======================================================================
C
      PINUMB=4*ATAN(1.0)
C
C=======================================================================
C
      IF (IARG_R.EQ.1) THEN
          DENTHE_INTEGR=4*PINUMB*DENSIT(XARGUM)*XARGUM**2
      END IF
C
      IF (IARG_Z.EQ.1) THEN
          DENTHE_INTEGR=2*PINUMB*AOSCIL**3*DENSIT(XARGUM)*SQRT(XARGUM)
      END IF
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      FUNCTION DENTHE_DENEXP(XARGUM)
C
C=======================================================================
C     Expression for the function of the integral of the difference
C     experimental - theory density. The integral is done via SIMPSON
C=======================================================================
C
      DENTHE_DENEXP=DENSIT(XARGUM)-DENEXP(XARGUM)
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      FUNCTION RMSEXP_INTEGR(XARGUM)
C
      COMMON
     *       /ARGUMN/ IARG_R,IARG_Z
      COMMON
     *       /SIMUSE/ AOSCIL,RADCUT,INUCLI
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C     Expression for the function of the integral of the volume 
C     integral of the rms radius. The integral is done via SIMPSON
C=======================================================================
C
C     IARG_R and IARG_Z are used in order to choose if we want to 
C     integrate over small r or over z.
C
C     IARG_R=1 - the integration will be done over r
C
C     IARG_Z=1 - the integration will be done over z
C
C=======================================================================
C
      PINUMB=4*ATAN(1.0)
C
C=======================================================================
C
      IF (IARG_R.EQ.1) THEN
          RMSEXP_INTEGR=4*PINUMB*DENEXP(XARGUM)*XARGUM**4
      END IF
C
      IF (IARG_Z.EQ.1) THEN
          RMSEXP_INTEGR=2*PINUMB*AOSCIL**3*DENEXP(XARGUM)
     *                 *SQRT(XARGUM)*XARGUM
      END IF
C
C=======================================================================
C
      RETURN
      END
C      
C=======================================================================
C=======================================================================
C
      SUBROUTINE SIMPSN_INTEGR(A,B,N,F,SIMINT,ERRORS)
C
      EXTERNAL
     *         F 
C   
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS 
C
C=======================================================================
C
C     Integration using the SIMPSON METHOD. The user have to give
C     the integration limits A and B,  the number of points N and 
C     the function to integrate F. For clarification the integral
C     is:
C                     SIMINT = \int F(X) dX
C
C     ERRORS - The nominal error of the Simpson method without f'
C
C=======================================================================
C
      STEP_H=(B-A)/N

      SIMINT=0.0

      DO I=0,N
         XARGUM=A+I*STEP_H
         FARGUM=F(XARGUM)
         IF ((I.EQ.0).OR.(I.EQ.N)) SIMINT=SIMINT+FARGUM
         IF ((I.GT.0).AND.(I.LT.N).AND.(MOD(I,2).EQ.0)) THEN
             SIMINT=SIMINT+2*FARGUM
         END IF
         IF ((I.GT.0).AND.(I.LT.N).AND.(MOD(I,2).NE.0)) THEN
             SIMINT=SIMINT+4*FARGUM
         END IF
      END DO
C
C=======================================================================
C
      SIMINT=SIMINT*STEP_H/3
C
      ERRORS=(B-A)*STEP_H**4/180.0
C
C=======================================================================
C
      IF (LOGWRI.GT.4) THEN
          WRITE(LOGFIL,'(12X,''Exiting  SIMPSN_INTEGR'')')
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
C                      TIMING SUBROUTINES
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE TIMPRI
C
      PARAMETER
     *          (NDSUBR=30)
C
      PARAMETER
     *          (NDCOLU=2)
C
      CHARACTER
     *          OUITEM(NDCOLU)*35
C
      CHARACTER
     *          NAMALL*6
C
      COMMON
     *       /TIMPRI_TIMEXE/ TIMALL(1:NDSUBR),TIMACT(1:NDSUBR)
     *       /TIMEXE_KONOFF/ KONOFF(1:NDSUBR)
     *       /TIMEXE_NAMALL/ NAMALL(1:NDSUBR)
     *       /CPUDAT_TIMNOW/ NUSUBR
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS    
C
C=======================================================================
C     This subroutine prints execution times for predefined subroutines
C=======================================================================
C
C      CALL CPUTIM('WSUNIV',0)
C
      IF (LOGWRI.GT.0) THEN
C
          WRITE(LOGFIL,'(/,''Running TIMPRI'',/,''NUSUBR,NDCOLU'',/,
     *                                2(3X,I4))') NUSUBR,NDCOLU
      END IF
C
C=======================================================================
C
      S_PERD=86400.0
      S_PERH=3600.0
      S_PMIN=60.0
      NSPERD=86400
      NSPERH=3600
      NSPMIN=60
C
      IF (NUSUBR.GT.0) THEN
C
          IF (LOGWRI.GT.0)
     *        WRITE(LOGFIL,'(//,80(''#''),/,         ''#'',78X,''#'',/,
     *                   ''#    CPU and system times for the routines'',
     *                   '' and their down-calling trees T1     #'',/,
     *                    ''#'',78X,''#'',/,               80(''#''),/,
     *                                               ''#'',78X,''#'')')
C_______________________________________________________________________
C
          DO ITSUBR=1,NUSUBR,NDCOLU
C
             DO NUITEM=1,NDCOLU
                 CALL BLANKS_STRING(OUITEM(NUITEM),LENGTH)
             END DO
C
             MXITEM=MIN(NUSUBR-ITSUBR+1,NDCOLU)
C
             DO NUITEM=1,MXITEM
C
                MUSUBR=ITSUBR+NUITEM-1
C
                IF (KONOFF(MUSUBR).EQ.1) THEN
C
                    IF (LOGWRI.GT.0)
     *                  WRITE(LOGFIL,'(/,1X,19(1H/),
     *                    '' In TIMPRI time is still on for '',
     *                                       A6,3X,19(1H/),/)')
     *                                           NAMALL(MUSUBR)
C
                    STOP 'In TIMPRI time is still on <<= '
C
                END IF
C
                N_DAYS=INT(TIMALL(MUSUBR)/S_PERD)
                T_DAYS=FLOAT(N_DAYS*NSPERD)
                N_HOUR=INT((TIMALL(MUSUBR)-T_DAYS)/S_PERH)
                T_HOUR=FLOAT(N_HOUR*NSPERH+N_DAYS*NSPERD)
                N_MINS=INT((TIMALL(MUSUBR)-T_HOUR)/S_PMIN)
                T_MINS=FLOAT(N_MINS*NSPMIN+N_HOUR*NSPERH+N_DAYS*NSPERD)
                SECOND=TIMALL(MUSUBR)-T_MINS
C
                WRITE(OUITEM(NUITEM),'(I2,'' d '',I2,'' h '',I2,
     *                                 '' min '',F6.3,'' s => '',A6)')
     *                N_DAYS,N_HOUR,N_MINS,SECOND,NAMALL(MUSUBR)
C
             END DO
C
             IF (LOGWRI.GT.0)
     *           WRITE(LOGFIL,'(''#'',2X,<NDCOLU>(A35,2X),2X,''#'',/,
     *                                             ''#'',78X,''#'')')
     *                               (OUITEM(NUITEM),NUITEM=1,NDCOLU)
C
          END DO
C
          IF (LOGWRI.GT.0) WRITE(LOGFIL,'(80(''#''),/)')
C_______________________________________________________________________
C
          IF (LOGWRI.GT.0)
     *        WRITE(LOGFIL,'(//,80(''#''),/,         ''#'',78X,''#'',/,
     *                   ''#    CPU and system times for the routines'',
     *                   '' and their down-calling trees T2     #'',/,
     *                    ''#'',78X,''#'',/,               80(''#''),/,
     *                                               ''#'',78X,''#'')')
C
          DO ITSUBR=1,NUSUBR,NDCOLU
C
             DO NUITEM=1,NDCOLU
                 CALL BLANKS_STRING(OUITEM(NUITEM),LENGTH)
             END DO
C
             MXITEM=MIN(NUSUBR-ITSUBR+1,NDCOLU)
C
             DO NUITEM=1,MXITEM
C
                MUSUBR=ITSUBR+NUITEM-1
C
                IF (KONOFF(MUSUBR).EQ.1) THEN
C
                    IF (LOGWRI.GT.0)
     *                  WRITE(LOGFIL,'(/,1X,19(1H/),
     *                    '' In TIMPRI time is still on for '',
     *                                       A6,3X,19(1H/),/)')
     *                                           NAMALL(MUSUBR)
C
                    STOP 'In TIMPRI time is still on <<= '
C
                END IF
C
                WRITE(OUITEM(NUITEM),'(F23.3,'' s => '',A6)')
     *                                 TIMALL(MUSUBR),NAMALL(MUSUBR)
C
             END DO
C
             IF (LOGWRI.GT.0)
     *           WRITE(LOGFIL,'(''#'',2X,<NDCOLU>(A35,2X),2X,''#'',/,
     *                                         ''#'',78X,''#'')')
     *                               (OUITEM(NUITEM),NUITEM=1,NDCOLU)
C
          END DO
C
          IF (LOGWRI.GT.0) WRITE(LOGFIL,'(80(''#''),/)')
C
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      BLOCK DATA CPUDAT
C
      COMMON
     *       /CPUDAT_TIMNOW/ NUSUBR
C
      DATA
     *       NUSUBR / 0 /
C
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE CPUTIM(NAMSUB,IONOFF)
C
      PARAMETER
     *         (NDSUBR=30)
C
      CHARACTER
     *          NAMALL*6
C
      CHARACTER
     *          NAMSUB*6
C
      COMMON
     *       /TIMPRI_TIMEXE/ TIMALL(NDSUBR),TIMACT(NDSUBR)
     *       /TIMEXE_KONOFF/ KONOFF(NDSUBR)
     *       /TIMEXE_NAMALL/ NAMALL(NDSUBR)
C
      COMMON
     *       /CPUDAT_TIMNOW/ NUSUBR
C
      COMMON
     *       /PRFILE/ ISCREN,LOGFIL,LOGCHP,LOGCHN,LOGHIP,LOGHIN,
     *                LOGPRO,LOGNEU,LOGWRI,LSCREN,IRESUL,ICONVE,
     *                NOUTPT,LOGAUX,LOGENE,LOGRAD,LOGGRD,LOGMSH,
     *                                                   LOGBIS   
C
C=======================================================================
C     This subroutine collects execution times for different
C     subroutines
C=======================================================================
C
      I_SUBR=0
C
C=======================================================================
C     Each subroutine is identified by its name. Consecutive
C     numbers are attributed to subroutines  in the sequence
C     of consecutive calls to CPUTIM
C=======================================================================
C
      IF (NUSUBR.GT.0) THEN
C
          DO MUSUBR=1,NUSUBR
             IF (NAMALL(MUSUBR).EQ.NAMSUB) I_SUBR=MUSUBR
          END DO
C
      ELSE
C
          DO MUSUBR=1,NDSUBR
             KONOFF(MUSUBR)=0
             TIMACT(MUSUBR)=0.0
          END DO
C
      END IF
C
      IF (I_SUBR.EQ.0) THEN
C
          IF (NUSUBR.GE.NDSUBR) STOP 'Too large NUSUBR in CPUTIM <<= '
C
          NUSUBR=NUSUBR+1
          I_SUBR=NUSUBR
          NAMALL(I_SUBR)=NAMSUB
          TIMALL(I_SUBR)=0.0
C
      END IF
C
C=======================================================================
C
C     Here a call is made to CPU_TIME which returns the cpu time
C
C=======================================================================
C
      CALL CPU_TIME(SECNDS) 
C
C=======================================================================
C
      IF (IONOFF.NE.0.AND.IONOFF.NE.1)
     *    STOP 'Wrong IONOFF in CPUTIM <<= '
C
C     Here the time is set
C
      IF (IONOFF.EQ.1) THEN
C
          IF (KONOFF(I_SUBR).EQ.1) THEN
              IF (LOGWRI.GT.0)
     *            WRITE(LOGFIL,'(''Subroutine '',A6)') NAMSUB
              IF (ISCREN.GT.0)
     *            WRITE(LSCREN,'(''Subroutine '',A6)') NAMSUB
              STOP 'CPU_TIME is already on in CPUTIM <<= '
          END IF
C
          TIMACT(I_SUBR)=SECNDS
          KONOFF(I_SUBR)=1
C
      ELSE
C
C         Here the time is collected
C
          IF (KONOFF(I_SUBR).EQ.0) THEN
              IF (LOGWRI.GT.0)
     *            WRITE(LOGFIL,'(''Subroutine '',A6)') NAMSUB
              IF (ISCREN.GT.0)
     *            WRITE(LSCREN,'(''Subroutine '',A6)') NAMSUB
              STOP 'CPU_TIME is already off in CPUTIM <<= '
          END IF
C
          TIMALL(I_SUBR)=TIMALL(I_SUBR)+SECNDS-TIMACT(I_SUBR)
          KONOFF(I_SUBR)=0
C
      END IF
C
C=======================================================================
C
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE BLANKS_STRING(STRING,LENGTH)
C
      CHARACTER
     *           STRING*(*)
C
C=======================================================================
C
      LENGTH=LEN(STRING)
C
      DO I=1,LENGTH
         STRING(I:I)=' '
      END DO
C
C=======================================================================
C
      RETURN
      END 
C
C=======================================================================
C
C
C=======================================================================
C=======================================================================
C
C FILE NAME = wspher13_lapac1_15.f ! Keep this symbol:    $ident@string$
C
C=======================================================================
C=======================================================================
C             This is the Lapack routine package. Routines DGETRF 
C             and DGETRI are used to perform the LU decomposition 
C             and matrix inversion respectively.  Other  routines 
C             are called form the above two.
C=======================================================================
C=======================================================================
C
      SUBROUTINE DGETRF( M, N, A, LDA, IPIV, INFO )
*
*  -- LAPACK routine (version 3.2) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER		 INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER		 IPIV( * )
      DIMENSION           A( LDA, lda ) !(ndpars)
*     ..
*
*  Purpose
*  =======
*
*  DGETRF computes an LU factorization of a general M-by-N matrix A
*  using partial pivoting with row interchanges.
*
*  The factorization has the form
*     A = P * L * U
*  where P is a permutation matrix, L is lower triangular with unit
*  diagonal elements (lower trapezoidal if m > n), and U is upper
*  triangular (upper trapezoidal if m < n).
*
*  This is the right-looking Level 3 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  M	   (input) INTEGER
*	   The number of rows of the matrix A.  M >= 0.
*
*  N	   (input) INTEGER
*	   The number of columns of the matrix A.  N >= 0.
*
*  A	   (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*	   On entry, the M-by-N matrix to be factored.
*	   On exit, the factors L and U from the factorization
*	   A = P*L*U; the unit diagonal elements of L are not stored.
*
*  LDA     (input) INTEGER
*	   The leading dimension of the array A.  LDA >= max(1,M).
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*	   The pivot indices; for 1 <= i <= min(M,N), row i of the
*	   matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*	   = 0:  successful exit
*	   < 0:  if INFO = -i, the i-th argument had an illegal value
*	   > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
*		 has been completed, but the factor U is exactly
*		 singular, and division by zero will occur if it is used
*		 to solve a system of equations.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE
      PARAMETER 	 ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER		 I, IINFO, J, JB, NB
*     ..
*     .. External Subroutines ..
      EXTERNAL  	 DGEMM, DGETF2, DLASWP, DTRSM, XERBLA
*     ..
*     .. External Functions ..
      INTEGER		 ILAENV
      EXTERNAL  	 ILAENV
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC 	 MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
	 INFO = -1
      ELSE IF( N.LT.0 ) THEN
	 INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
	 INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
	 CALL XERBLA( 'DGETRF', -INFO )
	 RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
*     Determine the block size for this environment.
*
      NB = ILAENV( 1, 'DGETRF', ' ', M, N, -1, -1 )
      IF( NB.LE.1 .OR. NB.GE.MIN( M, N ) ) THEN
*
*	 Use unblocked code.
*
	 CALL DGETF2( M, N, A, LDA, IPIV, INFO )
      ELSE
*
*	 Use blocked code.
*
	 DO 20 J = 1, MIN( M, N ), NB
	    JB = MIN( MIN( M, N )-J+1, NB )
*
*	    Factor diagonal and subdiagonal blocks and test for exact
*	    singularity.
*
	    CALL DGETF2( M-J+1, JB, A( J, J ), LDA, IPIV( J ), IINFO )
*
*	    Adjust INFO and the pivot indices.
*
	    IF( INFO.EQ.0 .AND. IINFO.GT.0 )
     $         INFO = IINFO + J - 1
	    DO 10 I = J, MIN( M, J+JB-1 )
	       IPIV( I ) = J - 1 + IPIV( I )
   10	    CONTINUE
*
*	    Apply interchanges to columns 1:J-1.
*
	    CALL DLASWP( J-1, A, LDA, J, J+JB-1, IPIV, 1 )
*
	    IF( J+JB.LE.N ) THEN
*
*	       Apply interchanges to columns J+JB:N.
*
	       CALL DLASWP( N-J-JB+1, A( 1, J+JB ), LDA, J, J+JB-1,
     $  		    IPIV, 1 )
*
*	       Compute block row of U.
*
	       CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit', JB,
     $  		   N-J-JB+1, ONE, A( J, J ), LDA, A( J, J+JB ),
     $  		   LDA )
	       IF( J+JB.LE.M ) THEN
*
*		  Update trailing submatrix.
*
		  CALL DGEMM( 'No transpose', 'No transpose', M-J-JB+1,
     $  		      N-J-JB+1, JB, -ONE, A( J+JB, J ), LDA,
     $  		      A( J, J+JB ), LDA, ONE, A( J+JB, J+JB ),
     $  		      LDA )
	       END IF
	    END IF
   20	 CONTINUE
      END IF
      RETURN
*
*     End of DGETRF
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.2) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER		 INFO, LDA, LWORK, N
*     ..
*     .. Array Arguments ..
      INTEGER		 IPIV( * )
      DIMENSION           A( LDA,lda ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DGETRI computes the inverse of a matrix using the LU factorization
*  computed by DGETRF.
*
*  This method inverts U and then computes inv(A) by solving the system
*  inv(A)*L = inv(U) for inv(A).
*
*  Arguments
*  =========
*
*  N	   (input) INTEGER
*	   The order of the matrix A.  N >= 0.
*
*  A	   (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*	   On entry, the factors L and U from the factorization
*	   A = P*L*U as computed by DGETRF.
*	   On exit, if INFO = 0, the inverse of the original matrix A.
*
*  LDA     (input) INTEGER
*	   The leading dimension of the array A.  LDA >= max(1,N).
*
*  IPIV    (input) INTEGER array, dimension (N)
*	   The pivot indices from DGETRF; for 1<=i<=N, row i of the
*	   matrix was interchanged with row IPIV(i).
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*	   On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*	   The dimension of the array WORK.  LWORK >= max(1,N).
*	   For optimal performance LWORK >= N*NB, where NB is
*	   the optimal blocksize returned by ILAENV.
*
*	   If LWORK = -1, then a workspace query is assumed; the routine
*	   only calculates the optimal size of the WORK array, returns
*	   this value as the first entry of the WORK array, and no error
*	   message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*	   = 0:  successful exit
*	   < 0:  if INFO = -i, the i-th argument had an illegal value
*	   > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
*		 singular and its inverse could not be computed.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO, ONE
      PARAMETER 	 ( ZERO = 0.0D+0, ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL		 LQUERY
      INTEGER		 I, IWS, J, JB, JJ, JP, LDWORK, LWKOPT, NB,
     $  		 NBMIN, NN
*     ..
*     .. External Functions ..
      INTEGER		 ILAENV
      EXTERNAL  	 ILAENV
*     ..
*     .. External Subroutines ..
      EXTERNAL  	 DGEMM, DGEMV, DSWAP, DTRSM, DTRTRI, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC 	 MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      NB = ILAENV( 1, 'DGETRI', ' ', N, -1, -1, -1 )
      LWKOPT = N*NB
      WORK( 1 ) = LWKOPT
      LQUERY = ( LWORK.EQ.-1 )
      IF( N.LT.0 ) THEN
	 INFO = -1
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
	 INFO = -3
      ELSE IF( LWORK.LT.MAX( 1, N ) .AND. .NOT.LQUERY ) THEN
	 INFO = -6
      END IF
      IF( INFO.NE.0 ) THEN
	 CALL XERBLA( 'DGETRI', -INFO )
	 RETURN
      ELSE IF( LQUERY ) THEN
	 RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 )
     $   RETURN
*
*     Form inv(U).  If INFO > 0 from DTRTRI, then U is singular,
*     and the inverse is not computed.
*
      CALL DTRTRI( 'Upper', 'Non-unit', N, A, LDA, INFO )
      IF( INFO.GT.0 )
     $   RETURN
*
      NBMIN = 2
      LDWORK = N
      IF( NB.GT.1 .AND. NB.LT.N ) THEN
	 IWS = MAX( LDWORK*NB, 1 )
	 IF( LWORK.LT.IWS ) THEN
	    NB = LWORK / LDWORK
	    NBMIN = MAX( 2, ILAENV( 2, 'DGETRI', ' ', N, -1, -1, -1 ) )
	 END IF
      ELSE
	 IWS = N
      END IF
*
*     Solve the equation inv(A)*L = inv(U) for inv(A).
*
      IF( NB.LT.NBMIN .OR. NB.GE.N ) THEN
*
*	 Use unblocked code.
*
	 DO 20 J = N, 1, -1
*
*	    Copy current column of L to WORK and replace with zeros.
*
	    DO 10 I = J + 1, N
	       WORK( I ) = A( I, J )
	       A( I, J ) = ZERO
   10	    CONTINUE
*
*	    Compute current column of inv(A).
*
	    IF( J.LT.N )
     $         CALL DGEMV( 'No transpose', N, N-J, -ONE, A( 1, J+1 ),
     $  		   LDA, WORK( J+1 ), 1, ONE, A( 1, J ), 1 )
   20	 CONTINUE
      ELSE
*
*	 Use blocked code.
*
	 NN = ( ( N-1 ) / NB )*NB + 1
	 DO 50 J = NN, 1, -NB
	    JB = MIN( NB, N-J+1 )
*
*	    Copy current block column of L to WORK and replace with
*	    zeros.
*
	    DO 40 JJ = J, J + JB - 1
	       DO 30 I = JJ + 1, N
		  WORK( I+( JJ-J )*LDWORK ) = A( I, JJ )
		  A( I, JJ ) = ZERO
   30	       CONTINUE
   40	    CONTINUE
*
*	    Compute current block column of inv(A).
*
	    IF( J+JB.LE.N )
     $         CALL DGEMM( 'No transpose', 'No transpose', N, JB,
     $  		   N-J-JB+1, -ONE, A( 1, J+JB ), LDA,
     $  		   WORK( J+JB ), LDWORK, ONE, A( 1, J ), LDA )
	    CALL DTRSM( 'Right', 'Lower', 'No transpose', 'Unit', N, JB,
     $  		ONE, WORK( J ), LDWORK, A( 1, J ), LDA )
   50	 CONTINUE
      END IF
*
*     Apply column interchanges.
*
      DO 60 J = N - 1, 1, -1
	 JP = IPIV( J )
	 IF( JP.NE.J )
     $      CALL DSWAP( N, A( 1, J ), 1, A( 1, JP ), 1 )
   60 CONTINUE
*
      WORK( 1 ) = IWS
      RETURN
*
*     End of DGETRI
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION ALPHA,BETA
      INTEGER K,LDA,LDB,LDC,M,N
      CHARACTER TRANSA,TRANSB
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)
      DIMENSION A(LDA,*),B(LDB,*),C(LDC,*)
*     ..
*
*  Purpose
*  =======
*
*  DGEMM  performs one of the matrix-matrix operations
*
*     C := alpha*op( A )*op( B ) + beta*C,
*
*  where  op( X ) is one of
*
*     op( X ) = X   or   op( X ) = X',
*
*  alpha and beta are scalars, and A, B and C are matrices, with op( A )
*  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
*
*  Arguments
*  ==========
*
*  TRANSA - CHARACTER*1.
*	    On entry, TRANSA specifies the form of op( A ) to be used in
*	    the matrix multiplication as follows:
*
*	       TRANSA = 'N' or 'n',  op( A ) = A.
*
*	       TRANSA = 'T' or 't',  op( A ) = A'.
*
*	       TRANSA = 'C' or 'c',  op( A ) = A'.
*
*	    Unchanged on exit.
*
*  TRANSB - CHARACTER*1.
*	    On entry, TRANSB specifies the form of op( B ) to be used in
*	    the matrix multiplication as follows:
*
*	       TRANSB = 'N' or 'n',  op( B ) = B.
*
*	       TRANSB = 'T' or 't',  op( B ) = B'.
*
*	       TRANSB = 'C' or 'c',  op( B ) = B'.
*
*	    Unchanged on exit.
*
*  M	  - INTEGER.
*	    On entry,  M  specifies  the number  of rows  of the  matrix
*	    op( A )  and of the  matrix  C.  M  must  be at least  zero.
*	    Unchanged on exit.
*
*  N	  - INTEGER.
*	    On entry,  N  specifies the number  of columns of the matrix
*	    op( B ) and the number of columns of the matrix C. N must be
*	    at least zero.
*	    Unchanged on exit.
*
*  K	  - INTEGER.
*	    On entry,  K  specifies  the number of columns of the matrix
*	    op( A ) and the number of rows of the matrix op( B ). K must
*	    be at least  zero.
*	    Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*	    On entry, ALPHA specifies the scalar alpha.
*	    Unchanged on exit.
*
*  A	  - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
*	    k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
*	    Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
*	    part of the array  A  must contain the matrix  A,  otherwise
*	    the leading  k by m  part of the array  A  must contain  the
*	    matrix A.
*	    Unchanged on exit.
*
*  LDA    - INTEGER.
*	    On entry, LDA specifies the first dimension of A as declared
*	    in the calling (sub) program. When  TRANSA = 'N' or 'n' then
*	    LDA must be at least  max( 1, m ), otherwise  LDA must be at
*	    least  max( 1, k ).
*	    Unchanged on exit.
*
*  B	  - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
*	    n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
*	    Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
*	    part of the array  B  must contain the matrix  B,  otherwise
*	    the leading  n by k  part of the array  B  must contain  the
*	    matrix B.
*	    Unchanged on exit.
*
*  LDB    - INTEGER.
*	    On entry, LDB specifies the first dimension of B as declared
*	    in the calling (sub) program. When  TRANSB = 'N' or 'n' then
*	    LDB must be at least  max( 1, k ), otherwise  LDB must be at
*	    least  max( 1, n ).
*	    Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*	    On entry,  BETA  specifies the scalar  beta.  When  BETA  is
*	    supplied as zero then C need not be set on input.
*	    Unchanged on exit.
*
*  C	  - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
*	    Before entry, the leading  m by n  part of the array  C must
*	    contain the matrix  C,  except when  beta  is zero, in which
*	    case C need not be set on entry.
*	    On exit, the array  C  is overwritten by the  m by n  matrix
*	    ( alpha*op( A )*op( B ) + beta*C ).
*
*  LDC    - INTEGER.
*	    On entry, LDC specifies the first dimension of C as declared
*	    in  the  calling  (sub)  program.	LDC  must  be  at  least
*	    max( 1, m ).
*	    Unchanged on exit.
*
*
*  Level 3 Blas routine.
*
*  -- Written on 8-February-1989.
*     Jack Dongarra, Argonne National Laboratory.
*     Iain Duff, AERE Harwell.
*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
*     Sven Hammarling, Numerical Algorithms Group Ltd.
*
*
*     .. External Functions ..
      LOGICAL LSAME
      EXTERNAL LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC MAX
*     ..
*     .. Local Scalars ..
CID      DOUBLE PRECISION TEMP
      INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB
      LOGICAL NOTA,NOTB
*     ..
*     .. Parameters ..
CID      DOUBLE PRECISION ONE,ZERO
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
*     ..
*
*     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
*     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
*     and  columns of  A  and the  number of  rows  of  B  respectively.
*
      NOTA = LSAME(TRANSA,'N')
      NOTB = LSAME(TRANSB,'N')
      IF (NOTA) THEN
	  NROWA = M
	  NCOLA = K
      ELSE
	  NROWA = K
	  NCOLA = M
      END IF
      IF (NOTB) THEN
	  NROWB = K
      ELSE
	  NROWB = N
      END IF
*
*     Test the input parameters.
*
      INFO = 0
      IF ((.NOT.NOTA) .AND. (.NOT.LSAME(TRANSA,'C')) .AND.
     +    (.NOT.LSAME(TRANSA,'T'))) THEN
	  INFO = 1
      ELSE IF ((.NOT.NOTB) .AND. (.NOT.LSAME(TRANSB,'C')) .AND.
     +         (.NOT.LSAME(TRANSB,'T'))) THEN
	  INFO = 2
      ELSE IF (M.LT.0) THEN
	  INFO = 3
      ELSE IF (N.LT.0) THEN
	  INFO = 4
      ELSE IF (K.LT.0) THEN
	  INFO = 5
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN
	  INFO = 8
      ELSE IF (LDB.LT.MAX(1,NROWB)) THEN
	  INFO = 10
      ELSE IF (LDC.LT.MAX(1,M)) THEN
	  INFO = 13
      END IF
      IF (INFO.NE.0) THEN
	  CALL XERBLA('DGEMM ',INFO)
	  RETURN
      END IF
*
*     Quick return if possible.
*
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.
     +    (((ALPHA.EQ.ZERO).OR. (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN
*
*     And if  alpha.eq.zero.
*
      IF (ALPHA.EQ.ZERO) THEN
	  IF (BETA.EQ.ZERO) THEN
	      DO 20 J = 1,N
		  DO 10 I = 1,M
		      C(I,J) = ZERO
   10		  CONTINUE
   20	      CONTINUE
	  ELSE
	      DO 40 J = 1,N
		  DO 30 I = 1,M
		      C(I,J) = BETA*C(I,J)
   30		  CONTINUE
   40	      CONTINUE
	  END IF
	  RETURN
      END IF
*
*     Start the operations.
*
      IF (NOTB) THEN
	  IF (NOTA) THEN
*
*	    Form  C := alpha*A*B + beta*C.
*
	      DO 90 J = 1,N
		  IF (BETA.EQ.ZERO) THEN
		      DO 50 I = 1,M
			  C(I,J) = ZERO
   50		      CONTINUE
		  ELSE IF (BETA.NE.ONE) THEN
		      DO 60 I = 1,M
			  C(I,J) = BETA*C(I,J)
   60		      CONTINUE
		  END IF
		  DO 80 L = 1,K
		      IF (B(L,J).NE.ZERO) THEN
			  TEMP = ALPHA*B(L,J)
			  DO 70 I = 1,M
			      C(I,J) = C(I,J) + TEMP*A(I,L)
   70			  CONTINUE
		      END IF
   80		  CONTINUE
   90	      CONTINUE
	  ELSE
*
*	    Form  C := alpha*A'*B + beta*C
*
	      DO 120 J = 1,N
		  DO 110 I = 1,M
		      TEMP = ZERO
		      DO 100 L = 1,K
			  TEMP = TEMP + A(L,I)*B(L,J)
  100		      CONTINUE
		      IF (BETA.EQ.ZERO) THEN
			  C(I,J) = ALPHA*TEMP
		      ELSE
			  C(I,J) = ALPHA*TEMP + BETA*C(I,J)
		      END IF
  110		  CONTINUE
  120	      CONTINUE
	  END IF
      ELSE
	  IF (NOTA) THEN
*
*	    Form  C := alpha*A*B' + beta*C
*
	      DO 170 J = 1,N
		  IF (BETA.EQ.ZERO) THEN
		      DO 130 I = 1,M
			  C(I,J) = ZERO
  130		      CONTINUE
		  ELSE IF (BETA.NE.ONE) THEN
		      DO 140 I = 1,M
			  C(I,J) = BETA*C(I,J)
  140		      CONTINUE
		  END IF
		  DO 160 L = 1,K
		      IF (B(J,L).NE.ZERO) THEN
			  TEMP = ALPHA*B(J,L)
			  DO 150 I = 1,M
			      C(I,J) = C(I,J) + TEMP*A(I,L)
  150			  CONTINUE
		      END IF
  160		  CONTINUE
  170	      CONTINUE
	  ELSE
*
*	    Form  C := alpha*A'*B' + beta*C
*
	      DO 200 J = 1,N
		  DO 190 I = 1,M
		      TEMP = ZERO
		      DO 180 L = 1,K
			  TEMP = TEMP + A(L,I)*B(J,L)
  180		      CONTINUE
		      IF (BETA.EQ.ZERO) THEN
			  C(I,J) = ALPHA*TEMP
		      ELSE
			  C(I,J) = ALPHA*TEMP + BETA*C(I,J)
		      END IF
  190		  CONTINUE
  200	      CONTINUE
	  END IF
      END IF
*
      RETURN
*
*     End of DGEMM .
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION ALPHA,BETA
      INTEGER INCX,INCY,LDA,M,N
      CHARACTER TRANS
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION A(LDA,*),X(*),Y(*)
      DIMENSION A(LDA,*),X(*),Y(*)
*     ..
*
*  Purpose
*  =======
*
*  DGEMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n matrix.
*
*  Arguments
*  ==========
*
*  TRANS  - CHARACTER*1.
*	    On entry, TRANS specifies the operation to be performed as
*	    follows:
*
*	       TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*	       TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*	       TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
*
*	    Unchanged on exit.
*
*  M	  - INTEGER.
*	    On entry, M specifies the number of rows of the matrix A.
*	    M must be at least zero.
*	    Unchanged on exit.
*
*  N	  - INTEGER.
*	    On entry, N specifies the number of columns of the matrix A.
*	    N must be at least zero.
*	    Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*	    On entry, ALPHA specifies the scalar alpha.
*	    Unchanged on exit.
*
*  A	  - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*	    Before entry, the leading m by n part of the array A must
*	    contain the matrix of coefficients.
*	    Unchanged on exit.
*
*  LDA    - INTEGER.
*	    On entry, LDA specifies the first dimension of A as declared
*	    in the calling (sub) program. LDA must be at least
*	    max( 1, m ).
*	    Unchanged on exit.
*
*  X	  - DOUBLE PRECISION array of DIMENSION at least
*	    ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
*	    and at least
*	    ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*	    Before entry, the incremented array X must contain the
*	    vector x.
*	    Unchanged on exit.
*
*  INCX   - INTEGER.
*	    On entry, INCX specifies the increment for the elements of
*	    X. INCX must not be zero.
*	    Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*	    On entry, BETA specifies the scalar beta. When BETA is
*	    supplied as zero then Y need not be set on input.
*	    Unchanged on exit.
*
*  Y	  - DOUBLE PRECISION array of DIMENSION at least
*	    ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*	    and at least
*	    ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
*	    Before entry with BETA non-zero, the incremented array Y
*	    must contain the vector y. On exit, Y is overwritten by the
*	    updated vector y.
*
*  INCY   - INTEGER.
*	    On entry, INCY specifies the increment for the elements of
*	    Y. INCY must not be zero.
*	    Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
CID      DOUBLE PRECISION ONE,ZERO
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
*     ..
*     .. Local Scalars ..
CID      DOUBLE PRECISION TEMP
      INTEGER I,INFO,IX,IY,J,JX,JY,KX,KY,LENX,LENY
*     ..
*     .. External Functions ..
      LOGICAL LSAME
      EXTERNAL LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC MAX
*     ..
*
*     Test the input parameters.
*
      INFO = 0
      IF (.NOT.LSAME(TRANS,'N') .AND. .NOT.LSAME(TRANS,'T') .AND.
     +    .NOT.LSAME(TRANS,'C')) THEN
	  INFO = 1
      ELSE IF (M.LT.0) THEN
	  INFO = 2
      ELSE IF (N.LT.0) THEN
	  INFO = 3
      ELSE IF (LDA.LT.MAX(1,M)) THEN
	  INFO = 6
      ELSE IF (INCX.EQ.0) THEN
	  INFO = 8
      ELSE IF (INCY.EQ.0) THEN
	  INFO = 11
      END IF
      IF (INFO.NE.0) THEN
	  CALL XERBLA('DGEMV ',INFO)
	  RETURN
      END IF
*
*     Quick return if possible.
*
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.
     +    ((ALPHA.EQ.ZERO).AND. (BETA.EQ.ONE))) RETURN
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
      IF (LSAME(TRANS,'N')) THEN
	  LENX = N
	  LENY = M
      ELSE
	  LENX = M
	  LENY = N
      END IF
      IF (INCX.GT.0) THEN
	  KX = 1
      ELSE
	  KX = 1 - (LENX-1)*INCX
      END IF
      IF (INCY.GT.0) THEN
	  KY = 1
      ELSE
	  KY = 1 - (LENY-1)*INCY
      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
      IF (BETA.NE.ONE) THEN
	  IF (INCY.EQ.1) THEN
	      IF (BETA.EQ.ZERO) THEN
		  DO 10 I = 1,LENY
		      Y(I) = ZERO
   10		  CONTINUE
	      ELSE
		  DO 20 I = 1,LENY
		      Y(I) = BETA*Y(I)
   20		  CONTINUE
	      END IF
	  ELSE
	      IY = KY
	      IF (BETA.EQ.ZERO) THEN
		  DO 30 I = 1,LENY
		      Y(IY) = ZERO
		      IY = IY + INCY
   30		  CONTINUE
	      ELSE
		  DO 40 I = 1,LENY
		      Y(IY) = BETA*Y(IY)
		      IY = IY + INCY
   40		  CONTINUE
	      END IF
	  END IF
      END IF
      IF (ALPHA.EQ.ZERO) RETURN
      IF (LSAME(TRANS,'N')) THEN
*
*	 Form  y := alpha*A*x + y.
*
	  JX = KX
	  IF (INCY.EQ.1) THEN
	      DO 60 J = 1,N
		  IF (X(JX).NE.ZERO) THEN
		      TEMP = ALPHA*X(JX)
		      DO 50 I = 1,M
			  Y(I) = Y(I) + TEMP*A(I,J)
   50		      CONTINUE
		  END IF
		  JX = JX + INCX
   60	      CONTINUE
	  ELSE
	      DO 80 J = 1,N
		  IF (X(JX).NE.ZERO) THEN
		      TEMP = ALPHA*X(JX)
		      IY = KY
		      DO 70 I = 1,M
			  Y(IY) = Y(IY) + TEMP*A(I,J)
			  IY = IY + INCY
   70		      CONTINUE
		  END IF
		  JX = JX + INCX
   80	      CONTINUE
	  END IF
      ELSE
*
*	 Form  y := alpha*A'*x + y.
*
	  JY = KY
	  IF (INCX.EQ.1) THEN
	      DO 100 J = 1,N
		  TEMP = ZERO
		  DO 90 I = 1,M
		      TEMP = TEMP + A(I,J)*X(I)
   90		  CONTINUE
		  Y(JY) = Y(JY) + ALPHA*TEMP
		  JY = JY + INCY
  100	      CONTINUE
	  ELSE
	      DO 120 J = 1,N
		  TEMP = ZERO
		  IX = KX
		  DO 110 I = 1,M
		      TEMP = TEMP + A(I,J)*X(IX)
		      IX = IX + INCX
  110		  CONTINUE
		  Y(JY) = Y(JY) + ALPHA*TEMP
		  JY = JY + INCY
  120	      CONTINUE
	  END IF
      END IF
*
      RETURN
*
*     End of DGEMV .
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DGER(M,N,ALPHA,X,INCX,Y,INCY,A,LDA)
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION ALPHA
      INTEGER INCX,INCY,LDA,M,N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION A(LDA,*),X(*),Y(*)
      DIMENSION A(LDA,*),X(*),Y(*)
*     ..
*
*  Purpose
*  =======
*
*  DGER   performs the rank 1 operation
*
*     A := alpha*x*y' + A,
*
*  where alpha is a scalar, x is an m element vector, y is an n element
*  vector and A is an m by n matrix.
*
*  Arguments
*  ==========
*
*  M	  - INTEGER.
*	    On entry, M specifies the number of rows of the matrix A.
*	    M must be at least zero.
*	    Unchanged on exit.
*
*  N	  - INTEGER.
*	    On entry, N specifies the number of columns of the matrix A.
*	    N must be at least zero.
*	    Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*	    On entry, ALPHA specifies the scalar alpha.
*	    Unchanged on exit.
*
*  X	  - DOUBLE PRECISION array of dimension at least
*	    ( 1 + ( m - 1 )*abs( INCX ) ).
*	    Before entry, the incremented array X must contain the m
*	    element vector x.
*	    Unchanged on exit.
*
*  INCX   - INTEGER.
*	    On entry, INCX specifies the increment for the elements of
*	    X. INCX must not be zero.
*	    Unchanged on exit.
*
*  Y	  - DOUBLE PRECISION array of dimension at least
*	    ( 1 + ( n - 1 )*abs( INCY ) ).
*	    Before entry, the incremented array Y must contain the n
*	    element vector y.
*	    Unchanged on exit.
*
*  INCY   - INTEGER.
*	    On entry, INCY specifies the increment for the elements of
*	    Y. INCY must not be zero.
*	    Unchanged on exit.
*
*  A	  - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*	    Before entry, the leading m by n part of the array A must
*	    contain the matrix of coefficients. On exit, A is
*	    overwritten by the updated matrix.
*
*  LDA    - INTEGER.
*	    On entry, LDA specifies the first dimension of A as declared
*	    in the calling (sub) program. LDA must be at least
*	    max( 1, m ).
*	    Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
CID      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D+0)
*     ..
*     .. Local Scalars ..
CID      DOUBLE PRECISION TEMP
      INTEGER I,INFO,IX,J,JY,KX
*     ..
*     .. External Subroutines ..
      EXTERNAL XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC MAX
*     ..
*
*     Test the input parameters.
*
      INFO = 0
      IF (M.LT.0) THEN
	  INFO = 1
      ELSE IF (N.LT.0) THEN
	  INFO = 2
      ELSE IF (INCX.EQ.0) THEN
	  INFO = 5
      ELSE IF (INCY.EQ.0) THEN
	  INFO = 7
      ELSE IF (LDA.LT.MAX(1,M)) THEN
	  INFO = 9
      END IF
      IF (INFO.NE.0) THEN
	  CALL XERBLA('DGER  ',INFO)
	  RETURN
      END IF
*
*     Quick return if possible.
*
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR. (ALPHA.EQ.ZERO)) RETURN
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
      IF (INCY.GT.0) THEN
	  JY = 1
      ELSE
	  JY = 1 - (N-1)*INCY
      END IF
      IF (INCX.EQ.1) THEN
	  DO 20 J = 1,N
	      IF (Y(JY).NE.ZERO) THEN
		  TEMP = ALPHA*Y(JY)
		  DO 10 I = 1,M
		      A(I,J) = A(I,J) + X(I)*TEMP
   10		  CONTINUE
	      END IF
	      JY = JY + INCY
   20	  CONTINUE
      ELSE
	  IF (INCX.GT.0) THEN
	      KX = 1
	  ELSE
	      KX = 1 - (M-1)*INCX
	  END IF
	  DO 40 J = 1,N
	      IF (Y(JY).NE.ZERO) THEN
		  TEMP = ALPHA*Y(JY)
		  IX = KX
		  DO 30 I = 1,M
		      A(I,J) = A(I,J) + X(IX)*TEMP
		      IX = IX + INCX
   30		  CONTINUE
	      END IF
	      JY = JY + INCY
   40	  CONTINUE
      END IF
*
      RETURN
*
*     End of DGER  .
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DGETF2( M, N, A, LDA, IPIV, INFO )
*
*  -- LAPACK routine (version 3.2) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER		 INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER		 IPIV( * )
CID      DOUBLE PRECISION   A( LDA, * )
      DIMENSION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DGETF2 computes an LU factorization of a general m-by-n matrix A
*  using partial pivoting with row interchanges.
*
*  The factorization has the form
*     A = P * L * U
*  where P is a permutation matrix, L is lower triangular with unit
*  diagonal elements (lower trapezoidal if m > n), and U is upper
*  triangular (upper trapezoidal if m < n).
*
*  This is the right-looking Level 2 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  M	   (input) INTEGER
*	   The number of rows of the matrix A.  M >= 0.
*
*  N	   (input) INTEGER
*	   The number of columns of the matrix A.  N >= 0.
*
*  A	   (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*	   On entry, the m by n matrix to be factored.
*	   On exit, the factors L and U from the factorization
*	   A = P*L*U; the unit diagonal elements of L are not stored.
*
*  LDA     (input) INTEGER
*	   The leading dimension of the array A.  LDA >= max(1,M).
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*	   The pivot indices; for 1 <= i <= min(M,N), row i of the
*	   matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*	   = 0: successful exit
*	   < 0: if INFO = -k, the k-th argument had an illegal value
*	   > 0: if INFO = k, U(k,k) is exactly zero. The factorization
*		has been completed, but the factor U is exactly
*		singular, and division by zero will occur if it is used
*		to solve a system of equations.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE, ZERO
      PARAMETER 	 ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
CID      DOUBLE PRECISION   SFMIN 
      INTEGER		 I, J, JP
*     ..
*     .. External Functions ..
CID      DOUBLE PRECISION   DLAMCH      
      INTEGER		 IDAMAX
      EXTERNAL  	 DLAMCH, IDAMAX
*     ..
*     .. External Subroutines ..
      EXTERNAL  	 DGER, DSCAL, DSWAP, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC 	 MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
	 INFO = -1
      ELSE IF( N.LT.0 ) THEN
	 INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
	 INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
	 CALL XERBLA( 'DGETF2', -INFO )
	 RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
*     Compute machine safe minimum 
* 
      SFMIN = DLAMCH('S')  
*
      DO 10 J = 1, MIN( M, N )
*
*	 Find pivot and test for singularity.
*
	 JP = J - 1 + IDAMAX( M-J+1, A( J, J ), 1 )
	 IPIV( J ) = JP
	 IF( A( JP, J ).NE.ZERO ) THEN
*
*	    Apply the interchange to columns 1:N.
*
	    IF( JP.NE.J )
     $         CALL DSWAP( N, A( J, 1 ), LDA, A( JP, 1 ), LDA )
*
*	    Compute elements J+1:M of J-th column.
*
	    IF( J.LT.M ) THEN 
	       IF( ABS(A( J, J )) .GE. SFMIN ) THEN 
		  CALL DSCAL( M-J, ONE / A( J, J ), A( J+1, J ), 1 ) 
	       ELSE 
		 DO 20 I = 1, M-J 
		    A( J+I, J ) = A( J+I, J ) / A( J, J ) 
   20		 CONTINUE 
	       END IF 
	    END IF 
*
	 ELSE IF( INFO.EQ.0 ) THEN
*
	    INFO = J
	 END IF
*
	 IF( J.LT.MIN( M, N ) ) THEN
*
*	    Update trailing submatrix.
*
	    CALL DGER( M-J, N-J, -ONE, A( J+1, J ), 1, A( J, J+1 ), LDA,
     $  	       A( J+1, J+1 ), LDA )
	 END IF
   10 CONTINUE
      RETURN
*
*     End of DGETF2
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DLASWP( N, A, LDA, K1, K2, IPIV, INCX )
*
*  -- LAPACK auxiliary routine (version 3.2) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER		 INCX, K1, K2, LDA, N
*     ..
*     .. Array Arguments ..
      INTEGER		 IPIV( * )
CID      DOUBLE PRECISION   A( LDA, * )
      DIMENSION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DLASWP performs a series of row interchanges on the matrix A.
*  One row interchange is initiated for each of rows K1 through K2 of A.
*
*  Arguments
*  =========
*
*  N	   (input) INTEGER
*	   The number of columns of the matrix A.
*
*  A	   (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*	   On entry, the matrix of column dimension N to which the row
*	   interchanges will be applied.
*	   On exit, the permuted matrix.
*
*  LDA     (input) INTEGER
*	   The leading dimension of the array A.
*
*  K1	   (input) INTEGER
*	   The first element of IPIV for which a row interchange will
*	   be done.
*
*  K2	   (input) INTEGER
*	   The last element of IPIV for which a row interchange will
*	   be done.
*
*  IPIV    (input) INTEGER array, dimension (K2*abs(INCX))
*	   The vector of pivot indices.  Only the elements in positions
*	   K1 through K2 of IPIV are accessed.
*	   IPIV(K) = L implies rows K and L are to be interchanged.
*
*  INCX    (input) INTEGER
*	   The increment between successive values of IPIV.  If IPIV
*	   is negative, the pivots are applied in reverse order.
*
*  Further Details
*  ===============
*
*  Modified by
*   R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
*
* =====================================================================
*
*     .. Local Scalars ..
      INTEGER		 I, I1, I2, INC, IP, IX, IX0, J, K, N32
CID      DOUBLE PRECISION   TEMP
*     ..
*     .. Executable Statements ..
*
*     Interchange row I with row IPIV(I) for each of rows K1 through K2.
*
      IF( INCX.GT.0 ) THEN
	 IX0 = K1
	 I1 = K1
	 I2 = K2
	 INC = 1
      ELSE IF( INCX.LT.0 ) THEN
	 IX0 = 1 + ( 1-K2 )*INCX
	 I1 = K2
	 I2 = K1
	 INC = -1
      ELSE
	 RETURN
      END IF
*
      N32 = ( N / 32 )*32
      IF( N32.NE.0 ) THEN
	 DO 30 J = 1, N32, 32
	    IX = IX0
	    DO 20 I = I1, I2, INC
	       IP = IPIV( IX )
	       IF( IP.NE.I ) THEN
		  DO 10 K = J, J + 31
		     TEMP = A( I, K )
		     A( I, K ) = A( IP, K )
		     A( IP, K ) = TEMP
   10		  CONTINUE
	       END IF
	       IX = IX + INCX
   20	    CONTINUE
   30	 CONTINUE
      END IF
      IF( N32.NE.N ) THEN
	 N32 = N32 + 1
	 IX = IX0
	 DO 50 I = I1, I2, INC
	    IP = IPIV( IX )
	    IF( IP.NE.I ) THEN
	       DO 40 K = N32, N
		  TEMP = A( I, K )
		  A( I, K ) = A( IP, K )
		  A( IP, K ) = TEMP
   40	       CONTINUE
	    END IF
	    IX = IX + INCX
   50	 CONTINUE
      END IF
*
      RETURN
*
*     End of DLASWP
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION ALPHA
      INTEGER LDA,LDB,M,N
      CHARACTER DIAG,SIDE,TRANSA,UPLO
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION A(LDA,*),B(LDB,*)
      DIMENSION A(LDA,*),B(LDB,*)
*     ..
*
*  Purpose
*  =======
*
*  DTRSM  solves one of the matrix equations
*
*     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
*
*  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
*  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
*
*     op( A ) = A   or   op( A ) = A'.
*
*  The matrix X is overwritten on B.
*
*  Arguments
*  ==========
*
*  SIDE   - CHARACTER*1.
*	    On entry, SIDE specifies whether op( A ) appears on the left
*	    or right of X as follows:
*
*	       SIDE = 'L' or 'l'   op( A )*X = alpha*B.
*
*	       SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
*
*	    Unchanged on exit.
*
*  UPLO   - CHARACTER*1.
*	    On entry, UPLO specifies whether the matrix A is an upper or
*	    lower triangular matrix as follows:
*
*	       UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*	       UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*	    Unchanged on exit.
*
*  TRANSA - CHARACTER*1.
*	    On entry, TRANSA specifies the form of op( A ) to be used in
*	    the matrix multiplication as follows:
*
*	       TRANSA = 'N' or 'n'   op( A ) = A.
*
*	       TRANSA = 'T' or 't'   op( A ) = A'.
*
*	       TRANSA = 'C' or 'c'   op( A ) = A'.
*
*	    Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*	    On entry, DIAG specifies whether or not A is unit triangular
*	    as follows:
*
*	       DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*	       DIAG = 'N' or 'n'   A is not assumed to be unit
*				   triangular.
*
*	    Unchanged on exit.
*
*  M	  - INTEGER.
*	    On entry, M specifies the number of rows of B. M must be at
*	    least zero.
*	    Unchanged on exit.
*
*  N	  - INTEGER.
*	    On entry, N specifies the number of columns of B.  N must be
*	    at least zero.
*	    Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*	    On entry,  ALPHA specifies the scalar  alpha. When  alpha is
*	    zero then  A is not referenced and  B need not be set before
*	    entry.
*	    Unchanged on exit.
*
*  A	  - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
*	    when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
*	    Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
*	    upper triangular part of the array  A must contain the upper
*	    triangular matrix  and the strictly lower triangular part of
*	    A is not referenced.
*	    Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
*	    lower triangular part of the array  A must contain the lower
*	    triangular matrix  and the strictly upper triangular part of
*	    A is not referenced.
*	    Note that when  DIAG = 'U' or 'u',  the diagonal elements of
*	    A  are not referenced either,  but are assumed to be  unity.
*	    Unchanged on exit.
*
*  LDA    - INTEGER.
*	    On entry, LDA specifies the first dimension of A as declared
*	    in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
*	    LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
*	    then LDA must be at least max( 1, n ).
*	    Unchanged on exit.
*
*  B	  - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
*	    Before entry,  the leading  m by n part of the array  B must
*	    contain  the  right-hand  side  matrix  B,  and  on exit  is
*	    overwritten by the solution matrix  X.
*
*  LDB    - INTEGER.
*	    On entry, LDB specifies the first dimension of B as declared
*	    in  the  calling  (sub)  program.	LDB  must  be  at  least
*	    max( 1, m ).
*	    Unchanged on exit.
*
*
*  Level 3 Blas routine.
*
*
*  -- Written on 8-February-1989.
*     Jack Dongarra, Argonne National Laboratory.
*     Iain Duff, AERE Harwell.
*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
*     Sven Hammarling, Numerical Algorithms Group Ltd.
*
*
*     .. External Functions ..
      LOGICAL LSAME
      EXTERNAL LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC MAX
*     ..
*     .. Local Scalars ..
CID      DOUBLE PRECISION TEMP
      INTEGER I,INFO,J,K,NROWA
      LOGICAL LSIDE,NOUNIT,UPPER
*     ..
*     .. Parameters ..
CID      DOUBLE PRECISION ONE,ZERO
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
*     ..
*
*     Test the input parameters.
*
      LSIDE = LSAME(SIDE,'L')
      IF (LSIDE) THEN
	  NROWA = M
      ELSE
	  NROWA = N
      END IF
      NOUNIT = LSAME(DIAG,'N')
      UPPER = LSAME(UPLO,'U')
*
      INFO = 0
      IF ((.NOT.LSIDE) .AND. (.NOT.LSAME(SIDE,'R'))) THEN
	  INFO = 1
      ELSE IF ((.NOT.UPPER) .AND. (.NOT.LSAME(UPLO,'L'))) THEN
	  INFO = 2
      ELSE IF ((.NOT.LSAME(TRANSA,'N')) .AND.
     +         (.NOT.LSAME(TRANSA,'T')) .AND.
     +         (.NOT.LSAME(TRANSA,'C'))) THEN
	  INFO = 3
      ELSE IF ((.NOT.LSAME(DIAG,'U')) .AND. (.NOT.LSAME(DIAG,'N'))) THEN
	  INFO = 4
      ELSE IF (M.LT.0) THEN
	  INFO = 5
      ELSE IF (N.LT.0) THEN
	  INFO = 6
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN
	  INFO = 9
      ELSE IF (LDB.LT.MAX(1,M)) THEN
	  INFO = 11
      END IF
      IF (INFO.NE.0) THEN
	  CALL XERBLA('DTRSM ',INFO)
	  RETURN
      END IF
*
*     Quick return if possible.
*
      IF (M.EQ.0 .OR. N.EQ.0) RETURN
*
*     And when  alpha.eq.zero.
*
      IF (ALPHA.EQ.ZERO) THEN
	  DO 20 J = 1,N
	      DO 10 I = 1,M
		  B(I,J) = ZERO
   10	      CONTINUE
   20	  CONTINUE
	  RETURN
      END IF
*
*     Start the operations.
*
      IF (LSIDE) THEN
	  IF (LSAME(TRANSA,'N')) THEN
*
*	    Form  B := alpha*inv( A )*B.
*
	      IF (UPPER) THEN
		  DO 60 J = 1,N
		      IF (ALPHA.NE.ONE) THEN
			  DO 30 I = 1,M
			      B(I,J) = ALPHA*B(I,J)
   30			  CONTINUE
		      END IF
		      DO 50 K = M,1,-1
			  IF (B(K,J).NE.ZERO) THEN
			      IF (NOUNIT) B(K,J) = B(K,J)/A(K,K)
			      DO 40 I = 1,K - 1
				  B(I,J) = B(I,J) - B(K,J)*A(I,K)
   40			      CONTINUE
			  END IF
   50		      CONTINUE
   60		  CONTINUE
	      ELSE
		  DO 100 J = 1,N
		      IF (ALPHA.NE.ONE) THEN
			  DO 70 I = 1,M
			      B(I,J) = ALPHA*B(I,J)
   70			  CONTINUE
		      END IF
		      DO 90 K = 1,M
			  IF (B(K,J).NE.ZERO) THEN
			      IF (NOUNIT) B(K,J) = B(K,J)/A(K,K)
			      DO 80 I = K + 1,M
				  B(I,J) = B(I,J) - B(K,J)*A(I,K)
   80			      CONTINUE
			  END IF
   90		      CONTINUE
  100		  CONTINUE
	      END IF
	  ELSE
*
*	    Form  B := alpha*inv( A' )*B.
*
	      IF (UPPER) THEN
		  DO 130 J = 1,N
		      DO 120 I = 1,M
			  TEMP = ALPHA*B(I,J)
			  DO 110 K = 1,I - 1
			      TEMP = TEMP - A(K,I)*B(K,J)
  110			  CONTINUE
			  IF (NOUNIT) TEMP = TEMP/A(I,I)
			  B(I,J) = TEMP
  120		      CONTINUE
  130		  CONTINUE
	      ELSE
		  DO 160 J = 1,N
		      DO 150 I = M,1,-1
			  TEMP = ALPHA*B(I,J)
			  DO 140 K = I + 1,M
			      TEMP = TEMP - A(K,I)*B(K,J)
  140			  CONTINUE
			  IF (NOUNIT) TEMP = TEMP/A(I,I)
			  B(I,J) = TEMP
  150		      CONTINUE
  160		  CONTINUE
	      END IF
	  END IF
      ELSE
	  IF (LSAME(TRANSA,'N')) THEN
*
*	    Form  B := alpha*B*inv( A ).
*
	      IF (UPPER) THEN
		  DO 210 J = 1,N
		      IF (ALPHA.NE.ONE) THEN
			  DO 170 I = 1,M
			      B(I,J) = ALPHA*B(I,J)
  170			  CONTINUE
		      END IF
		      DO 190 K = 1,J - 1
			  IF (A(K,J).NE.ZERO) THEN
			      DO 180 I = 1,M
				  B(I,J) = B(I,J) - A(K,J)*B(I,K)
  180			      CONTINUE
			  END IF
  190		      CONTINUE
		      IF (NOUNIT) THEN
			  TEMP = ONE/A(J,J)
			  DO 200 I = 1,M
			      B(I,J) = TEMP*B(I,J)
  200			  CONTINUE
		      END IF
  210		  CONTINUE
	      ELSE
		  DO 260 J = N,1,-1
		      IF (ALPHA.NE.ONE) THEN
			  DO 220 I = 1,M
			      B(I,J) = ALPHA*B(I,J)
  220			  CONTINUE
		      END IF
		      DO 240 K = J + 1,N
			  IF (A(K,J).NE.ZERO) THEN
			      DO 230 I = 1,M
				  B(I,J) = B(I,J) - A(K,J)*B(I,K)
  230			      CONTINUE
			  END IF
  240		      CONTINUE
		      IF (NOUNIT) THEN
			  TEMP = ONE/A(J,J)
			  DO 250 I = 1,M
			      B(I,J) = TEMP*B(I,J)
  250			  CONTINUE
		      END IF
  260		  CONTINUE
	      END IF
	  ELSE
*
*	    Form  B := alpha*B*inv( A' ).
*
	      IF (UPPER) THEN
		  DO 310 K = N,1,-1
		      IF (NOUNIT) THEN
			  TEMP = ONE/A(K,K)
			  DO 270 I = 1,M
			      B(I,K) = TEMP*B(I,K)
  270			  CONTINUE
		      END IF
		      DO 290 J = 1,K - 1
			  IF (A(J,K).NE.ZERO) THEN
			      TEMP = A(J,K)
			      DO 280 I = 1,M
				  B(I,J) = B(I,J) - TEMP*B(I,K)
  280			      CONTINUE
			  END IF
  290		      CONTINUE
		      IF (ALPHA.NE.ONE) THEN
			  DO 300 I = 1,M
			      B(I,K) = ALPHA*B(I,K)
  300			  CONTINUE
		      END IF
  310		  CONTINUE
	      ELSE
		  DO 360 K = 1,N
		      IF (NOUNIT) THEN
			  TEMP = ONE/A(K,K)
			  DO 320 I = 1,M
			      B(I,K) = TEMP*B(I,K)
  320			  CONTINUE
		      END IF
		      DO 340 J = K + 1,N
			  IF (A(J,K).NE.ZERO) THEN
			      TEMP = A(J,K)
			      DO 330 I = 1,M
				  B(I,J) = B(I,J) - TEMP*B(I,K)
  330			      CONTINUE
			  END IF
  340		      CONTINUE
		      IF (ALPHA.NE.ONE) THEN
			  DO 350 I = 1,M
			      B(I,K) = ALPHA*B(I,K)
  350			  CONTINUE
		      END IF
  360		  CONTINUE
	      END IF
	  END IF
      END IF
*
      RETURN
*
*     End of DTRSM .
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DTRTI2( UPLO, DIAG, N, A, LDA, INFO )
*
*  -- LAPACK routine (version 3.2) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER 	 DIAG, UPLO
      INTEGER		 INFO, LDA, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * )
      DIMENSION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DTRTI2 computes the inverse of a real upper or lower triangular
*  matrix.
*
*  This is the Level 2 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*	   Specifies whether the matrix A is upper or lower triangular.
*	   = 'U':  Upper triangular
*	   = 'L':  Lower triangular
*
*  DIAG    (input) CHARACTER*1
*	   Specifies whether or not the matrix A is unit triangular.
*	   = 'N':  Non-unit triangular
*	   = 'U':  Unit triangular
*
*  N	   (input) INTEGER
*	   The order of the matrix A.  N >= 0.
*
*  A	   (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*	   On entry, the triangular matrix A.  If UPLO = 'U', the
*	   leading n by n upper triangular part of the array A contains
*	   the upper triangular matrix, and the strictly lower
*	   triangular part of A is not referenced.  If UPLO = 'L', the
*	   leading n by n lower triangular part of the array A contains
*	   the lower triangular matrix, and the strictly upper
*	   triangular part of A is not referenced.  If DIAG = 'U', the
*	   diagonal elements of A are also not referenced and are
*	   assumed to be 1.
*
*	   On exit, the (triangular) inverse of the original matrix, in
*	   the same storage format.
*
*  LDA     (input) INTEGER
*	   The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*	   = 0: successful exit
*	   < 0: if INFO = -k, the k-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE
      PARAMETER 	 ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL		 NOUNIT, UPPER
      INTEGER		 J
CID      DOUBLE PRECISION   AJJ
*     ..
*     .. External Functions ..
      LOGICAL		 LSAME
      EXTERNAL  	 LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL  	 DSCAL, DTRMV, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC 	 MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      NOUNIT = LSAME( DIAG, 'N' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
	 INFO = -1
      ELSE IF( .NOT.NOUNIT .AND. .NOT.LSAME( DIAG, 'U' ) ) THEN
	 INFO = -2
      ELSE IF( N.LT.0 ) THEN
	 INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
	 INFO = -5
      END IF
      IF( INFO.NE.0 ) THEN
	 CALL XERBLA( 'DTRTI2', -INFO )
	 RETURN
      END IF
*
      IF( UPPER ) THEN
*
*	 Compute inverse of upper triangular matrix.
*
	 DO 10 J = 1, N
	    IF( NOUNIT ) THEN
	       A( J, J ) = ONE / A( J, J )
	       AJJ = -A( J, J )
	    ELSE
	       AJJ = -ONE
	    END IF
*
*	    Compute elements 1:j-1 of j-th column.
*
	    CALL DTRMV( 'Upper', 'No transpose', DIAG, J-1, A, LDA,
     $  		A( 1, J ), 1 )
	    CALL DSCAL( J-1, AJJ, A( 1, J ), 1 )
   10	 CONTINUE
      ELSE
*
*	 Compute inverse of lower triangular matrix.
*
	 DO 20 J = N, 1, -1
	    IF( NOUNIT ) THEN
	       A( J, J ) = ONE / A( J, J )
	       AJJ = -A( J, J )
	    ELSE
	       AJJ = -ONE
	    END IF
	    IF( J.LT.N ) THEN
*
*	       Compute elements j+1:n of j-th column.
*
	       CALL DTRMV( 'Lower', 'No transpose', DIAG, N-J,
     $  		   A( J+1, J+1 ), LDA, A( J+1, J ), 1 )
	       CALL DSCAL( N-J, AJJ, A( J+1, J ), 1 )
	    END IF
   20	 CONTINUE
      END IF
*
      RETURN
*
*     End of DTRTI2
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DTRTRI( UPLO, DIAG, N, A, LDA, INFO )
*
*  -- LAPACK routine (version 3.2) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER 	 DIAG, UPLO
      INTEGER		 INFO, LDA, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * )
      DIMENSION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DTRTRI computes the inverse of a real upper or lower triangular
*  matrix A.
*
*  This is the Level 3 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*	   = 'U':  A is upper triangular;
*	   = 'L':  A is lower triangular.
*
*  DIAG    (input) CHARACTER*1
*	   = 'N':  A is non-unit triangular;
*	   = 'U':  A is unit triangular.
*
*  N	   (input) INTEGER
*	   The order of the matrix A.  N >= 0.
*
*  A	   (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*	   On entry, the triangular matrix A.  If UPLO = 'U', the
*	   leading N-by-N upper triangular part of the array A contains
*	   the upper triangular matrix, and the strictly lower
*	   triangular part of A is not referenced.  If UPLO = 'L', the
*	   leading N-by-N lower triangular part of the array A contains
*	   the lower triangular matrix, and the strictly upper
*	   triangular part of A is not referenced.  If DIAG = 'U', the
*	   diagonal elements of A are also not referenced and are
*	   assumed to be 1.
*	   On exit, the (triangular) inverse of the original matrix, in
*	   the same storage format.
*
*  LDA     (input) INTEGER
*	   The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*	   = 0: successful exit
*	   < 0: if INFO = -i, the i-th argument had an illegal value
*	   > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
*		matrix is singular and its inverse can not be computed.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE, ZERO
      PARAMETER 	 ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL		 NOUNIT, UPPER
      INTEGER		 J, JB, NB, NN
*     ..
*     .. External Functions ..
      LOGICAL		 LSAME
      INTEGER		 ILAENV
      EXTERNAL  	 LSAME, ILAENV
*     ..
*     .. External Subroutines ..
      EXTERNAL  	 DTRMM, DTRSM, DTRTI2, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC 	 MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      NOUNIT = LSAME( DIAG, 'N' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
	 INFO = -1
      ELSE IF( .NOT.NOUNIT .AND. .NOT.LSAME( DIAG, 'U' ) ) THEN
	 INFO = -2
      ELSE IF( N.LT.0 ) THEN
	 INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
	 INFO = -5
      END IF
      IF( INFO.NE.0 ) THEN
	 CALL XERBLA( 'DTRTRI', -INFO )
	 RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 )
     $   RETURN
*
*     Check for singularity if non-unit.
*
      IF( NOUNIT ) THEN
	 DO 10 INFO = 1, N
	    IF( A( INFO, INFO ).EQ.ZERO )
     $         RETURN
   10	 CONTINUE
	 INFO = 0
      END IF
*
*     Determine the block size for this environment.
*
      NB = ILAENV( 1, 'DTRTRI', UPLO // DIAG, N, -1, -1, -1 )
      IF( NB.LE.1 .OR. NB.GE.N ) THEN
*
*	 Use unblocked code
*
	 CALL DTRTI2( UPLO, DIAG, N, A, LDA, INFO )
      ELSE
*
*	 Use blocked code
*
	 IF( UPPER ) THEN
*
*	    Compute inverse of upper triangular matrix
*
	    DO 20 J = 1, N, NB
	       JB = MIN( NB, N-J+1 )
*
*	       Compute rows 1:j-1 of current block column
*
	       CALL DTRMM( 'Left', 'Upper', 'No transpose', DIAG, J-1,
     $  		   JB, ONE, A, LDA, A( 1, J ), LDA )
	       CALL DTRSM( 'Right', 'Upper', 'No transpose', DIAG, J-1,
     $  		   JB, -ONE, A( J, J ), LDA, A( 1, J ), LDA )
*
*	       Compute inverse of current diagonal block
*
	       CALL DTRTI2( 'Upper', DIAG, JB, A( J, J ), LDA, INFO )
   20	    CONTINUE
	 ELSE
*
*	    Compute inverse of lower triangular matrix
*
	    NN = ( ( N-1 ) / NB )*NB + 1
	    DO 30 J = NN, 1, -NB
	       JB = MIN( NB, N-J+1 )
	       IF( J+JB.LE.N ) THEN
*
*		  Compute rows j+jb:n of current block column
*
		  CALL DTRMM( 'Left', 'Lower', 'No transpose', DIAG,
     $  		      N-J-JB+1, JB, ONE, A( J+JB, J+JB ), LDA,
     $  		      A( J+JB, J ), LDA )
		  CALL DTRSM( 'Right', 'Lower', 'No transpose', DIAG,
     $  		      N-J-JB+1, JB, -ONE, A( J, J ), LDA,
     $  		      A( J+JB, J ), LDA )
	       END IF
*
*	       Compute inverse of current diagonal block
*
	       CALL DTRTI2( 'Lower', DIAG, JB, A( J, J ), LDA, INFO )
   30	    CONTINUE
	 END IF
      END IF
*
      RETURN
*
*     End of DTRTRI
*
      END
C
C=======================================================================
C=======================================================================
C
      INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 )
*
*  -- LAPACK auxiliary routine (version 3.2) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     January 2007
*
*     .. Scalar Arguments ..
      CHARACTER*( * )	 NAME, OPTS
      INTEGER		 ISPEC, N1, N2, N3, N4
*     ..
*
*  Purpose
*  =======
*
*  ILAENV is called from the LAPACK routines to choose problem-dependent
*  parameters for the local environment.  See ISPEC for a description of
*  the parameters.
*
*  ILAENV returns an INTEGER
*  if ILAENV >= 0: ILAENV returns the value of the parameter specified by ISPEC
*  if ILAENV < 0:  if ILAENV = -k, the k-th argument had an illegal value.
*
*  This version provides a set of parameters which should give good,
*  but not optimal, performance on many of the currently available
*  computers.  Users are encouraged to modify this subroutine to set
*  the tuning parameters for their particular machine using the option
*  and problem size information in the arguments.
*
*  This routine will not function correctly if it is converted to all
*  lower case.  Converting it to all upper case is allowed.
*
*  Arguments
*  =========
*
*  ISPEC   (input) INTEGER
*	   Specifies the parameter to be returned as the value of
*	   ILAENV.
*	   = 1: the optimal blocksize; if this value is 1, an unblocked
*		algorithm will give the best performance.
*	   = 2: the minimum block size for which the block routine
*		should be used; if the usable block size is less than
*		this value, an unblocked routine should be used.
*	   = 3: the crossover point (in a block routine, for N less
*		than this value, an unblocked routine should be used)
*	   = 4: the number of shifts, used in the nonsymmetric
*		eigenvalue routines (DEPRECATED)
*	   = 5: the minimum column dimension for blocking to be used;
*		rectangular blocks must have dimension at least k by m,
*		where k is given by ILAENV(2,...) and m by ILAENV(5,...)
*	   = 6: the crossover point for the SVD (when reducing an m by n
*		matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
*		this value, a QR factorization is used first to reduce
*		the matrix to a triangular form.)
*	   = 7: the number of processors
*	   = 8: the crossover point for the multishift QR method
*		for nonsymmetric eigenvalue problems (DEPRECATED)
*	   = 9: maximum size of the subproblems at the bottom of the
*		computation tree in the divide-and-conquer algorithm
*		(used by xGELSD and xGESDD)
*	   =10: ieee NaN arithmetic can be trusted not to trap
*	   =11: infinity arithmetic can be trusted not to trap
*	   12 <= ISPEC <= 16:
*		xHSEQR or one of its subroutines,
*		see IPARMQ for detailed explanation
*
*  NAME    (input) CHARACTER*(*)
*	   The name of the calling subroutine, in either upper case or
*	   lower case.
*
*  OPTS    (input) CHARACTER*(*)
*	   The character options to the subroutine NAME, concatenated
*	   into a single character string.  For example, UPLO = 'U',
*	   TRANS = 'T', and DIAG = 'N' for a triangular routine would
*	   be specified as OPTS = 'UTN'.
*
*  N1	   (input) INTEGER
*  N2	   (input) INTEGER
*  N3	   (input) INTEGER
*  N4	   (input) INTEGER
*	   Problem dimensions for the subroutine NAME; these may not all
*	   be required.
*
*  Further Details
*  ===============
*
*  The following conventions have been used when calling ILAENV from the
*  LAPACK routines:
*  1)  OPTS is a concatenation of all of the character options to
*      subroutine NAME, in the same order that they appear in the
*      argument list for NAME, even if they are not used in determining
*      the value of the parameter specified by ISPEC.
*  2)  The problem dimensions N1, N2, N3, N4 are specified in the order
*      that they appear in the argument list for NAME.  N1 is used
*      first, N2 second, and so on, and unused problem dimensions are
*      passed a value of -1.
*  3)  The parameter value returned by ILAENV is checked for validity in
*      the calling subroutine.  For example, ILAENV is used to retrieve
*      the optimal blocksize for STRTRI as follows:
*
*      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
*      IF( NB.LE.1 ) NB = MAX( 1, N )
*
*  =====================================================================
*
*     .. Local Scalars ..
      INTEGER		 I, IC, IZ, NB, NBMIN, NX
      LOGICAL		 CNAME, SNAME
      CHARACTER 	 C1*1, C2*2, C4*2, C3*3, SUBNAM*6
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC 	 CHAR, ICHAR, INT, MIN, REAL
*     ..
*     .. External Functions ..
      INTEGER		 IEEECK, IPARMQ
      EXTERNAL  	 IEEECK, IPARMQ
*     ..
*     .. Executable Statements ..
*
      GO TO ( 10, 10, 10, 80, 90, 100, 110, 120,
     $        130, 140, 150, 160, 160, 160, 160, 160 )ISPEC
*
*     Invalid value for ISPEC
*
      ILAENV = -1
      RETURN
*
   10 CONTINUE
*
*     Convert NAME to upper case if the first character is lower case.
*
      ILAENV = 1
      SUBNAM = NAME
      IC = ICHAR( SUBNAM( 1: 1 ) )
      IZ = ICHAR( 'Z' )
      IF( IZ.EQ.90 .OR. IZ.EQ.122 ) THEN
*
*	 ASCII character set
*
	 IF( IC.GE.97 .AND. IC.LE.122 ) THEN
	    SUBNAM( 1: 1 ) = CHAR( IC-32 )
	    DO 20 I = 2, 6
	       IC = ICHAR( SUBNAM( I: I ) )
	       IF( IC.GE.97 .AND. IC.LE.122 )
     $  	  SUBNAM( I: I ) = CHAR( IC-32 )
   20	    CONTINUE
	 END IF
*
      ELSE IF( IZ.EQ.233 .OR. IZ.EQ.169 ) THEN
*
*	 EBCDIC character set
*
	 IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.
     $       ( IC.GE.145 .AND. IC.LE.153 ) .OR.
     $       ( IC.GE.162 .AND. IC.LE.169 ) ) THEN
	    SUBNAM( 1: 1 ) = CHAR( IC+64 )
	    DO 30 I = 2, 6
	       IC = ICHAR( SUBNAM( I: I ) )
	       IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.
     $  	   ( IC.GE.145 .AND. IC.LE.153 ) .OR.
     $  	   ( IC.GE.162 .AND. IC.LE.169 ) )SUBNAM( I:
     $  	   I ) = CHAR( IC+64 )
   30	    CONTINUE
	 END IF
*
      ELSE IF( IZ.EQ.218 .OR. IZ.EQ.250 ) THEN
*
*	 Prime machines:  ASCII+128
*
	 IF( IC.GE.225 .AND. IC.LE.250 ) THEN
	    SUBNAM( 1: 1 ) = CHAR( IC-32 )
	    DO 40 I = 2, 6
	       IC = ICHAR( SUBNAM( I: I ) )
	       IF( IC.GE.225 .AND. IC.LE.250 )
     $  	  SUBNAM( I: I ) = CHAR( IC-32 )
   40	    CONTINUE
	 END IF
      END IF
*
      C1 = SUBNAM( 1: 1 )
      SNAME = C1.EQ.'S' .OR. C1.EQ.'D'
      CNAME = C1.EQ.'C' .OR. C1.EQ.'Z'
      IF( .NOT.( CNAME .OR. SNAME ) )
     $   RETURN
      C2 = SUBNAM( 2: 3 )
      C3 = SUBNAM( 4: 6 )
      C4 = C3( 2: 3 )
*
      GO TO ( 50, 60, 70 )ISPEC
*
   50 CONTINUE
*
*     ISPEC = 1:  block size
*
*     In these examples, separate code is provided for setting NB for
*     real and complex.  We assume that NB will take the same value in
*     single or double precision.
*
      NB = 1
*
      IF( C2.EQ.'GE' ) THEN
	 IF( C3.EQ.'TRF' ) THEN
	    IF( SNAME ) THEN
	       NB = 64
	    ELSE
	       NB = 64
	    END IF
	 ELSE IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.
     $  	  C3.EQ.'QLF' ) THEN
	    IF( SNAME ) THEN
	       NB = 32
	    ELSE
	       NB = 32
	    END IF
	 ELSE IF( C3.EQ.'HRD' ) THEN
	    IF( SNAME ) THEN
	       NB = 32
	    ELSE
	       NB = 32
	    END IF
	 ELSE IF( C3.EQ.'BRD' ) THEN
	    IF( SNAME ) THEN
	       NB = 32
	    ELSE
	       NB = 32
	    END IF
	 ELSE IF( C3.EQ.'TRI' ) THEN
	    IF( SNAME ) THEN
	       NB = 64
	    ELSE
	       NB = 64
	    END IF
	 END IF
      ELSE IF( C2.EQ.'PO' ) THEN
	 IF( C3.EQ.'TRF' ) THEN
	    IF( SNAME ) THEN
	       NB = 64
	    ELSE
	       NB = 64
	    END IF
	 END IF
      ELSE IF( C2.EQ.'SY' ) THEN
	 IF( C3.EQ.'TRF' ) THEN
	    IF( SNAME ) THEN
	       NB = 64
	    ELSE
	       NB = 64
	    END IF
	 ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN
	    NB = 32
	 ELSE IF( SNAME .AND. C3.EQ.'GST' ) THEN
	    NB = 64
	 END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
	 IF( C3.EQ.'TRF' ) THEN
	    NB = 64
	 ELSE IF( C3.EQ.'TRD' ) THEN
	    NB = 32
	 ELSE IF( C3.EQ.'GST' ) THEN
	    NB = 64
	 END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
	 IF( C3( 1: 1 ).EQ.'G' ) THEN
	    IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.
     $  	'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )
     $  	 THEN
	       NB = 32
	    END IF
	 ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN
	    IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.
     $  	'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )
     $  	 THEN
	       NB = 32
	    END IF
	 END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
	 IF( C3( 1: 1 ).EQ.'G' ) THEN
	    IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.
     $  	'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )
     $  	 THEN
	       NB = 32
	    END IF
	 ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN
	    IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.
     $  	'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )
     $  	 THEN
	       NB = 32
	    END IF
	 END IF
      ELSE IF( C2.EQ.'GB' ) THEN
	 IF( C3.EQ.'TRF' ) THEN
	    IF( SNAME ) THEN
	       IF( N4.LE.64 ) THEN
		  NB = 1
	       ELSE
		  NB = 32
	       END IF
	    ELSE
	       IF( N4.LE.64 ) THEN
		  NB = 1
	       ELSE
		  NB = 32
	       END IF
	    END IF
	 END IF
      ELSE IF( C2.EQ.'PB' ) THEN
	 IF( C3.EQ.'TRF' ) THEN
	    IF( SNAME ) THEN
	       IF( N2.LE.64 ) THEN
		  NB = 1
	       ELSE
		  NB = 32
	       END IF
	    ELSE
	       IF( N2.LE.64 ) THEN
		  NB = 1
	       ELSE
		  NB = 32
	       END IF
	    END IF
	 END IF
      ELSE IF( C2.EQ.'TR' ) THEN
	 IF( C3.EQ.'TRI' ) THEN
	    IF( SNAME ) THEN
	       NB = 64
	    ELSE
	       NB = 64
	    END IF
	 END IF
      ELSE IF( C2.EQ.'LA' ) THEN
	 IF( C3.EQ.'UUM' ) THEN
	    IF( SNAME ) THEN
	       NB = 64
	    ELSE
	       NB = 64
	    END IF
	 END IF
      ELSE IF( SNAME .AND. C2.EQ.'ST' ) THEN
	 IF( C3.EQ.'EBZ' ) THEN
	    NB = 1
	 END IF
      END IF
      ILAENV = NB
      RETURN
*
   60 CONTINUE
*
*     ISPEC = 2:  minimum block size
*
      NBMIN = 2
      IF( C2.EQ.'GE' ) THEN
	 IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR. C3.EQ.
     $       'QLF' ) THEN
	    IF( SNAME ) THEN
	       NBMIN = 2
	    ELSE
	       NBMIN = 2
	    END IF
	 ELSE IF( C3.EQ.'HRD' ) THEN
	    IF( SNAME ) THEN
	       NBMIN = 2
	    ELSE
	       NBMIN = 2
	    END IF
	 ELSE IF( C3.EQ.'BRD' ) THEN
	    IF( SNAME ) THEN
	       NBMIN = 2
	    ELSE
	       NBMIN = 2
	    END IF
	 ELSE IF( C3.EQ.'TRI' ) THEN
	    IF( SNAME ) THEN
	       NBMIN = 2
	    ELSE
	       NBMIN = 2
	    END IF
	 END IF
      ELSE IF( C2.EQ.'SY' ) THEN
	 IF( C3.EQ.'TRF' ) THEN
	    IF( SNAME ) THEN
	       NBMIN = 8
	    ELSE
	       NBMIN = 8
	    END IF
	 ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN
	    NBMIN = 2
	 END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
	 IF( C3.EQ.'TRD' ) THEN
	    NBMIN = 2
	 END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
	 IF( C3( 1: 1 ).EQ.'G' ) THEN
	    IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.
     $  	'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )
     $  	 THEN
	       NBMIN = 2
	    END IF
	 ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN
	    IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.
     $  	'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )
     $  	 THEN
	       NBMIN = 2
	    END IF
	 END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
	 IF( C3( 1: 1 ).EQ.'G' ) THEN
	    IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.
     $  	'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )
     $  	 THEN
	       NBMIN = 2
	    END IF
	 ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN
	    IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.
     $  	'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )
     $  	 THEN
	       NBMIN = 2
	    END IF
	 END IF
      END IF
      ILAENV = NBMIN
      RETURN
*
   70 CONTINUE
*
*     ISPEC = 3:  crossover point
*
      NX = 0
      IF( C2.EQ.'GE' ) THEN
	 IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR. C3.EQ.
     $       'QLF' ) THEN
	    IF( SNAME ) THEN
	       NX = 128
	    ELSE
	       NX = 128
	    END IF
	 ELSE IF( C3.EQ.'HRD' ) THEN
	    IF( SNAME ) THEN
	       NX = 128
	    ELSE
	       NX = 128
	    END IF
	 ELSE IF( C3.EQ.'BRD' ) THEN
	    IF( SNAME ) THEN
	       NX = 128
	    ELSE
	       NX = 128
	    END IF
	 END IF
      ELSE IF( C2.EQ.'SY' ) THEN
	 IF( SNAME .AND. C3.EQ.'TRD' ) THEN
	    NX = 32
	 END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
	 IF( C3.EQ.'TRD' ) THEN
	    NX = 32
	 END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
	 IF( C3( 1: 1 ).EQ.'G' ) THEN
	    IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.
     $  	'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )
     $  	 THEN
	       NX = 128
	    END IF
	 END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
	 IF( C3( 1: 1 ).EQ.'G' ) THEN
	    IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.
     $  	'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )
     $  	 THEN
	       NX = 128
	    END IF
	 END IF
      END IF
      ILAENV = NX
      RETURN
*
   80 CONTINUE
*
*     ISPEC = 4:  number of shifts (used by xHSEQR)
*
      ILAENV = 6
      RETURN
*
   90 CONTINUE
*
*     ISPEC = 5:  minimum column dimension (not used)
*
      ILAENV = 2
      RETURN
*
  100 CONTINUE
*
*     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD)
*
      ILAENV = INT( REAL( MIN( N1, N2 ) )*1.6E0 )
      RETURN
*
  110 CONTINUE
*
*     ISPEC = 7:  number of processors (not used)
*
      ILAENV = 1
      RETURN
*
  120 CONTINUE
*
*     ISPEC = 8:  crossover point for multishift (used by xHSEQR)
*
      ILAENV = 50
      RETURN
*
  130 CONTINUE
*
*     ISPEC = 9:  maximum size of the subproblems at the bottom of the
*		  computation tree in the divide-and-conquer algorithm
*		  (used by xGELSD and xGESDD)
*
      ILAENV = 25
      RETURN
*
  140 CONTINUE
*
*     ISPEC = 10: ieee NaN arithmetic can be trusted not to trap
*
*     ILAENV = 0
      ILAENV = 1
      IF( ILAENV.EQ.1 ) THEN
	 ILAENV = IEEECK( 1, 0.0, 1.0 )
      END IF
      RETURN
*
  150 CONTINUE
*
*     ISPEC = 11: infinity arithmetic can be trusted not to trap
*
*     ILAENV = 0
      ILAENV = 1
      IF( ILAENV.EQ.1 ) THEN
	 ILAENV = IEEECK( 0, 0.0, 1.0 )
      END IF
      RETURN
*
  160 CONTINUE
*
*     12 <= ISPEC <= 16: xHSEQR or one of its subroutines. 
*
      ILAENV = IPARMQ( ISPEC, NAME, OPTS, N1, N2, N3, N4 )
      RETURN
*
*     End of ILAENV
*
      END
C
C=======================================================================
C=======================================================================
C
      INTEGER FUNCTION IPARMQ( ISPEC, NAME, OPTS, N, ILO, IHI, LWORK )
*
*  -- LAPACK auxiliary routine (version 3.2) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*     
*     .. Scalar Arguments ..
      INTEGER		 IHI, ILO, ISPEC, LWORK, N
      CHARACTER 	 NAME*( * ), OPTS*( * )
*
*  Purpose
*  =======
*
*	This program sets problem and machine dependent parameters
*	useful for xHSEQR and its subroutines. It is called whenever 
*	ILAENV is called with 12 <= ISPEC <= 16
*
*  Arguments
*  =========
*
*	ISPEC  (input) integer scalar
*	       ISPEC specifies which tunable parameter IPARMQ should
*	       return.
*
*	       ISPEC=12: (INMIN)  Matrices of order nmin or less
*			 are sent directly to xLAHQR, the implicit
*			 double shift QR algorithm.  NMIN must be
*			 at least 11.
*
*	       ISPEC=13: (INWIN)  Size of the deflation window.
*			 This is best set greater than or equal to
*			 the number of simultaneous shifts NS.
*			 Larger matrices benefit from larger deflation
*			 windows.
*
*	       ISPEC=14: (INIBL) Determines when to stop nibbling and
*			 invest in an (expensive) multi-shift QR sweep.
*			 If the aggressive early deflation subroutine
*			 finds LD converged eigenvalues from an order
*			 NW deflation window and LD.GT.(NW*NIBBLE)/100,
*			 then the next QR sweep is skipped and early
*			 deflation is applied immediately to the
*			 remaining active diagonal block.  Setting
*			 IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a
*			 multi-shift QR sweep whenever early deflation
*			 finds a converged eigenvalue.  Setting
*			 IPARMQ(ISPEC=14) greater than or equal to 100
*			 prevents TTQRE from skipping a multi-shift
*			 QR sweep.
*
*	       ISPEC=15: (NSHFTS) The number of simultaneous shifts in
*			 a multi-shift QR iteration.
*
*	       ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the
*			 following meanings.
*			 0:  During the multi-shift QR sweep,
*			     xLAQR5 does not accumulate reflections and
*			     does not use matrix-matrix multiply to
*			     update the far-from-diagonal matrix
*			     entries.
*			 1:  During the multi-shift QR sweep,
*			     xLAQR5 and/or xLAQRaccumulates reflections and uses
*			     matrix-matrix multiply to update the
*			     far-from-diagonal matrix entries.
*			 2:  During the multi-shift QR sweep.
*			     xLAQR5 accumulates reflections and takes
*			     advantage of 2-by-2 block structure during
*			     matrix-matrix multiplies.
*			 (If xTRMM is slower than xGEMM, then
*			 IPARMQ(ISPEC=16)=1 may be more efficient than
*			 IPARMQ(ISPEC=16)=2 despite the greater level of
*			 arithmetic work implied by the latter choice.)
*
*	NAME	(input) character string
*		Name of the calling subroutine
*
*	OPTS	(input) character string
*		This is a concatenation of the string arguments to
*		TTQRE.
*
*	N	(input) integer scalar
*		N is the order of the Hessenberg matrix H.
*
*	ILO	(input) INTEGER
*	IHI	(input) INTEGER
*		It is assumed that H is already upper triangular
*		in rows and columns 1:ILO-1 and IHI+1:N.
*
*	LWORK	(input) integer scalar
*		The amount of workspace available.
*
*  Further Details
*  ===============
*
*	Little is known about how best to choose these parameters.
*	It is possible to use different values of the parameters
*	for each of CHSEQR, DHSEQR, SHSEQR and ZHSEQR.
*
*	It is probably best to choose different parameters for
*	different matrices and different parameters at different
*	times during the iteration, but this has not been
*	implemented --- yet.
*
*
*	The best choices of most of the parameters depend
*	in an ill-understood way on the relative execution
*	rate of xLAQR3 and xLAQR5 and on the nature of each
*	particular eigenvalue problem.  Experiment may be the
*	only practical way to determine which choices are most
*	effective.
*
*	Following is a list of default values supplied by IPARMQ.
*	These defaults may be adjusted in order to attain better
*	performance in any particular computational environment.
*
*	IPARMQ(ISPEC=12) The xLAHQR vs xLAQR0 crossover point.
*			 Default: 75. (Must be at least 11.)
*
*	IPARMQ(ISPEC=13) Recommended deflation window size.
*			 This depends on ILO, IHI and NS, the
*			 number of simultaneous shifts returned
*			 by IPARMQ(ISPEC=15).  The default for
*			 (IHI-ILO+1).LE.500 is NS.  The default
*			 for (IHI-ILO+1).GT.500 is 3*NS/2.
*
*	IPARMQ(ISPEC=14) Nibble crossover point.  Default: 14.
*
*	IPARMQ(ISPEC=15) Number of simultaneous shifts, NS.
*			 a multi-shift QR iteration.
*
*			 If IHI-ILO+1 is ...
*
*			 greater than	   ...but less    ... the
*			 or equal to ...      than	  default is
*
*				 0		 30	  NS =   2+
*				30		 60	  NS =   4+
*				60		150	  NS =  10
*			       150		590	  NS =  **
*			       590	       3000	  NS =  64
*			      3000	       6000	  NS = 128
*			      6000	       infinity   NS = 256
*
*		     (+)  By default matrices of this order are
*			  passed to the implicit double shift routine
*			  xLAHQR.  See IPARMQ(ISPEC=12) above.   These
*			  values of NS are used only in case of a rare
*			  xLAHQR failure.
*
*		     (**) The asterisks (**) indicate an ad-hoc
*			  function increasing from 10 to 64.
*
*	IPARMQ(ISPEC=16) Select structured matrix multiply.
*			 (See ISPEC=16 above for details.)
*			 Default: 3.
*
*     ================================================================
*     .. Parameters ..
      INTEGER		 INMIN, INWIN, INIBL, ISHFTS, IACC22
      PARAMETER 	 ( INMIN = 12, INWIN = 13, INIBL = 14,
     $  		 ISHFTS = 15, IACC22 = 16 )
      INTEGER		 NMIN, K22MIN, KACMIN, NIBBLE, KNWSWP
      PARAMETER 	 ( NMIN = 75, K22MIN = 14, KACMIN = 14,
     $  		 NIBBLE = 14, KNWSWP = 500 )
      REAL		 TWO
      PARAMETER 	 ( TWO = 2.0 )
*     ..
*     .. Local Scalars ..
      INTEGER		 NH, NS
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC 	 LOG, MAX, MOD, NINT, REAL
*     ..
*     .. Executable Statements ..
      IF( ( ISPEC.EQ.ISHFTS ) .OR. ( ISPEC.EQ.INWIN ) .OR.
     $    ( ISPEC.EQ.IACC22 ) ) THEN
*
*	 ==== Set the number simultaneous shifts ====
*
	 NH = IHI - ILO + 1
	 NS = 2
	 IF( NH.GE.30 )
     $      NS = 4
	 IF( NH.GE.60 )
     $      NS = 10
	 IF( NH.GE.150 )
     $      NS = MAX( 10, NH / NINT( LOG( REAL( NH ) ) / LOG( TWO ) ) )
	 IF( NH.GE.590 )
     $      NS = 64
	 IF( NH.GE.3000 )
     $      NS = 128
	 IF( NH.GE.6000 )
     $      NS = 256
	 NS = MAX( 2, NS-MOD( NS, 2 ) )
      END IF
*
      IF( ISPEC.EQ.INMIN ) THEN
*
*
*	 ===== Matrices of order smaller than NMIN get sent
*	 .     to xLAHQR, the classic double shift algorithm.
*	 .     This must be at least 11. ====
*
	 IPARMQ = NMIN
*
      ELSE IF( ISPEC.EQ.INIBL ) THEN
*
*	 ==== INIBL: skip a multi-shift qr iteration and
*	 .    whenever aggressive early deflation finds
*	 .    at least (NIBBLE*(window size)/100) deflations. ====
*
	 IPARMQ = NIBBLE
*
      ELSE IF( ISPEC.EQ.ISHFTS ) THEN
*
*	 ==== NSHFTS: The number of simultaneous shifts =====
*
	 IPARMQ = NS
*
      ELSE IF( ISPEC.EQ.INWIN ) THEN
*
*	 ==== NW: deflation window size.  ====
*
	 IF( NH.LE.KNWSWP ) THEN
	    IPARMQ = NS
	 ELSE
	    IPARMQ = 3*NS / 2
	 END IF
*
      ELSE IF( ISPEC.EQ.IACC22 ) THEN
*
*	 ==== IACC22: Whether to accumulate reflections
*	 .     before updating the far-from-diagonal elements
*	 .     and whether to use 2-by-2 block structure while
*	 .     doing it.  A small amount of work could be saved
*	 .     by making this choice dependent also upon the
*	 .     NH=IHI-ILO+1.
*
	 IPARMQ = 0
	 IF( NS.GE.KACMIN )
     $      IPARMQ = 1
	 IF( NS.GE.K22MIN )
     $      IPARMQ = 2
*
      ELSE
*	 ===== invalid value of ispec =====
	 IPARMQ = -1
*
      END IF
*
*     ==== End of IPARMQ ====
*
      END
C
C=======================================================================
C=======================================================================
C
      INTEGER	       FUNCTION IEEECK( ISPEC, ZERO, ONE )
*
*  -- LAPACK auxiliary routine (version 3.2) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER		 ISPEC
      REAL		 ONE, ZERO
*     ..
*
*  Purpose
*  =======
*
*  IEEECK is called from the ILAENV to verify that Infinity and
*  possibly NaN arithmetic is safe (i.e. will not trap).
*
*  Arguments
*  =========
*
*  ISPEC   (input) INTEGER
*	   Specifies whether to test just for inifinity arithmetic
*	   or whether to test for infinity and NaN arithmetic.
*	   = 0: Verify infinity arithmetic only.
*	   = 1: Verify infinity and NaN arithmetic.
*
*  ZERO    (input) REAL
*	   Must contain the value 0.0
*	   This is passed to prevent the compiler from optimizing
*	   away this code.
*
*  ONE     (input) REAL
*	   Must contain the value 1.0
*	   This is passed to prevent the compiler from optimizing
*	   away this code.
*
*  RETURN VALUE:  INTEGER
*	   = 0:  Arithmetic failed to produce the correct answers
*	   = 1:  Arithmetic produced the correct answers
*
*     .. Local Scalars ..
      REAL		 NAN1, NAN2, NAN3, NAN4, NAN5, NAN6, NEGINF,
     $  		 NEGZRO, NEWZRO, POSINF
*     ..
*     .. Executable Statements ..
      IEEECK = 1
*
      POSINF = ONE / ZERO
      IF( POSINF.LE.ONE ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      NEGINF = -ONE / ZERO
      IF( NEGINF.GE.ZERO ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      NEGZRO = ONE / ( NEGINF+ONE )
      IF( NEGZRO.NE.ZERO ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      NEGINF = ONE / NEGZRO
      IF( NEGINF.GE.ZERO ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      NEWZRO = NEGZRO + ZERO
      IF( NEWZRO.NE.ZERO ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      POSINF = ONE / NEWZRO
      IF( POSINF.LE.ONE ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      NEGINF = NEGINF*POSINF
      IF( NEGINF.GE.ZERO ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      POSINF = POSINF*POSINF
      IF( POSINF.LE.ONE ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
*
*
*
*     Return if we were only asked to check infinity arithmetic
*
      IF( ISPEC.EQ.0 )
     $   RETURN
*
      NAN1 = POSINF + NEGINF
*
      NAN2 = POSINF / NEGINF
*
      NAN3 = POSINF / POSINF
*
      NAN4 = POSINF*ZERO
*
      NAN5 = NEGINF*NEGZRO
*
      NAN6 = NAN5*0.0
*
      IF( NAN1.EQ.NAN1 ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      IF( NAN2.EQ.NAN2 ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      IF( NAN3.EQ.NAN3 ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      IF( NAN4.EQ.NAN4 ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      IF( NAN5.EQ.NAN5 ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      IF( NAN6.EQ.NAN6 ) THEN
	 IEEECK = 0
	 RETURN
      END IF
*
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION ALPHA
      INTEGER LDA,LDB,M,N
      CHARACTER DIAG,SIDE,TRANSA,UPLO
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION A(LDA,*),B(LDB,*)
      DIMENSION A(LDA,*),B(LDB,*)
*     ..
*
*  Purpose
*  =======
*
*  DTRMM  performs one of the matrix-matrix operations
*
*     B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
*
*  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
*  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
*
*     op( A ) = A   or   op( A ) = A'.
*
*  Arguments
*  ==========
*
*  SIDE   - CHARACTER*1.
*	    On entry,  SIDE specifies whether  op( A ) multiplies B from
*	    the left or right as follows:
*
*	       SIDE = 'L' or 'l'   B := alpha*op( A )*B.
*
*	       SIDE = 'R' or 'r'   B := alpha*B*op( A ).
*
*	    Unchanged on exit.
*
*  UPLO   - CHARACTER*1.
*	    On entry, UPLO specifies whether the matrix A is an upper or
*	    lower triangular matrix as follows:
*
*	       UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*	       UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*	    Unchanged on exit.
*
*  TRANSA - CHARACTER*1.
*	    On entry, TRANSA specifies the form of op( A ) to be used in
*	    the matrix multiplication as follows:
*
*	       TRANSA = 'N' or 'n'   op( A ) = A.
*
*	       TRANSA = 'T' or 't'   op( A ) = A'.
*
*	       TRANSA = 'C' or 'c'   op( A ) = A'.
*
*	    Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*	    On entry, DIAG specifies whether or not A is unit triangular
*	    as follows:
*
*	       DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*	       DIAG = 'N' or 'n'   A is not assumed to be unit
*				   triangular.
*
*	    Unchanged on exit.
*
*  M	  - INTEGER.
*	    On entry, M specifies the number of rows of B. M must be at
*	    least zero.
*	    Unchanged on exit.
*
*  N	  - INTEGER.
*	    On entry, N specifies the number of columns of B.  N must be
*	    at least zero.
*	    Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*	    On entry,  ALPHA specifies the scalar  alpha. When  alpha is
*	    zero then  A is not referenced and  B need not be set before
*	    entry.
*	    Unchanged on exit.
*
*  A	  - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
*	    when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
*	    Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
*	    upper triangular part of the array  A must contain the upper
*	    triangular matrix  and the strictly lower triangular part of
*	    A is not referenced.
*	    Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
*	    lower triangular part of the array  A must contain the lower
*	    triangular matrix  and the strictly upper triangular part of
*	    A is not referenced.
*	    Note that when  DIAG = 'U' or 'u',  the diagonal elements of
*	    A  are not referenced either,  but are assumed to be  unity.
*	    Unchanged on exit.
*
*  LDA    - INTEGER.
*	    On entry, LDA specifies the first dimension of A as declared
*	    in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
*	    LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
*	    then LDA must be at least max( 1, n ).
*	    Unchanged on exit.
*
*  B	  - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
*	    Before entry,  the leading  m by n part of the array  B must
*	    contain the matrix  B,  and  on exit  is overwritten  by the
*	    transformed matrix.
*
*  LDB    - INTEGER.
*	    On entry, LDB specifies the first dimension of B as declared
*	    in  the  calling  (sub)  program.	LDB  must  be  at  least
*	    max( 1, m ).
*	    Unchanged on exit.
*
*
*  Level 3 Blas routine.
*
*  -- Written on 8-February-1989.
*     Jack Dongarra, Argonne National Laboratory.
*     Iain Duff, AERE Harwell.
*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
*     Sven Hammarling, Numerical Algorithms Group Ltd.
*
*
*     .. External Functions ..
      LOGICAL LSAME
      EXTERNAL LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC MAX
*     ..
*     .. Local Scalars ..
CID      DOUBLE PRECISION TEMP
      INTEGER I,INFO,J,K,NROWA
      LOGICAL LSIDE,NOUNIT,UPPER
*     ..
*     .. Parameters ..
CID      DOUBLE PRECISION ONE,ZERO
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
*     ..
*
*     Test the input parameters.
*
      LSIDE = LSAME(SIDE,'L')
      IF (LSIDE) THEN
	  NROWA = M
      ELSE
	  NROWA = N
      END IF
      NOUNIT = LSAME(DIAG,'N')
      UPPER = LSAME(UPLO,'U')
*
      INFO = 0
      IF ((.NOT.LSIDE) .AND. (.NOT.LSAME(SIDE,'R'))) THEN
	  INFO = 1
      ELSE IF ((.NOT.UPPER) .AND. (.NOT.LSAME(UPLO,'L'))) THEN
	  INFO = 2
      ELSE IF ((.NOT.LSAME(TRANSA,'N')) .AND.
     +         (.NOT.LSAME(TRANSA,'T')) .AND.
     +         (.NOT.LSAME(TRANSA,'C'))) THEN
	  INFO = 3
      ELSE IF ((.NOT.LSAME(DIAG,'U')) .AND. (.NOT.LSAME(DIAG,'N'))) THEN
	  INFO = 4
      ELSE IF (M.LT.0) THEN
	  INFO = 5
      ELSE IF (N.LT.0) THEN
	  INFO = 6
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN
	  INFO = 9
      ELSE IF (LDB.LT.MAX(1,M)) THEN
	  INFO = 11
      END IF
      IF (INFO.NE.0) THEN
	  CALL XERBLA('DTRMM ',INFO)
	  RETURN
      END IF
*
*     Quick return if possible.
*
      IF (M.EQ.0 .OR. N.EQ.0) RETURN
*
*     And when  alpha.eq.zero.
*
      IF (ALPHA.EQ.ZERO) THEN
	  DO 20 J = 1,N
	      DO 10 I = 1,M
		  B(I,J) = ZERO
   10	      CONTINUE
   20	  CONTINUE
	  RETURN
      END IF
*
*     Start the operations.
*
      IF (LSIDE) THEN
	  IF (LSAME(TRANSA,'N')) THEN
*
*	    Form  B := alpha*A*B.
*
	      IF (UPPER) THEN
		  DO 50 J = 1,N
		      DO 40 K = 1,M
			  IF (B(K,J).NE.ZERO) THEN
			      TEMP = ALPHA*B(K,J)
			      DO 30 I = 1,K - 1
				  B(I,J) = B(I,J) + TEMP*A(I,K)
   30			      CONTINUE
			      IF (NOUNIT) TEMP = TEMP*A(K,K)
			      B(K,J) = TEMP
			  END IF
   40		      CONTINUE
   50		  CONTINUE
	      ELSE
		  DO 80 J = 1,N
		      DO 70 K = M,1,-1
			  IF (B(K,J).NE.ZERO) THEN
			      TEMP = ALPHA*B(K,J)
			      B(K,J) = TEMP
			      IF (NOUNIT) B(K,J) = B(K,J)*A(K,K)
			      DO 60 I = K + 1,M
				  B(I,J) = B(I,J) + TEMP*A(I,K)
   60			      CONTINUE
			  END IF
   70		      CONTINUE
   80		  CONTINUE
	      END IF
	  ELSE
*
*	    Form  B := alpha*A'*B.
*
	      IF (UPPER) THEN
		  DO 110 J = 1,N
		      DO 100 I = M,1,-1
			  TEMP = B(I,J)
			  IF (NOUNIT) TEMP = TEMP*A(I,I)
			  DO 90 K = 1,I - 1
			      TEMP = TEMP + A(K,I)*B(K,J)
   90			  CONTINUE
			  B(I,J) = ALPHA*TEMP
  100		      CONTINUE
  110		  CONTINUE
	      ELSE
		  DO 140 J = 1,N
		      DO 130 I = 1,M
			  TEMP = B(I,J)
			  IF (NOUNIT) TEMP = TEMP*A(I,I)
			  DO 120 K = I + 1,M
			      TEMP = TEMP + A(K,I)*B(K,J)
  120			  CONTINUE
			  B(I,J) = ALPHA*TEMP
  130		      CONTINUE
  140		  CONTINUE
	      END IF
	  END IF
      ELSE
	  IF (LSAME(TRANSA,'N')) THEN
*
*	    Form  B := alpha*B*A.
*
	      IF (UPPER) THEN
		  DO 180 J = N,1,-1
		      TEMP = ALPHA
		      IF (NOUNIT) TEMP = TEMP*A(J,J)
		      DO 150 I = 1,M
			  B(I,J) = TEMP*B(I,J)
  150		      CONTINUE
		      DO 170 K = 1,J - 1
			  IF (A(K,J).NE.ZERO) THEN
			      TEMP = ALPHA*A(K,J)
			      DO 160 I = 1,M
				  B(I,J) = B(I,J) + TEMP*B(I,K)
  160			      CONTINUE
			  END IF
  170		      CONTINUE
  180		  CONTINUE
	      ELSE
		  DO 220 J = 1,N
		      TEMP = ALPHA
		      IF (NOUNIT) TEMP = TEMP*A(J,J)
		      DO 190 I = 1,M
			  B(I,J) = TEMP*B(I,J)
  190		      CONTINUE
		      DO 210 K = J + 1,N
			  IF (A(K,J).NE.ZERO) THEN
			      TEMP = ALPHA*A(K,J)
			      DO 200 I = 1,M
				  B(I,J) = B(I,J) + TEMP*B(I,K)
  200			      CONTINUE
			  END IF
  210		      CONTINUE
  220		  CONTINUE
	      END IF
	  ELSE
*
*	    Form  B := alpha*B*A'.
*
	      IF (UPPER) THEN
		  DO 260 K = 1,N
		      DO 240 J = 1,K - 1
			  IF (A(J,K).NE.ZERO) THEN
			      TEMP = ALPHA*A(J,K)
			      DO 230 I = 1,M
				  B(I,J) = B(I,J) + TEMP*B(I,K)
  230			      CONTINUE
			  END IF
  240		      CONTINUE
		      TEMP = ALPHA
		      IF (NOUNIT) TEMP = TEMP*A(K,K)
		      IF (TEMP.NE.ONE) THEN
			  DO 250 I = 1,M
			      B(I,K) = TEMP*B(I,K)
  250			  CONTINUE
		      END IF
  260		  CONTINUE
	      ELSE
		  DO 300 K = N,1,-1
		      DO 280 J = K + 1,N
			  IF (A(J,K).NE.ZERO) THEN
			      TEMP = ALPHA*A(J,K)
			      DO 270 I = 1,M
				  B(I,J) = B(I,J) + TEMP*B(I,K)
  270			      CONTINUE
			  END IF
  280		      CONTINUE
		      TEMP = ALPHA
		      IF (NOUNIT) TEMP = TEMP*A(K,K)
		      IF (TEMP.NE.ONE) THEN
			  DO 290 I = 1,M
			      B(I,K) = TEMP*B(I,K)
  290			  CONTINUE
		      END IF
  300		  CONTINUE
	      END IF
	  END IF
      END IF
*
      RETURN
*
*     End of DTRMM .
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE XERBLA( SRNAME, INFO )
*
*  -- LAPACK auxiliary routine (preliminary version) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER*(*)	 SRNAME
      INTEGER		 INFO
*     ..
*
*  Purpose
*  =======
*
*  XERBLA  is an error handler for the LAPACK routines.
*  It is called by an LAPACK routine if an input parameter has an
*  invalid value.  A message is printed and execution stops.
*
*  Installers may consider modifying the STOP statement in order to
*  call system-specific exception-handling facilities.
*
*  Arguments
*  =========
*
*  SRNAME  (input) CHARACTER*(*)
*	   The name of the routine which called XERBLA.
*
*  INFO    (input) INTEGER
*	   The position of the invalid parameter in the parameter list
*	   of the calling routine.
*
* =====================================================================
*
*     .. Intrinsic Functions ..
      INTRINSIC 	 LEN_TRIM
*     ..
*     .. Executable Statements ..
*
      WRITE( *, FMT = 9999 )SRNAME( 1:LEN_TRIM( SRNAME ) ), INFO
*
      STOP
*
 9999 FORMAT( ' ** On entry to ', A, ' parameter number ', I2, ' had ',
     $      'an illegal value' )
*
*     End of XERBLA
*
      END
C
C=======================================================================
C=======================================================================
C
      INTEGER FUNCTION IDAMAX(N,DX,INCX)
*     .. Scalar Arguments ..
      INTEGER INCX,N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION DX(*)
      DIMENSION DX(*)
*     ..
*
*  Purpose
*  =======
*
*     finds the index of element having max. absolute value.
*     jack dongarra, linpack, 3/11/78.
*     modified 3/93 to return if incx .le. 0.
*     modified 12/3/93, array(1) declarations changed to array(*)
*
*
*     .. Local Scalars ..
CID      DOUBLE PRECISION DMAX
      INTEGER I,IX
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC DABS
*     ..
      IDAMAX = 0
      IF (N.LT.1 .OR. INCX.LE.0) RETURN
      IDAMAX = 1
      IF (N.EQ.1) RETURN
      IF (INCX.EQ.1) GO TO 20
*
*	 code for increment not equal to 1
*
      IX = 1
      DMAX = DABS(DX(1))
      IX = IX + INCX
      DO 10 I = 2,N
          IF (DABS(DX(IX)).LE.DMAX) GO TO 5
          IDAMAX = I
          DMAX = DABS(DX(IX))
    5	  IX = IX + INCX
   10 CONTINUE
      RETURN
*
*	 code for increment equal to 1
*
   20 DMAX = DABS(DX(1))
      DO 30 I = 2,N
          IF (DABS(DX(I)).LE.DMAX) GO TO 30
          IDAMAX = I
          DMAX = DABS(DX(I))
   30 CONTINUE
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DSCAL(N,DA,DX,INCX)
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION DA
      INTEGER INCX,N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION DX(*)
      DIMENSION DX(*)
*     ..
*
*  Purpose
*  =======
**
*     scales a vector by a constant.
*     uses unrolled loops for increment equal to one.
*     jack dongarra, linpack, 3/11/78.
*     modified 3/93 to return if incx .le. 0.
*     modified 12/3/93, array(1) declarations changed to array(*)
*
*
*     .. Local Scalars ..
      INTEGER I,M,MP1,NINCX
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC MOD
*     ..
      IF (N.LE.0 .OR. INCX.LE.0) RETURN
      IF (INCX.EQ.1) GO TO 20
*
*	 code for increment not equal to 1
*
      NINCX = N*INCX
      DO 10 I = 1,NINCX,INCX
          DX(I) = DA*DX(I)
   10 CONTINUE
      RETURN
*
*	 code for increment equal to 1
*
*
*	 clean-up loop
*
   20 M = MOD(N,5)
      IF (M.EQ.0) GO TO 40
      DO 30 I = 1,M
          DX(I) = DA*DX(I)
   30 CONTINUE
      IF (N.LT.5) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,5
          DX(I) = DA*DX(I)
          DX(I+1) = DA*DX(I+1)
          DX(I+2) = DA*DX(I+2)
          DX(I+3) = DA*DX(I+3)
          DX(I+4) = DA*DX(I+4)
   50 CONTINUE
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      LOGICAL FUNCTION LSAME(CA,CB)
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER CA,CB
*     ..
*
*  Purpose
*  =======
*
*  LSAME returns .TRUE. if CA is the same letter as CB regardless of
*  case.
*
*  Arguments
*  =========
*
*  CA	   (input) CHARACTER*1
*
*  CB	   (input) CHARACTER*1
*	   CA and CB specify the single characters to be compared.
*
* =====================================================================
*
*     .. Intrinsic Functions ..
      INTRINSIC ICHAR
*     ..
*     .. Local Scalars ..
      INTEGER INTA,INTB,ZCODE
*     ..
*
*     Test if the characters are equal
*
      LSAME = CA .EQ. CB
      IF (LSAME) RETURN
*
*     Now test for equivalence if both characters are alphabetic.
*
      ZCODE = ICHAR('Z')
*
*     Use 'Z' rather than 'A' so that ASCII can be detected on Prime
*     machines, on which ICHAR returns a value with bit 8 set.
*     ICHAR('A') on Prime machines returns 193 which is the same as
*     ICHAR('A') on an EBCDIC machine.
*
      INTA = ICHAR(CA)
      INTB = ICHAR(CB)
*
      IF (ZCODE.EQ.90 .OR. ZCODE.EQ.122) THEN
*
*	 ASCII is assumed - ZCODE is the ASCII code of either lower or
*	 upper case 'Z'.
*
	  IF (INTA.GE.97 .AND. INTA.LE.122) INTA = INTA - 32
	  IF (INTB.GE.97 .AND. INTB.LE.122) INTB = INTB - 32
*
      ELSE IF (ZCODE.EQ.233 .OR. ZCODE.EQ.169) THEN
*
*	 EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or
*	 upper case 'Z'.
*
	  IF (INTA.GE.129 .AND. INTA.LE.137 .OR.
     +        INTA.GE.145 .AND. INTA.LE.153 .OR.
     +        INTA.GE.162 .AND. INTA.LE.169) INTA = INTA + 64
	  IF (INTB.GE.129 .AND. INTB.LE.137 .OR.
     +        INTB.GE.145 .AND. INTB.LE.153 .OR.
     +        INTB.GE.162 .AND. INTB.LE.169) INTB = INTB + 64
*
      ELSE IF (ZCODE.EQ.218 .OR. ZCODE.EQ.250) THEN
*
*	 ASCII is assumed, on Prime machines - ZCODE is the ASCII code
*	 plus 128 of either lower or upper case 'Z'.
*
	  IF (INTA.GE.225 .AND. INTA.LE.250) INTA = INTA - 32
	  IF (INTB.GE.225 .AND. INTB.LE.250) INTB = INTB - 32
      END IF
      LSAME = INTA .EQ. INTB
*
*     RETURN
*
*     End of LSAME
*
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DSWAP(N,DX,INCX,DY,INCY)
*     .. Scalar Arguments ..
      INTEGER INCX,INCY,N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION DX(*),DY(*)
      DIMENSION DX(*),DY(*)
*     ..
*
*  Purpose
*  =======
*
*     interchanges two vectors.
*     uses unrolled loops for increments equal one.
*     jack dongarra, linpack, 3/11/78.
*     modified 12/3/93, array(1) declarations changed to array(*)
*
*
*     .. Local Scalars ..
CID      DOUBLE PRECISION DTEMP
      INTEGER I,IX,IY,M,MP1
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC MOD
*     ..
      IF (N.LE.0) RETURN
      IF (INCX.EQ.1 .AND. INCY.EQ.1) GO TO 20
*
*	code for unequal increments or equal increments not equal
*	  to 1
*
      IX = 1
      IY = 1
      IF (INCX.LT.0) IX = (-N+1)*INCX + 1
      IF (INCY.LT.0) IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
	  DTEMP = DX(IX)
	  DX(IX) = DY(IY)
	  DY(IY) = DTEMP
	  IX = IX + INCX
	  IY = IY + INCY
   10 CONTINUE
      RETURN
*
*	code for both increments equal to 1
*
*
*	clean-up loop
*
   20 M = MOD(N,3)
      IF (M.EQ.0) GO TO 40
      DO 30 I = 1,M
	  DTEMP = DX(I)
	  DX(I) = DY(I)
	  DY(I) = DTEMP
   30 CONTINUE
      IF (N.LT.3) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,3
	  DTEMP = DX(I)
	  DX(I) = DY(I)
	  DY(I) = DTEMP
	  DTEMP = DX(I+1)
	  DX(I+1) = DY(I+1)
	  DY(I+1) = DTEMP
	  DTEMP = DX(I+2)
	  DX(I+2) = DY(I+2)
	  DY(I+2) = DTEMP
   50 CONTINUE
      RETURN
      END
C
C=======================================================================
C=======================================================================
C
      SUBROUTINE DTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)
*     .. Scalar Arguments ..
      INTEGER INCX,LDA,N
      CHARACTER DIAG,TRANS,UPLO
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION A(LDA,*),X(*)
      DIMENSION A(LDA,*),X(*)
*     ..
*
*  Purpose
*  =======
*
*  DTRMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix.
*
*  Arguments
*  ==========
*
*  UPLO   - CHARACTER*1.
*	    On entry, UPLO specifies whether the matrix is an upper or
*	    lower triangular matrix as follows:
*
*	       UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*	       UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*	    Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*	    On entry, TRANS specifies the operation to be performed as
*	    follows:
*
*	       TRANS = 'N' or 'n'   x := A*x.
*
*	       TRANS = 'T' or 't'   x := A'*x.
*
*	       TRANS = 'C' or 'c'   x := A'*x.
*
*	    Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*	    On entry, DIAG specifies whether or not A is unit
*	    triangular as follows:
*
*	       DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*	       DIAG = 'N' or 'n'   A is not assumed to be unit
*				   triangular.
*
*	    Unchanged on exit.
*
*  N	  - INTEGER.
*	    On entry, N specifies the order of the matrix A.
*	    N must be at least zero.
*	    Unchanged on exit.
*
*  A	  - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*	    Before entry with  UPLO = 'U' or 'u', the leading n by n
*	    upper triangular part of the array A must contain the upper
*	    triangular matrix and the strictly lower triangular part of
*	    A is not referenced.
*	    Before entry with UPLO = 'L' or 'l', the leading n by n
*	    lower triangular part of the array A must contain the lower
*	    triangular matrix and the strictly upper triangular part of
*	    A is not referenced.
*	    Note that when  DIAG = 'U' or 'u', the diagonal elements of
*	    A are not referenced either, but are assumed to be unity.
*	    Unchanged on exit.
*
*  LDA    - INTEGER.
*	    On entry, LDA specifies the first dimension of A as declared
*	    in the calling (sub) program. LDA must be at least
*	    max( 1, n ).
*	    Unchanged on exit.
*
*  X	  - DOUBLE PRECISION array of dimension at least
*	    ( 1 + ( n - 1 )*abs( INCX ) ).
*	    Before entry, the incremented array X must contain the n
*	    element vector x. On exit, X is overwritten with the
*	    tranformed vector x.
*
*  INCX   - INTEGER.
*	    On entry, INCX specifies the increment for the elements of
*	    X. INCX must not be zero.
*	    Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
CID      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D+0)
*     ..
*     .. Local Scalars ..
CID      DOUBLE PRECISION TEMP
      INTEGER I,INFO,IX,J,JX,KX
      LOGICAL NOUNIT
*     ..
*     .. External Functions ..
      LOGICAL LSAME
      EXTERNAL LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC MAX
*     ..
*
*     Test the input parameters.
*
      INFO = 0
      IF (.NOT.LSAME(UPLO,'U') .AND. .NOT.LSAME(UPLO,'L')) THEN
	  INFO = 1
      ELSE IF (.NOT.LSAME(TRANS,'N') .AND. .NOT.LSAME(TRANS,'T') .AND.
     +         .NOT.LSAME(TRANS,'C')) THEN
	  INFO = 2
      ELSE IF (.NOT.LSAME(DIAG,'U') .AND. .NOT.LSAME(DIAG,'N')) THEN
	  INFO = 3
      ELSE IF (N.LT.0) THEN
	  INFO = 4
      ELSE IF (LDA.LT.MAX(1,N)) THEN
	  INFO = 6
      ELSE IF (INCX.EQ.0) THEN
	  INFO = 8
      END IF
      IF (INFO.NE.0) THEN
	  CALL XERBLA('DTRMV ',INFO)
	  RETURN
      END IF
*
*     Quick return if possible.
*
      IF (N.EQ.0) RETURN
*
      NOUNIT = LSAME(DIAG,'N')
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
      IF (INCX.LE.0) THEN
	  KX = 1 - (N-1)*INCX
      ELSE IF (INCX.NE.1) THEN
	  KX = 1
      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
      IF (LSAME(TRANS,'N')) THEN
*
*	 Form  x := A*x.
*
	  IF (LSAME(UPLO,'U')) THEN
	      IF (INCX.EQ.1) THEN
		  DO 20 J = 1,N
		      IF (X(J).NE.ZERO) THEN
			  TEMP = X(J)
			  DO 10 I = 1,J - 1
			      X(I) = X(I) + TEMP*A(I,J)
   10			  CONTINUE
			  IF (NOUNIT) X(J) = X(J)*A(J,J)
		      END IF
   20		  CONTINUE
	      ELSE
		  JX = KX
		  DO 40 J = 1,N
		      IF (X(JX).NE.ZERO) THEN
			  TEMP = X(JX)
			  IX = KX
			  DO 30 I = 1,J - 1
			      X(IX) = X(IX) + TEMP*A(I,J)
			      IX = IX + INCX
   30			  CONTINUE
			  IF (NOUNIT) X(JX) = X(JX)*A(J,J)
		      END IF
		      JX = JX + INCX
   40		  CONTINUE
	      END IF
	  ELSE
	      IF (INCX.EQ.1) THEN
		  DO 60 J = N,1,-1
		      IF (X(J).NE.ZERO) THEN
			  TEMP = X(J)
			  DO 50 I = N,J + 1,-1
			      X(I) = X(I) + TEMP*A(I,J)
   50			  CONTINUE
			  IF (NOUNIT) X(J) = X(J)*A(J,J)
		      END IF
   60		  CONTINUE
	      ELSE
		  KX = KX + (N-1)*INCX
		  JX = KX
		  DO 80 J = N,1,-1
		      IF (X(JX).NE.ZERO) THEN
			  TEMP = X(JX)
			  IX = KX
			  DO 70 I = N,J + 1,-1
			      X(IX) = X(IX) + TEMP*A(I,J)
			      IX = IX - INCX
   70			  CONTINUE
			  IF (NOUNIT) X(JX) = X(JX)*A(J,J)
		      END IF
		      JX = JX - INCX
   80		  CONTINUE
	      END IF
	  END IF
      ELSE
*
*	 Form  x := A'*x.
*
	  IF (LSAME(UPLO,'U')) THEN
	      IF (INCX.EQ.1) THEN
		  DO 100 J = N,1,-1
		      TEMP = X(J)
		      IF (NOUNIT) TEMP = TEMP*A(J,J)
		      DO 90 I = J - 1,1,-1
			  TEMP = TEMP + A(I,J)*X(I)
   90		      CONTINUE
		      X(J) = TEMP
  100		  CONTINUE
	      ELSE
		  JX = KX + (N-1)*INCX
		  DO 120 J = N,1,-1
		      TEMP = X(JX)
		      IX = JX
		      IF (NOUNIT) TEMP = TEMP*A(J,J)
		      DO 110 I = J - 1,1,-1
			  IX = IX - INCX
			  TEMP = TEMP + A(I,J)*X(IX)
  110		      CONTINUE
		      X(JX) = TEMP
		      JX = JX - INCX
  120		  CONTINUE
	      END IF
	  ELSE
	      IF (INCX.EQ.1) THEN
		  DO 140 J = 1,N
		      TEMP = X(J)
		      IF (NOUNIT) TEMP = TEMP*A(J,J)
		      DO 130 I = J + 1,N
			  TEMP = TEMP + A(I,J)*X(I)
  130		      CONTINUE
		      X(J) = TEMP
  140		  CONTINUE
	      ELSE
		  JX = KX
		  DO 160 J = 1,N
		      TEMP = X(JX)
		      IX = JX
		      IF (NOUNIT) TEMP = TEMP*A(J,J)
		      DO 150 I = J + 1,N
			  IX = IX + INCX
			  TEMP = TEMP + A(I,J)*X(IX)
  150		      CONTINUE
		      X(JX) = TEMP
		      JX = JX + INCX
  160		  CONTINUE
	      END IF
	  END IF
      END IF
*
      RETURN
*
*     End of DTRMV .
*
      END
C
C=======================================================================
C=======================================================================
C
CID      DOUBLE PRECISION FUNCTION DLAMCH( CMACH )
      FUNCTION DLAMCH( CMACH )
*
*  -- LAPACK auxiliary routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     October 31, 1992
*
*     .. Scalar Arguments ..
      CHARACTER          CMACH
*     ..
*
*  Purpose
*  =======
*
*  DLAMCH determines double precision machine parameters.
*
*  Arguments
*  =========
*
*  CMACH   (input) CHARACTER*1
*          Specifies the value to be returned by DLAMCH:
*          = 'E' or 'e',   DLAMCH := eps
*          = 'S' or 's ,   DLAMCH := sfmin
*          = 'B' or 'b',   DLAMCH := base
*          = 'P' or 'p',   DLAMCH := eps*base
*          = 'N' or 'n',   DLAMCH := t
*          = 'R' or 'r',   DLAMCH := rnd
*          = 'M' or 'm',   DLAMCH := emin
*          = 'U' or 'u',   DLAMCH := rmin
*          = 'L' or 'l',   DLAMCH := emax
*          = 'O' or 'o',   DLAMCH := rmax
*
*          where
*
*          eps   = relative machine precision
*          sfmin = safe minimum, such that 1/sfmin does not overflow
*          base  = base of the machine
*          prec  = eps*base
*          t     = number of (base) digits in the mantissa
*          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
*          emin  = minimum exponent before (gradual) underflow
*          rmin  = underflow threshold - base**(emin-1)
*          emax  = largest exponent before overflow
*          rmax  = overflow threshold  - (base**emax)*(1-eps)
*
* =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            FIRST, LRND
      INTEGER            BETA, IMAX, IMIN, IT
CID      DOUBLE PRECISION   BASE, EMAX, EMIN, EPS, PREC, RMACH, RMAX, RMIN,
CID     $                   RND, SFMIN, SMALL, T
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLAMC2
*     ..
*     .. Save statement ..
      SAVE               FIRST, EPS, SFMIN, BASE, T, RND, EMIN, RMIN,
     $                   EMAX, RMAX, PREC
*     ..
*     .. Data statements ..
      DATA               FIRST / .TRUE. /
*     ..
*     .. Executable Statements ..
*
      IF( FIRST ) THEN
         FIRST = .FALSE.
         CALL DLAMC2( BETA, IT, LRND, EPS, IMIN, RMIN, IMAX, RMAX )
         BASE = BETA
         T = IT
         IF( LRND ) THEN
            RND = ONE
            EPS = ( BASE**( 1-IT ) ) / 2
         ELSE
            RND = ZERO
            EPS = BASE**( 1-IT )
         END IF
         PREC = EPS*BASE
         EMIN = IMIN
         EMAX = IMAX
         SFMIN = RMIN
         SMALL = ONE / RMAX
         IF( SMALL.GE.SFMIN ) THEN
*
*           Use SMALL plus a bit, to avoid the possibility of rounding
*           causing overflow when computing  1/sfmin.
*
            SFMIN = SMALL*( ONE+EPS )
         END IF
      END IF
*
      IF( LSAME( CMACH, 'E' ) ) THEN
         RMACH = EPS
      ELSE IF( LSAME( CMACH, 'S' ) ) THEN
         RMACH = SFMIN
      ELSE IF( LSAME( CMACH, 'B' ) ) THEN
         RMACH = BASE
      ELSE IF( LSAME( CMACH, 'P' ) ) THEN
         RMACH = PREC
      ELSE IF( LSAME( CMACH, 'N' ) ) THEN
         RMACH = T
      ELSE IF( LSAME( CMACH, 'R' ) ) THEN
         RMACH = RND
      ELSE IF( LSAME( CMACH, 'M' ) ) THEN
         RMACH = EMIN
      ELSE IF( LSAME( CMACH, 'U' ) ) THEN
         RMACH = RMIN
      ELSE IF( LSAME( CMACH, 'L' ) ) THEN
         RMACH = EMAX
      ELSE IF( LSAME( CMACH, 'O' ) ) THEN
         RMACH = RMAX
      END IF
*
      DLAMCH = RMACH
      RETURN
*
*     End of DLAMCH
*
      END
C
C=======================================================================
C=======================================================================
C
*
************************************************************************
*
      SUBROUTINE DLAMC1( BETA, T, RND, IEEE1 )
*
*  -- LAPACK auxiliary routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     October 31, 1992
*
*     .. Scalar Arguments ..
      LOGICAL            IEEE1, RND
      INTEGER            BETA, T
*     ..
*
*  Purpose
*  =======
*
*  DLAMC1 determines the machine parameters given by BETA, T, RND, and
*  IEEE1.
*
*  Arguments
*  =========
*
*  BETA    (output) INTEGER
*          The base of the machine.
*
*  T       (output) INTEGER
*          The number of ( BETA ) digits in the mantissa.
*
*  RND     (output) LOGICAL
*          Specifies whether proper rounding  ( RND = .TRUE. )  or
*          chopping  ( RND = .FALSE. )  occurs in addition. This may not
*          be a reliable guide to the way in which the machine performs
*          its arithmetic.
*
*  IEEE1   (output) LOGICAL
*          Specifies whether rounding appears to be done in the IEEE
*          'round to nearest' style.
*
*  Further Details
*  ===============
*
*  The routine is based on the routine  ENVRON  by Malcolm and
*  incorporates suggestions by Gentleman and Marovich. See
*
*     Malcolm M. A. (1972) Algorithms to reveal properties of
*        floating-point arithmetic. Comms. of the ACM, 15, 949-951.
*
*     Gentleman W. M. and Marovich S. B. (1974) More on algorithms
*        that reveal properties of floating point arithmetic units.
*        Comms. of the ACM, 17, 276-277.
*
* =====================================================================
*
*     .. Local Scalars ..
      LOGICAL            FIRST, LIEEE1, LRND
      INTEGER            LBETA, LT
CID      DOUBLE PRECISION   A, B, C, F, ONE, QTR, SAVEC, T1, T2
*     ..
*     .. External Functions ..
CID      DOUBLE PRECISION   DLAMC3
      EXTERNAL           DLAMC3
*     ..
*     .. Save statement ..
      SAVE               FIRST, LIEEE1, LBETA, LRND, LT
*     ..
*     .. Data statements ..
      DATA               FIRST / .TRUE. /
*     ..
*     .. Executable Statements ..
*
      IF( FIRST ) THEN
         FIRST = .FALSE.
         ONE = 1
*
*        LBETA,  LIEEE1,  LT and  LRND  are the  local values  of  BETA,
*        IEEE1, T and RND.
*
*        Throughout this routine  we use the function  DLAMC3  to ensure
*        that relevant values are  stored and not held in registers,  or
*        are not affected by optimizers.
*
*        Compute  a = 2.0**m  with the  smallest positive integer m such
*        that
*
*           fl( a + 1.0 ) = a.
*
         A = 1
         C = 1
*
*+       WHILE( C.EQ.ONE )LOOP
   10    CONTINUE
         IF( C.EQ.ONE ) THEN
            A = 2*A
            C = DLAMC3( A, ONE )
            C = DLAMC3( C, -A )
            GO TO 10
         END IF
*+       END WHILE
*
*        Now compute  b = 2.0**m  with the smallest positive integer m
*        such that
*
*           fl( a + b ) .gt. a.
*
         B = 1
         C = DLAMC3( A, B )
*
*+       WHILE( C.EQ.A )LOOP
   20    CONTINUE
         IF( C.EQ.A ) THEN
            B = 2*B
            C = DLAMC3( A, B )
            GO TO 20
         END IF
*+       END WHILE
*
*        Now compute the base.  a and c  are neighbouring floating point
*        numbers  in the  interval  ( beta**t, beta**( t + 1 ) )  and so
*        their difference is beta. Adding 0.25 to c is to ensure that it
*        is truncated to beta and not ( beta - 1 ).
*
         QTR = ONE / 4
         SAVEC = C
         C = DLAMC3( C, -A )
         LBETA = C + QTR
*
*        Now determine whether rounding or chopping occurs,  by adding a
*        bit  less  than  beta/2  and a  bit  more  than  beta/2  to  a.
*
         B = LBETA
         F = DLAMC3( B / 2, -B / 100 )
         C = DLAMC3( F, A )
         IF( C.EQ.A ) THEN
            LRND = .TRUE.
         ELSE
            LRND = .FALSE.
         END IF
         F = DLAMC3( B / 2, B / 100 )
         C = DLAMC3( F, A )
         IF( ( LRND ) .AND. ( C.EQ.A ) )
     $      LRND = .FALSE.
*
*        Try and decide whether rounding is done in the  IEEE  'round to
*        nearest' style. B/2 is half a unit in the last place of the two
*        numbers A and SAVEC. Furthermore, A is even, i.e. has last  bit
*        zero, and SAVEC is odd. Thus adding B/2 to A should not  change
*        A, but adding B/2 to SAVEC should change SAVEC.
*
         T1 = DLAMC3( B / 2, A )
         T2 = DLAMC3( B / 2, SAVEC )
         LIEEE1 = ( T1.EQ.A ) .AND. ( T2.GT.SAVEC ) .AND. LRND
*
*        Now find  the  mantissa, t.  It should  be the  integer part of
*        log to the base beta of a,  however it is safer to determine  t
*        by powering.  So we find t as the smallest positive integer for
*        which
*
*           fl( beta**t + 1.0 ) = 1.0.
*
         LT = 0
         A = 1
         C = 1
*
*+       WHILE( C.EQ.ONE )LOOP
   30    CONTINUE
         IF( C.EQ.ONE ) THEN
            LT = LT + 1
            A = A*LBETA
            C = DLAMC3( A, ONE )
            C = DLAMC3( C, -A )
            GO TO 30
         END IF
*+       END WHILE
*
      END IF
*
      BETA = LBETA
      T = LT
      RND = LRND
      IEEE1 = LIEEE1
      RETURN
*
*     End of DLAMC1
*
      END
*
************************************************************************
*
      SUBROUTINE DLAMC2( BETA, T, RND, EPS, EMIN, RMIN, EMAX, RMAX )
*
*  -- LAPACK auxiliary routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     October 31, 1992
*
*     .. Scalar Arguments ..
      LOGICAL            RND
      INTEGER            BETA, EMAX, EMIN, T
CID      DOUBLE PRECISION   EPS, RMAX, RMIN
*     ..
*
*  Purpose
*  =======
*
*  DLAMC2 determines the machine parameters specified in its argument
*  list.
*
*  Arguments
*  =========
*
*  BETA    (output) INTEGER
*          The base of the machine.
*
*  T       (output) INTEGER
*          The number of ( BETA ) digits in the mantissa.
*
*  RND     (output) LOGICAL
*          Specifies whether proper rounding  ( RND = .TRUE. )  or
*          chopping  ( RND = .FALSE. )  occurs in addition. This may not
*          be a reliable guide to the way in which the machine performs
*          its arithmetic.
*
*  EPS     (output) DOUBLE PRECISION
*          The smallest positive number such that
*
*             fl( 1.0 - EPS ) .LT. 1.0,
*
*          where fl denotes the computed value.
*
*  EMIN    (output) INTEGER
*          The minimum exponent before (gradual) underflow occurs.
*
*  RMIN    (output) DOUBLE PRECISION
*          The smallest normalized number for the machine, given by
*          BASE**( EMIN - 1 ), where  BASE  is the floating point value
*          of BETA.
*
*  EMAX    (output) INTEGER
*          The maximum exponent before overflow occurs.
*
*  RMAX    (output) DOUBLE PRECISION
*          The largest positive number for the machine, given by
*          BASE**EMAX * ( 1 - EPS ), where  BASE  is the floating point
*          value of BETA.
*
*  Further Details
*  ===============
*
*  The computation of  EPS  is based on a routine PARANOIA by
*  W. Kahan of the University of California at Berkeley.
*
* =====================================================================
*
*     .. Local Scalars ..
      LOGICAL            FIRST, IEEE, IWARN, LIEEE1, LRND
      INTEGER            GNMIN, GPMIN, I, LBETA, LEMAX, LEMIN, LT,
     $                   NGNMIN, NGPMIN
      REAL               LEPS, LRMAX, LRMIN
CID      DOUBLE PRECISION   A, B, C, HALF, LEPS, LRMAX, LRMIN, ONE, RBASE,
CID     $                   SIXTH, SMALL, THIRD, TWO, ZERO
*     ..
*     .. External Functions ..
CID      DOUBLE PRECISION   DLAMC3
      EXTERNAL           DLAMC3
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLAMC1, DLAMC4, DLAMC5
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, MAX, MIN
*     ..
*     .. Save statement ..
      SAVE               FIRST, IWARN, LBETA, LEMAX, LEMIN, LEPS, LRMAX,
     $                   LRMIN, LT
*     ..
*     .. Data statements ..
      DATA               FIRST / .TRUE. / , IWARN / .FALSE. /
*     ..
*     .. Executable Statements ..
*
      IF( FIRST ) THEN
         FIRST = .FALSE.
         ZERO = 0
         ONE = 1
         TWO = 2
*
*        LBETA, LT, LRND, LEPS, LEMIN and LRMIN  are the local values of
*        BETA, T, RND, EPS, EMIN and RMIN.
*
*        Throughout this routine  we use the function  DLAMC3  to ensure
*        that relevant values are stored  and not held in registers,  or
*        are not affected by optimizers.
*
*        DLAMC1 returns the parameters  LBETA, LT, LRND and LIEEE1.
*
         CALL DLAMC1( LBETA, LT, LRND, LIEEE1 )
*
*        Start to find EPS.
*
         B = LBETA
         A = B**( -LT )
         LEPS = A
*
*        Try some tricks to see whether or not this is the correct  EPS.
*
         B = TWO / 3
         HALF = ONE / 2
         SIXTH = DLAMC3( B, -HALF )
         THIRD = DLAMC3( SIXTH, SIXTH )
         B = DLAMC3( THIRD, -HALF )
         B = DLAMC3( B, SIXTH )
         B = ABS( B )
         IF( B.LT.LEPS )
     $      B = LEPS
*
         LEPS = 1
*
*+       WHILE( ( LEPS.GT.B ).AND.( B.GT.ZERO ) )LOOP
   10    CONTINUE
         IF( ( LEPS.GT.B ) .AND. ( B.GT.ZERO ) ) THEN
            LEPS = B
            C = DLAMC3( HALF*LEPS, ( TWO**5 )*( LEPS**2 ) )
            C = DLAMC3( HALF, -C )
            B = DLAMC3( HALF, C )
            C = DLAMC3( HALF, -B )
            B = DLAMC3( HALF, C )
            GO TO 10
         END IF
*+       END WHILE
*
         IF( A.LT.LEPS )
     $      LEPS = A
*
*        Computation of EPS complete.
*
*        Now find  EMIN.  Let A = + or - 1, and + or - (1 + BASE**(-3)).
*        Keep dividing  A by BETA until (gradual) underflow occurs. This
*        is detected when we cannot recover the previous A.
*
         RBASE = ONE / LBETA
         SMALL = ONE
         DO 20 I = 1, 3
            SMALL = DLAMC3( SMALL*RBASE, ZERO )
   20    CONTINUE
         A = DLAMC3( ONE, SMALL )
         CALL DLAMC4( NGPMIN, ONE, LBETA )
         CALL DLAMC4( NGNMIN, -ONE, LBETA )
         CALL DLAMC4( GPMIN, A, LBETA )
         CALL DLAMC4( GNMIN, -A, LBETA )
         IEEE = .FALSE.
*
         IF( ( NGPMIN.EQ.NGNMIN ) .AND. ( GPMIN.EQ.GNMIN ) ) THEN
            IF( NGPMIN.EQ.GPMIN ) THEN
               LEMIN = NGPMIN
*            ( Non twos-complement machines, no gradual underflow;
*              e.g.,  VAX )
            ELSE IF( ( GPMIN-NGPMIN ).EQ.3 ) THEN
               LEMIN = NGPMIN - 1 + LT
               IEEE = .TRUE.
*            ( Non twos-complement machines, with gradual underflow;
*              e.g., IEEE standard followers )
            ELSE
               LEMIN = MIN( NGPMIN, GPMIN )
*            ( A guess; no known machine )
               IWARN = .TRUE.
            END IF
*
         ELSE IF( ( NGPMIN.EQ.GPMIN ) .AND. ( NGNMIN.EQ.GNMIN ) ) THEN
            IF( ABS( NGPMIN-NGNMIN ).EQ.1 ) THEN
               LEMIN = MAX( NGPMIN, NGNMIN )
*            ( Twos-complement machines, no gradual underflow;
*              e.g., CYBER 205 )
            ELSE
               LEMIN = MIN( NGPMIN, NGNMIN )
*            ( A guess; no known machine )
               IWARN = .TRUE.
            END IF
*
         ELSE IF( ( ABS( NGPMIN-NGNMIN ).EQ.1 ) .AND.
     $            ( GPMIN.EQ.GNMIN ) ) THEN
            IF( ( GPMIN-MIN( NGPMIN, NGNMIN ) ).EQ.3 ) THEN
               LEMIN = MAX( NGPMIN, NGNMIN ) - 1 + LT
*            ( Twos-complement machines with gradual underflow;
*              no known machine )
            ELSE
               LEMIN = MIN( NGPMIN, NGNMIN )
*            ( A guess; no known machine )
               IWARN = .TRUE.
            END IF
*
         ELSE
            LEMIN = MIN( NGPMIN, NGNMIN, GPMIN, GNMIN )
*         ( A guess; no known machine )
            IWARN = .TRUE.
         END IF
***
* Comment out this if block if EMIN is ok
         IF( IWARN ) THEN
            FIRST = .TRUE.
            WRITE( 6, FMT = 9999 )LEMIN
         END IF
***
*
*        Assume IEEE arithmetic if we found denormalised  numbers above,
*        or if arithmetic seems to round in the  IEEE style,  determined
*        in routine DLAMC1. A true IEEE machine should have both  things
*        true; however, faulty machines may have one or the other.
*
         IEEE = IEEE .OR. LIEEE1
*
*        Compute  RMIN by successive division by  BETA. We could compute
*        RMIN as BASE**( EMIN - 1 ),  but some machines underflow during
*        this computation.
*
         LRMIN = 1
         DO 30 I = 1, 1 - LEMIN
            LRMIN = DLAMC3( LRMIN*RBASE, ZERO )
   30    CONTINUE
*
*        Finally, call DLAMC5 to compute EMAX and RMAX.
*
         CALL DLAMC5( LBETA, LT, LEMIN, IEEE, LEMAX, LRMAX )
      END IF
*
      BETA = LBETA
      T = LT
      RND = LRND
      EPS = LEPS
      EMIN = LEMIN
      RMIN = LRMIN
      EMAX = LEMAX
      RMAX = LRMAX
*
      RETURN
*
 9999 FORMAT( / / ' WARNING. The value EMIN may be incorrect:-',
     $      '  EMIN = ', I8, /
     $      ' If, after inspection, the value EMIN looks',
     $      ' acceptable please comment out ',
     $      / ' the IF block as marked within the code of routine',
     $      ' DLAMC2,', / ' otherwise supply EMIN explicitly.', / )
*
*     End of DLAMC2
*
      END
*
************************************************************************
*
CID      DOUBLE PRECISION FUNCTION DLAMC3( A, B )
      FUNCTION DLAMC3( A, B )
*
*  -- LAPACK auxiliary routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     October 31, 1992
*
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION   A, B
*     ..
*
*  Purpose
*  =======
*
*  DLAMC3  is intended to force  A  and  B  to be stored prior to doing
*  the addition of  A  and  B ,  for use in situations where optimizers
*  might hold one of these in a register.
*
*  Arguments
*  =========
*
*  A, B    (input) DOUBLE PRECISION
*          The values A and B.
*
* =====================================================================
*
*     .. Executable Statements ..
*
      DLAMC3 = A + B
*
      RETURN
*
*     End of DLAMC3
*
      END
*
************************************************************************
*
      SUBROUTINE DLAMC4( EMIN, START, BASE )
*
*  -- LAPACK auxiliary routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     October 31, 1992
*
*     .. Scalar Arguments ..
      INTEGER            BASE, EMIN
CID      DOUBLE PRECISION   START
*     ..
*
*  Purpose
*  =======
*
*  DLAMC4 is a service routine for DLAMC2.
*
*  Arguments
*  =========
*
*  EMIN    (output) EMIN
*          The minimum exponent before (gradual) underflow, computed by
*          setting A = START and dividing by BASE until the previous A
*          can not be recovered.
*
*  START   (input) DOUBLE PRECISION
*          The starting point for determining EMIN.
*
*  BASE    (input) INTEGER
*          The base of the machine.
*
* =====================================================================
*
*     .. Local Scalars ..
      INTEGER            I
CID      DOUBLE PRECISION   A, B1, B2, C1, C2, D1, D2, ONE, RBASE, ZERO
*     ..
*     .. External Functions ..
CID      DOUBLE PRECISION   DLAMC3
      EXTERNAL           DLAMC3
*     ..
*     .. Executable Statements ..
*
      A = START
      ONE = 1
      RBASE = ONE / BASE
      ZERO = 0
      EMIN = 1
      B1 = DLAMC3( A*RBASE, ZERO )
      C1 = A
      C2 = A
      D1 = A
      D2 = A
*+    WHILE( ( C1.EQ.A ).AND.( C2.EQ.A ).AND.
*    $       ( D1.EQ.A ).AND.( D2.EQ.A )      )LOOP
   10 CONTINUE
      IF( ( C1.EQ.A ) .AND. ( C2.EQ.A ) .AND. ( D1.EQ.A ) .AND.
     $    ( D2.EQ.A ) ) THEN
         EMIN = EMIN - 1
         A = B1
         B1 = DLAMC3( A / BASE, ZERO )
         C1 = DLAMC3( B1*BASE, ZERO )
         D1 = ZERO
         DO 20 I = 1, BASE
            D1 = D1 + B1
   20    CONTINUE
         B2 = DLAMC3( A*RBASE, ZERO )
         C2 = DLAMC3( B2 / RBASE, ZERO )
         D2 = ZERO
         DO 30 I = 1, BASE
            D2 = D2 + B2
   30    CONTINUE
         GO TO 10
      END IF
*+    END WHILE
*
      RETURN
*
*     End of DLAMC4
*
      END
*
************************************************************************
*
      SUBROUTINE DLAMC5( BETA, P, EMIN, IEEE, EMAX, RMAX )
*
*  -- LAPACK auxiliary routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     October 31, 1992
*
*     .. Scalar Arguments ..
      LOGICAL            IEEE
      INTEGER            BETA, EMAX, EMIN, P
CID      DOUBLE PRECISION   RMAX
*     ..
*
*  Purpose
*  =======
*
*  DLAMC5 attempts to compute RMAX, the largest machine floating-point
*  number, without overflow.  It assumes that EMAX + abs(EMIN) sum
*  approximately to a power of 2.  It will fail on machines where this
*  assumption does not hold, for example, the Cyber 205 (EMIN = -28625,
*  EMAX = 28718).  It will also fail if the value supplied for EMIN is
*  too large (i.e. too close to zero), probably with overflow.
*
*  Arguments
*  =========
*
*  BETA    (input) INTEGER
*          The base of floating-point arithmetic.
*
*  P       (input) INTEGER
*          The number of base BETA digits in the mantissa of a
*          floating-point value.
*
*  EMIN    (input) INTEGER
*          The minimum exponent before (gradual) underflow.
*
*  IEEE    (input) LOGICAL
*          A logical flag specifying whether or not the arithmetic
*          system is thought to comply with the IEEE standard.
*
*  EMAX    (output) INTEGER
*          The largest exponent before overflow
*
*  RMAX    (output) DOUBLE PRECISION
*          The largest machine floating-point number.
*
* =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
*     ..
*     .. Local Scalars ..
      INTEGER            EXBITS, EXPSUM, I, LEXP, NBITS, TRY, UEXP
CID      DOUBLE PRECISION   OLDY, RECBAS, Y, Z
*     ..
*     .. External Functions ..
CID      DOUBLE PRECISION   DLAMC3
      EXTERNAL           DLAMC3
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MOD
*     ..
*     .. Executable Statements ..
*
*     First compute LEXP and UEXP, two powers of 2 that bound
*     abs(EMIN). We then assume that EMAX + abs(EMIN) will sum
*     approximately to the bound that is closest to abs(EMIN).
*     (EMAX is the exponent of the required number RMAX).
*
      LEXP = 1
      EXBITS = 1
   10 CONTINUE
      TRY = LEXP*2
      IF( TRY.LE.( -EMIN ) ) THEN
         LEXP = TRY
         EXBITS = EXBITS + 1
         GO TO 10
      END IF
      IF( LEXP.EQ.-EMIN ) THEN
         UEXP = LEXP
      ELSE
         UEXP = TRY
         EXBITS = EXBITS + 1
      END IF
*
*     Now -LEXP is less than or equal to EMIN, and -UEXP is greater
*     than or equal to EMIN. EXBITS is the number of bits needed to
*     store the exponent.
*
      IF( ( UEXP+EMIN ).GT.( -LEXP-EMIN ) ) THEN
         EXPSUM = 2*LEXP
      ELSE
         EXPSUM = 2*UEXP
      END IF
*
*     EXPSUM is the exponent range, approximately equal to
*     EMAX - EMIN + 1 .
*
      EMAX = EXPSUM + EMIN - 1
      NBITS = 1 + EXBITS + P
*
*     NBITS is the total number of bits needed to store a
*     floating-point number.
*
      IF( ( MOD( NBITS, 2 ).EQ.1 ) .AND. ( BETA.EQ.2 ) ) THEN
*
*        Either there are an odd number of bits used to store a
*        floating-point number, which is unlikely, or some bits are
*        not used in the representation of numbers, which is possible,
*        (e.g. Cray machines) or the mantissa has an implicit bit,
*        (e.g. IEEE machines, Dec Vax machines), which is perhaps the
*        most likely. We have to assume the last alternative.
*        If this is true, then we need to reduce EMAX by one because
*        there must be some way of representing zero in an implicit-bit
*        system. On machines like Cray, we are reducing EMAX by one
*        unnecessarily.
*
         EMAX = EMAX - 1
      END IF
*
      IF( IEEE ) THEN
*
*        Assume we are on an IEEE machine which reserves one exponent
*        for infinity and NaN.
*
         EMAX = EMAX - 1
      END IF
*
*     Now create RMAX, the largest machine number, which should
*     be equal to (1.0 - BETA**(-P)) * BETA**EMAX .
*
*     First compute 1.0 - BETA**(-P), being careful that the
*     result is less than 1.0 .
*
      RECBAS = ONE / BETA
      Z = BETA - ONE
      Y = ZERO
      DO 20 I = 1, P
         Z = Z*RECBAS
         IF( Y.LT.ONE )
     $      OLDY = Y
         Y = DLAMC3( Y, Z )
   20 CONTINUE
      IF( Y.GE.ONE )
     $   Y = OLDY
*
*     Now multiply by BETA**EMAX to get RMAX.
*
      DO 30 I = 1, EMAX
         Y = DLAMC3( Y*BETA, ZERO )
   30 CONTINUE
*
      RMAX = Y
      RETURN
*
*     End of DLAMC5
*
      END
C
C=======================================================================
C=======================================================================
C=======================================================================
C=======================================================================
C=======================================================================
C
      SUBROUTINE DGESVD( JOBU, JOBVT, M, N, A, LDA, LDB, S, U, LDU, VT,
     $  LDVT, WORK, LWORK, INFO )
*
*  -- LAPACK driver routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          JOBU, JOBVT
      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, LDB), S(LDB), U( LDU,LDU),
CID     $                   VT( LDVT,LDVT ), WORK( * )
      DIMENSION   A( LDA, LDB), S(LDB), U( LDU,LDU),
     $                   VT( LDVT,LDVT ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DGESVD computes the singular value decomposition (SVD) of a real
*  M-by-N matrix A, optionally computing the left and/or right singular
*  vectors. The SVD is written
*
*       A = U * SIGMA * transpose(V)
*
*  where SIGMA is an M-by-N matrix which is zero except for its
*  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
*  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
*  are the singular values of A; they are real and non-negative, and
*  are returned in descending order.  The first min(m,n) columns of
*  U and V are the left and right singular vectors of A.
*
*  Note that the routine returns V**T, not V.
*
*  Arguments
*  =========
*
*  JOBU    (input) CHARACTER*1
*          Specifies options for computing all or part of the matrix U:
*          = 'A':  all M columns of U are returned in array U:
*          = 'S':  the first min(m,n) columns of U (the left singular
*                  vectors) are returned in the array U;
*          = 'O':  the first min(m,n) columns of U (the left singular
*                  vectors) are overwritten on the array A;
*          = 'N':  no columns of U (no left singular vectors) are
*                  computed.
*
*  JOBVT   (input) CHARACTER*1
*          Specifies options for computing all or part of the matrix
*          V**T:
*          = 'A':  all N rows of V**T are returned in the array VT;
*          = 'S':  the first min(m,n) rows of V**T (the right singular
*                  vectors) are returned in the array VT;
*          = 'O':  the first min(m,n) rows of V**T (the right singular
*                  vectors) are overwritten on the array A;
*          = 'N':  no rows of V**T (no right singular vectors) are
*                  computed.
*
*          JOBVT and JOBU cannot both be 'O'.
*
*  M       (input) INTEGER
*          The number of rows of the input matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the input matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the M-by-N matrix A.
*          On exit,
*          if JOBU = 'O',  A is overwritten with the first min(m,n)
*                          columns of U (the left singular vectors,
*                          stored columnwise);
*          if JOBVT = 'O', A is overwritten with the first min(m,n)
*                          rows of V**T (the right singular vectors,
*                          stored rowwise);
*          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
*                          are destroyed.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
*          The singular values of A, sorted so that S(i) >= S(i+1).
*
*  U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
*          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
*          If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
*          if JOBU = 'S', U contains the first min(m,n) columns of U
*          (the left singular vectors, stored columnwise);
*          if JOBU = 'N' or 'O', U is not referenced.
*
*  LDU     (input) INTEGER
*          The leading dimension of the array U.  LDU >= 1; if
*          JOBU = 'S' or 'A', LDU >= M.
*
*  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
*          If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
*          V**T;
*          if JOBVT = 'S', VT contains the first min(m,n) rows of
*          V**T (the right singular vectors, stored rowwise);
*          if JOBVT = 'N' or 'O', VT is not referenced.
*
*  LDVT    (input) INTEGER
*          The leading dimension of the array VT.  LDVT >= 1; if
*          JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
*          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged
*          superdiagonal elements of an upper bidiagonal matrix B
*          whose diagonal is in S (not necessarily sorted). B
*          satisfies A = U * B * VT, so it has the same singular values
*          as A, and singular vectors related by U and VT.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK.
*          LWORK >= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).
*          For good performance, LWORK should generally be larger.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit.
*          < 0:  if INFO = -i, the i-th argument had an illegal value.
*          > 0:  if DBDSQR did not converge, INFO specifies how many
*                superdiagonals of an intermediate bidiagonal form B
*                did not converge to zero. See the description of WORK
*                above for details.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LQUERY, WNTUA, WNTUAS, WNTUN, WNTUO, WNTUS,
     $                   WNTVA, WNTVAS, WNTVN, WNTVO, WNTVS
      INTEGER            BDSPAC, BLK, CHUNK, I, IE, IERR, IR, ISCL,
     $                   ITAU, ITAUP, ITAUQ, IU, IWORK, LDWRKR, LDWRKU,
     $                   MAXWRK, MINMN, MINWRK, MNTHR, NCU, NCVT, NRU,
     $                   NRVT, WRKBL
CID      DOUBLE PRECISION   ANRM, BIGNUM, EPS, SMLNUM
*     ..
*     .. Local Arrays ..
CID      DOUBLE PRECISION   DUM( 1 )
      DIMENSION   DUM( 1 )
*     ..
*     .. External Subroutines ..
      EXTERNAL           DBDSQR, DGEBRD, DGELQF, DGEMM, DGEQRF, DLACPY,
     $                   DLASCL, DLASET, DORGBR, DORGLQ, DORGQR, DORMBR,
     $                   XERBLA
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      INTEGER            ILAENV
CID      DOUBLE PRECISION   DLAMCH, DLANGE
      EXTERNAL           LSAME, ILAENV, DLAMCH, DLANGE
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN, SQRT
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      MINMN = MIN( M, N )
      WNTUA = LSAME( JOBU, 'A' )
      WNTUS = LSAME( JOBU, 'S' )
      WNTUAS = WNTUA .OR. WNTUS
      WNTUO = LSAME( JOBU, 'O' )
      WNTUN = LSAME( JOBU, 'N' )
      WNTVA = LSAME( JOBVT, 'A' )
      WNTVS = LSAME( JOBVT, 'S' )
      WNTVAS = WNTVA .OR. WNTVS
      WNTVO = LSAME( JOBVT, 'O' )
      WNTVN = LSAME( JOBVT, 'N' )
      LQUERY = ( LWORK.EQ.-1 )
*
      IF( .NOT.( WNTUA .OR. WNTUS .OR. WNTUO .OR. WNTUN ) ) THEN
         INFO = -1
      ELSE IF( .NOT.( WNTVA .OR. WNTVS .OR. WNTVO .OR. WNTVN ) .OR.
     $         ( WNTVO .AND. WNTUO ) ) THEN
         INFO = -2
      ELSE IF( M.LT.0 ) THEN
         INFO = -3
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -6
      ELSE IF( LDU.LT.1 .OR. ( WNTUAS .AND. LDU.LT.M ) ) THEN
         INFO = -9
      ELSE IF( LDVT.LT.1 .OR. ( WNTVA .AND. LDVT.LT.N ) .OR.
     $         ( WNTVS .AND. LDVT.LT.MINMN ) ) THEN
         INFO = -11
      END IF
*
*     Compute workspace
*      (Note: Comments in the code beginning "Workspace:" describe the
*       minimal amount of workspace needed at that point in the code,
*       as well as the preferred amount for good performance.
*       NB refers to the optimal block size for the immediately
*       following subroutine, as returned by ILAENV.)
*
      IF( INFO.EQ.0 ) THEN
         MINWRK = 1
         MAXWRK = 1
         IF( M.GE.N .AND. MINMN.GT.0 ) THEN
*
*           Compute space needed for DBDSQR
*
            MNTHR = ILAENV( 6, 'DGESVD', JOBU // JOBVT, M, N, 0, 0 )
            BDSPAC = 5*N
            IF( M.GE.MNTHR ) THEN
               IF( WNTUN ) THEN
*
*                 Path 1 (M much larger than N, JOBU='N')
*
                  MAXWRK = N + N*ILAENV( 1, 'DGEQRF', ' ', M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 3*N+2*N*
     $                     ILAENV( 1, 'DGEBRD', ' ', N, N, -1, -1 ) )
                  IF( WNTVO .OR. WNTVAS )
     $               MAXWRK = MAX( MAXWRK, 3*N+( N-1 )*
     $                        ILAENV( 1, 'DORGBR', 'P', N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, BDSPAC )
                  MINWRK = MAX( 4*N, BDSPAC )
               ELSE IF( WNTUO .AND. WNTVN ) THEN
*
*                 Path 2 (M much larger than N, JOBU='O', JOBVT='N')
*
                  WRKBL = N + N*ILAENV( 1, 'DGEQRF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*ILAENV( 1, 'DORGQR', ' ', M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    ILAENV( 1, 'DGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    ILAENV( 1, 'DORGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( N*N+WRKBL, N*N+M*N+N )
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUO .AND. WNTVAS ) THEN
*
*                 Path 3 (M much larger than N, JOBU='O', JOBVT='S' or
*                 'A')
*
                  WRKBL = N + N*ILAENV( 1, 'DGEQRF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*ILAENV( 1, 'DORGQR', ' ', M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    ILAENV( 1, 'DGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    ILAENV( 1, 'DORGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( N*N+WRKBL, N*N+M*N+N )
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUS .AND. WNTVN ) THEN
*
*                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
*
                  WRKBL = N + N*ILAENV( 1, 'DGEQRF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*ILAENV( 1, 'DORGQR', ' ', M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    ILAENV( 1, 'DGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    ILAENV( 1, 'DORGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUS .AND. WNTVO ) THEN
*
*                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
*
                  WRKBL = N + N*ILAENV( 1, 'DGEQRF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*ILAENV( 1, 'DORGQR', ' ', M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    ILAENV( 1, 'DGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    ILAENV( 1, 'DORGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUS .AND. WNTVAS ) THEN
*
*                 Path 6 (M much larger than N, JOBU='S', JOBVT='S' or
*                 'A')
*
                  WRKBL = N + N*ILAENV( 1, 'DGEQRF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*ILAENV( 1, 'DORGQR', ' ', M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    ILAENV( 1, 'DGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    ILAENV( 1, 'DORGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUA .AND. WNTVN ) THEN
*
*                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
*
                  WRKBL = N + N*ILAENV( 1, 'DGEQRF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*ILAENV( 1, 'DORGQR', ' ', M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    ILAENV( 1, 'DGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    ILAENV( 1, 'DORGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUA .AND. WNTVO ) THEN
*
*                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
*
                  WRKBL = N + N*ILAENV( 1, 'DGEQRF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*ILAENV( 1, 'DORGQR', ' ', M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    ILAENV( 1, 'DGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    ILAENV( 1, 'DORGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUA .AND. WNTVAS ) THEN
*
*                 Path 9 (M much larger than N, JOBU='A', JOBVT='S' or
*                 'A')
*
                  WRKBL = N + N*ILAENV( 1, 'DGEQRF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*ILAENV( 1, 'DORGQR', ' ', M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    ILAENV( 1, 'DGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    ILAENV( 1, 'DORGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               END IF
            ELSE
*
*              Path 10 (M at least N, but not much larger)
*
               MAXWRK = 3*N + ( M+N )*ILAENV( 1, 'DGEBRD', ' ', M, N,
     $                  -1, -1 )
               IF( WNTUS .OR. WNTUO )
     $            MAXWRK = MAX( MAXWRK, 3*N+N*
     $                     ILAENV( 1, 'DORGBR', 'Q', M, N, N, -1 ) )
               IF( WNTUA )
     $            MAXWRK = MAX( MAXWRK, 3*N+M*
     $                     ILAENV( 1, 'DORGBR', 'Q', M, M, N, -1 ) )
               IF( .NOT.WNTVN )
     $            MAXWRK = MAX( MAXWRK, 3*N+( N-1 )*
     $                     ILAENV( 1, 'DORGBR', 'P', N, N, N, -1 ) )
               MAXWRK = MAX( MAXWRK, BDSPAC )
               MINWRK = MAX( 3*N+M, BDSPAC )
            END IF
         ELSE IF( MINMN.GT.0 ) THEN
*
*           Compute space needed for DBDSQR
*
            MNTHR = ILAENV( 6, 'DGESVD', JOBU // JOBVT, M, N, 0, 0 )
            BDSPAC = 5*M
            IF( N.GE.MNTHR ) THEN
               IF( WNTVN ) THEN
*
*                 Path 1t(N much larger than M, JOBVT='N')
*
                  MAXWRK = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 3*M+2*M*
     $                     ILAENV( 1, 'DGEBRD', ' ', M, M, -1, -1 ) )
                  IF( WNTUO .OR. WNTUAS )
     $               MAXWRK = MAX( MAXWRK, 3*M+M*
     $                        ILAENV( 1, 'DORGBR', 'Q', M, M, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, BDSPAC )
                  MINWRK = MAX( 4*M, BDSPAC )
               ELSE IF( WNTVO .AND. WNTUN ) THEN
*
*                 Path 2t(N much larger than M, JOBU='N', JOBVT='O')
*
                  WRKBL = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*ILAENV( 1, 'DORGLQ', ' ', M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    ILAENV( 1, 'DGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( M*M+WRKBL, M*M+M*N+M )
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVO .AND. WNTUAS ) THEN
*
*                 Path 3t(N much larger than M, JOBU='S' or 'A',
*                 JOBVT='O')
*
                  WRKBL = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*ILAENV( 1, 'DORGLQ', ' ', M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    ILAENV( 1, 'DGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    ILAENV( 1, 'DORGBR', 'Q', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( M*M+WRKBL, M*M+M*N+M )
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVS .AND. WNTUN ) THEN
*
*                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
*
                  WRKBL = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*ILAENV( 1, 'DORGLQ', ' ', M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    ILAENV( 1, 'DGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVS .AND. WNTUO ) THEN
*
*                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
*
                  WRKBL = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*ILAENV( 1, 'DORGLQ', ' ', M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    ILAENV( 1, 'DGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    ILAENV( 1, 'DORGBR', 'Q', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVS .AND. WNTUAS ) THEN
*
*                 Path 6t(N much larger than M, JOBU='S' or 'A',
*                 JOBVT='S')
*
                  WRKBL = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*ILAENV( 1, 'DORGLQ', ' ', M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    ILAENV( 1, 'DGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    ILAENV( 1, 'DORGBR', 'Q', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVA .AND. WNTUN ) THEN
*
*                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
*
                  WRKBL = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*ILAENV( 1, 'DORGLQ', ' ', N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    ILAENV( 1, 'DGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVA .AND. WNTUO ) THEN
*
*                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
*
                  WRKBL = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*ILAENV( 1, 'DORGLQ', ' ', N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    ILAENV( 1, 'DGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    ILAENV( 1, 'DORGBR', 'Q', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVA .AND. WNTUAS ) THEN
*
*                 Path 9t(N much larger than M, JOBU='S' or 'A',
*                 JOBVT='A')
*
                  WRKBL = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*ILAENV( 1, 'DORGLQ', ' ', N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    ILAENV( 1, 'DGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    ILAENV( 1, 'DORGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    ILAENV( 1, 'DORGBR', 'Q', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               END IF
            ELSE
*
*              Path 10t(N greater than M, but not much larger)
*
               MAXWRK = 3*M + ( M+N )*ILAENV( 1, 'DGEBRD', ' ', M, N,
     $                  -1, -1 )
               IF( WNTVS .OR. WNTVO )
     $            MAXWRK = MAX( MAXWRK, 3*M+M*
     $                     ILAENV( 1, 'DORGBR', 'P', M, N, M, -1 ) )
               IF( WNTVA )
     $            MAXWRK = MAX( MAXWRK, 3*M+N*
     $                     ILAENV( 1, 'DORGBR', 'P', N, N, M, -1 ) )
               IF( .NOT.WNTUN )
     $            MAXWRK = MAX( MAXWRK, 3*M+( M-1 )*
     $                     ILAENV( 1, 'DORGBR', 'Q', M, M, M, -1 ) )
               MAXWRK = MAX( MAXWRK, BDSPAC )
               MINWRK = MAX( 3*M+N, BDSPAC )
            END IF
         END IF
         MAXWRK = MAX( MAXWRK, MINWRK )
         WORK( 1 ) = MAXWRK
*
         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -13
         END IF
      END IF
*
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGESVD', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RETURN
      END IF
*
*     Get machine constants
*
      EPS = DLAMCH( 'P' )
      SMLNUM = SQRT( DLAMCH( 'S' ) ) / EPS
      BIGNUM = ONE / SMLNUM
*
*     Scale A if max element outside range [SMLNUM,BIGNUM]
*
      ANRM = DLANGE( 'M', M, N, A, LDA, DUM )
      ISCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         ISCL = 1
         CALL DLASCL( 'G', 0, 0, ANRM, SMLNUM, M, N, A, LDA, IERR )
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         ISCL = 1
         CALL DLASCL( 'G', 0, 0, ANRM, BIGNUM, M, N, A, LDA, IERR )
      END IF
*
      IF( M.GE.N ) THEN
*
*        A has at least as many rows as columns. If A has sufficiently
*        more rows than columns, first reduce using the QR
*        decomposition (if sufficient workspace available)
*
         IF( M.GE.MNTHR ) THEN
*
            IF( WNTUN ) THEN
*
*              Path 1 (M much larger than N, JOBU='N')
*              No left singular vectors to be computed
*
               ITAU = 1
               IWORK = ITAU + N
*
*              Compute A=Q*R
*              (Workspace: need 2*N, prefer N+N*NB)
*
               CALL DGEQRF( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                      LWORK-IWORK+1, IERR )
*
*              Zero out below R
*
               CALL DLASET( 'L', N-1, N-1, ZERO, ZERO, A( 2, 1 ), LDA )
               IE = 1
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               IWORK = ITAUP + N
*
*              Bidiagonalize R in A
*              (Workspace: need 4*N, prefer 3*N+2*N*NB)
*
               CALL DGEBRD( N, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                      IERR )
               NCVT = 0
               IF( WNTVO .OR. WNTVAS ) THEN
*
*                 If right singular vectors desired, generate P'.
*                 (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
*
                  CALL DORGBR( 'P', N, N, N, A, LDA, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  NCVT = N
               END IF
               IWORK = IE + N
*
*              Perform bidiagonal QR iteration, computing right
*              singular vectors of A in A if desired
*              (Workspace: need BDSPAC)
*
               CALL DBDSQR( 'U', N, NCVT, 0, 0, S, WORK( IE ), A, LDA,
     $                      DUM, 1, DUM, 1, WORK( IWORK ), INFO )
*
*              If right singular vectors desired in VT, copy them there
*
               IF( WNTVAS )
     $            CALL DLACPY( 'F', N, N, A, LDA, VT, LDVT )
*
            ELSE IF( WNTUO .AND. WNTVN ) THEN
*
*              Path 2 (M much larger than N, JOBU='O', JOBVT='N')
*              N left singular vectors to be overwritten on A and
*              no right singular vectors to be computed
*
               IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
*
*                 Sufficient workspace for a fast algorithm
*
                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+LDA*N ) THEN
*
*                    WORK(IU) is LDA by N, WORK(IR) is LDA by N
*
                     LDWRKU = LDA
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+N*N ) THEN
*
*                    WORK(IU) is LDA by N, WORK(IR) is N by N
*
                     LDWRKU = LDA
                     LDWRKR = N
                  ELSE
*
*                    WORK(IU) is LDWRKU by N, WORK(IR) is N by N
*
                     LDWRKU = ( LWORK-N*N-N ) / N
                     LDWRKR = N
                  END IF
                  ITAU = IR + LDWRKR*N
                  IWORK = ITAU + N
*
*                 Compute A=Q*R
*                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*
                  CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Copy R to WORK(IR) and zero out below it
*
                  CALL DLACPY( 'U', N, N, A, LDA, WORK( IR ), LDWRKR )
                  CALL DLASET( 'L', N-1, N-1, ZERO, ZERO, WORK( IR+1 ),
     $                         LDWRKR )
*
*                 Generate Q in A
*                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*
                  CALL DORGQR( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
*
*                 Bidiagonalize R in WORK(IR)
*                 (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
*
                  CALL DGEBRD( N, N, WORK( IR ), LDWRKR, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Generate left vectors bidiagonalizing R
*                 (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
*
                  CALL DORGBR( 'Q', N, N, N, WORK( IR ), LDWRKR,
     $                         WORK( ITAUQ ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
                  IWORK = IE + N
*
*                 Perform bidiagonal QR iteration, computing left
*                 singular vectors of R in WORK(IR)
*                 (Workspace: need N*N+BDSPAC)
*
                  CALL DBDSQR( 'U', N, 0, N, 0, S, WORK( IE ), DUM, 1,
     $                         WORK( IR ), LDWRKR, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + N
*
*                 Multiply Q in A by left singular vectors of R in
*                 WORK(IR), storing result in WORK(IU) and copying to A
*                 (Workspace: need N*N+2*N, prefer N*N+M*N+N)
*
                  DO 10 I = 1, M, LDWRKU
                     CHUNK = MIN( M-I+1, LDWRKU )
                     CALL DGEMM( 'N', 'N', CHUNK, N, N, ONE, A( I, 1 ),
     $                           LDA, WORK( IR ), LDWRKR, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL DLACPY( 'F', CHUNK, N, WORK( IU ), LDWRKU,
     $                            A( I, 1 ), LDA )
   10             CONTINUE
*
               ELSE
*
*                 Insufficient workspace for a fast algorithm
*
                  IE = 1
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
*
*                 Bidiagonalize A
*                 (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
*
                  CALL DGEBRD( M, N, A, LDA, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Generate left vectors bidiagonalizing A
*                 (Workspace: need 4*N, prefer 3*N+N*NB)
*
                  CALL DORGBR( 'Q', M, N, N, A, LDA, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + N
*
*                 Perform bidiagonal QR iteration, computing left
*                 singular vectors of A in A
*                 (Workspace: need BDSPAC)
*
                  CALL DBDSQR( 'U', N, 0, M, 0, S, WORK( IE ), DUM, 1,
     $                         A, LDA, DUM, 1, WORK( IWORK ), INFO )
*
               END IF
*
            ELSE IF( WNTUO .AND. WNTVAS ) THEN
*
*              Path 3 (M much larger than N, JOBU='O', JOBVT='S' or 'A')
*              N left singular vectors to be overwritten on A and
*              N right singular vectors to be computed in VT
*
               IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
*
*                 Sufficient workspace for a fast algorithm
*
                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+LDA*N ) THEN
*
*                    WORK(IU) is LDA by N and WORK(IR) is LDA by N
*
                     LDWRKU = LDA
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+N*N ) THEN
*
*                    WORK(IU) is LDA by N and WORK(IR) is N by N
*
                     LDWRKU = LDA
                     LDWRKR = N
                  ELSE
*
*                    WORK(IU) is LDWRKU by N and WORK(IR) is N by N
*
                     LDWRKU = ( LWORK-N*N-N ) / N
                     LDWRKR = N
                  END IF
                  ITAU = IR + LDWRKR*N
                  IWORK = ITAU + N
*
*                 Compute A=Q*R
*                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*
                  CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Copy R to VT, zeroing out below it
*
                  CALL DLACPY( 'U', N, N, A, LDA, VT, LDVT )
                  IF( N.GT.1 )
     $               CALL DLASET( 'L', N-1, N-1, ZERO, ZERO,
     $                            VT( 2, 1 ), LDVT )
*
*                 Generate Q in A
*                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*
                  CALL DORGQR( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
*
*                 Bidiagonalize R in VT, copying result to WORK(IR)
*                 (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
*
                  CALL DGEBRD( N, N, VT, LDVT, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  CALL DLACPY( 'L', N, N, VT, LDVT, WORK( IR ), LDWRKR )
*
*                 Generate left vectors bidiagonalizing R in WORK(IR)
*                 (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
*
                  CALL DORGBR( 'Q', N, N, N, WORK( IR ), LDWRKR,
     $                         WORK( ITAUQ ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
*
*                 Generate right vectors bidiagonalizing R in VT
*                 (Workspace: need N*N+4*N-1, prefer N*N+3*N+(N-1)*NB)
*
                  CALL DORGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + N
*
*                 Perform bidiagonal QR iteration, computing left
*                 singular vectors of R in WORK(IR) and computing right
*                 singular vectors of R in VT
*                 (Workspace: need N*N+BDSPAC)
*
                  CALL DBDSQR( 'U', N, N, N, 0, S, WORK( IE ), VT, LDVT,
     $                         WORK( IR ), LDWRKR, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + N
*
*                 Multiply Q in A by left singular vectors of R in
*                 WORK(IR), storing result in WORK(IU) and copying to A
*                 (Workspace: need N*N+2*N, prefer N*N+M*N+N)
*
                  DO 20 I = 1, M, LDWRKU
                     CHUNK = MIN( M-I+1, LDWRKU )
                     CALL DGEMM( 'N', 'N', CHUNK, N, N, ONE, A( I, 1 ),
     $                           LDA, WORK( IR ), LDWRKR, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL DLACPY( 'F', CHUNK, N, WORK( IU ), LDWRKU,
     $                            A( I, 1 ), LDA )
   20             CONTINUE
*
               ELSE
*
*                 Insufficient workspace for a fast algorithm
*
                  ITAU = 1
                  IWORK = ITAU + N
*
*                 Compute A=Q*R
*                 (Workspace: need 2*N, prefer N+N*NB)
*
                  CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Copy R to VT, zeroing out below it
*
                  CALL DLACPY( 'U', N, N, A, LDA, VT, LDVT )
                  IF( N.GT.1 )
     $               CALL DLASET( 'L', N-1, N-1, ZERO, ZERO,
     $                            VT( 2, 1 ), LDVT )
*
*                 Generate Q in A
*                 (Workspace: need 2*N, prefer N+N*NB)
*
                  CALL DORGQR( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
*
*                 Bidiagonalize R in VT
*                 (Workspace: need 4*N, prefer 3*N+2*N*NB)
*
                  CALL DGEBRD( N, N, VT, LDVT, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Multiply Q in A by left vectors bidiagonalizing R
*                 (Workspace: need 3*N+M, prefer 3*N+M*NB)
*
                  CALL DORMBR( 'Q', 'R', 'N', M, N, N, VT, LDVT,
     $                         WORK( ITAUQ ), A, LDA, WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
*
*                 Generate right vectors bidiagonalizing R in VT
*                 (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
*
                  CALL DORGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + N
*
*                 Perform bidiagonal QR iteration, computing left
*                 singular vectors of A in A and computing right
*                 singular vectors of A in VT
*                 (Workspace: need BDSPAC)
*
                  CALL DBDSQR( 'U', N, N, M, 0, S, WORK( IE ), VT, LDVT,
     $                         A, LDA, DUM, 1, WORK( IWORK ), INFO )
*
               END IF
*
            ELSE IF( WNTUS ) THEN
*
               IF( WNTVN ) THEN
*
*                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
*                 N left singular vectors to be computed in U and
*                 no right singular vectors to be computed
*
                  IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
*
*                       WORK(IR) is LDA by N
*
                        LDWRKR = LDA
                     ELSE
*
*                       WORK(IR) is N by N
*
                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
*
*                    Compute A=Q*R
*                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy R to WORK(IR), zeroing out below it
*
                     CALL DLACPY( 'U', N, N, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL DLASET( 'L', N-1, N-1, ZERO, ZERO,
     $                            WORK( IR+1 ), LDWRKR )
*
*                    Generate Q in A
*                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*
                     CALL DORGQR( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Bidiagonalize R in WORK(IR)
*                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate left vectors bidiagonalizing R in WORK(IR)
*                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
*
                     CALL DORGBR( 'Q', N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of R in WORK(IR)
*                    (Workspace: need N*N+BDSPAC)
*
                     CALL DBDSQR( 'U', N, 0, N, 0, S, WORK( IE ), DUM,
     $                            1, WORK( IR ), LDWRKR, DUM, 1,
     $                            WORK( IWORK ), INFO )
*
*                    Multiply Q in A by left singular vectors of R in
*                    WORK(IR), storing result in U
*                    (Workspace: need N*N)
*
                     CALL DGEMM( 'N', 'N', M, N, N, ONE, A, LDA,
     $                           WORK( IR ), LDWRKR, ZERO, U, LDU )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + N
*
*                    Compute A=Q*R, copying result to U
*                    (Workspace: need 2*N, prefer N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, N, A, LDA, U, LDU )
*
*                    Generate Q in U
*                    (Workspace: need 2*N, prefer N+N*NB)
*
                     CALL DORGQR( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Zero out below R in A
*
                     CALL DLASET( 'L', N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
*
*                    Bidiagonalize R in A
*                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply Q in U by left vectors bidiagonalizing R
*                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
*
                     CALL DORMBR( 'Q', 'R', 'N', M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of A in U
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', N, 0, M, 0, S, WORK( IE ), DUM,
     $                            1, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               ELSE IF( WNTVO ) THEN
*
*                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
*                 N left singular vectors to be computed in U and
*                 N right singular vectors to be overwritten on A
*
                  IF( LWORK.GE.2*N*N+MAX( 4*N, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*N ) THEN
*
*                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
*
                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+N )*N ) THEN
*
*                       WORK(IU) is LDA by N and WORK(IR) is N by N
*
                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     ELSE
*
*                       WORK(IU) is N by N and WORK(IR) is N by N
*
                        LDWRKU = N
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
*
*                    Compute A=Q*R
*                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy R to WORK(IU), zeroing out below it
*
                     CALL DLACPY( 'U', N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL DLASET( 'L', N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
*
*                    Generate Q in A
*                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
*
                     CALL DORGQR( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Bidiagonalize R in WORK(IU), copying result to
*                    WORK(IR)
*                    (Workspace: need 2*N*N+4*N,
*                                prefer 2*N*N+3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', N, N, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
*
*                    Generate left bidiagonalizing vectors in WORK(IU)
*                    (Workspace: need 2*N*N+4*N, prefer 2*N*N+3*N+N*NB)
*
                     CALL DORGBR( 'Q', N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate right bidiagonalizing vectors in WORK(IR)
*                    (Workspace: need 2*N*N+4*N-1,
*                                prefer 2*N*N+3*N+(N-1)*NB)
*
                     CALL DORGBR( 'P', N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of R in WORK(IU) and computing
*                    right singular vectors of R in WORK(IR)
*                    (Workspace: need 2*N*N+BDSPAC)
*
                     CALL DBDSQR( 'U', N, N, N, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, WORK( IU ),
     $                            LDWRKU, DUM, 1, WORK( IWORK ), INFO )
*
*                    Multiply Q in A by left singular vectors of R in
*                    WORK(IU), storing result in U
*                    (Workspace: need N*N)
*
                     CALL DGEMM( 'N', 'N', M, N, N, ONE, A, LDA,
     $                           WORK( IU ), LDWRKU, ZERO, U, LDU )
*
*                    Copy right singular vectors of R to A
*                    (Workspace: need N*N)
*
                     CALL DLACPY( 'F', N, N, WORK( IR ), LDWRKR, A,
     $                            LDA )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + N
*
*                    Compute A=Q*R, copying result to U
*                    (Workspace: need 2*N, prefer N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, N, A, LDA, U, LDU )
*
*                    Generate Q in U
*                    (Workspace: need 2*N, prefer N+N*NB)
*
                     CALL DORGQR( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Zero out below R in A
*
                     CALL DLASET( 'L', N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
*
*                    Bidiagonalize R in A
*                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply Q in U by left vectors bidiagonalizing R
*                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
*
                     CALL DORMBR( 'Q', 'R', 'N', M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate right vectors bidiagonalizing R in A
*                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
*
                     CALL DORGBR( 'P', N, N, N, A, LDA, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of A in U and computing right
*                    singular vectors of A in A
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', N, N, M, 0, S, WORK( IE ), A,
     $                            LDA, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               ELSE IF( WNTVAS ) THEN
*
*                 Path 6 (M much larger than N, JOBU='S', JOBVT='S'
*                         or 'A')
*                 N left singular vectors to be computed in U and
*                 N right singular vectors to be computed in VT
*
                  IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
*
*                       WORK(IU) is LDA by N
*
                        LDWRKU = LDA
                     ELSE
*
*                       WORK(IU) is N by N
*
                        LDWRKU = N
                     END IF
                     ITAU = IU + LDWRKU*N
                     IWORK = ITAU + N
*
*                    Compute A=Q*R
*                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy R to WORK(IU), zeroing out below it
*
                     CALL DLACPY( 'U', N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL DLASET( 'L', N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
*
*                    Generate Q in A
*                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*
                     CALL DORGQR( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Bidiagonalize R in WORK(IU), copying result to VT
*                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', N, N, WORK( IU ), LDWRKU, VT,
     $                            LDVT )
*
*                    Generate left bidiagonalizing vectors in WORK(IU)
*                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
*
                     CALL DORGBR( 'Q', N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate right bidiagonalizing vectors in VT
*                    (Workspace: need N*N+4*N-1,
*                                prefer N*N+3*N+(N-1)*NB)
*
                     CALL DORGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of R in WORK(IU) and computing
*                    right singular vectors of R in VT
*                    (Workspace: need N*N+BDSPAC)
*
                     CALL DBDSQR( 'U', N, N, N, 0, S, WORK( IE ), VT,
     $                            LDVT, WORK( IU ), LDWRKU, DUM, 1,
     $                            WORK( IWORK ), INFO )
*
*                    Multiply Q in A by left singular vectors of R in
*                    WORK(IU), storing result in U
*                    (Workspace: need N*N)
*
                     CALL DGEMM( 'N', 'N', M, N, N, ONE, A, LDA,
     $                           WORK( IU ), LDWRKU, ZERO, U, LDU )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + N
*
*                    Compute A=Q*R, copying result to U
*                    (Workspace: need 2*N, prefer N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, N, A, LDA, U, LDU )
*
*                    Generate Q in U
*                    (Workspace: need 2*N, prefer N+N*NB)
*
                     CALL DORGQR( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy R to VT, zeroing out below it
*
                     CALL DLACPY( 'U', N, N, A, LDA, VT, LDVT )
                     IF( N.GT.1 )
     $                  CALL DLASET( 'L', N-1, N-1, ZERO, ZERO,
     $                               VT( 2, 1 ), LDVT )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Bidiagonalize R in VT
*                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, VT, LDVT, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply Q in U by left bidiagonalizing vectors
*                    in VT
*                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
*
                     CALL DORMBR( 'Q', 'R', 'N', M, N, N, VT, LDVT,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate right bidiagonalizing vectors in VT
*                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
*
                     CALL DORGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of A in U and computing right
*                    singular vectors of A in VT
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', N, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               END IF
*
            ELSE IF( WNTUA ) THEN
*
               IF( WNTVN ) THEN
*
*                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
*                 M left singular vectors to be computed in U and
*                 no right singular vectors to be computed
*
                  IF( LWORK.GE.N*N+MAX( N+M, 4*N, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
*
*                       WORK(IR) is LDA by N
*
                        LDWRKR = LDA
                     ELSE
*
*                       WORK(IR) is N by N
*
                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
*
*                    Compute A=Q*R, copying result to U
*                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, N, A, LDA, U, LDU )
*
*                    Copy R to WORK(IR), zeroing out below it
*
                     CALL DLACPY( 'U', N, N, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL DLASET( 'L', N-1, N-1, ZERO, ZERO,
     $                            WORK( IR+1 ), LDWRKR )
*
*                    Generate Q in U
*                    (Workspace: need N*N+N+M, prefer N*N+N+M*NB)
*
                     CALL DORGQR( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Bidiagonalize R in WORK(IR)
*                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate left bidiagonalizing vectors in WORK(IR)
*                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
*
                     CALL DORGBR( 'Q', N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of R in WORK(IR)
*                    (Workspace: need N*N+BDSPAC)
*
                     CALL DBDSQR( 'U', N, 0, N, 0, S, WORK( IE ), DUM,
     $                            1, WORK( IR ), LDWRKR, DUM, 1,
     $                            WORK( IWORK ), INFO )
*
*                    Multiply Q in U by left singular vectors of R in
*                    WORK(IR), storing result in A
*                    (Workspace: need N*N)
*
                     CALL DGEMM( 'N', 'N', M, N, N, ONE, U, LDU,
     $                           WORK( IR ), LDWRKR, ZERO, A, LDA )
*
*                    Copy left singular vectors of A from A to U
*
                     CALL DLACPY( 'F', M, N, A, LDA, U, LDU )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + N
*
*                    Compute A=Q*R, copying result to U
*                    (Workspace: need 2*N, prefer N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, N, A, LDA, U, LDU )
*
*                    Generate Q in U
*                    (Workspace: need N+M, prefer N+M*NB)
*
                     CALL DORGQR( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Zero out below R in A
*
                     CALL DLASET( 'L', N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
*
*                    Bidiagonalize R in A
*                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply Q in U by left bidiagonalizing vectors
*                    in A
*                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
*
                     CALL DORMBR( 'Q', 'R', 'N', M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of A in U
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', N, 0, M, 0, S, WORK( IE ), DUM,
     $                            1, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               ELSE IF( WNTVO ) THEN
*
*                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
*                 M left singular vectors to be computed in U and
*                 N right singular vectors to be overwritten on A
*
                  IF( LWORK.GE.2*N*N+MAX( N+M, 4*N, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*N ) THEN
*
*                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
*
                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+N )*N ) THEN
*
*                       WORK(IU) is LDA by N and WORK(IR) is N by N
*
                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     ELSE
*
*                       WORK(IU) is N by N and WORK(IR) is N by N
*
                        LDWRKU = N
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
*
*                    Compute A=Q*R, copying result to U
*                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, N, A, LDA, U, LDU )
*
*                    Generate Q in U
*                    (Workspace: need 2*N*N+N+M, prefer 2*N*N+N+M*NB)
*
                     CALL DORGQR( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy R to WORK(IU), zeroing out below it
*
                     CALL DLACPY( 'U', N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL DLASET( 'L', N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Bidiagonalize R in WORK(IU), copying result to
*                    WORK(IR)
*                    (Workspace: need 2*N*N+4*N,
*                                prefer 2*N*N+3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', N, N, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
*
*                    Generate left bidiagonalizing vectors in WORK(IU)
*                    (Workspace: need 2*N*N+4*N, prefer 2*N*N+3*N+N*NB)
*
                     CALL DORGBR( 'Q', N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate right bidiagonalizing vectors in WORK(IR)
*                    (Workspace: need 2*N*N+4*N-1,
*                                prefer 2*N*N+3*N+(N-1)*NB)
*
                     CALL DORGBR( 'P', N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of R in WORK(IU) and computing
*                    right singular vectors of R in WORK(IR)
*                    (Workspace: need 2*N*N+BDSPAC)
*
                     CALL DBDSQR( 'U', N, N, N, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, WORK( IU ),
     $                            LDWRKU, DUM, 1, WORK( IWORK ), INFO )
*
*                    Multiply Q in U by left singular vectors of R in
*                    WORK(IU), storing result in A
*                    (Workspace: need N*N)
*
                     CALL DGEMM( 'N', 'N', M, N, N, ONE, U, LDU,
     $                           WORK( IU ), LDWRKU, ZERO, A, LDA )
*
*                    Copy left singular vectors of A from A to U
*
                     CALL DLACPY( 'F', M, N, A, LDA, U, LDU )
*
*                    Copy right singular vectors of R from WORK(IR) to A
*
                     CALL DLACPY( 'F', N, N, WORK( IR ), LDWRKR, A,
     $                            LDA )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + N
*
*                    Compute A=Q*R, copying result to U
*                    (Workspace: need 2*N, prefer N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, N, A, LDA, U, LDU )
*
*                    Generate Q in U
*                    (Workspace: need N+M, prefer N+M*NB)
*
                     CALL DORGQR( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Zero out below R in A
*
                     CALL DLASET( 'L', N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
*
*                    Bidiagonalize R in A
*                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply Q in U by left bidiagonalizing vectors
*                    in A
*                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
*
                     CALL DORMBR( 'Q', 'R', 'N', M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate right bidiagonalizing vectors in A
*                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
*
                     CALL DORGBR( 'P', N, N, N, A, LDA, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of A in U and computing right
*                    singular vectors of A in A
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', N, N, M, 0, S, WORK( IE ), A,
     $                            LDA, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               ELSE IF( WNTVAS ) THEN
*
*                 Path 9 (M much larger than N, JOBU='A', JOBVT='S'
*                         or 'A')
*                 M left singular vectors to be computed in U and
*                 N right singular vectors to be computed in VT
*
                  IF( LWORK.GE.N*N+MAX( N+M, 4*N, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
*
*                       WORK(IU) is LDA by N
*
                        LDWRKU = LDA
                     ELSE
*
*                       WORK(IU) is N by N
*
                        LDWRKU = N
                     END IF
                     ITAU = IU + LDWRKU*N
                     IWORK = ITAU + N
*
*                    Compute A=Q*R, copying result to U
*                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, N, A, LDA, U, LDU )
*
*                    Generate Q in U
*                    (Workspace: need N*N+N+M, prefer N*N+N+M*NB)
*
                     CALL DORGQR( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy R to WORK(IU), zeroing out below it
*
                     CALL DLACPY( 'U', N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL DLASET( 'L', N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Bidiagonalize R in WORK(IU), copying result to VT
*                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', N, N, WORK( IU ), LDWRKU, VT,
     $                            LDVT )
*
*                    Generate left bidiagonalizing vectors in WORK(IU)
*                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
*
                     CALL DORGBR( 'Q', N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate right bidiagonalizing vectors in VT
*                    (Workspace: need N*N+4*N-1,
*                                prefer N*N+3*N+(N-1)*NB)
*
                     CALL DORGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of R in WORK(IU) and computing
*                    right singular vectors of R in VT
*                    (Workspace: need N*N+BDSPAC)
*
                     CALL DBDSQR( 'U', N, N, N, 0, S, WORK( IE ), VT,
     $                            LDVT, WORK( IU ), LDWRKU, DUM, 1,
     $                            WORK( IWORK ), INFO )
*
*                    Multiply Q in U by left singular vectors of R in
*                    WORK(IU), storing result in A
*                    (Workspace: need N*N)
*
                     CALL DGEMM( 'N', 'N', M, N, N, ONE, U, LDU,
     $                           WORK( IU ), LDWRKU, ZERO, A, LDA )
*
*                    Copy left singular vectors of A from A to U
*
                     CALL DLACPY( 'F', M, N, A, LDA, U, LDU )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + N
*
*                    Compute A=Q*R, copying result to U
*                    (Workspace: need 2*N, prefer N+N*NB)
*
                     CALL DGEQRF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, N, A, LDA, U, LDU )
*
*                    Generate Q in U
*                    (Workspace: need N+M, prefer N+M*NB)
*
                     CALL DORGQR( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy R from A to VT, zeroing out below it
*
                     CALL DLACPY( 'U', N, N, A, LDA, VT, LDVT )
                     IF( N.GT.1 )
     $                  CALL DLASET( 'L', N-1, N-1, ZERO, ZERO,
     $                               VT( 2, 1 ), LDVT )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
*
*                    Bidiagonalize R in VT
*                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
*
                     CALL DGEBRD( N, N, VT, LDVT, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply Q in U by left bidiagonalizing vectors
*                    in VT
*                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
*
                     CALL DORMBR( 'Q', 'R', 'N', M, N, N, VT, LDVT,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate right bidiagonalizing vectors in VT
*                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
*
                     CALL DORGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of A in U and computing right
*                    singular vectors of A in VT
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', N, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               END IF
*
            END IF
*
         ELSE
*
*           M .LT. MNTHR
*
*           Path 10 (M at least N, but not much larger)
*           Reduce to bidiagonal form without QR decomposition
*
            IE = 1
            ITAUQ = IE + N
            ITAUP = ITAUQ + N
            IWORK = ITAUP + N
*
*           Bidiagonalize A
*           (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
*
            CALL DGEBRD( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                   IERR )
            IF( WNTUAS ) THEN
*
*              If left singular vectors desired in U, copy result to U
*              and generate left bidiagonalizing vectors in U
*              (Workspace: need 3*N+NCU, prefer 3*N+NCU*NB)
*
               CALL DLACPY( 'L', M, N, A, LDA, U, LDU )
               IF( WNTUS )
     $            NCU = N
               IF( WNTUA )
     $            NCU = M
               CALL DORGBR( 'Q', M, NCU, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVAS ) THEN
*
*              If right singular vectors desired in VT, copy result to
*              VT and generate right bidiagonalizing vectors in VT
*              (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
*
               CALL DLACPY( 'U', N, N, A, LDA, VT, LDVT )
               CALL DORGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTUO ) THEN
*
*              If left singular vectors desired in A, generate left
*              bidiagonalizing vectors in A
*              (Workspace: need 4*N, prefer 3*N+N*NB)
*
               CALL DORGBR( 'Q', M, N, N, A, LDA, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVO ) THEN
*
*              If right singular vectors desired in A, generate right
*              bidiagonalizing vectors in A
*              (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
*
               CALL DORGBR( 'P', N, N, N, A, LDA, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IWORK = IE + N
            IF( WNTUAS .OR. WNTUO )
     $         NRU = M
            IF( WNTUN )
     $         NRU = 0
            IF( WNTVAS .OR. WNTVO )
     $         NCVT = N
            IF( WNTVN )
     $         NCVT = 0
            IF( ( .NOT.WNTUO ) .AND. ( .NOT.WNTVO ) ) THEN
*
*              Perform bidiagonal QR iteration, if desired, computing
*              left singular vectors in U and computing right singular
*              vectors in VT
*              (Workspace: need BDSPAC)
*
               CALL DBDSQR( 'U', N, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE IF( ( .NOT.WNTUO ) .AND. WNTVO ) THEN
*
*              Perform bidiagonal QR iteration, if desired, computing
*              left singular vectors in U and computing right singular
*              vectors in A
*              (Workspace: need BDSPAC)
*
               CALL DBDSQR( 'U', N, NCVT, NRU, 0, S, WORK( IE ), A, LDA,
     $                      U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE
*
*              Perform bidiagonal QR iteration, if desired, computing
*              left singular vectors in A and computing right singular
*              vectors in VT
*              (Workspace: need BDSPAC)
*
               CALL DBDSQR( 'U', N, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, A, LDA, DUM, 1, WORK( IWORK ), INFO )
            END IF
*
         END IF
*
      ELSE
*
*        A has more columns than rows. If A has sufficiently more
*        columns than rows, first reduce using the LQ decomposition (if
*        sufficient workspace available)
*
         IF( N.GE.MNTHR ) THEN
*
            IF( WNTVN ) THEN
*
*              Path 1t(N much larger than M, JOBVT='N')
*              No right singular vectors to be computed
*
               ITAU = 1
               IWORK = ITAU + M
*
*              Compute A=L*Q
*              (Workspace: need 2*M, prefer M+M*NB)
*
               CALL DGELQF( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                      LWORK-IWORK+1, IERR )
*
*              Zero out above L
*
               CALL DLASET( 'U', M-1, M-1, ZERO, ZERO, A( 1, 2 ), LDA )
               IE = 1
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               IWORK = ITAUP + M
*
*              Bidiagonalize L in A
*              (Workspace: need 4*M, prefer 3*M+2*M*NB)
*
               CALL DGEBRD( M, M, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                      IERR )
               IF( WNTUO .OR. WNTUAS ) THEN
*
*                 If left singular vectors desired, generate Q
*                 (Workspace: need 4*M, prefer 3*M+M*NB)
*
                  CALL DORGBR( 'Q', M, M, M, A, LDA, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
               END IF
               IWORK = IE + M
               NRU = 0
               IF( WNTUO .OR. WNTUAS )
     $            NRU = M
*
*              Perform bidiagonal QR iteration, computing left singular
*              vectors of A in A if desired
*              (Workspace: need BDSPAC)
*
               CALL DBDSQR( 'U', M, 0, NRU, 0, S, WORK( IE ), DUM, 1, A,
     $                      LDA, DUM, 1, WORK( IWORK ), INFO )
*
*              If left singular vectors desired in U, copy them there
*
               IF( WNTUAS )
     $            CALL DLACPY( 'F', M, M, A, LDA, U, LDU )
*
            ELSE IF( WNTVO .AND. WNTUN ) THEN
*
*              Path 2t(N much larger than M, JOBU='N', JOBVT='O')
*              M right singular vectors to be overwritten on A and
*              no left singular vectors to be computed
*
               IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
*
*                 Sufficient workspace for a fast algorithm
*
                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+LDA*M ) THEN
*
*                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
*
                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+M*M ) THEN
*
*                    WORK(IU) is LDA by N and WORK(IR) is M by M
*
                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = M
                  ELSE
*
*                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
*
                     LDWRKU = M
                     CHUNK = ( LWORK-M*M-M ) / M
                     LDWRKR = M
                  END IF
                  ITAU = IR + LDWRKR*M
                  IWORK = ITAU + M
*
*                 Compute A=L*Q
*                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*
                  CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Copy L to WORK(IR) and zero out above it
*
                  CALL DLACPY( 'L', M, M, A, LDA, WORK( IR ), LDWRKR )
                  CALL DLASET( 'U', M-1, M-1, ZERO, ZERO,
     $                         WORK( IR+LDWRKR ), LDWRKR )
*
*                 Generate Q in A
*                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*
                  CALL DORGLQ( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
*
*                 Bidiagonalize L in WORK(IR)
*                 (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
*
                  CALL DGEBRD( M, M, WORK( IR ), LDWRKR, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Generate right vectors bidiagonalizing L
*                 (Workspace: need M*M+4*M-1, prefer M*M+3*M+(M-1)*NB)
*
                  CALL DORGBR( 'P', M, M, M, WORK( IR ), LDWRKR,
     $                         WORK( ITAUP ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
                  IWORK = IE + M
*
*                 Perform bidiagonal QR iteration, computing right
*                 singular vectors of L in WORK(IR)
*                 (Workspace: need M*M+BDSPAC)
*
                  CALL DBDSQR( 'U', M, M, 0, 0, S, WORK( IE ),
     $                         WORK( IR ), LDWRKR, DUM, 1, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + M
*
*                 Multiply right singular vectors of L in WORK(IR) by Q
*                 in A, storing result in WORK(IU) and copying to A
*                 (Workspace: need M*M+2*M, prefer M*M+M*N+M)
*
                  DO 30 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL DGEMM( 'N', 'N', M, BLK, M, ONE, WORK( IR ),
     $                           LDWRKR, A( 1, I ), LDA, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL DLACPY( 'F', M, BLK, WORK( IU ), LDWRKU,
     $                            A( 1, I ), LDA )
   30             CONTINUE
*
               ELSE
*
*                 Insufficient workspace for a fast algorithm
*
                  IE = 1
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
*
*                 Bidiagonalize A
*                 (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
*
                  CALL DGEBRD( M, N, A, LDA, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Generate right vectors bidiagonalizing A
*                 (Workspace: need 4*M, prefer 3*M+M*NB)
*
                  CALL DORGBR( 'P', M, N, M, A, LDA, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + M
*
*                 Perform bidiagonal QR iteration, computing right
*                 singular vectors of A in A
*                 (Workspace: need BDSPAC)
*
                  CALL DBDSQR( 'L', M, N, 0, 0, S, WORK( IE ), A, LDA,
     $                         DUM, 1, DUM, 1, WORK( IWORK ), INFO )
*
               END IF
*
            ELSE IF( WNTVO .AND. WNTUAS ) THEN
*
*              Path 3t(N much larger than M, JOBU='S' or 'A', JOBVT='O')
*              M right singular vectors to be overwritten on A and
*              M left singular vectors to be computed in U
*
               IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
*
*                 Sufficient workspace for a fast algorithm
*
                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+LDA*M ) THEN
*
*                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
*
                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+M*M ) THEN
*
*                    WORK(IU) is LDA by N and WORK(IR) is M by M
*
                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = M
                  ELSE
*
*                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
*
                     LDWRKU = M
                     CHUNK = ( LWORK-M*M-M ) / M
                     LDWRKR = M
                  END IF
                  ITAU = IR + LDWRKR*M
                  IWORK = ITAU + M
*
*                 Compute A=L*Q
*                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*
                  CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Copy L to U, zeroing about above it
*
                  CALL DLACPY( 'L', M, M, A, LDA, U, LDU )
                  CALL DLASET( 'U', M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                         LDU )
*
*                 Generate Q in A
*                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*
                  CALL DORGLQ( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
*
*                 Bidiagonalize L in U, copying result to WORK(IR)
*                 (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
*
                  CALL DGEBRD( M, M, U, LDU, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  CALL DLACPY( 'U', M, M, U, LDU, WORK( IR ), LDWRKR )
*
*                 Generate right vectors bidiagonalizing L in WORK(IR)
*                 (Workspace: need M*M+4*M-1, prefer M*M+3*M+(M-1)*NB)
*
                  CALL DORGBR( 'P', M, M, M, WORK( IR ), LDWRKR,
     $                         WORK( ITAUP ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
*
*                 Generate left vectors bidiagonalizing L in U
*                 (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
*
                  CALL DORGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + M
*
*                 Perform bidiagonal QR iteration, computing left
*                 singular vectors of L in U, and computing right
*                 singular vectors of L in WORK(IR)
*                 (Workspace: need M*M+BDSPAC)
*
                  CALL DBDSQR( 'U', M, M, M, 0, S, WORK( IE ),
     $                         WORK( IR ), LDWRKR, U, LDU, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + M
*
*                 Multiply right singular vectors of L in WORK(IR) by Q
*                 in A, storing result in WORK(IU) and copying to A
*                 (Workspace: need M*M+2*M, prefer M*M+M*N+M))
*
                  DO 40 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL DGEMM( 'N', 'N', M, BLK, M, ONE, WORK( IR ),
     $                           LDWRKR, A( 1, I ), LDA, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL DLACPY( 'F', M, BLK, WORK( IU ), LDWRKU,
     $                            A( 1, I ), LDA )
   40             CONTINUE
*
               ELSE
*
*                 Insufficient workspace for a fast algorithm
*
                  ITAU = 1
                  IWORK = ITAU + M
*
*                 Compute A=L*Q
*                 (Workspace: need 2*M, prefer M+M*NB)
*
                  CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Copy L to U, zeroing out above it
*
                  CALL DLACPY( 'L', M, M, A, LDA, U, LDU )
                  CALL DLASET( 'U', M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                         LDU )
*
*                 Generate Q in A
*                 (Workspace: need 2*M, prefer M+M*NB)
*
                  CALL DORGLQ( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
*
*                 Bidiagonalize L in U
*                 (Workspace: need 4*M, prefer 3*M+2*M*NB)
*
                  CALL DGEBRD( M, M, U, LDU, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                 Multiply right vectors bidiagonalizing L by Q in A
*                 (Workspace: need 3*M+N, prefer 3*M+N*NB)
*
                  CALL DORMBR( 'P', 'L', 'T', M, N, M, U, LDU,
     $                         WORK( ITAUP ), A, LDA, WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
*
*                 Generate left vectors bidiagonalizing L in U
*                 (Workspace: need 4*M, prefer 3*M+M*NB)
*
                  CALL DORGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + M
*
*                 Perform bidiagonal QR iteration, computing left
*                 singular vectors of A in U and computing right
*                 singular vectors of A in A
*                 (Workspace: need BDSPAC)
*
                  CALL DBDSQR( 'U', M, N, M, 0, S, WORK( IE ), A, LDA,
     $                         U, LDU, DUM, 1, WORK( IWORK ), INFO )
*
               END IF
*
            ELSE IF( WNTVS ) THEN
*
               IF( WNTUN ) THEN
*
*                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
*                 M right singular vectors to be computed in VT and
*                 no left singular vectors to be computed
*
                  IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
*
*                       WORK(IR) is LDA by M
*
                        LDWRKR = LDA
                     ELSE
*
*                       WORK(IR) is M by M
*
                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
*
*                    Compute A=L*Q
*                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy L to WORK(IR), zeroing out above it
*
                     CALL DLACPY( 'L', M, M, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO,
     $                            WORK( IR+LDWRKR ), LDWRKR )
*
*                    Generate Q in A
*                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*
                     CALL DORGLQ( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Bidiagonalize L in WORK(IR)
*                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate right vectors bidiagonalizing L in
*                    WORK(IR)
*                    (Workspace: need M*M+4*M, prefer M*M+3*M+(M-1)*NB)
*
                     CALL DORGBR( 'P', M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing right
*                    singular vectors of L in WORK(IR)
*                    (Workspace: need M*M+BDSPAC)
*
                     CALL DBDSQR( 'U', M, M, 0, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, DUM, 1, DUM, 1,
     $                            WORK( IWORK ), INFO )
*
*                    Multiply right singular vectors of L in WORK(IR) by
*                    Q in A, storing result in VT
*                    (Workspace: need M*M)
*
                     CALL DGEMM( 'N', 'N', M, N, M, ONE, WORK( IR ),
     $                           LDWRKR, A, LDA, ZERO, VT, LDVT )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + M
*
*                    Compute A=L*Q
*                    (Workspace: need 2*M, prefer M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy result to VT
*
                     CALL DLACPY( 'U', M, N, A, LDA, VT, LDVT )
*
*                    Generate Q in VT
*                    (Workspace: need 2*M, prefer M+M*NB)
*
                     CALL DORGLQ( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Zero out above L in A
*
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
*
*                    Bidiagonalize L in A
*                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply right vectors bidiagonalizing L by Q in VT
*                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
*
                     CALL DORMBR( 'P', 'L', 'T', M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing right
*                    singular vectors of A in VT
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', M, N, 0, 0, S, WORK( IE ), VT,
     $                            LDVT, DUM, 1, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               ELSE IF( WNTUO ) THEN
*
*                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
*                 M right singular vectors to be computed in VT and
*                 M left singular vectors to be overwritten on A
*
                  IF( LWORK.GE.2*M*M+MAX( 4*M, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*M ) THEN
*
*                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
*
                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+M )*M ) THEN
*
*                       WORK(IU) is LDA by M and WORK(IR) is M by M
*
                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     ELSE
*
*                       WORK(IU) is M by M and WORK(IR) is M by M
*
                        LDWRKU = M
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
*
*                    Compute A=L*Q
*                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy L to WORK(IU), zeroing out below it
*
                     CALL DLACPY( 'L', M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
*
*                    Generate Q in A
*                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
*
                     CALL DORGLQ( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Bidiagonalize L in WORK(IU), copying result to
*                    WORK(IR)
*                    (Workspace: need 2*M*M+4*M,
*                                prefer 2*M*M+3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, M, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
*
*                    Generate right bidiagonalizing vectors in WORK(IU)
*                    (Workspace: need 2*M*M+4*M-1,
*                                prefer 2*M*M+3*M+(M-1)*NB)
*
                     CALL DORGBR( 'P', M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate left bidiagonalizing vectors in WORK(IR)
*                    (Workspace: need 2*M*M+4*M, prefer 2*M*M+3*M+M*NB)
*
                     CALL DORGBR( 'Q', M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of L in WORK(IR) and computing
*                    right singular vectors of L in WORK(IU)
*                    (Workspace: need 2*M*M+BDSPAC)
*
                     CALL DBDSQR( 'U', M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, WORK( IR ),
     $                            LDWRKR, DUM, 1, WORK( IWORK ), INFO )
*
*                    Multiply right singular vectors of L in WORK(IU) by
*                    Q in A, storing result in VT
*                    (Workspace: need M*M)
*
                     CALL DGEMM( 'N', 'N', M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, A, LDA, ZERO, VT, LDVT )
*
*                    Copy left singular vectors of L to A
*                    (Workspace: need M*M)
*
                     CALL DLACPY( 'F', M, M, WORK( IR ), LDWRKR, A,
     $                            LDA )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + M
*
*                    Compute A=L*Q, copying result to VT
*                    (Workspace: need 2*M, prefer M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', M, N, A, LDA, VT, LDVT )
*
*                    Generate Q in VT
*                    (Workspace: need 2*M, prefer M+M*NB)
*
                     CALL DORGLQ( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Zero out above L in A
*
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
*
*                    Bidiagonalize L in A
*                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply right vectors bidiagonalizing L by Q in VT
*                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
*
                     CALL DORMBR( 'P', 'L', 'T', M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Generate left bidiagonalizing vectors of L in A
*                    (Workspace: need 4*M, prefer 3*M+M*NB)
*
                     CALL DORGBR( 'Q', M, M, M, A, LDA, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, compute left
*                    singular vectors of A in A and compute right
*                    singular vectors of A in VT
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, A, LDA, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               ELSE IF( WNTUAS ) THEN
*
*                 Path 6t(N much larger than M, JOBU='S' or 'A',
*                         JOBVT='S')
*                 M right singular vectors to be computed in VT and
*                 M left singular vectors to be computed in U
*
                  IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
*
*                       WORK(IU) is LDA by N
*
                        LDWRKU = LDA
                     ELSE
*
*                       WORK(IU) is LDA by M
*
                        LDWRKU = M
                     END IF
                     ITAU = IU + LDWRKU*M
                     IWORK = ITAU + M
*
*                    Compute A=L*Q
*                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy L to WORK(IU), zeroing out above it
*
                     CALL DLACPY( 'L', M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
*
*                    Generate Q in A
*                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*
                     CALL DORGLQ( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Bidiagonalize L in WORK(IU), copying result to U
*                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, M, WORK( IU ), LDWRKU, U,
     $                            LDU )
*
*                    Generate right bidiagonalizing vectors in WORK(IU)
*                    (Workspace: need M*M+4*M-1,
*                                prefer M*M+3*M+(M-1)*NB)
*
                     CALL DORGBR( 'P', M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate left bidiagonalizing vectors in U
*                    (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
*
                     CALL DORGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of L in U and computing right
*                    singular vectors of L in WORK(IU)
*                    (Workspace: need M*M+BDSPAC)
*
                     CALL DBDSQR( 'U', M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, U, LDU, DUM, 1,
     $                            WORK( IWORK ), INFO )
*
*                    Multiply right singular vectors of L in WORK(IU) by
*                    Q in A, storing result in VT
*                    (Workspace: need M*M)
*
                     CALL DGEMM( 'N', 'N', M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, A, LDA, ZERO, VT, LDVT )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + M
*
*                    Compute A=L*Q, copying result to VT
*                    (Workspace: need 2*M, prefer M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', M, N, A, LDA, VT, LDVT )
*
*                    Generate Q in VT
*                    (Workspace: need 2*M, prefer M+M*NB)
*
                     CALL DORGLQ( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy L to U, zeroing out above it
*
                     CALL DLACPY( 'L', M, M, A, LDA, U, LDU )
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                            LDU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Bidiagonalize L in U
*                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, U, LDU, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply right bidiagonalizing vectors in U by Q
*                    in VT
*                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
*
                     CALL DORMBR( 'P', 'L', 'T', M, N, M, U, LDU,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Generate left bidiagonalizing vectors in U
*                    (Workspace: need 4*M, prefer 3*M+M*NB)
*
                     CALL DORGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of A in U and computing right
*                    singular vectors of A in VT
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               END IF
*
            ELSE IF( WNTVA ) THEN
*
               IF( WNTUN ) THEN
*
*                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
*                 N right singular vectors to be computed in VT and
*                 no left singular vectors to be computed
*
                  IF( LWORK.GE.M*M+MAX( N+M, 4*M, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
*
*                       WORK(IR) is LDA by M
*
                        LDWRKR = LDA
                     ELSE
*
*                       WORK(IR) is M by M
*
                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
*
*                    Compute A=L*Q, copying result to VT
*                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', M, N, A, LDA, VT, LDVT )
*
*                    Copy L to WORK(IR), zeroing out above it
*
                     CALL DLACPY( 'L', M, M, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO,
     $                            WORK( IR+LDWRKR ), LDWRKR )
*
*                    Generate Q in VT
*                    (Workspace: need M*M+M+N, prefer M*M+M+N*NB)
*
                     CALL DORGLQ( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Bidiagonalize L in WORK(IR)
*                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate right bidiagonalizing vectors in WORK(IR)
*                    (Workspace: need M*M+4*M-1,
*                                prefer M*M+3*M+(M-1)*NB)
*
                     CALL DORGBR( 'P', M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing right
*                    singular vectors of L in WORK(IR)
*                    (Workspace: need M*M+BDSPAC)
*
                     CALL DBDSQR( 'U', M, M, 0, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, DUM, 1, DUM, 1,
     $                            WORK( IWORK ), INFO )
*
*                    Multiply right singular vectors of L in WORK(IR) by
*                    Q in VT, storing result in A
*                    (Workspace: need M*M)
*
                     CALL DGEMM( 'N', 'N', M, N, M, ONE, WORK( IR ),
     $                           LDWRKR, VT, LDVT, ZERO, A, LDA )
*
*                    Copy right singular vectors of A from A to VT
*
                     CALL DLACPY( 'F', M, N, A, LDA, VT, LDVT )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + M
*
*                    Compute A=L*Q, copying result to VT
*                    (Workspace: need 2*M, prefer M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', M, N, A, LDA, VT, LDVT )
*
*                    Generate Q in VT
*                    (Workspace: need M+N, prefer M+N*NB)
*
                     CALL DORGLQ( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Zero out above L in A
*
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
*
*                    Bidiagonalize L in A
*                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply right bidiagonalizing vectors in A by Q
*                    in VT
*                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
*
                     CALL DORMBR( 'P', 'L', 'T', M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing right
*                    singular vectors of A in VT
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', M, N, 0, 0, S, WORK( IE ), VT,
     $                            LDVT, DUM, 1, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               ELSE IF( WNTUO ) THEN
*
*                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
*                 N right singular vectors to be computed in VT and
*                 M left singular vectors to be overwritten on A
*
                  IF( LWORK.GE.2*M*M+MAX( N+M, 4*M, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*M ) THEN
*
*                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
*
                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+M )*M ) THEN
*
*                       WORK(IU) is LDA by M and WORK(IR) is M by M
*
                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     ELSE
*
*                       WORK(IU) is M by M and WORK(IR) is M by M
*
                        LDWRKU = M
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
*
*                    Compute A=L*Q, copying result to VT
*                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', M, N, A, LDA, VT, LDVT )
*
*                    Generate Q in VT
*                    (Workspace: need 2*M*M+M+N, prefer 2*M*M+M+N*NB)
*
                     CALL DORGLQ( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy L to WORK(IU), zeroing out above it
*
                     CALL DLACPY( 'L', M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Bidiagonalize L in WORK(IU), copying result to
*                    WORK(IR)
*                    (Workspace: need 2*M*M+4*M,
*                                prefer 2*M*M+3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, M, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
*
*                    Generate right bidiagonalizing vectors in WORK(IU)
*                    (Workspace: need 2*M*M+4*M-1,
*                                prefer 2*M*M+3*M+(M-1)*NB)
*
                     CALL DORGBR( 'P', M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate left bidiagonalizing vectors in WORK(IR)
*                    (Workspace: need 2*M*M+4*M, prefer 2*M*M+3*M+M*NB)
*
                     CALL DORGBR( 'Q', M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of L in WORK(IR) and computing
*                    right singular vectors of L in WORK(IU)
*                    (Workspace: need 2*M*M+BDSPAC)
*
                     CALL DBDSQR( 'U', M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, WORK( IR ),
     $                            LDWRKR, DUM, 1, WORK( IWORK ), INFO )
*
*                    Multiply right singular vectors of L in WORK(IU) by
*                    Q in VT, storing result in A
*                    (Workspace: need M*M)
*
                     CALL DGEMM( 'N', 'N', M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, VT, LDVT, ZERO, A, LDA )
*
*                    Copy right singular vectors of A from A to VT
*
                     CALL DLACPY( 'F', M, N, A, LDA, VT, LDVT )
*
*                    Copy left singular vectors of A from WORK(IR) to A
*
                     CALL DLACPY( 'F', M, M, WORK( IR ), LDWRKR, A,
     $                            LDA )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + M
*
*                    Compute A=L*Q, copying result to VT
*                    (Workspace: need 2*M, prefer M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', M, N, A, LDA, VT, LDVT )
*
*                    Generate Q in VT
*                    (Workspace: need M+N, prefer M+N*NB)
*
                     CALL DORGLQ( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Zero out above L in A
*
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
*
*                    Bidiagonalize L in A
*                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply right bidiagonalizing vectors in A by Q
*                    in VT
*                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
*
                     CALL DORMBR( 'P', 'L', 'T', M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Generate left bidiagonalizing vectors in A
*                    (Workspace: need 4*M, prefer 3*M+M*NB)
*
                     CALL DORGBR( 'Q', M, M, M, A, LDA, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of A in A and computing right
*                    singular vectors of A in VT
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, A, LDA, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               ELSE IF( WNTUAS ) THEN
*
*                 Path 9t(N much larger than M, JOBU='S' or 'A',
*                         JOBVT='A')
*                 N right singular vectors to be computed in VT and
*                 M left singular vectors to be computed in U
*
                  IF( LWORK.GE.M*M+MAX( N+M, 4*M, BDSPAC ) ) THEN
*
*                    Sufficient workspace for a fast algorithm
*
                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
*
*                       WORK(IU) is LDA by M
*
                        LDWRKU = LDA
                     ELSE
*
*                       WORK(IU) is M by M
*
                        LDWRKU = M
                     END IF
                     ITAU = IU + LDWRKU*M
                     IWORK = ITAU + M
*
*                    Compute A=L*Q, copying result to VT
*                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', M, N, A, LDA, VT, LDVT )
*
*                    Generate Q in VT
*                    (Workspace: need M*M+M+N, prefer M*M+M+N*NB)
*
                     CALL DORGLQ( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy L to WORK(IU), zeroing out above it
*
                     CALL DLACPY( 'L', M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Bidiagonalize L in WORK(IU), copying result to U
*                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'L', M, M, WORK( IU ), LDWRKU, U,
     $                            LDU )
*
*                    Generate right bidiagonalizing vectors in WORK(IU)
*                    (Workspace: need M*M+4*M, prefer M*M+3*M+(M-1)*NB)
*
                     CALL DORGBR( 'P', M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
*
*                    Generate left bidiagonalizing vectors in U
*                    (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
*
                     CALL DORGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of L in U and computing right
*                    singular vectors of L in WORK(IU)
*                    (Workspace: need M*M+BDSPAC)
*
                     CALL DBDSQR( 'U', M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, U, LDU, DUM, 1,
     $                            WORK( IWORK ), INFO )
*
*                    Multiply right singular vectors of L in WORK(IU) by
*                    Q in VT, storing result in A
*                    (Workspace: need M*M)
*
                     CALL DGEMM( 'N', 'N', M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, VT, LDVT, ZERO, A, LDA )
*
*                    Copy right singular vectors of A from A to VT
*
                     CALL DLACPY( 'F', M, N, A, LDA, VT, LDVT )
*
                  ELSE
*
*                    Insufficient workspace for a fast algorithm
*
                     ITAU = 1
                     IWORK = ITAU + M
*
*                    Compute A=L*Q, copying result to VT
*                    (Workspace: need 2*M, prefer M+M*NB)
*
                     CALL DGELQF( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL DLACPY( 'U', M, N, A, LDA, VT, LDVT )
*
*                    Generate Q in VT
*                    (Workspace: need M+N, prefer M+N*NB)
*
                     CALL DORGLQ( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Copy L to U, zeroing out above it
*
                     CALL DLACPY( 'L', M, M, A, LDA, U, LDU )
                     CALL DLASET( 'U', M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                            LDU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
*
*                    Bidiagonalize L in U
*                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
*
                     CALL DGEBRD( M, M, U, LDU, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Multiply right bidiagonalizing vectors in U by Q
*                    in VT
*                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
*
                     CALL DORMBR( 'P', 'L', 'T', M, N, M, U, LDU,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
*
*                    Generate left bidiagonalizing vectors in U
*                    (Workspace: need 4*M, prefer 3*M+M*NB)
*
                     CALL DORGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
*
*                    Perform bidiagonal QR iteration, computing left
*                    singular vectors of A in U and computing right
*                    singular vectors of A in VT
*                    (Workspace: need BDSPAC)
*
                     CALL DBDSQR( 'U', M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
*
                  END IF
*
               END IF
*
            END IF
*
         ELSE
*
*           N .LT. MNTHR
*
*           Path 10t(N greater than M, but not much larger)
*           Reduce to bidiagonal form without LQ decomposition
*
            IE = 1
            ITAUQ = IE + M
            ITAUP = ITAUQ + M
            IWORK = ITAUP + M
*
*           Bidiagonalize A
*           (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
*
            CALL DGEBRD( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                   IERR )
            IF( WNTUAS ) THEN
*
*              If left singular vectors desired in U, copy result to U
*              and generate left bidiagonalizing vectors in U
*              (Workspace: need 4*M-1, prefer 3*M+(M-1)*NB)
*
               CALL DLACPY( 'L', M, M, A, LDA, U, LDU )
               CALL DORGBR( 'Q', M, M, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVAS ) THEN
*
*              If right singular vectors desired in VT, copy result to
*              VT and generate right bidiagonalizing vectors in VT
*              (Workspace: need 3*M+NRVT, prefer 3*M+NRVT*NB)
*
               CALL DLACPY( 'U', M, N, A, LDA, VT, LDVT )
               IF( WNTVA )
     $            NRVT = N
               IF( WNTVS )
     $            NRVT = M
               CALL DORGBR( 'P', NRVT, N, M, VT, LDVT, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTUO ) THEN
*
*              If left singular vectors desired in A, generate left
*              bidiagonalizing vectors in A
*              (Workspace: need 4*M-1, prefer 3*M+(M-1)*NB)
*
               CALL DORGBR( 'Q', M, M, N, A, LDA, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVO ) THEN
*
*              If right singular vectors desired in A, generate right
*              bidiagonalizing vectors in A
*              (Workspace: need 4*M, prefer 3*M+M*NB)
*
               CALL DORGBR( 'P', M, N, M, A, LDA, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IWORK = IE + M
            IF( WNTUAS .OR. WNTUO )
     $         NRU = M
            IF( WNTUN )
     $         NRU = 0
            IF( WNTVAS .OR. WNTVO )
     $         NCVT = N
            IF( WNTVN )
     $         NCVT = 0
            IF( ( .NOT.WNTUO ) .AND. ( .NOT.WNTVO ) ) THEN
*
*              Perform bidiagonal QR iteration, if desired, computing
*              left singular vectors in U and computing right singular
*              vectors in VT
*              (Workspace: need BDSPAC)
*
               CALL DBDSQR( 'L', M, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE IF( ( .NOT.WNTUO ) .AND. WNTVO ) THEN
*
*              Perform bidiagonal QR iteration, if desired, computing
*              left singular vectors in U and computing right singular
*              vectors in A
*              (Workspace: need BDSPAC)
*
               CALL DBDSQR( 'L', M, NCVT, NRU, 0, S, WORK( IE ), A, LDA,
     $                      U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE
*
*              Perform bidiagonal QR iteration, if desired, computing
*              left singular vectors in A and computing right singular
*              vectors in VT
*              (Workspace: need BDSPAC)
*
               CALL DBDSQR( 'L', M, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, A, LDA, DUM, 1, WORK( IWORK ), INFO )
            END IF
*
         END IF
*
      END IF
*
*     If DBDSQR failed to converge, copy unconverged superdiagonals
*     to WORK( 2:MINMN )
*
      IF( INFO.NE.0 ) THEN
         IF( IE.GT.2 ) THEN
            DO 50 I = 1, MINMN - 1
               WORK( I+1 ) = WORK( I+IE-1 )
   50       CONTINUE
         END IF
         IF( IE.LT.2 ) THEN
            DO 60 I = MINMN - 1, 1, -1
               WORK( I+1 ) = WORK( I+IE-1 )
   60       CONTINUE
         END IF
      END IF
*
*     Undo scaling if necessary
*
      IF( ISCL.EQ.1 ) THEN
         IF( ANRM.GT.BIGNUM )
     $      CALL DLASCL( 'G', 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( INFO.NE.0 .AND. ANRM.GT.BIGNUM )
     $      CALL DLASCL( 'G', 0, 0, BIGNUM, ANRM, MINMN-1, 1, WORK( 2 ),
     $                   MINMN, IERR )
         IF( ANRM.LT.SMLNUM )
     $      CALL DLASCL( 'G', 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( INFO.NE.0 .AND. ANRM.LT.SMLNUM )
     $      CALL DLASCL( 'G', 0, 0, SMLNUM, ANRM, MINMN-1, 1, WORK( 2 ),
     $                   MINMN, IERR )
      END IF
*
*     Return optimal workspace in WORK(1)
*
      WORK( 1 ) = MAXWRK
*
      RETURN
*
*     End of DGESVD
*
      END
C
C=======================================================================
C=======================================================================
C
C FILE NAME = wspher14_lapac2_15.f ! Keep this symbol:    $ident@string$
C
C=======================================================================
C=======================================================================
C                SINGULAR-VALUE DECOMPOSITION PACKAGE
C=======================================================================
C=======================================================================
C
      SUBROUTINE DBDSQR( UPLO, N, NCVT, NRU, NCC, D, E, VT, LDVT, U,
     $                   LDU, C, LDC, WORK, INFO )
*
*  -- LAPACK routine (version 3.1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     January 2007
*
*     .. Scalar Arguments ..
      CHARACTER          UPLO
      INTEGER            INFO, LDC, LDU, LDVT, N, NCC, NCVT, NRU
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   C( LDC, * ), D( * ), E( * ), U( LDU, * ),
CID     $                   VT( LDVT, * ), WORK( * )
      DIMENSION   C( LDC, * ), D( * ), E( * ), U( LDU, * ),
     $                   VT( LDVT, * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DBDSQR computes the singular values and, optionally, the right and/or
*  left singular vectors from the singular value decomposition (SVD) of
*  a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
*  zero-shift QR algorithm.  The SVD of B has the form
* 
*     B = Q * S * P**T
* 
*  where S is the diagonal matrix of singular values, Q is an orthogonal
*  matrix of left singular vectors, and P is an orthogonal matrix of
*  right singular vectors.  If left singular vectors are requested, this
*  subroutine actually returns U*Q instead of Q, and, if right singular
*  vectors are requested, this subroutine returns P**T*VT instead of
*  P**T, for given real input matrices U and VT.  When U and VT are the
*  orthogonal matrices that reduce a general matrix A to bidiagonal
*  form:  A = U*B*VT, as computed by DGEBRD, then
*
*     A = (U*Q) * S * (P**T*VT)
*
*  is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
*  for a given real input matrix C.
*
*  See "Computing  Small Singular Values of Bidiagonal Matrices With
*  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
*  LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
*  no. 5, pp. 873-912, Sept 1990) and
*  "Accurate singular values and differential qd algorithms," by
*  B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
*  Department, University of California at Berkeley, July 1992
*  for a detailed description of the algorithm.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          = 'U':  B is upper bidiagonal;
*          = 'L':  B is lower bidiagonal.
*
*  N       (input) INTEGER
*          The order of the matrix B.  N >= 0.
*
*  NCVT    (input) INTEGER
*          The number of columns of the matrix VT. NCVT >= 0.
*
*  NRU     (input) INTEGER
*          The number of rows of the matrix U. NRU >= 0.
*
*  NCC     (input) INTEGER
*          The number of columns of the matrix C. NCC >= 0.
*
*  D       (input/output) DOUBLE PRECISION array, dimension (N)
*          On entry, the n diagonal elements of the bidiagonal matrix B.
*          On exit, if INFO=0, the singular values of B in decreasing
*          order.
*
*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
*          On entry, the N-1 offdiagonal elements of the bidiagonal
*          matrix B. 
*          On exit, if INFO = 0, E is destroyed; if INFO > 0, D and E
*          will contain the diagonal and superdiagonal elements of a
*          bidiagonal matrix orthogonally equivalent to the one given
*          as input.
*
*  VT      (input/output) DOUBLE PRECISION array, dimension (LDVT, NCVT)
*          On entry, an N-by-NCVT matrix VT.
*          On exit, VT is overwritten by P**T * VT.
*          Not referenced if NCVT = 0.
*
*  LDVT    (input) INTEGER
*          The leading dimension of the array VT.
*          LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.
*
*  U       (input/output) DOUBLE PRECISION array, dimension (LDU, N)
*          On entry, an NRU-by-N matrix U.
*          On exit, U is overwritten by U * Q.
*          Not referenced if NRU = 0.
*
*  LDU     (input) INTEGER
*          The leading dimension of the array U.  LDU >= max(1,NRU).
*
*  C       (input/output) DOUBLE PRECISION array, dimension (LDC, NCC)
*          On entry, an N-by-NCC matrix C.
*          On exit, C is overwritten by Q**T * C.
*          Not referenced if NCC = 0.
*
*  LDC     (input) INTEGER
*          The leading dimension of the array C.
*          LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*N)
*          if NCVT = NRU = NCC = 0, (max(1, 4*N)) otherwise
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  If INFO = -i, the i-th argument had an illegal value
*          > 0:  the algorithm did not converge; D and E contain the
*                elements of a bidiagonal matrix which is orthogonally
*                similar to the input matrix B;  if INFO = i, i
*                elements of E have not converged to zero.
*
*  Internal Parameters
*  ===================
*
*  TOLMUL  DOUBLE PRECISION, default = max(10,min(100,EPS**(-1/8)))
*          TOLMUL controls the convergence criterion of the QR loop.
*          If it is positive, TOLMUL*EPS is the desired relative
*             precision in the computed singular values.
*          If it is negative, abs(TOLMUL*EPS*sigma_max) is the
*             desired absolute accuracy in the computed singular
*             values (corresponds to relative accuracy
*             abs(TOLMUL*EPS) in the largest singular value.
*          abs(TOLMUL) should be between 1 and 1/EPS, and preferably
*             between 10 (for fast convergence) and .1/EPS
*             (for there to be some accuracy in the results).
*          Default is to lose at either one eighth or 2 of the
*             available decimal digits in each computed singular value
*             (whichever is smaller).
*
*  MAXITR  INTEGER, default = 6
*          MAXITR controls the maximum number of passes of the
*          algorithm through its inner loop. The algorithms stops
*          (and so fails to converge) if the number of passes
*          through the inner loop exceeds MAXITR*N**2.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D0 )
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D0 )
CID      DOUBLE PRECISION   NEGONE
      REAL                 NEGONE
      PARAMETER          ( NEGONE = -1.0D0 )
CID      DOUBLE PRECISION   HNDRTH
      PARAMETER          ( HNDRTH = 0.01D0 )
CID      DOUBLE PRECISION   TEN
      PARAMETER          ( TEN = 10.0D0 )
CID      DOUBLE PRECISION   HNDRD
      PARAMETER          ( HNDRD = 100.0D0 )
CID      DOUBLE PRECISION   MEIGTH
      REAL                 MEIGTH
      PARAMETER          ( MEIGTH = -0.125D0 )
      INTEGER            MAXITR
      PARAMETER          ( MAXITR = 6 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LOWER, ROTATE
      REAL               MU
      INTEGER            I, IDIR, ISUB, ITER, J, LL, LLL, M, MAXIT, NM1,
     $                   NM12, NM13, OLDLL, OLDM
CID      DOUBLE PRECISION   ABSE, ABSS, COSL, COSR, CS, EPS, F, G, H, MU,
CID     $                   OLDCS, OLDSN, R, SHIFT, SIGMN, SIGMX, SINL,
CID     $                   SINR, SLL, SMAX, SMIN, SMINL, SMINOA,
CID     $                   SN, THRESH, TOL, TOLMUL, UNFL
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
CID      DOUBLE PRECISION   DLAMCH
      EXTERNAL           LSAME, DLAMCH
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARTG, DLAS2, DLASQ1, DLASR, DLASV2, DROT,
     $                   DSCAL, DSWAP, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, DBLE, MAX, MIN, SIGN, SQRT
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      LOWER = LSAME( UPLO, 'L' )
      IF( .NOT.LSAME( UPLO, 'U' ) .AND. .NOT.LOWER ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NCVT.LT.0 ) THEN
         INFO = -3
      ELSE IF( NRU.LT.0 ) THEN
         INFO = -4
      ELSE IF( NCC.LT.0 ) THEN
         INFO = -5
      ELSE IF( ( NCVT.EQ.0 .AND. LDVT.LT.1 ) .OR.
     $         ( NCVT.GT.0 .AND. LDVT.LT.MAX( 1, N ) ) ) THEN
         INFO = -9
      ELSE IF( LDU.LT.MAX( 1, NRU ) ) THEN
         INFO = -11
      ELSE IF( ( NCC.EQ.0 .AND. LDC.LT.1 ) .OR.
     $         ( NCC.GT.0 .AND. LDC.LT.MAX( 1, N ) ) ) THEN
         INFO = -13
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DBDSQR', -INFO )
         RETURN
      END IF
      IF( N.EQ.0 )
     $   RETURN
      IF( N.EQ.1 )
     $   GO TO 160
*
*     ROTATE is true if any singular vectors desired, false otherwise
*
      ROTATE = ( NCVT.GT.0 ) .OR. ( NRU.GT.0 ) .OR. ( NCC.GT.0 )
*
*     If no singular vectors desired, use qd algorithm
*
      IF( .NOT.ROTATE ) THEN
         CALL DLASQ1( N, D, E, WORK, INFO )
         RETURN
      END IF
*
      NM1 = N - 1
      NM12 = NM1 + NM1
      NM13 = NM12 + NM1
      IDIR = 0
*
*     Get machine constants
*
      EPS = DLAMCH( 'Epsilon' )
      UNFL = DLAMCH( 'Safe minimum' )
*
*     If matrix lower bidiagonal, rotate to be upper bidiagonal
*     by applying Givens rotations on the left
*
      IF( LOWER ) THEN
         DO 10 I = 1, N - 1
            CALL DLARTG( D( I ), E( I ), CS, SN, R )
            D( I ) = R
            E( I ) = SN*D( I+1 )
            D( I+1 ) = CS*D( I+1 )
            WORK( I ) = CS
            WORK( NM1+I ) = SN
   10    CONTINUE
*
*        Update singular vectors if desired
*
         IF( NRU.GT.0 )
     $      CALL DLASR( 'R', 'V', 'F', NRU, N, WORK( 1 ), WORK( N ), U,
     $                  LDU )
         IF( NCC.GT.0 )
     $      CALL DLASR( 'L', 'V', 'F', N, NCC, WORK( 1 ), WORK( N ), C,
     $                  LDC )
      END IF
*
*     Compute singular values to relative accuracy TOL
*     (By setting TOL to be negative, algorithm will compute
*     singular values to absolute accuracy ABS(TOL)*norm(input matrix))
*
      TOLMUL = MAX( TEN, MIN( HNDRD, EPS**MEIGTH ) )
      TOL = TOLMUL*EPS
*
*     Compute approximate maximum, minimum singular values
*
      SMAX = ZERO
      DO 20 I = 1, N
         SMAX = MAX( SMAX, ABS( D( I ) ) )
   20 CONTINUE
      DO 30 I = 1, N - 1
         SMAX = MAX( SMAX, ABS( E( I ) ) )
   30 CONTINUE
      SMINL = ZERO
      IF( TOL.GE.ZERO ) THEN
*
*        Relative accuracy desired
*
         SMINOA = ABS( D( 1 ) )
         IF( SMINOA.EQ.ZERO )
     $      GO TO 50
         MU = SMINOA
         DO 40 I = 2, N
            MU = ABS( D( I ) )*( MU / ( MU+ABS( E( I-1 ) ) ) )
            SMINOA = MIN( SMINOA, MU )
            IF( SMINOA.EQ.ZERO )
     $         GO TO 50
   40    CONTINUE
   50    CONTINUE
         SMINOA = SMINOA / SQRT( DBLE( N ) )
         THRESH = MAX( TOL*SMINOA, MAXITR*N*N*UNFL )
      ELSE
*
*        Absolute accuracy desired
*
         THRESH = MAX( ABS( TOL )*SMAX, MAXITR*N*N*UNFL )
      END IF
*
*     Prepare for main iteration loop for the singular values
*     (MAXIT is the maximum number of passes through the inner
*     loop permitted before nonconvergence signalled.)
*
      MAXIT = MAXITR*N*N
      ITER = 0
      OLDLL = -1
      OLDM = -1
*
*     M points to last element of unconverged part of matrix
*
      M = N
*
*     Begin main iteration loop
*
   60 CONTINUE
*
*     Check for convergence or exceeding iteration count
*
      IF( M.LE.1 )
     $   GO TO 160
      IF( ITER.GT.MAXIT )
     $   GO TO 200
*
*     Find diagonal block of matrix to work on
*
      IF( TOL.LT.ZERO .AND. ABS( D( M ) ).LE.THRESH )
     $   D( M ) = ZERO
      SMAX = ABS( D( M ) )
      SMIN = SMAX
      DO 70 LLL = 1, M - 1
         LL = M - LLL
         ABSS = ABS( D( LL ) )
         ABSE = ABS( E( LL ) )
         IF( TOL.LT.ZERO .AND. ABSS.LE.THRESH )
     $      D( LL ) = ZERO
         IF( ABSE.LE.THRESH )
     $      GO TO 80
         SMIN = MIN( SMIN, ABSS )
         SMAX = MAX( SMAX, ABSS, ABSE )
   70 CONTINUE
      LL = 0
      GO TO 90
   80 CONTINUE
      E( LL ) = ZERO
*
*     Matrix splits since E(LL) = 0
*
      IF( LL.EQ.M-1 ) THEN
*
*        Convergence of bottom singular value, return to top of loop
*
         M = M - 1
         GO TO 60
      END IF
   90 CONTINUE
      LL = LL + 1
*
*     E(LL) through E(M-1) are nonzero, E(LL-1) is zero
*
      IF( LL.EQ.M-1 ) THEN
*
*        2 by 2 block, handle separately
*
         CALL DLASV2( D( M-1 ), E( M-1 ), D( M ), SIGMN, SIGMX, SINR,
     $                COSR, SINL, COSL )
         D( M-1 ) = SIGMX
         E( M-1 ) = ZERO
         D( M ) = SIGMN
*
*        Compute singular vectors, if desired
*
         IF( NCVT.GT.0 )
     $      CALL DROT( NCVT, VT( M-1, 1 ), LDVT, VT( M, 1 ), LDVT, COSR,
     $                 SINR )
         IF( NRU.GT.0 )
     $      CALL DROT( NRU, U( 1, M-1 ), 1, U( 1, M ), 1, COSL, SINL )
         IF( NCC.GT.0 )
     $      CALL DROT( NCC, C( M-1, 1 ), LDC, C( M, 1 ), LDC, COSL,
     $                 SINL )
         M = M - 2
         GO TO 60
      END IF
*
*     If working on new submatrix, choose shift direction
*     (from larger end diagonal element towards smaller)
*
      IF( LL.GT.OLDM .OR. M.LT.OLDLL ) THEN
         IF( ABS( D( LL ) ).GE.ABS( D( M ) ) ) THEN
*
*           Chase bulge from top (big end) to bottom (small end)
*
            IDIR = 1
         ELSE
*
*           Chase bulge from bottom (big end) to top (small end)
*
            IDIR = 2
         END IF
      END IF
*
*     Apply convergence tests
*
      IF( IDIR.EQ.1 ) THEN
*
*        Run convergence test in forward direction
*        First apply standard test to bottom of matrix
*
         IF( ABS( E( M-1 ) ).LE.ABS( TOL )*ABS( D( M ) ) .OR.
     $       ( TOL.LT.ZERO .AND. ABS( E( M-1 ) ).LE.THRESH ) ) THEN
            E( M-1 ) = ZERO
            GO TO 60
         END IF
*
         IF( TOL.GE.ZERO ) THEN
*
*           If relative accuracy desired,
*           apply convergence criterion forward
*
            MU = ABS( D( LL ) )
            SMINL = MU
            DO 100 LLL = LL, M - 1
               IF( ABS( E( LLL ) ).LE.TOL*MU ) THEN
                  E( LLL ) = ZERO
                  GO TO 60
               END IF
               MU = ABS( D( LLL+1 ) )*( MU / ( MU+ABS( E( LLL ) ) ) )
               SMINL = MIN( SMINL, MU )
  100       CONTINUE
         END IF
*
      ELSE
*
*        Run convergence test in backward direction
*        First apply standard test to top of matrix
*
         IF( ABS( E( LL ) ).LE.ABS( TOL )*ABS( D( LL ) ) .OR.
     $       ( TOL.LT.ZERO .AND. ABS( E( LL ) ).LE.THRESH ) ) THEN
            E( LL ) = ZERO
            GO TO 60
         END IF
*
         IF( TOL.GE.ZERO ) THEN
*
*           If relative accuracy desired,
*           apply convergence criterion backward
*
            MU = ABS( D( M ) )
            SMINL = MU
            DO 110 LLL = M - 1, LL, -1
               IF( ABS( E( LLL ) ).LE.TOL*MU ) THEN
                  E( LLL ) = ZERO
                  GO TO 60
               END IF
               MU = ABS( D( LLL ) )*( MU / ( MU+ABS( E( LLL ) ) ) )
               SMINL = MIN( SMINL, MU )
  110       CONTINUE
         END IF
      END IF
      OLDLL = LL
      OLDM = M
*
*     Compute shift.  First, test if shifting would ruin relative
*     accuracy, and if so set the shift to zero.
*
      IF( TOL.GE.ZERO .AND. N*TOL*( SMINL / SMAX ).LE.
     $    MAX( EPS, HNDRTH*TOL ) ) THEN
*
*        Use a zero shift to avoid loss of relative accuracy
*
         SHIFT = ZERO
      ELSE
*
*        Compute the shift from 2-by-2 block at end of matrix
*
         IF( IDIR.EQ.1 ) THEN
            SLL = ABS( D( LL ) )
            CALL DLAS2( D( M-1 ), E( M-1 ), D( M ), SHIFT, R )
         ELSE
            SLL = ABS( D( M ) )
            CALL DLAS2( D( LL ), E( LL ), D( LL+1 ), SHIFT, R )
         END IF
*
*        Test if shift negligible, and if so set to zero
*
         IF( SLL.GT.ZERO ) THEN
            IF( ( SHIFT / SLL )**2.LT.EPS )
     $         SHIFT = ZERO
         END IF
      END IF
*
*     Increment iteration count
*
      ITER = ITER + M - LL
*
*     If SHIFT = 0, do simplified QR iteration
*
      IF( SHIFT.EQ.ZERO ) THEN
         IF( IDIR.EQ.1 ) THEN
*
*           Chase bulge from top to bottom
*           Save cosines and sines for later singular vector updates
*
            CS = ONE
            OLDCS = ONE
            DO 120 I = LL, M - 1
               CALL DLARTG( D( I )*CS, E( I ), CS, SN, R )
               IF( I.GT.LL )
     $            E( I-1 ) = OLDSN*R
               CALL DLARTG( OLDCS*R, D( I+1 )*SN, OLDCS, OLDSN, D( I ) )
               WORK( I-LL+1 ) = CS
               WORK( I-LL+1+NM1 ) = SN
               WORK( I-LL+1+NM12 ) = OLDCS
               WORK( I-LL+1+NM13 ) = OLDSN
  120       CONTINUE
            H = D( M )*CS
            D( M ) = H*OLDCS
            E( M-1 ) = H*OLDSN
*
*           Update singular vectors
*
            IF( NCVT.GT.0 )
     $         CALL DLASR( 'L', 'V', 'F', M-LL+1, NCVT, WORK( 1 ),
     $                     WORK( N ), VT( LL, 1 ), LDVT )
            IF( NRU.GT.0 )
     $         CALL DLASR( 'R', 'V', 'F', NRU, M-LL+1, WORK( NM12+1 ),
     $                     WORK( NM13+1 ), U( 1, LL ), LDU )
            IF( NCC.GT.0 )
     $         CALL DLASR( 'L', 'V', 'F', M-LL+1, NCC, WORK( NM12+1 ),
     $                     WORK( NM13+1 ), C( LL, 1 ), LDC )
*
*           Test convergence
*
            IF( ABS( E( M-1 ) ).LE.THRESH )
     $         E( M-1 ) = ZERO
*
         ELSE
*
*           Chase bulge from bottom to top
*           Save cosines and sines for later singular vector updates
*
            CS = ONE
            OLDCS = ONE
            DO 130 I = M, LL + 1, -1
               CALL DLARTG( D( I )*CS, E( I-1 ), CS, SN, R )
               IF( I.LT.M )
     $            E( I ) = OLDSN*R
               CALL DLARTG( OLDCS*R, D( I-1 )*SN, OLDCS, OLDSN, D( I ) )
               WORK( I-LL ) = CS
               WORK( I-LL+NM1 ) = -SN
               WORK( I-LL+NM12 ) = OLDCS
               WORK( I-LL+NM13 ) = -OLDSN
  130       CONTINUE
            H = D( LL )*CS
            D( LL ) = H*OLDCS
            E( LL ) = H*OLDSN
*
*           Update singular vectors
*
            IF( NCVT.GT.0 )
     $         CALL DLASR( 'L', 'V', 'B', M-LL+1, NCVT, WORK( NM12+1 ),
     $                     WORK( NM13+1 ), VT( LL, 1 ), LDVT )
            IF( NRU.GT.0 )
     $         CALL DLASR( 'R', 'V', 'B', NRU, M-LL+1, WORK( 1 ),
     $                     WORK( N ), U( 1, LL ), LDU )
            IF( NCC.GT.0 )
     $         CALL DLASR( 'L', 'V', 'B', M-LL+1, NCC, WORK( 1 ),
     $                     WORK( N ), C( LL, 1 ), LDC )
*
*           Test convergence
*
            IF( ABS( E( LL ) ).LE.THRESH )
     $         E( LL ) = ZERO
         END IF
      ELSE
*
*        Use nonzero shift
*
         IF( IDIR.EQ.1 ) THEN
*
*           Chase bulge from top to bottom
*           Save cosines and sines for later singular vector updates
*
            F = ( ABS( D( LL ) )-SHIFT )*
     $          ( SIGN( ONE, D( LL ) )+SHIFT / D( LL ) )
            G = E( LL )
            DO 140 I = LL, M - 1
               CALL DLARTG( F, G, COSR, SINR, R )
               IF( I.GT.LL )
     $            E( I-1 ) = R
               F = COSR*D( I ) + SINR*E( I )
               E( I ) = COSR*E( I ) - SINR*D( I )
               G = SINR*D( I+1 )
               D( I+1 ) = COSR*D( I+1 )
               CALL DLARTG( F, G, COSL, SINL, R )
               D( I ) = R
               F = COSL*E( I ) + SINL*D( I+1 )
               D( I+1 ) = COSL*D( I+1 ) - SINL*E( I )
               IF( I.LT.M-1 ) THEN
                  G = SINL*E( I+1 )
                  E( I+1 ) = COSL*E( I+1 )
               END IF
               WORK( I-LL+1 ) = COSR
               WORK( I-LL+1+NM1 ) = SINR
               WORK( I-LL+1+NM12 ) = COSL
               WORK( I-LL+1+NM13 ) = SINL
  140       CONTINUE
            E( M-1 ) = F
*
*           Update singular vectors
*
            IF( NCVT.GT.0 )
     $         CALL DLASR( 'L', 'V', 'F', M-LL+1, NCVT, WORK( 1 ),
     $                     WORK( N ), VT( LL, 1 ), LDVT )
            IF( NRU.GT.0 )
     $         CALL DLASR( 'R', 'V', 'F', NRU, M-LL+1, WORK( NM12+1 ),
     $                     WORK( NM13+1 ), U( 1, LL ), LDU )
            IF( NCC.GT.0 )
     $         CALL DLASR( 'L', 'V', 'F', M-LL+1, NCC, WORK( NM12+1 ),
     $                     WORK( NM13+1 ), C( LL, 1 ), LDC )
*
*           Test convergence
*
            IF( ABS( E( M-1 ) ).LE.THRESH )
     $         E( M-1 ) = ZERO
*
         ELSE
*
*           Chase bulge from bottom to top
*           Save cosines and sines for later singular vector updates
*
            F = ( ABS( D( M ) )-SHIFT )*( SIGN( ONE, D( M ) )+SHIFT /
     $          D( M ) )
            G = E( M-1 )
            DO 150 I = M, LL + 1, -1
               CALL DLARTG( F, G, COSR, SINR, R )
               IF( I.LT.M )
     $            E( I ) = R
               F = COSR*D( I ) + SINR*E( I-1 )
               E( I-1 ) = COSR*E( I-1 ) - SINR*D( I )
               G = SINR*D( I-1 )
               D( I-1 ) = COSR*D( I-1 )
               CALL DLARTG( F, G, COSL, SINL, R )
               D( I ) = R
               F = COSL*E( I-1 ) + SINL*D( I-1 )
               D( I-1 ) = COSL*D( I-1 ) - SINL*E( I-1 )
               IF( I.GT.LL+1 ) THEN
                  G = SINL*E( I-2 )
                  E( I-2 ) = COSL*E( I-2 )
               END IF
               WORK( I-LL ) = COSR
               WORK( I-LL+NM1 ) = -SINR
               WORK( I-LL+NM12 ) = COSL
               WORK( I-LL+NM13 ) = -SINL
  150       CONTINUE
            E( LL ) = F
*
*           Test convergence
*
            IF( ABS( E( LL ) ).LE.THRESH )
     $         E( LL ) = ZERO
*
*           Update singular vectors if desired
*
            IF( NCVT.GT.0 )
     $         CALL DLASR( 'L', 'V', 'B', M-LL+1, NCVT, WORK( NM12+1 ),
     $                     WORK( NM13+1 ), VT( LL, 1 ), LDVT )
            IF( NRU.GT.0 )
     $         CALL DLASR( 'R', 'V', 'B', NRU, M-LL+1, WORK( 1 ),
     $                     WORK( N ), U( 1, LL ), LDU )
            IF( NCC.GT.0 )
     $         CALL DLASR( 'L', 'V', 'B', M-LL+1, NCC, WORK( 1 ),
     $                     WORK( N ), C( LL, 1 ), LDC )
         END IF
      END IF
*
*     QR iteration finished, go back and check convergence
*
      GO TO 60
*
*     All singular values converged, so make them positive
*
  160 CONTINUE
      DO 170 I = 1, N
         IF( D( I ).LT.ZERO ) THEN
            D( I ) = -D( I )
*
*           Change sign of singular vectors, if desired
*
            IF( NCVT.GT.0 )
     $         CALL DSCAL( NCVT, NEGONE, VT( I, 1 ), LDVT )
         END IF
  170 CONTINUE
*
*     Sort the singular values into decreasing order (insertion sort on
*     singular values, but only one transposition per singular vector)
*
      DO 190 I = 1, N - 1
*
*        Scan for smallest D(I)
*
         ISUB = 1
         SMIN = D( 1 )
         DO 180 J = 2, N + 1 - I
            IF( D( J ).LE.SMIN ) THEN
               ISUB = J
               SMIN = D( J )
            END IF
  180    CONTINUE
         IF( ISUB.NE.N+1-I ) THEN
*
*           Swap singular values and vectors
*
            D( ISUB ) = D( N+1-I )
            D( N+1-I ) = SMIN
            IF( NCVT.GT.0 )
     $         CALL DSWAP( NCVT, VT( ISUB, 1 ), LDVT, VT( N+1-I, 1 ),
     $                     LDVT )
            IF( NRU.GT.0 )
     $         CALL DSWAP( NRU, U( 1, ISUB ), 1, U( 1, N+1-I ), 1 )
            IF( NCC.GT.0 )
     $         CALL DSWAP( NCC, C( ISUB, 1 ), LDC, C( N+1-I, 1 ), LDC )
         END IF
  190 CONTINUE
      GO TO 220
*
*     Maximum number of iterations exceeded, failure to converge
*
  200 CONTINUE
      INFO = 0
      DO 210 I = 1, N - 1
         IF( E( I ).NE.ZERO )
     $      INFO = INFO + 1
  210 CONTINUE
  220 CONTINUE
      RETURN
*
*     End of DBDSQR
*
      END
      SUBROUTINE DGEBD2( M, N, A, LDA, D, E, TAUQ, TAUP, WORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAUP( * ),
CID     $                   TAUQ( * ), WORK( * )
      DIMENSION          A( LDA, * ), D( * ), E( * ), TAUP( * ),
     $                   TAUQ( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DGEBD2 reduces a real general m by n matrix A to upper or lower
*  bidiagonal form B by an orthogonal transformation: Q' * A * P = B.
*
*  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows in the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns in the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the m by n general matrix to be reduced.
*          On exit,
*          if m >= n, the diagonal and the first superdiagonal are
*            overwritten with the upper bidiagonal matrix B; the
*            elements below the diagonal, with the array TAUQ, represent
*            the orthogonal matrix Q as a product of elementary
*            reflectors, and the elements above the first superdiagonal,
*            with the array TAUP, represent the orthogonal matrix P as
*            a product of elementary reflectors;
*          if m < n, the diagonal and the first subdiagonal are
*            overwritten with the lower bidiagonal matrix B; the
*            elements below the first subdiagonal, with the array TAUQ,
*            represent the orthogonal matrix Q as a product of
*            elementary reflectors, and the elements above the diagonal,
*            with the array TAUP, represent the orthogonal matrix P as
*            a product of elementary reflectors.
*          See Further Details.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  D       (output) DOUBLE PRECISION array, dimension (min(M,N))
*          The diagonal elements of the bidiagonal matrix B:
*          D(i) = A(i,i).
*
*  E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
*          The off-diagonal elements of the bidiagonal matrix B:
*          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
*          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
*
*  TAUQ    (output) DOUBLE PRECISION array dimension (min(M,N))
*          The scalar factors of the elementary reflectors which
*          represent the orthogonal matrix Q. See Further Details.
*
*  TAUP    (output) DOUBLE PRECISION array, dimension (min(M,N))
*          The scalar factors of the elementary reflectors which
*          represent the orthogonal matrix P. See Further Details.
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension (max(M,N))
*
*  INFO    (output) INTEGER
*          = 0: successful exit.
*          < 0: if INFO = -i, the i-th argument had an illegal value.
*
*  Further Details
*  ===============
*
*  The matrices Q and P are represented as products of elementary
*  reflectors:
*
*  If m >= n,
*
*     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
*
*  Each H(i) and G(i) has the form:
*
*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
*
*  where tauq and taup are real scalars, and v and u are real vectors;
*  v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
*  u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
*  tauq is stored in TAUQ(i) and taup in TAUP(i).
*
*  If m < n,
*
*     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
*
*  Each H(i) and G(i) has the form:
*
*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
*
*  where tauq and taup are real scalars, and v and u are real vectors;
*  v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
*  u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
*  tauq is stored in TAUQ(i) and taup in TAUP(i).
*
*  The contents of A on exit are illustrated by the following examples:
*
*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
*
*    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
*    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
*    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
*    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
*    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
*    (  v1  v2  v3  v4  v5 )
*
*  where d and e denote diagonal and off-diagonal elements of B, vi
*  denotes an element of the vector defining H(i), and ui an element of
*  the vector defining G(i).
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARF, DLARFG, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.LT.0 ) THEN
         CALL XERBLA( 'DGEBD2', -INFO )
         RETURN
      END IF
*
      IF( M.GE.N ) THEN
*
*        Reduce to upper bidiagonal form
*
         DO 10 I = 1, N
*
*           Generate elementary reflector H(i) to annihilate A(i+1:m,i)
*
            CALL DLARFG( M-I+1, A( I, I ), A( MIN( I+1, M ), I ), 1,
     $                   TAUQ( I ) )
            D( I ) = A( I, I )
            A( I, I ) = ONE
*
*           Apply H(i) to A(i:m,i+1:n) from the left
*
            IF( I.LT.N )
     $         CALL DLARF( 'Left', M-I+1, N-I, A( I, I ), 1, TAUQ( I ),
     $                     A( I, I+1 ), LDA, WORK )
            A( I, I ) = D( I )
*
            IF( I.LT.N ) THEN
*
*              Generate elementary reflector G(i) to annihilate
*              A(i,i+2:n)
*
               CALL DLARFG( N-I, A( I, I+1 ), A( I, MIN( I+2, N ) ),
     $                      LDA, TAUP( I ) )
               E( I ) = A( I, I+1 )
               A( I, I+1 ) = ONE
*
*              Apply G(i) to A(i+1:m,i+1:n) from the right
*
               CALL DLARF( 'Right', M-I, N-I, A( I, I+1 ), LDA,
     $                     TAUP( I ), A( I+1, I+1 ), LDA, WORK )
               A( I, I+1 ) = E( I )
            ELSE
               TAUP( I ) = ZERO
            END IF
   10    CONTINUE
      ELSE
*
*        Reduce to lower bidiagonal form
*
         DO 20 I = 1, M
*
*           Generate elementary reflector G(i) to annihilate A(i,i+1:n)
*
            CALL DLARFG( N-I+1, A( I, I ), A( I, MIN( I+1, N ) ), LDA,
     $                   TAUP( I ) )
            D( I ) = A( I, I )
            A( I, I ) = ONE
*
*           Apply G(i) to A(i+1:m,i:n) from the right
*
            IF( I.LT.M )
     $         CALL DLARF( 'Right', M-I, N-I+1, A( I, I ), LDA,
     $                     TAUP( I ), A( I+1, I ), LDA, WORK )
            A( I, I ) = D( I )
*
            IF( I.LT.M ) THEN
*
*              Generate elementary reflector H(i) to annihilate
*              A(i+2:m,i)
*
               CALL DLARFG( M-I, A( I+1, I ), A( MIN( I+2, M ), I ), 1,
     $                      TAUQ( I ) )
               E( I ) = A( I+1, I )
               A( I+1, I ) = ONE
*
*              Apply H(i) to A(i+1:m,i+1:n) from the left
*
               CALL DLARF( 'Left', M-I, N-I, A( I+1, I ), 1, TAUQ( I ),
     $                     A( I+1, I+1 ), LDA, WORK )
               A( I+1, I ) = E( I )
            ELSE
               TAUQ( I ) = ZERO
            END IF
   20    CONTINUE
      END IF
      RETURN
*
*     End of DGEBD2
*
      END
      SUBROUTINE DGEBRD( M, N, A, LDA, D, E, TAUQ, TAUP, WORK, LWORK,
     $                   INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, LWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAUP( * ),
CID     $                   TAUQ( * ), WORK( * )
      DIMENSION          A( LDA, * ), D( * ), E( * ), TAUP( * ),
     $                   TAUQ( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DGEBRD reduces a general real M-by-N matrix A to upper or lower
*  bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.
*
*  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows in the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns in the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the M-by-N general matrix to be reduced.
*          On exit,
*          if m >= n, the diagonal and the first superdiagonal are
*            overwritten with the upper bidiagonal matrix B; the
*            elements below the diagonal, with the array TAUQ, represent
*            the orthogonal matrix Q as a product of elementary
*            reflectors, and the elements above the first superdiagonal,
*            with the array TAUP, represent the orthogonal matrix P as
*            a product of elementary reflectors;
*          if m < n, the diagonal and the first subdiagonal are
*            overwritten with the lower bidiagonal matrix B; the
*            elements below the first subdiagonal, with the array TAUQ,
*            represent the orthogonal matrix Q as a product of
*            elementary reflectors, and the elements above the diagonal,
*            with the array TAUP, represent the orthogonal matrix P as
*            a product of elementary reflectors.
*          See Further Details.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  D       (output) DOUBLE PRECISION array, dimension (min(M,N))
*          The diagonal elements of the bidiagonal matrix B:
*          D(i) = A(i,i).
*
*  E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
*          The off-diagonal elements of the bidiagonal matrix B:
*          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
*          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
*
*  TAUQ    (output) DOUBLE PRECISION array dimension (min(M,N))
*          The scalar factors of the elementary reflectors which
*          represent the orthogonal matrix Q. See Further Details.
*
*  TAUP    (output) DOUBLE PRECISION array, dimension (min(M,N))
*          The scalar factors of the elementary reflectors which
*          represent the orthogonal matrix P. See Further Details.
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The length of the array WORK.  LWORK >= max(1,M,N).
*          For optimum performance LWORK >= (M+N)*NB, where NB
*          is the optimal blocksize.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value.
*
*  Further Details
*  ===============
*
*  The matrices Q and P are represented as products of elementary
*  reflectors:
*
*  If m >= n,
*
*     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
*
*  Each H(i) and G(i) has the form:
*
*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
*
*  where tauq and taup are real scalars, and v and u are real vectors;
*  v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
*  u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
*  tauq is stored in TAUQ(i) and taup in TAUP(i).
*
*  If m < n,
*
*     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
*
*  Each H(i) and G(i) has the form:
*
*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
*
*  where tauq and taup are real scalars, and v and u are real vectors;
*  v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
*  u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
*  tauq is stored in TAUQ(i) and taup in TAUP(i).
*
*  The contents of A on exit are illustrated by the following examples:
*
*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
*
*    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
*    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
*    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
*    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
*    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
*    (  v1  v2  v3  v4  v5 )
*
*  where d and e denote diagonal and off-diagonal elements of B, vi
*  denotes an element of the vector defining H(i), and ui an element of
*  the vector defining G(i).
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LQUERY
      INTEGER            I, IINFO, J, LDWRKX, LDWRKY, LWKOPT, MINMN, NB,
     $                   NBMIN, NX
CID      DOUBLE PRECISION   WS
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEBD2, DGEMM, DLABRD, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          DBLE, MAX, MIN
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
      EXTERNAL           ILAENV
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters
*
      INFO = 0
      NB = MAX( 1, ILAENV( 1, 'DGEBRD', ' ', M, N, -1, -1 ) )
      LWKOPT = ( M+N )*NB
      WORK( 1 ) = DBLE( LWKOPT )
      LQUERY = ( LWORK.EQ.-1 )
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      ELSE IF( LWORK.LT.MAX( 1, M, N ) .AND. .NOT.LQUERY ) THEN
         INFO = -10
      END IF
      IF( INFO.LT.0 ) THEN
         CALL XERBLA( 'DGEBRD', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      MINMN = MIN( M, N )
      IF( MINMN.EQ.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
      WS = MAX( M, N )
      LDWRKX = M
      LDWRKY = N
*
      IF( NB.GT.1 .AND. NB.LT.MINMN ) THEN
*
*        Set the crossover point NX.
*
         NX = MAX( NB, ILAENV( 3, 'DGEBRD', ' ', M, N, -1, -1 ) )
*
*        Determine when to switch from blocked to unblocked code.
*
         IF( NX.LT.MINMN ) THEN
            WS = ( M+N )*NB
            IF( LWORK.LT.WS ) THEN
*
*              Not enough work space for the optimal NB, consider using
*              a smaller block size.
*
               NBMIN = ILAENV( 2, 'DGEBRD', ' ', M, N, -1, -1 )
               IF( LWORK.GE.( M+N )*NBMIN ) THEN
                  NB = LWORK / ( M+N )
               ELSE
                  NB = 1
                  NX = MINMN
               END IF
            END IF
         END IF
      ELSE
         NX = MINMN
      END IF
*
      DO 30 I = 1, MINMN - NX, NB
*
*        Reduce rows and columns i:i+nb-1 to bidiagonal form and return
*        the matrices X and Y which are needed to update the unreduced
*        part of the matrix
*
         CALL DLABRD( M-I+1, N-I+1, NB, A( I, I ), LDA, D( I ), E( I ),
     $                TAUQ( I ), TAUP( I ), WORK, LDWRKX,
     $                WORK( LDWRKX*NB+1 ), LDWRKY )
*
*        Update the trailing submatrix A(i+nb:m,i+nb:n), using an update
*        of the form  A := A - V*Y' - X*U'
*
         CALL DGEMM( 'No transpose', 'Transpose', M-I-NB+1, N-I-NB+1,
     $               NB, -ONE, A( I+NB, I ), LDA,
     $               WORK( LDWRKX*NB+NB+1 ), LDWRKY, ONE,
     $               A( I+NB, I+NB ), LDA )
         CALL DGEMM( 'No transpose', 'No transpose', M-I-NB+1, N-I-NB+1,
     $               NB, -ONE, WORK( NB+1 ), LDWRKX, A( I, I+NB ), LDA,
     $               ONE, A( I+NB, I+NB ), LDA )
*
*        Copy diagonal and off-diagonal elements of B back into A
*
         IF( M.GE.N ) THEN
            DO 10 J = I, I + NB - 1
               A( J, J ) = D( J )
               A( J, J+1 ) = E( J )
   10       CONTINUE
         ELSE
            DO 20 J = I, I + NB - 1
               A( J, J ) = D( J )
               A( J+1, J ) = E( J )
   20       CONTINUE
         END IF
   30 CONTINUE
*
*     Use unblocked code to reduce the remainder of the matrix
*
      CALL DGEBD2( M-I+1, N-I+1, A( I, I ), LDA, D( I ), E( I ),
     $             TAUQ( I ), TAUP( I ), WORK, IINFO )
      WORK( 1 ) = WS
      RETURN
*
*     End of DGEBRD
*
      END
      SUBROUTINE DGELQ2( M, N, A, LDA, TAU, WORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
      DIMENSION A( LDA, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DGELQ2 computes an LQ factorization of a real m by n matrix A:
*  A = L * Q.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the m by n matrix A.
*          On exit, the elements on and below the diagonal of the array
*          contain the m by min(m,n) lower trapezoidal matrix L (L is
*          lower triangular if m <= n); the elements above the diagonal,
*          with the array TAU, represent the orthogonal matrix Q as a
*          product of elementary reflectors (see Further Details).
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
*          The scalar factors of the elementary reflectors (see Further
*          Details).
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*
*  Further Details
*  ===============
*
*  The matrix Q is represented as a product of elementary reflectors
*
*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
*
*  Each H(i) has the form
*
*     H(i) = I - tau * v * v'
*
*  where tau is a real scalar, and v is a real vector with
*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
*  and tau in TAU(i).
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, K
CID      DOUBLE PRECISION   AII
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARF, DLARFG, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGELQ2', -INFO )
         RETURN
      END IF
*
      K = MIN( M, N )
*
      DO 10 I = 1, K
*
*        Generate elementary reflector H(i) to annihilate A(i,i+1:n)
*
         CALL DLARFG( N-I+1, A( I, I ), A( I, MIN( I+1, N ) ), LDA,
     $                TAU( I ) )
         IF( I.LT.M ) THEN
*
*           Apply H(i) to A(i+1:m,i:n) from the right
*
            AII = A( I, I )
            A( I, I ) = ONE
            CALL DLARF( 'Right', M-I, N-I+1, A( I, I ), LDA, TAU( I ),
     $                  A( I+1, I ), LDA, WORK )
            A( I, I ) = AII
         END IF
   10 CONTINUE
      RETURN
*
*     End of DGELQ2
*
      END
      SUBROUTINE DGELQF( M, N, A, LDA, TAU, WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, LWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
      DIMENSION A( LDA, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DGELQF computes an LQ factorization of a real M-by-N matrix A:
*  A = L * Q.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the M-by-N matrix A.
*          On exit, the elements on and below the diagonal of the array
*          contain the m-by-min(m,n) lower trapezoidal matrix L (L is
*          lower triangular if m <= n); the elements above the diagonal,
*          with the array TAU, represent the orthogonal matrix Q as a
*          product of elementary reflectors (see Further Details).
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
*          The scalar factors of the elementary reflectors (see Further
*          Details).
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK.  LWORK >= max(1,M).
*          For optimum performance LWORK >= M*NB, where NB is the
*          optimal blocksize.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  Further Details
*  ===============
*
*  The matrix Q is represented as a product of elementary reflectors
*
*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
*
*  Each H(i) has the form
*
*     H(i) = I - tau * v * v'
*
*  where tau is a real scalar, and v is a real vector with
*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
*  and tau in TAU(i).
*
*  =====================================================================
*
*     .. Local Scalars ..
      LOGICAL            LQUERY
      INTEGER            I, IB, IINFO, IWS, K, LDWORK, LWKOPT, NB,
     $                   NBMIN, NX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGELQ2, DLARFB, DLARFT, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
      EXTERNAL           ILAENV
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      NB = ILAENV( 1, 'DGELQF', ' ', M, N, -1, -1 )
      LWKOPT = M*NB
      WORK( 1 ) = LWKOPT
      LQUERY = ( LWORK.EQ.-1 )
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      ELSE IF( LWORK.LT.MAX( 1, M ) .AND. .NOT.LQUERY ) THEN
         INFO = -7
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGELQF', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      K = MIN( M, N )
      IF( K.EQ.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
      NBMIN = 2
      NX = 0
      IWS = M
      IF( NB.GT.1 .AND. NB.LT.K ) THEN
*
*        Determine when to cross over from blocked to unblocked code.
*
         NX = MAX( 0, ILAENV( 3, 'DGELQF', ' ', M, N, -1, -1 ) )
         IF( NX.LT.K ) THEN
*
*           Determine if workspace is large enough for blocked code.
*
            LDWORK = M
            IWS = LDWORK*NB
            IF( LWORK.LT.IWS ) THEN
*
*              Not enough workspace to use optimal NB:  reduce NB and
*              determine the minimum value of NB.
*
               NB = LWORK / LDWORK
               NBMIN = MAX( 2, ILAENV( 2, 'DGELQF', ' ', M, N, -1,
     $                 -1 ) )
            END IF
         END IF
      END IF
*
      IF( NB.GE.NBMIN .AND. NB.LT.K .AND. NX.LT.K ) THEN
*
*        Use blocked code initially
*
         DO 10 I = 1, K - NX, NB
            IB = MIN( K-I+1, NB )
*
*           Compute the LQ factorization of the current block
*           A(i:i+ib-1,i:n)
*
            CALL DGELQ2( IB, N-I+1, A( I, I ), LDA, TAU( I ), WORK,
     $                   IINFO )
            IF( I+IB.LE.M ) THEN
*
*              Form the triangular factor of the block reflector
*              H = H(i) H(i+1) . . . H(i+ib-1)
*
               CALL DLARFT( 'Forward', 'Rowwise', N-I+1, IB, A( I, I ),
     $                      LDA, TAU( I ), WORK, LDWORK )
*
*              Apply H to A(i+ib:m,i:n) from the right
*
               CALL DLARFB( 'Right', 'No transpose', 'Forward',
     $                      'Rowwise', M-I-IB+1, N-I+1, IB, A( I, I ),
     $                      LDA, WORK, LDWORK, A( I+IB, I ), LDA,
     $                      WORK( IB+1 ), LDWORK )
            END IF
   10    CONTINUE
      ELSE
         I = 1
      END IF
*
*     Use unblocked code to factor the last or only block.
*
      IF( I.LE.K )
     $   CALL DGELQ2( M-I+1, N-I+1, A( I, I ), LDA, TAU( I ), WORK,
     $                IINFO )
*
      WORK( 1 ) = IWS
      RETURN
*
*     End of DGELQF
*
      END
      SUBROUTINE DGEQR2( M, N, A, LDA, TAU, WORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
      DIMENSION   A( LDA, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DGEQR2 computes a QR factorization of a real m by n matrix A:
*  A = Q * R.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the m by n matrix A.
*          On exit, the elements on and above the diagonal of the array
*          contain the min(m,n) by n upper trapezoidal matrix R (R is
*          upper triangular if m >= n); the elements below the diagonal,
*          with the array TAU, represent the orthogonal matrix Q as a
*          product of elementary reflectors (see Further Details).
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
*          The scalar factors of the elementary reflectors (see Further
*          Details).
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*
*  Further Details
*  ===============
*
*  The matrix Q is represented as a product of elementary reflectors
*
*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
*
*  Each H(i) has the form
*
*     H(i) = I - tau * v * v'
*
*  where tau is a real scalar, and v is a real vector with
*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
*  and tau in TAU(i).
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, K
CID      DOUBLE PRECISION   AII
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARF, DLARFG, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGEQR2', -INFO )
         RETURN
      END IF
*
      K = MIN( M, N )
*
      DO 10 I = 1, K
*
*        Generate elementary reflector H(i) to annihilate A(i+1:m,i)
*
         CALL DLARFG( M-I+1, A( I, I ), A( MIN( I+1, M ), I ), 1,
     $                TAU( I ) )
         IF( I.LT.N ) THEN
*
*           Apply H(i) to A(i:m,i+1:n) from the left
*
            AII = A( I, I )
            A( I, I ) = ONE
            CALL DLARF( 'Left', M-I+1, N-I, A( I, I ), 1, TAU( I ),
     $                  A( I, I+1 ), LDA, WORK )
            A( I, I ) = AII
         END IF
   10 CONTINUE
      RETURN
*
*     End of DGEQR2
*
      END
      SUBROUTINE DGEQRF( M, N, A, LDA, TAU, WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, LWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
      DIMENSION    A( LDA, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DGEQRF computes a QR factorization of a real M-by-N matrix A:
*  A = Q * R.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the M-by-N matrix A.
*          On exit, the elements on and above the diagonal of the array
*          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
*          upper triangular if m >= n); the elements below the diagonal,
*          with the array TAU, represent the orthogonal matrix Q as a
*          product of min(m,n) elementary reflectors (see Further
*          Details).
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
*          The scalar factors of the elementary reflectors (see Further
*          Details).
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK.  LWORK >= max(1,N).
*          For optimum performance LWORK >= N*NB, where NB is
*          the optimal blocksize.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  Further Details
*  ===============
*
*  The matrix Q is represented as a product of elementary reflectors
*
*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
*
*  Each H(i) has the form
*
*     H(i) = I - tau * v * v'
*
*  where tau is a real scalar, and v is a real vector with
*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
*  and tau in TAU(i).
*
*  =====================================================================
*
*     .. Local Scalars ..
      LOGICAL            LQUERY
      INTEGER            I, IB, IINFO, IWS, K, LDWORK, LWKOPT, NB,
     $                   NBMIN, NX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEQR2, DLARFB, DLARFT, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
      EXTERNAL           ILAENV
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      NB = ILAENV( 1, 'DGEQRF', ' ', M, N, -1, -1 )
      LWKOPT = N*NB
      WORK( 1 ) = LWKOPT
      LQUERY = ( LWORK.EQ.-1 )
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      ELSE IF( LWORK.LT.MAX( 1, N ) .AND. .NOT.LQUERY ) THEN
         INFO = -7
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGEQRF', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      K = MIN( M, N )
      IF( K.EQ.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
      NBMIN = 2
      NX = 0
      IWS = N
      IF( NB.GT.1 .AND. NB.LT.K ) THEN
*
*        Determine when to cross over from blocked to unblocked code.
*
         NX = MAX( 0, ILAENV( 3, 'DGEQRF', ' ', M, N, -1, -1 ) )
         IF( NX.LT.K ) THEN
*
*           Determine if workspace is large enough for blocked code.
*
            LDWORK = N
            IWS = LDWORK*NB
            IF( LWORK.LT.IWS ) THEN
*
*              Not enough workspace to use optimal NB:  reduce NB and
*              determine the minimum value of NB.
*
               NB = LWORK / LDWORK
               NBMIN = MAX( 2, ILAENV( 2, 'DGEQRF', ' ', M, N, -1,
     $                 -1 ) )
            END IF
         END IF
      END IF
*
      IF( NB.GE.NBMIN .AND. NB.LT.K .AND. NX.LT.K ) THEN
*
*        Use blocked code initially
*
         DO 10 I = 1, K - NX, NB
            IB = MIN( K-I+1, NB )
*
*           Compute the QR factorization of the current block
*           A(i:m,i:i+ib-1)
*
            CALL DGEQR2( M-I+1, IB, A( I, I ), LDA, TAU( I ), WORK,
     $                   IINFO )
            IF( I+IB.LE.N ) THEN
*
*              Form the triangular factor of the block reflector
*              H = H(i) H(i+1) . . . H(i+ib-1)
*
               CALL DLARFT( 'Forward', 'Columnwise', M-I+1, IB,
     $                      A( I, I ), LDA, TAU( I ), WORK, LDWORK )
*
*              Apply H' to A(i:m,i+ib:n) from the left
*
               CALL DLARFB( 'Left', 'Transpose', 'Forward',
     $                      'Columnwise', M-I+1, N-I-IB+1, IB,
     $                      A( I, I ), LDA, WORK, LDWORK, A( I, I+IB ),
     $                      LDA, WORK( IB+1 ), LDWORK )
            END IF
   10    CONTINUE
      ELSE
         I = 1
      END IF
*
*     Use unblocked code to factor the last or only block.
*
      IF( I.LE.K )
     $   CALL DGEQR2( M-I+1, N-I+1, A( I, I ), LDA, TAU( I ), WORK,
     $                IINFO )
*
      WORK( 1 ) = IWS
      RETURN
*
*     End of DGEQRF
*
      END
      SUBROUTINE DLABRD( M, N, NB, A, LDA, D, E, TAUQ, TAUP, X, LDX, Y,
     $                   LDY )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            LDA, LDX, LDY, M, N, NB
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAUP( * ),
CID     $                   TAUQ( * ), X( LDX, * ), Y( LDY, * )
      DIMENSION          A( LDA, * ), D( * ), E( * ), TAUP( * ),
     $                   TAUQ( * ), X( LDX, * ), Y( LDY, * )
*     ..
*
*  Purpose
*  =======
*
*  DLABRD reduces the first NB rows and columns of a real general
*  m by n matrix A to upper or lower bidiagonal form by an orthogonal
*  transformation Q' * A * P, and returns the matrices X and Y which
*  are needed to apply the transformation to the unreduced part of A.
*
*  If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
*  bidiagonal form.
*
*  This is an auxiliary routine called by DGEBRD
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows in the matrix A.
*
*  N       (input) INTEGER
*          The number of columns in the matrix A.
*
*  NB      (input) INTEGER
*          The number of leading rows and columns of A to be reduced.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the m by n general matrix to be reduced.
*          On exit, the first NB rows and columns of the matrix are
*          overwritten; the rest of the array is unchanged.
*          If m >= n, elements on and below the diagonal in the first NB
*            columns, with the array TAUQ, represent the orthogonal
*            matrix Q as a product of elementary reflectors; and
*            elements above the diagonal in the first NB rows, with the
*            array TAUP, represent the orthogonal matrix P as a product
*            of elementary reflectors.
*          If m < n, elements below the diagonal in the first NB
*            columns, with the array TAUQ, represent the orthogonal
*            matrix Q as a product of elementary reflectors, and
*            elements on and above the diagonal in the first NB rows,
*            with the array TAUP, represent the orthogonal matrix P as
*            a product of elementary reflectors.
*          See Further Details.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  D       (output) DOUBLE PRECISION array, dimension (NB)
*          The diagonal elements of the first NB rows and columns of
*          the reduced matrix.  D(i) = A(i,i).
*
*  E       (output) DOUBLE PRECISION array, dimension (NB)
*          The off-diagonal elements of the first NB rows and columns of
*          the reduced matrix.
*
*  TAUQ    (output) DOUBLE PRECISION array dimension (NB)
*          The scalar factors of the elementary reflectors which
*          represent the orthogonal matrix Q. See Further Details.
*
*  TAUP    (output) DOUBLE PRECISION array, dimension (NB)
*          The scalar factors of the elementary reflectors which
*          represent the orthogonal matrix P. See Further Details.
*
*  X       (output) DOUBLE PRECISION array, dimension (LDX,NB)
*          The m-by-nb matrix X required to update the unreduced part
*          of A.
*
*  LDX     (input) INTEGER
*          The leading dimension of the array X. LDX >= M.
*
*  Y       (output) DOUBLE PRECISION array, dimension (LDY,NB)
*          The n-by-nb matrix Y required to update the unreduced part
*          of A.
*
*  LDY     (input) INTEGER
*          The leading dimension of the array Y. LDY >= N.
*
*  Further Details
*  ===============
*
*  The matrices Q and P are represented as products of elementary
*  reflectors:
*
*     Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
*
*  Each H(i) and G(i) has the form:
*
*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
*
*  where tauq and taup are real scalars, and v and u are real vectors.
*
*  If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
*  A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
*
*  If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
*  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
*
*  The elements of the vectors v and u together form the m-by-nb matrix
*  V and the nb-by-n matrix U' which are needed, with X and Y, to apply
*  the transformation to the unreduced part of the matrix, using a block
*  update of the form:  A := A - V*Y' - X*U'.
*
*  The contents of A on exit are illustrated by the following examples
*  with nb = 2:
*
*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
*
*    (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
*    (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
*    (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
*    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
*    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
*    (  v1  v2  a   a   a  )
*
*  where a denotes an element of the original matrix which is unchanged,
*  vi denotes an element of the vector defining H(i), and ui an element
*  of the vector defining G(i).
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMV, DLARFG, DSCAL
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MIN
*     ..
*     .. Executable Statements ..
*
*     Quick return if possible
*
      IF( M.LE.0 .OR. N.LE.0 )
     $   RETURN
*
      IF( M.GE.N ) THEN
*
*        Reduce to upper bidiagonal form
*
         DO 10 I = 1, NB
*
*           Update A(i:m,i)
*
            CALL DGEMV( 'No transpose', M-I+1, I-1, -ONE, A( I, 1 ),
     $                  LDA, Y( I, 1 ), LDY, ONE, A( I, I ), 1 )
            CALL DGEMV( 'No transpose', M-I+1, I-1, -ONE, X( I, 1 ),
     $                  LDX, A( 1, I ), 1, ONE, A( I, I ), 1 )
*
*           Generate reflection Q(i) to annihilate A(i+1:m,i)
*
            CALL DLARFG( M-I+1, A( I, I ), A( MIN( I+1, M ), I ), 1,
     $                   TAUQ( I ) )
            D( I ) = A( I, I )
            IF( I.LT.N ) THEN
               A( I, I ) = ONE
*
*              Compute Y(i+1:n,i)
*
               CALL DGEMV( 'Transpose', M-I+1, N-I, ONE, A( I, I+1 ),
     $                     LDA, A( I, I ), 1, ZERO, Y( I+1, I ), 1 )
               CALL DGEMV( 'Transpose', M-I+1, I-1, ONE, A( I, 1 ), LDA,
     $                     A( I, I ), 1, ZERO, Y( 1, I ), 1 )
               CALL DGEMV( 'No transpose', N-I, I-1, -ONE, Y( I+1, 1 ),
     $                     LDY, Y( 1, I ), 1, ONE, Y( I+1, I ), 1 )
               CALL DGEMV( 'Transpose', M-I+1, I-1, ONE, X( I, 1 ), LDX,
     $                     A( I, I ), 1, ZERO, Y( 1, I ), 1 )
               CALL DGEMV( 'Transpose', I-1, N-I, -ONE, A( 1, I+1 ),
     $                     LDA, Y( 1, I ), 1, ONE, Y( I+1, I ), 1 )
               CALL DSCAL( N-I, TAUQ( I ), Y( I+1, I ), 1 )
*
*              Update A(i,i+1:n)
*
               CALL DGEMV( 'No transpose', N-I, I, -ONE, Y( I+1, 1 ),
     $                     LDY, A( I, 1 ), LDA, ONE, A( I, I+1 ), LDA )
               CALL DGEMV( 'Transpose', I-1, N-I, -ONE, A( 1, I+1 ),
     $                     LDA, X( I, 1 ), LDX, ONE, A( I, I+1 ), LDA )
*
*              Generate reflection P(i) to annihilate A(i,i+2:n)
*
               CALL DLARFG( N-I, A( I, I+1 ), A( I, MIN( I+2, N ) ),
     $                      LDA, TAUP( I ) )
               E( I ) = A( I, I+1 )
               A( I, I+1 ) = ONE
*
*              Compute X(i+1:m,i)
*
               CALL DGEMV( 'No transpose', M-I, N-I, ONE, A( I+1, I+1 ),
     $                     LDA, A( I, I+1 ), LDA, ZERO, X( I+1, I ), 1 )
               CALL DGEMV( 'Transpose', N-I, I, ONE, Y( I+1, 1 ), LDY,
     $                     A( I, I+1 ), LDA, ZERO, X( 1, I ), 1 )
               CALL DGEMV( 'No transpose', M-I, I, -ONE, A( I+1, 1 ),
     $                     LDA, X( 1, I ), 1, ONE, X( I+1, I ), 1 )
               CALL DGEMV( 'No transpose', I-1, N-I, ONE, A( 1, I+1 ),
     $                     LDA, A( I, I+1 ), LDA, ZERO, X( 1, I ), 1 )
               CALL DGEMV( 'No transpose', M-I, I-1, -ONE, X( I+1, 1 ),
     $                     LDX, X( 1, I ), 1, ONE, X( I+1, I ), 1 )
               CALL DSCAL( M-I, TAUP( I ), X( I+1, I ), 1 )
            END IF
   10    CONTINUE
      ELSE
*
*        Reduce to lower bidiagonal form
*
         DO 20 I = 1, NB
*
*           Update A(i,i:n)
*
            CALL DGEMV( 'No transpose', N-I+1, I-1, -ONE, Y( I, 1 ),
     $                  LDY, A( I, 1 ), LDA, ONE, A( I, I ), LDA )
            CALL DGEMV( 'Transpose', I-1, N-I+1, -ONE, A( 1, I ), LDA,
     $                  X( I, 1 ), LDX, ONE, A( I, I ), LDA )
*
*           Generate reflection P(i) to annihilate A(i,i+1:n)
*
            CALL DLARFG( N-I+1, A( I, I ), A( I, MIN( I+1, N ) ), LDA,
     $                   TAUP( I ) )
            D( I ) = A( I, I )
            IF( I.LT.M ) THEN
               A( I, I ) = ONE
*
*              Compute X(i+1:m,i)
*
               CALL DGEMV( 'No transpose', M-I, N-I+1, ONE, A( I+1, I ),
     $                     LDA, A( I, I ), LDA, ZERO, X( I+1, I ), 1 )
               CALL DGEMV( 'Transpose', N-I+1, I-1, ONE, Y( I, 1 ), LDY,
     $                     A( I, I ), LDA, ZERO, X( 1, I ), 1 )
               CALL DGEMV( 'No transpose', M-I, I-1, -ONE, A( I+1, 1 ),
     $                     LDA, X( 1, I ), 1, ONE, X( I+1, I ), 1 )
               CALL DGEMV( 'No transpose', I-1, N-I+1, ONE, A( 1, I ),
     $                     LDA, A( I, I ), LDA, ZERO, X( 1, I ), 1 )
               CALL DGEMV( 'No transpose', M-I, I-1, -ONE, X( I+1, 1 ),
     $                     LDX, X( 1, I ), 1, ONE, X( I+1, I ), 1 )
               CALL DSCAL( M-I, TAUP( I ), X( I+1, I ), 1 )
*
*              Update A(i+1:m,i)
*
               CALL DGEMV( 'No transpose', M-I, I-1, -ONE, A( I+1, 1 ),
     $                     LDA, Y( I, 1 ), LDY, ONE, A( I+1, I ), 1 )
               CALL DGEMV( 'No transpose', M-I, I, -ONE, X( I+1, 1 ),
     $                     LDX, A( 1, I ), 1, ONE, A( I+1, I ), 1 )
*
*              Generate reflection Q(i) to annihilate A(i+2:m,i)
*
               CALL DLARFG( M-I, A( I+1, I ), A( MIN( I+2, M ), I ), 1,
     $                      TAUQ( I ) )
               E( I ) = A( I+1, I )
               A( I+1, I ) = ONE
*
*              Compute Y(i+1:n,i)
*
               CALL DGEMV( 'Transpose', M-I, N-I, ONE, A( I+1, I+1 ),
     $                     LDA, A( I+1, I ), 1, ZERO, Y( I+1, I ), 1 )
               CALL DGEMV( 'Transpose', M-I, I-1, ONE, A( I+1, 1 ), LDA,
     $                     A( I+1, I ), 1, ZERO, Y( 1, I ), 1 )
               CALL DGEMV( 'No transpose', N-I, I-1, -ONE, Y( I+1, 1 ),
     $                     LDY, Y( 1, I ), 1, ONE, Y( I+1, I ), 1 )
               CALL DGEMV( 'Transpose', M-I, I, ONE, X( I+1, 1 ), LDX,
     $                     A( I+1, I ), 1, ZERO, Y( 1, I ), 1 )
               CALL DGEMV( 'Transpose', I, N-I, -ONE, A( 1, I+1 ), LDA,
     $                     Y( 1, I ), 1, ONE, Y( I+1, I ), 1 )
               CALL DSCAL( N-I, TAUQ( I ), Y( I+1, I ), 1 )
            END IF
   20    CONTINUE
      END IF
      RETURN
*
*     End of DLABRD
*
      END
      SUBROUTINE DLACPY( UPLO, M, N, A, LDA, B, LDB )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          UPLO
      INTEGER            LDA, LDB, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
      DIMENSION A( LDA, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  DLACPY copies all or part of a two-dimensional matrix A to another
*  matrix B.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          Specifies the part of the matrix A to be copied to B.
*          = 'U':      Upper triangular part
*          = 'L':      Lower triangular part
*          Otherwise:  All of the matrix A
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
*          The m by n matrix A.  If UPLO = 'U', only the upper triangle
*          or trapezoid is accessed; if UPLO = 'L', only the lower
*          triangle or trapezoid is accessed.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  B       (output) DOUBLE PRECISION array, dimension (LDB,N)
*          On exit, B = A in the locations specified by UPLO.
*
*  LDB     (input) INTEGER
*          The leading dimension of the array B.  LDB >= max(1,M).
*
*  =====================================================================
*
*     .. Local Scalars ..
      INTEGER            I, J
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MIN
*     ..
*     .. Executable Statements ..
*
      IF( LSAME( UPLO, 'U' ) ) THEN
         DO 20 J = 1, N
            DO 10 I = 1, MIN( J, M )
               B( I, J ) = A( I, J )
   10       CONTINUE
   20    CONTINUE
      ELSE IF( LSAME( UPLO, 'L' ) ) THEN
         DO 40 J = 1, N
            DO 30 I = J, M
               B( I, J ) = A( I, J )
   30       CONTINUE
   40    CONTINUE
      ELSE
         DO 60 J = 1, N
            DO 50 I = 1, M
               B( I, J ) = A( I, J )
   50       CONTINUE
   60    CONTINUE
      END IF
      RETURN
*
*     End of DLACPY
*
      END
C      
CID      DOUBLE PRECISION FUNCTION DLANGE( NORM, M, N, A, LDA, WORK )
      FUNCTION DLANGE( NORM, M, N, A, LDA, WORK )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          NORM
      INTEGER            LDA, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), WORK( * )
      DIMENSION    A( LDA, * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DLANGE  returns the value of the one norm,  or the Frobenius norm, or
*  the  infinity norm,  or the  element of  largest absolute value  of a
*  real matrix A.
*
*  Description
*  ===========
*
*  DLANGE returns the value
*
*     DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
*              (
*              ( norm1(A),         NORM = '1', 'O' or 'o'
*              (
*              ( normI(A),         NORM = 'I' or 'i'
*              (
*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
*
*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
*  squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
*
*  Arguments
*  =========
*
*  NORM    (input) CHARACTER*1
*          Specifies the value to be returned in DLANGE as described
*          above.
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.  When M = 0,
*          DLANGE is set to zero.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.  When N = 0,
*          DLANGE is set to zero.
*
*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
*          The m by n matrix A.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(M,1).
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
*          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
*          referenced.
*
* =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, J
CID      DOUBLE PRECISION   SCALE, SUM, VALUE
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLASSQ
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, MAX, MIN, SQRT
*     ..
*     .. Executable Statements ..
*
      IF( MIN( M, N ).EQ.0 ) THEN
         VALUE = ZERO
      ELSE IF( LSAME( NORM, 'M' ) ) THEN
*
*        Find max(abs(A(i,j))).
*
         VALUE = ZERO
         DO 20 J = 1, N
            DO 10 I = 1, M
               VALUE = MAX( VALUE, ABS( A( I, J ) ) )
   10       CONTINUE
   20    CONTINUE
      ELSE IF( ( LSAME( NORM, 'O' ) ) .OR. ( NORM.EQ.'1' ) ) THEN
*
*        Find norm1(A).
*
         VALUE = ZERO
         DO 40 J = 1, N
            SUM = ZERO
            DO 30 I = 1, M
               SUM = SUM + ABS( A( I, J ) )
   30       CONTINUE
            VALUE = MAX( VALUE, SUM )
   40    CONTINUE
      ELSE IF( LSAME( NORM, 'I' ) ) THEN
*
*        Find normI(A).
*
         DO 50 I = 1, M
            WORK( I ) = ZERO
   50    CONTINUE
         DO 70 J = 1, N
            DO 60 I = 1, M
               WORK( I ) = WORK( I ) + ABS( A( I, J ) )
   60       CONTINUE
   70    CONTINUE
         VALUE = ZERO
         DO 80 I = 1, M
            VALUE = MAX( VALUE, WORK( I ) )
   80    CONTINUE
      ELSE IF( ( LSAME( NORM, 'F' ) ) .OR. ( LSAME( NORM, 'E' ) ) ) THEN
*
*        Find normF(A).
*
         SCALE = ZERO
         SUM = ONE
         DO 90 J = 1, N
            CALL DLASSQ( M, A( 1, J ), 1, SCALE, SUM )
   90    CONTINUE
         VALUE = SCALE*SQRT( SUM )
      END IF
*
      DLANGE = VALUE
      RETURN
*
*     End of DLANGE
*
      END
CID      DOUBLE PRECISION FUNCTION DLAPY2( X, Y )
      FUNCTION DLAPY2( X, Y )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION   X, Y
*     ..
*
*  Purpose
*  =======
*
*  DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
*  overflow.
*
*  Arguments
*  =========
*
*  X       (input) DOUBLE PRECISION
*  Y       (input) DOUBLE PRECISION
*          X and Y specify the values x and y.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D0 )
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D0 )
*     ..
*     .. Local Scalars ..
CID      DOUBLE PRECISION   W, XABS, YABS, Z
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, MAX, MIN, SQRT
*     ..
*     .. Executable Statements ..
*
      XABS = ABS( X )
      YABS = ABS( Y )
      W = MAX( XABS, YABS )
      Z = MIN( XABS, YABS )
      IF( Z.EQ.ZERO ) THEN
         DLAPY2 = W
      ELSE
         DLAPY2 = W*SQRT( ONE+( Z / W )**2 )
      END IF
      RETURN
*
*     End of DLAPY2
*
      END
      SUBROUTINE DLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          SIDE
      INTEGER            INCV, LDC, M, N
CID      DOUBLE PRECISION   TAU
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   C( LDC, * ), V( * ), WORK( * )
      DIMENSION    C( LDC, * ), V( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DLARF applies a real elementary reflector H to a real m by n matrix
*  C, from either the left or the right. H is represented in the form
*
*        H = I - tau * v * v'
*
*  where tau is a real scalar and v is a real vector.
*
*  If tau = 0, then H is taken to be the unit matrix.
*
*  Arguments
*  =========
*
*  SIDE    (input) CHARACTER*1
*          = 'L': form  H * C
*          = 'R': form  C * H
*
*  M       (input) INTEGER
*          The number of rows of the matrix C.
*
*  N       (input) INTEGER
*          The number of columns of the matrix C.
*
*  V       (input) DOUBLE PRECISION array, dimension
*                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'
*                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
*          The vector v in the representation of H. V is not used if
*          TAU = 0.
*
*  INCV    (input) INTEGER
*          The increment between elements of v. INCV <> 0.
*
*  TAU     (input) DOUBLE PRECISION
*          The value tau in the representation of H.
*
*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
*          On entry, the m by n matrix C.
*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
*          or C * H if SIDE = 'R'.
*
*  LDC     (input) INTEGER
*          The leading dimension of the array C. LDC >= max(1,M).
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension
*                         (N) if SIDE = 'L'
*                      or (M) if SIDE = 'R'
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMV, DGER
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. Executable Statements ..
*
      IF( LSAME( SIDE, 'L' ) ) THEN
*
*        Form  H * C
*
         IF( TAU.NE.ZERO ) THEN
*
*           w := C' * v
*
            CALL DGEMV( 'Transpose', M, N, ONE, C, LDC, V, INCV, ZERO,
     $                  WORK, 1 )
*
*           C := C - v * w'
*
            CALL DGER( M, N, -TAU, V, INCV, WORK, 1, C, LDC )
         END IF
      ELSE
*
*        Form  C * H
*
         IF( TAU.NE.ZERO ) THEN
*
*           w := C * v
*
            CALL DGEMV( 'No transpose', M, N, ONE, C, LDC, V, INCV,
     $                  ZERO, WORK, 1 )
*
*           C := C - w * v'
*
            CALL DGER( M, N, -TAU, WORK, 1, V, INCV, C, LDC )
         END IF
      END IF
      RETURN
*
*     End of DLARF
*
      END
      SUBROUTINE DLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,
     $                   T, LDT, C, LDC, WORK, LDWORK )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          DIRECT, SIDE, STOREV, TRANS
      INTEGER            K, LDC, LDT, LDV, LDWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   C( LDC, * ), T( LDT, * ), V( LDV, * ),
CID     $                   WORK( LDWORK, * )
      DIMENSION    C( LDC, * ), T( LDT, * ), V( LDV, * ),
     $                   WORK( LDWORK, * )
*     ..
*
*  Purpose
*  =======
*
*  DLARFB applies a real block reflector H or its transpose H' to a
*  real m by n matrix C, from either the left or the right.
*
*  Arguments
*  =========
*
*  SIDE    (input) CHARACTER*1
*          = 'L': apply H or H' from the Left
*          = 'R': apply H or H' from the Right
*
*  TRANS   (input) CHARACTER*1
*          = 'N': apply H (No transpose)
*          = 'T': apply H' (Transpose)
*
*  DIRECT  (input) CHARACTER*1
*          Indicates how H is formed from a product of elementary
*          reflectors
*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
*
*  STOREV  (input) CHARACTER*1
*          Indicates how the vectors which define the elementary
*          reflectors are stored:
*          = 'C': Columnwise
*          = 'R': Rowwise
*
*  M       (input) INTEGER
*          The number of rows of the matrix C.
*
*  N       (input) INTEGER
*          The number of columns of the matrix C.
*
*  K       (input) INTEGER
*          The order of the matrix T (= the number of elementary
*          reflectors whose product defines the block reflector).
*
*  V       (input) DOUBLE PRECISION array, dimension
*                                (LDV,K) if STOREV = 'C'
*                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
*                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
*          The matrix V. See further details.
*
*  LDV     (input) INTEGER
*          The leading dimension of the array V.
*          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
*          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
*          if STOREV = 'R', LDV >= K.
*
*  T       (input) DOUBLE PRECISION array, dimension (LDT,K)
*          The triangular k by k matrix T in the representation of the
*          block reflector.
*
*  LDT     (input) INTEGER
*          The leading dimension of the array T. LDT >= K.
*
*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
*          On entry, the m by n matrix C.
*          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
*
*  LDC     (input) INTEGER
*          The leading dimension of the array C. LDA >= max(1,M).
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension (LDWORK,K)
*
*  LDWORK  (input) INTEGER
*          The leading dimension of the array WORK.
*          If SIDE = 'L', LDWORK >= max(1,N);
*          if SIDE = 'R', LDWORK >= max(1,M).
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      CHARACTER          TRANST
      INTEGER            I, J
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           DCOPY, DGEMM, DTRMM
*     ..
*     .. Executable Statements ..
*
*     Quick return if possible
*
      IF( M.LE.0 .OR. N.LE.0 )
     $   RETURN
*
      IF( LSAME( TRANS, 'N' ) ) THEN
         TRANST = 'T'
      ELSE
         TRANST = 'N'
      END IF
*
      IF( LSAME( STOREV, 'C' ) ) THEN
*
         IF( LSAME( DIRECT, 'F' ) ) THEN
*
*           Let  V =  ( V1 )    (first K rows)
*                     ( V2 )
*           where  V1  is unit lower triangular.
*
            IF( LSAME( SIDE, 'L' ) ) THEN
*
*              Form  H * C  or  H' * C  where  C = ( C1 )
*                                                  ( C2 )
*
*              W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
*
*              W := C1'
*
               DO 10 J = 1, K
                  CALL DCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )
   10          CONTINUE
*
*              W := W * V1
*
               CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N,
     $                     K, ONE, V, LDV, WORK, LDWORK )
               IF( M.GT.K ) THEN
*
*                 W := W + C2'*V2
*
                  CALL DGEMM( 'Transpose', 'No transpose', N, K, M-K,
     $                        ONE, C( K+1, 1 ), LDC, V( K+1, 1 ), LDV,
     $                        ONE, WORK, LDWORK )
               END IF
*
*              W := W * T'  or  W * T
*
               CALL DTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*
*              C := C - V * W'
*
               IF( M.GT.K ) THEN
*
*                 C2 := C2 - V2 * W'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M-K, N, K,
     $                        -ONE, V( K+1, 1 ), LDV, WORK, LDWORK, ONE,
     $                        C( K+1, 1 ), LDC )
               END IF
*
*              W := W * V1'
*
               CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K,
     $                     ONE, V, LDV, WORK, LDWORK )
*
*              C1 := C1 - W'
*
               DO 30 J = 1, K
                  DO 20 I = 1, N
                     C( J, I ) = C( J, I ) - WORK( I, J )
   20             CONTINUE
   30          CONTINUE
*
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN
*
*              Form  C * H  or  C * H'  where  C = ( C1  C2 )
*
*              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
*
*              W := C1
*
               DO 40 J = 1, K
                  CALL DCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 )
   40          CONTINUE
*
*              W := W * V1
*
               CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M,
     $                     K, ONE, V, LDV, WORK, LDWORK )
               IF( N.GT.K ) THEN
*
*                 W := W + C2 * V2
*
                  CALL DGEMM( 'No transpose', 'No transpose', M, K, N-K,
     $                        ONE, C( 1, K+1 ), LDC, V( K+1, 1 ), LDV,
     $                        ONE, WORK, LDWORK )
               END IF
*
*              W := W * T  or  W * T'
*
               CALL DTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*
*              C := C - W * V'
*
               IF( N.GT.K ) THEN
*
*                 C2 := C2 - W * V2'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M, N-K, K,
     $                        -ONE, WORK, LDWORK, V( K+1, 1 ), LDV, ONE,
     $                        C( 1, K+1 ), LDC )
               END IF
*
*              W := W * V1'
*
               CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K,
     $                     ONE, V, LDV, WORK, LDWORK )
*
*              C1 := C1 - W
*
               DO 60 J = 1, K
                  DO 50 I = 1, M
                     C( I, J ) = C( I, J ) - WORK( I, J )
   50             CONTINUE
   60          CONTINUE
            END IF
*
         ELSE
*
*           Let  V =  ( V1 )
*                     ( V2 )    (last K rows)
*           where  V2  is unit upper triangular.
*
            IF( LSAME( SIDE, 'L' ) ) THEN
*
*              Form  H * C  or  H' * C  where  C = ( C1 )
*                                                  ( C2 )
*
*              W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
*
*              W := C2'
*
               DO 70 J = 1, K
                  CALL DCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )
   70          CONTINUE
*
*              W := W * V2
*
               CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N,
     $                     K, ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )
               IF( M.GT.K ) THEN
*
*                 W := W + C1'*V1
*
                  CALL DGEMM( 'Transpose', 'No transpose', N, K, M-K,
     $                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
               END IF
*
*              W := W * T'  or  W * T
*
               CALL DTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*
*              C := C - V * W'
*
               IF( M.GT.K ) THEN
*
*                 C1 := C1 - V1 * W'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M-K, N, K,
     $                        -ONE, V, LDV, WORK, LDWORK, ONE, C, LDC )
               END IF
*
*              W := W * V2'
*
               CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K,
     $                     ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )
*
*              C2 := C2 - W'
*
               DO 90 J = 1, K
                  DO 80 I = 1, N
                     C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J )
   80             CONTINUE
   90          CONTINUE
*
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN
*
*              Form  C * H  or  C * H'  where  C = ( C1  C2 )
*
*              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
*
*              W := C2
*
               DO 100 J = 1, K
                  CALL DCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )
  100          CONTINUE
*
*              W := W * V2
*
               CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M,
     $                     K, ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )
               IF( N.GT.K ) THEN
*
*                 W := W + C1 * V1
*
                  CALL DGEMM( 'No transpose', 'No transpose', M, K, N-K,
     $                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
               END IF
*
*              W := W * T  or  W * T'
*
               CALL DTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*
*              C := C - W * V'
*
               IF( N.GT.K ) THEN
*
*                 C1 := C1 - W * V1'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M, N-K, K,
     $                        -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC )
               END IF
*
*              W := W * V2'
*
               CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K,
     $                     ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )
*
*              C2 := C2 - W
*
               DO 120 J = 1, K
                  DO 110 I = 1, M
                     C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )
  110             CONTINUE
  120          CONTINUE
            END IF
         END IF
*
      ELSE IF( LSAME( STOREV, 'R' ) ) THEN
*
         IF( LSAME( DIRECT, 'F' ) ) THEN
*
*           Let  V =  ( V1  V2 )    (V1: first K columns)
*           where  V1  is unit upper triangular.
*
            IF( LSAME( SIDE, 'L' ) ) THEN
*
*              Form  H * C  or  H' * C  where  C = ( C1 )
*                                                  ( C2 )
*
*              W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
*
*              W := C1'
*
               DO 130 J = 1, K
                  CALL DCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )
  130          CONTINUE
*
*              W := W * V1'
*
               CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K,
     $                     ONE, V, LDV, WORK, LDWORK )
               IF( M.GT.K ) THEN
*
*                 W := W + C2'*V2'
*
                  CALL DGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE,
     $                        C( K+1, 1 ), LDC, V( 1, K+1 ), LDV, ONE,
     $                        WORK, LDWORK )
               END IF
*
*              W := W * T'  or  W * T
*
               CALL DTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*
*              C := C - V' * W'
*
               IF( M.GT.K ) THEN
*
*                 C2 := C2 - V2' * W'
*
                  CALL DGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE,
     $                        V( 1, K+1 ), LDV, WORK, LDWORK, ONE,
     $                        C( K+1, 1 ), LDC )
               END IF
*
*              W := W * V1
*
               CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N,
     $                     K, ONE, V, LDV, WORK, LDWORK )
*
*              C1 := C1 - W'
*
               DO 150 J = 1, K
                  DO 140 I = 1, N
                     C( J, I ) = C( J, I ) - WORK( I, J )
  140             CONTINUE
  150          CONTINUE
*
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN
*
*              Form  C * H  or  C * H'  where  C = ( C1  C2 )
*
*              W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
*
*              W := C1
*
               DO 160 J = 1, K
                  CALL DCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 )
  160          CONTINUE
*
*              W := W * V1'
*
               CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K,
     $                     ONE, V, LDV, WORK, LDWORK )
               IF( N.GT.K ) THEN
*
*                 W := W + C2 * V2'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M, K, N-K,
     $                        ONE, C( 1, K+1 ), LDC, V( 1, K+1 ), LDV,
     $                        ONE, WORK, LDWORK )
               END IF
*
*              W := W * T  or  W * T'
*
               CALL DTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*
*              C := C - W * V
*
               IF( N.GT.K ) THEN
*
*                 C2 := C2 - W * V2
*
                  CALL DGEMM( 'No transpose', 'No transpose', M, N-K, K,
     $                        -ONE, WORK, LDWORK, V( 1, K+1 ), LDV, ONE,
     $                        C( 1, K+1 ), LDC )
               END IF
*
*              W := W * V1
*
               CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M,
     $                     K, ONE, V, LDV, WORK, LDWORK )
*
*              C1 := C1 - W
*
               DO 180 J = 1, K
                  DO 170 I = 1, M
                     C( I, J ) = C( I, J ) - WORK( I, J )
  170             CONTINUE
  180          CONTINUE
*
            END IF
*
         ELSE
*
*           Let  V =  ( V1  V2 )    (V2: last K columns)
*           where  V2  is unit lower triangular.
*
            IF( LSAME( SIDE, 'L' ) ) THEN
*
*              Form  H * C  or  H' * C  where  C = ( C1 )
*                                                  ( C2 )
*
*              W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
*
*              W := C2'
*
               DO 190 J = 1, K
                  CALL DCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )
  190          CONTINUE
*
*              W := W * V2'
*
               CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K,
     $                     ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )
               IF( M.GT.K ) THEN
*
*                 W := W + C1'*V1'
*
                  CALL DGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE,
     $                        C, LDC, V, LDV, ONE, WORK, LDWORK )
               END IF
*
*              W := W * T'  or  W * T
*
               CALL DTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*
*              C := C - V' * W'
*
               IF( M.GT.K ) THEN
*
*                 C1 := C1 - V1' * W'
*
                  CALL DGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE,
     $                        V, LDV, WORK, LDWORK, ONE, C, LDC )
               END IF
*
*              W := W * V2
*
               CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N,
     $                     K, ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )
*
*              C2 := C2 - W'
*
               DO 210 J = 1, K
                  DO 200 I = 1, N
                     C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J )
  200             CONTINUE
  210          CONTINUE
*
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN
*
*              Form  C * H  or  C * H'  where  C = ( C1  C2 )
*
*              W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
*
*              W := C2
*
               DO 220 J = 1, K
                  CALL DCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )
  220          CONTINUE
*
*              W := W * V2'
*
               CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K,
     $                     ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )
               IF( N.GT.K ) THEN
*
*                 W := W + C1 * V1'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M, K, N-K,
     $                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
               END IF
*
*              W := W * T  or  W * T'
*
               CALL DTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*
*              C := C - W * V
*
               IF( N.GT.K ) THEN
*
*                 C1 := C1 - W * V1
*
                  CALL DGEMM( 'No transpose', 'No transpose', M, N-K, K,
     $                        -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC )
               END IF
*
*              W := W * V2
*
               CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M,
     $                     K, ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )
*
*              C1 := C1 - W
*
               DO 240 J = 1, K
                  DO 230 I = 1, M
                     C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )
  230             CONTINUE
  240          CONTINUE
*
            END IF
*
         END IF
      END IF
*
      RETURN
*
*     End of DLARFB
*
      END
      SUBROUTINE DLARFG( N, ALPHA, X, INCX, TAU )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INCX, N
CID      DOUBLE PRECISION   ALPHA, TAU
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   X( * )
      DIMENSION X( * )
*     ..
*
*  Purpose
*  =======
*
*  DLARFG generates a real elementary reflector H of order n, such
*  that
*
*        H * ( alpha ) = ( beta ),   H' * H = I.
*            (   x   )   (   0  )
*
*  where alpha and beta are scalars, and x is an (n-1)-element real
*  vector. H is represented in the form
*
*        H = I - tau * ( 1 ) * ( 1 v' ) ,
*                      ( v )
*
*  where tau is a real scalar and v is a real (n-1)-element
*  vector.
*
*  If the elements of x are all zero, then tau = 0 and H is taken to be
*  the unit matrix.
*
*  Otherwise  1 <= tau <= 2.
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The order of the elementary reflector.
*
*  ALPHA   (input/output) DOUBLE PRECISION
*          On entry, the value alpha.
*          On exit, it is overwritten with the value beta.
*
*  X       (input/output) DOUBLE PRECISION array, dimension
*                         (1+(N-2)*abs(INCX))
*          On entry, the vector x.
*          On exit, it is overwritten with the vector v.
*
*  INCX    (input) INTEGER
*          The increment between elements of X. INCX > 0.
*
*  TAU     (output) DOUBLE PRECISION
*          The value tau.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            J, KNT
CID      DOUBLE PRECISION   BETA, RSAFMN, SAFMIN, XNORM
*     ..
*     .. External Functions ..
CID      DOUBLE PRECISION   DLAMCH, DLAPY2, DNRM2
      EXTERNAL           DLAMCH, DLAPY2, DNRM2
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, SIGN
*     ..
*     .. External Subroutines ..
      EXTERNAL           DSCAL
*     ..
*     .. Executable Statements ..
*
      IF( N.LE.1 ) THEN
         TAU = ZERO
         RETURN
      END IF
*
      XNORM = DNRM2( N-1, X, INCX )
*
      IF( XNORM.EQ.ZERO ) THEN
*
*        H  =  I
*
         TAU = ZERO
      ELSE
*
*        general case
*
         BETA = -SIGN( DLAPY2( ALPHA, XNORM ), ALPHA )
         SAFMIN = DLAMCH( 'S' ) / DLAMCH( 'E' )
         IF( ABS( BETA ).LT.SAFMIN ) THEN
*
*           XNORM, BETA may be inaccurate; scale X and recompute them
*
            RSAFMN = ONE / SAFMIN
            KNT = 0
   10       CONTINUE
            KNT = KNT + 1
            CALL DSCAL( N-1, RSAFMN, X, INCX )
            BETA = BETA*RSAFMN
            ALPHA = ALPHA*RSAFMN
            IF( ABS( BETA ).LT.SAFMIN )
     $         GO TO 10
*
*           New BETA is at most 1, at least SAFMIN
*
            XNORM = DNRM2( N-1, X, INCX )
            BETA = -SIGN( DLAPY2( ALPHA, XNORM ), ALPHA )
            TAU = ( BETA-ALPHA ) / BETA
            CALL DSCAL( N-1, ONE / ( ALPHA-BETA ), X, INCX )
*
*           If ALPHA is subnormal, it may lose relative accuracy
*
            ALPHA = BETA
            DO 20 J = 1, KNT
               ALPHA = ALPHA*SAFMIN
   20       CONTINUE
         ELSE
            TAU = ( BETA-ALPHA ) / BETA
            CALL DSCAL( N-1, ONE / ( ALPHA-BETA ), X, INCX )
            ALPHA = BETA
         END IF
      END IF
*
      RETURN
*
*     End of DLARFG
*
      END
      SUBROUTINE DLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          DIRECT, STOREV
      INTEGER            K, LDT, LDV, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   T( LDT, * ), TAU( * ), V( LDV, * )
      DIMENSION    T( LDT, * ), TAU( * ), V( LDV, * )
*     ..
*
*  Purpose
*  =======
*
*  DLARFT forms the triangular factor T of a real block reflector H
*  of order n, which is defined as a product of k elementary reflectors.
*
*  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
*
*  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
*
*  If STOREV = 'C', the vector which defines the elementary reflector
*  H(i) is stored in the i-th column of the array V, and
*
*     H  =  I - V * T * V'
*
*  If STOREV = 'R', the vector which defines the elementary reflector
*  H(i) is stored in the i-th row of the array V, and
*
*     H  =  I - V' * T * V
*
*  Arguments
*  =========
*
*  DIRECT  (input) CHARACTER*1
*          Specifies the order in which the elementary reflectors are
*          multiplied to form the block reflector:
*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
*
*  STOREV  (input) CHARACTER*1
*          Specifies how the vectors which define the elementary
*          reflectors are stored (see also Further Details):
*          = 'C': columnwise
*          = 'R': rowwise
*
*  N       (input) INTEGER
*          The order of the block reflector H. N >= 0.
*
*  K       (input) INTEGER
*          The order of the triangular factor T (= the number of
*          elementary reflectors). K >= 1.
*
*  V       (input/output) DOUBLE PRECISION array, dimension
*                               (LDV,K) if STOREV = 'C'
*                               (LDV,N) if STOREV = 'R'
*          The matrix V. See further details.
*
*  LDV     (input) INTEGER
*          The leading dimension of the array V.
*          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
*
*  TAU     (input) DOUBLE PRECISION array, dimension (K)
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i).
*
*  T       (output) DOUBLE PRECISION array, dimension (LDT,K)
*          The k by k triangular factor T of the block reflector.
*          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
*          lower triangular. The rest of the array is not used.
*
*  LDT     (input) INTEGER
*          The leading dimension of the array T. LDT >= K.
*
*  Further Details
*  ===============
*
*  The shape of the matrix V and the storage of the vectors which define
*  the H(i) is best illustrated by the following example with n = 5 and
*  k = 3. The elements equal to 1 are not stored; the corresponding
*  array elements are modified but restored on exit. The rest of the
*  array is not used.
*
*  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
*
*               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
*                   ( v1  1    )                     (     1 v2 v2 v2 )
*                   ( v1 v2  1 )                     (        1 v3 v3 )
*                   ( v1 v2 v3 )
*                   ( v1 v2 v3 )
*
*  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
*
*               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
*                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
*                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
*                   (     1 v3 )
*                   (        1 )
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, J
CID      DOUBLE PRECISION   VII
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMV, DTRMV
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. Executable Statements ..
*
*     Quick return if possible
*
      IF( N.EQ.0 )
     $   RETURN
*
      IF( LSAME( DIRECT, 'F' ) ) THEN
         DO 20 I = 1, K
            IF( TAU( I ).EQ.ZERO ) THEN
*
*              H(i)  =  I
*
               DO 10 J = 1, I
                  T( J, I ) = ZERO
   10          CONTINUE
            ELSE
*
*              general case
*
               VII = V( I, I )
               V( I, I ) = ONE
               IF( LSAME( STOREV, 'C' ) ) THEN
*
*                 T(1:i-1,i) := - tau(i) * V(i:n,1:i-1)' * V(i:n,i)
*
                  CALL DGEMV( 'Transpose', N-I+1, I-1, -TAU( I ),
     $                        V( I, 1 ), LDV, V( I, I ), 1, ZERO,
     $                        T( 1, I ), 1 )
               ELSE
*
*                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:n) * V(i,i:n)'
*
                  CALL DGEMV( 'No transpose', I-1, N-I+1, -TAU( I ),
     $                        V( 1, I ), LDV, V( I, I ), LDV, ZERO,
     $                        T( 1, I ), 1 )
               END IF
               V( I, I ) = VII
*
*              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i)
*
               CALL DTRMV( 'Upper', 'No transpose', 'Non-unit', I-1, T,
     $                     LDT, T( 1, I ), 1 )
               T( I, I ) = TAU( I )
            END IF
   20    CONTINUE
      ELSE
         DO 40 I = K, 1, -1
            IF( TAU( I ).EQ.ZERO ) THEN
*
*              H(i)  =  I
*
               DO 30 J = I, K
                  T( J, I ) = ZERO
   30          CONTINUE
            ELSE
*
*              general case
*
               IF( I.LT.K ) THEN
                  IF( LSAME( STOREV, 'C' ) ) THEN
                     VII = V( N-K+I, I )
                     V( N-K+I, I ) = ONE
*
*                    T(i+1:k,i) :=
*                            - tau(i) * V(1:n-k+i,i+1:k)' * V(1:n-k+i,i)
*
                     CALL DGEMV( 'Transpose', N-K+I, K-I, -TAU( I ),
     $                           V( 1, I+1 ), LDV, V( 1, I ), 1, ZERO,
     $                           T( I+1, I ), 1 )
                     V( N-K+I, I ) = VII
                  ELSE
                     VII = V( I, N-K+I )
                     V( I, N-K+I ) = ONE
*
*                    T(i+1:k,i) :=
*                            - tau(i) * V(i+1:k,1:n-k+i) * V(i,1:n-k+i)'
*
                     CALL DGEMV( 'No transpose', K-I, N-K+I, -TAU( I ),
     $                           V( I+1, 1 ), LDV, V( I, 1 ), LDV, ZERO,
     $                           T( I+1, I ), 1 )
                     V( I, N-K+I ) = VII
                  END IF
*
*                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)
*
                  CALL DTRMV( 'Lower', 'No transpose', 'Non-unit', K-I,
     $                        T( I+1, I+1 ), LDT, T( I+1, I ), 1 )
               END IF
               T( I, I ) = TAU( I )
            END IF
   40    CONTINUE
      END IF
      RETURN
*
*     End of DLARFT
*
      END
      SUBROUTINE DLARTG( F, G, CS, SN, R )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION   CS, F, G, R, SN
*     ..
*
*  Purpose
*  =======
*
*  DLARTG generate a plane rotation so that
*
*     [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
*     [ -SN  CS  ]     [ G ]     [ 0 ]
*
*  This is a slower, more accurate version of the BLAS1 routine DROTG,
*  with the following other differences:
*     F and G are unchanged on return.
*     If G=0, then CS=1 and SN=0.
*     If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
*        floating point operations (saves work in DBDSQR when
*        there are zeros on the diagonal).
*
*  If F exceeds G in magnitude, CS will be positive.
*
*  Arguments
*  =========
*
*  F       (input) DOUBLE PRECISION
*          The first component of vector to be rotated.
*
*  G       (input) DOUBLE PRECISION
*          The second component of vector to be rotated.
*
*  CS      (output) DOUBLE PRECISION
*          The cosine of the rotation.
*
*  SN      (output) DOUBLE PRECISION
*          The sine of the rotation.
*
*  R       (output) DOUBLE PRECISION
*          The nonzero component of the rotated vector.
*
*  This version has a few statements commented out for thread safety
*  (machine parameters are computed on each entry). 10 feb 03, SJH.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D0 )
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D0 )
CID      DOUBLE PRECISION   TWO
      PARAMETER          ( TWO = 2.0D0 )
*     ..
*     .. Local Scalars ..
*     LOGICAL            FIRST
      INTEGER            COUNT, I
CID      DOUBLE PRECISION   EPS, F1, G1, SAFMIN, SAFMN2, SAFMX2, SCALE
*     ..
*     .. External Functions ..
CID      DOUBLE PRECISION   DLAMCH
      EXTERNAL           DLAMCH
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, INT, LOG, MAX, SQRT
*     ..
*     .. Save statement ..
*     SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2
*     ..
*     .. Data statements ..
*     DATA               FIRST / .TRUE. /
*     ..
*     .. Executable Statements ..
*
*     IF( FIRST ) THEN
         SAFMIN = DLAMCH( 'S' )
         EPS = DLAMCH( 'E' )
         SAFMN2 = DLAMCH( 'B' )**INT( LOG( SAFMIN / EPS ) /
     $            LOG( DLAMCH( 'B' ) ) / TWO )
         SAFMX2 = ONE / SAFMN2
*        FIRST = .FALSE.
*     END IF
      IF( G.EQ.ZERO ) THEN
         CS = ONE
         SN = ZERO
         R = F
      ELSE IF( F.EQ.ZERO ) THEN
         CS = ZERO
         SN = ONE
         R = G
      ELSE
         F1 = F
         G1 = G
         SCALE = MAX( ABS( F1 ), ABS( G1 ) )
         IF( SCALE.GE.SAFMX2 ) THEN
            COUNT = 0
   10       CONTINUE
            COUNT = COUNT + 1
            F1 = F1*SAFMN2
            G1 = G1*SAFMN2
            SCALE = MAX( ABS( F1 ), ABS( G1 ) )
            IF( SCALE.GE.SAFMX2 )
     $         GO TO 10
            R = SQRT( F1**2+G1**2 )
            CS = F1 / R
            SN = G1 / R
            DO 20 I = 1, COUNT
               R = R*SAFMX2
   20       CONTINUE
         ELSE IF( SCALE.LE.SAFMN2 ) THEN
            COUNT = 0
   30       CONTINUE
            COUNT = COUNT + 1
            F1 = F1*SAFMX2
            G1 = G1*SAFMX2
            SCALE = MAX( ABS( F1 ), ABS( G1 ) )
            IF( SCALE.LE.SAFMN2 )
     $         GO TO 30
            R = SQRT( F1**2+G1**2 )
            CS = F1 / R
            SN = G1 / R
            DO 40 I = 1, COUNT
               R = R*SAFMN2
   40       CONTINUE
         ELSE
            R = SQRT( F1**2+G1**2 )
            CS = F1 / R
            SN = G1 / R
         END IF
         IF( ABS( F ).GT.ABS( G ) .AND. CS.LT.ZERO ) THEN
            CS = -CS
            SN = -SN
            R = -R
         END IF
      END IF
      RETURN
*
*     End of DLARTG
*
      END
      SUBROUTINE DLAS2( F, G, H, SSMIN, SSMAX )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION   F, G, H, SSMAX, SSMIN
*     ..
*
*  Purpose
*  =======
*
*  DLAS2  computes the singular values of the 2-by-2 matrix
*     [  F   G  ]
*     [  0   H  ].
*  On return, SSMIN is the smaller singular value and SSMAX is the
*  larger singular value.
*
*  Arguments
*  =========
*
*  F       (input) DOUBLE PRECISION
*          The (1,1) element of the 2-by-2 matrix.
*
*  G       (input) DOUBLE PRECISION
*          The (1,2) element of the 2-by-2 matrix.
*
*  H       (input) DOUBLE PRECISION
*          The (2,2) element of the 2-by-2 matrix.
*
*  SSMIN   (output) DOUBLE PRECISION
*          The smaller singular value.
*
*  SSMAX   (output) DOUBLE PRECISION
*          The larger singular value.
*
*  Further Details
*  ===============
*
*  Barring over/underflow, all output quantities are correct to within
*  a few units in the last place (ulps), even in the absence of a guard
*  digit in addition/subtraction.
*
*  In IEEE arithmetic, the code works correctly if one matrix element is
*  infinite.
*
*  Overflow will not occur unless the largest singular value itself
*  overflows, or is within a few ulps of overflow. (On machines with
*  partial overflow, like the Cray, overflow may occur if the largest
*  singular value is within a factor of 2 of overflow.)
*
*  Underflow is harmless if underflow is gradual. Otherwise, results
*  may correspond to a matrix modified by perturbations of size near
*  the underflow threshold.
*
*  ====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D0 )
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D0 )
CID      DOUBLE PRECISION   TWO
      PARAMETER          ( TWO = 2.0D0 )
*     ..
*     .. Local Scalars ..
CID      DOUBLE PRECISION   AS, AT, AU, C, FA, FHMN, FHMX, GA, HA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, MAX, MIN, SQRT
*     ..
*     .. Executable Statements ..
*
      FA = ABS( F )
      GA = ABS( G )
      HA = ABS( H )
      FHMN = MIN( FA, HA )
      FHMX = MAX( FA, HA )
      IF( FHMN.EQ.ZERO ) THEN
         SSMIN = ZERO
         IF( FHMX.EQ.ZERO ) THEN
            SSMAX = GA
         ELSE
            SSMAX = MAX( FHMX, GA )*SQRT( ONE+
     $              ( MIN( FHMX, GA ) / MAX( FHMX, GA ) )**2 )
         END IF
      ELSE
         IF( GA.LT.FHMX ) THEN
            AS = ONE + FHMN / FHMX
            AT = ( FHMX-FHMN ) / FHMX
            AU = ( GA / FHMX )**2
            C = TWO / ( SQRT( AS*AS+AU )+SQRT( AT*AT+AU ) )
            SSMIN = FHMN*C
            SSMAX = FHMX / C
         ELSE
            AU = FHMX / GA
            IF( AU.EQ.ZERO ) THEN
*
*              Avoid possible harmful underflow if exponent range
*              asymmetric (true SSMIN may not underflow even if
*              AU underflows)
*
               SSMIN = ( FHMN*FHMX ) / GA
               SSMAX = GA
            ELSE
               AS = ONE + FHMN / FHMX
               AT = ( FHMX-FHMN ) / FHMX
               C = ONE / ( SQRT( ONE+( AS*AU )**2 )+
     $             SQRT( ONE+( AT*AU )**2 ) )
               SSMIN = ( FHMN*C )*AU
               SSMIN = SSMIN + SSMIN
               SSMAX = GA / ( C+C )
            END IF
         END IF
      END IF
      RETURN
*
*     End of DLAS2
*
      END
      SUBROUTINE DLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          TYPE
      INTEGER            INFO, KL, KU, LDA, M, N
CID      DOUBLE PRECISION   CFROM, CTO
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * )
      DIMENSION A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DLASCL multiplies the M by N real matrix A by the real scalar
*  CTO/CFROM.  This is done without over/underflow as long as the final
*  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
*  A may be full, upper triangular, lower triangular, upper Hessenberg,
*  or banded.
*
*  Arguments
*  =========
*
*  TYPE    (input) CHARACTER*1
*          TYPE indices the storage type of the input matrix.
*          = 'G':  A is a full matrix.
*          = 'L':  A is a lower triangular matrix.
*          = 'U':  A is an upper triangular matrix.
*          = 'H':  A is an upper Hessenberg matrix.
*          = 'B':  A is a symmetric band matrix with lower bandwidth KL
*                  and upper bandwidth KU and with the only the lower
*                  half stored.
*          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
*                  and upper bandwidth KU and with the only the upper
*                  half stored.
*          = 'Z':  A is a band matrix with lower bandwidth KL and upper
*                  bandwidth KU.
*
*  KL      (input) INTEGER
*          The lower bandwidth of A.  Referenced only if TYPE = 'B',
*          'Q' or 'Z'.
*
*  KU      (input) INTEGER
*          The upper bandwidth of A.  Referenced only if TYPE = 'B',
*          'Q' or 'Z'.
*
*  CFROM   (input) DOUBLE PRECISION
*  CTO     (input) DOUBLE PRECISION
*          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
*          without over/underflow if the final result CTO*A(I,J)/CFROM
*          can be represented without over/underflow.  CFROM must be
*          nonzero.
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          The matrix to be multiplied by CTO/CFROM.  See TYPE for the
*          storage type.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  INFO    (output) INTEGER
*          0  - successful exit
*          <0 - if INFO = -i, the i-th argument had an illegal value.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            DONE
      INTEGER            I, ITYPE, J, K1, K2, K3, K4
CID      DOUBLE PRECISION   BIGNUM, CFROM1, CFROMC, CTO1, CTOC, MUL, SMLNUM
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
CID      DOUBLE PRECISION   DLAMCH
      EXTERNAL           LSAME, DLAMCH
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, MAX, MIN
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
*
      IF( LSAME( TYPE, 'G' ) ) THEN
         ITYPE = 0
      ELSE IF( LSAME( TYPE, 'L' ) ) THEN
         ITYPE = 1
      ELSE IF( LSAME( TYPE, 'U' ) ) THEN
         ITYPE = 2
      ELSE IF( LSAME( TYPE, 'H' ) ) THEN
         ITYPE = 3
      ELSE IF( LSAME( TYPE, 'B' ) ) THEN
         ITYPE = 4
      ELSE IF( LSAME( TYPE, 'Q' ) ) THEN
         ITYPE = 5
      ELSE IF( LSAME( TYPE, 'Z' ) ) THEN
         ITYPE = 6
      ELSE
         ITYPE = -1
      END IF
*
      IF( ITYPE.EQ.-1 ) THEN
         INFO = -1
      ELSE IF( CFROM.EQ.ZERO ) THEN
         INFO = -4
      ELSE IF( M.LT.0 ) THEN
         INFO = -6
      ELSE IF( N.LT.0 .OR. ( ITYPE.EQ.4 .AND. N.NE.M ) .OR.
     $         ( ITYPE.EQ.5 .AND. N.NE.M ) ) THEN
         INFO = -7
      ELSE IF( ITYPE.LE.3 .AND. LDA.LT.MAX( 1, M ) ) THEN
         INFO = -9
      ELSE IF( ITYPE.GE.4 ) THEN
         IF( KL.LT.0 .OR. KL.GT.MAX( M-1, 0 ) ) THEN
            INFO = -2
         ELSE IF( KU.LT.0 .OR. KU.GT.MAX( N-1, 0 ) .OR.
     $            ( ( ITYPE.EQ.4 .OR. ITYPE.EQ.5 ) .AND. KL.NE.KU ) )
     $             THEN
            INFO = -3
         ELSE IF( ( ITYPE.EQ.4 .AND. LDA.LT.KL+1 ) .OR.
     $            ( ITYPE.EQ.5 .AND. LDA.LT.KU+1 ) .OR.
     $            ( ITYPE.EQ.6 .AND. LDA.LT.2*KL+KU+1 ) ) THEN
            INFO = -9
         END IF
      END IF
*
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DLASCL', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 .OR. M.EQ.0 )
     $   RETURN
*
*     Get machine parameters
*
      SMLNUM = DLAMCH( 'S' )
      BIGNUM = ONE / SMLNUM
*
      CFROMC = CFROM
      CTOC = CTO
*
   10 CONTINUE
      CFROM1 = CFROMC*SMLNUM
      CTO1 = CTOC / BIGNUM
      IF( ABS( CFROM1 ).GT.ABS( CTOC ) .AND. CTOC.NE.ZERO ) THEN
         MUL = SMLNUM
         DONE = .FALSE.
         CFROMC = CFROM1
      ELSE IF( ABS( CTO1 ).GT.ABS( CFROMC ) ) THEN
         MUL = BIGNUM
         DONE = .FALSE.
         CTOC = CTO1
      ELSE
         MUL = CTOC / CFROMC
         DONE = .TRUE.
      END IF
*
      IF( ITYPE.EQ.0 ) THEN
*
*        Full matrix
*
         DO 30 J = 1, N
            DO 20 I = 1, M
               A( I, J ) = A( I, J )*MUL
   20       CONTINUE
   30    CONTINUE
*
      ELSE IF( ITYPE.EQ.1 ) THEN
*
*        Lower triangular matrix
*
         DO 50 J = 1, N
            DO 40 I = J, M
               A( I, J ) = A( I, J )*MUL
   40       CONTINUE
   50    CONTINUE
*
      ELSE IF( ITYPE.EQ.2 ) THEN
*
*        Upper triangular matrix
*
         DO 70 J = 1, N
            DO 60 I = 1, MIN( J, M )
               A( I, J ) = A( I, J )*MUL
   60       CONTINUE
   70    CONTINUE
*
      ELSE IF( ITYPE.EQ.3 ) THEN
*
*        Upper Hessenberg matrix
*
         DO 90 J = 1, N
            DO 80 I = 1, MIN( J+1, M )
               A( I, J ) = A( I, J )*MUL
   80       CONTINUE
   90    CONTINUE
*
      ELSE IF( ITYPE.EQ.4 ) THEN
*
*        Lower half of a symmetric band matrix
*
         K3 = KL + 1
         K4 = N + 1
         DO 110 J = 1, N
            DO 100 I = 1, MIN( K3, K4-J )
               A( I, J ) = A( I, J )*MUL
  100       CONTINUE
  110    CONTINUE
*
      ELSE IF( ITYPE.EQ.5 ) THEN
*
*        Upper half of a symmetric band matrix
*
         K1 = KU + 2
         K3 = KU + 1
         DO 130 J = 1, N
            DO 120 I = MAX( K1-J, 1 ), K3
               A( I, J ) = A( I, J )*MUL
  120       CONTINUE
  130    CONTINUE
*
      ELSE IF( ITYPE.EQ.6 ) THEN
*
*        Band matrix
*
         K1 = KL + KU + 2
         K2 = KL + 1
         K3 = 2*KL + KU + 1
         K4 = KL + KU + 1 + M
         DO 150 J = 1, N
            DO 140 I = MAX( K1-J, K2 ), MIN( K3, K4-J )
               A( I, J ) = A( I, J )*MUL
  140       CONTINUE
  150    CONTINUE
*
      END IF
*
      IF( .NOT.DONE )
     $   GO TO 10
*
      RETURN
*
*     End of DLASCL
*
      END
      SUBROUTINE DLASET( UPLO, M, N, ALPHA, BETA, A, LDA )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          UPLO
      INTEGER            LDA, M, N
CID      DOUBLE PRECISION   ALPHA, BETA
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * )
      DIMENSION A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DLASET initializes an m-by-n matrix A to BETA on the diagonal and
*  ALPHA on the offdiagonals.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          Specifies the part of the matrix A to be set.
*          = 'U':      Upper triangular part is set; the strictly lower
*                      triangular part of A is not changed.
*          = 'L':      Lower triangular part is set; the strictly upper
*                      triangular part of A is not changed.
*          Otherwise:  All of the matrix A is set.
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  ALPHA   (input) DOUBLE PRECISION
*          The constant to which the offdiagonal elements are to be set.
*
*  BETA    (input) DOUBLE PRECISION
*          The constant to which the diagonal elements are to be set.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On exit, the leading m-by-n submatrix of A is set as follows:
*
*          if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,
*          if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,
*          otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,
*
*          and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
* =====================================================================
*
*     .. Local Scalars ..
      INTEGER            I, J
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MIN
*     ..
*     .. Executable Statements ..
*
      IF( LSAME( UPLO, 'U' ) ) THEN
*
*        Set the strictly upper triangular or trapezoidal part of the
*        array to ALPHA.
*
         DO 20 J = 2, N
            DO 10 I = 1, MIN( J-1, M )
               A( I, J ) = ALPHA
   10       CONTINUE
   20    CONTINUE
*
      ELSE IF( LSAME( UPLO, 'L' ) ) THEN
*
*        Set the strictly lower triangular or trapezoidal part of the
*        array to ALPHA.
*
         DO 40 J = 1, MIN( M, N )
            DO 30 I = J + 1, M
               A( I, J ) = ALPHA
   30       CONTINUE
   40    CONTINUE
*
      ELSE
*
*        Set the leading m-by-n submatrix to ALPHA.
*
         DO 60 J = 1, N
            DO 50 I = 1, M
               A( I, J ) = ALPHA
   50       CONTINUE
   60    CONTINUE
      END IF
*
*     Set the first min(M,N) diagonal elements to BETA.
*
      DO 70 I = 1, MIN( M, N )
         A( I, I ) = BETA
   70 CONTINUE
*
      RETURN
*
*     End of DLASET
*
      END
      SUBROUTINE DLASQ1( N, D, E, WORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   D( * ), E( * ), WORK( * )
      DIMENSION D( * ), E( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DLASQ1 computes the singular values of a real N-by-N bidiagonal
*  matrix with diagonal D and off-diagonal E. The singular values
*  are computed to high relative accuracy, in the absence of
*  denormalization, underflow and overflow. The algorithm was first
*  presented in
*
*  "Accurate singular values and differential qd algorithms" by K. V.
*  Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
*  1994,
*
*  and the present implementation is described in "An implementation of
*  the dqds Algorithm (Positive Case)", LAPACK Working Note.
*
*  Arguments
*  =========
*
*  N     (input) INTEGER
*        The number of rows and columns in the matrix. N >= 0.
*
*  D     (input/output) DOUBLE PRECISION array, dimension (N)
*        On entry, D contains the diagonal elements of the
*        bidiagonal matrix whose SVD is desired. On normal exit,
*        D contains the singular values in decreasing order.
*
*  E     (input/output) DOUBLE PRECISION array, dimension (N)
*        On entry, elements E(1:N-1) contain the off-diagonal elements
*        of the bidiagonal matrix whose SVD is desired.
*        On exit, E is overwritten.
*
*  WORK  (workspace) DOUBLE PRECISION array, dimension (4*N)
*
*  INFO  (output) INTEGER
*        = 0: successful exit
*        < 0: if INFO = -i, the i-th argument had an illegal value
*        > 0: the algorithm failed
*             = 1, a split was marked by a positive value in E
*             = 2, current block of Z not diagonalized after 30*N
*                  iterations (in inner while loop)
*             = 3, termination criterion of outer while loop not met 
*                  (program created more than N unreduced blocks)
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, IINFO
CID      DOUBLE PRECISION   EPS, SCALE, SAFMIN, SIGMN, SIGMX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DCOPY, DLAS2, DLASCL, DLASQ2, DLASRT, XERBLA
*     ..
*     .. External Functions ..
CID      DOUBLE PRECISION   DLAMCH
      EXTERNAL           DLAMCH
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, MAX, SQRT
*     ..
*     .. Executable Statements ..
*
      INFO = 0
      IF( N.LT.0 ) THEN
         INFO = -2
         CALL XERBLA( 'DLASQ1', -INFO )
         RETURN
      ELSE IF( N.EQ.0 ) THEN
         RETURN
      ELSE IF( N.EQ.1 ) THEN
         D( 1 ) = ABS( D( 1 ) )
         RETURN
      ELSE IF( N.EQ.2 ) THEN
         CALL DLAS2( D( 1 ), E( 1 ), D( 2 ), SIGMN, SIGMX )
         D( 1 ) = SIGMX
         D( 2 ) = SIGMN
         RETURN
      END IF
*
*     Estimate the largest singular value.
*
      SIGMX = ZERO
      DO 10 I = 1, N - 1
         D( I ) = ABS( D( I ) )
         SIGMX = MAX( SIGMX, ABS( E( I ) ) )
   10 CONTINUE
      D( N ) = ABS( D( N ) )
*
*     Early return if SIGMX is zero (matrix is already diagonal).
*
      IF( SIGMX.EQ.ZERO ) THEN
         CALL DLASRT( 'D', N, D, IINFO )
         RETURN
      END IF
*
      DO 20 I = 1, N
         SIGMX = MAX( SIGMX, D( I ) )
   20 CONTINUE
*
*     Copy D and E into WORK (in the Z format) and scale (squaring the
*     input data makes scaling by a power of the radix pointless).
*
      EPS = DLAMCH( 'Precision' )
      SAFMIN = DLAMCH( 'Safe minimum' )
      SCALE = SQRT( EPS / SAFMIN )
      CALL DCOPY( N, D, 1, WORK( 1 ), 2 )
      CALL DCOPY( N-1, E, 1, WORK( 2 ), 2 )
      CALL DLASCL( 'G', 0, 0, SIGMX, SCALE, 2*N-1, 1, WORK, 2*N-1,
     $             IINFO )
*         
*     Compute the q's and e's.
*
      DO 30 I = 1, 2*N - 1
         WORK( I ) = WORK( I )**2
   30 CONTINUE
      WORK( 2*N ) = ZERO
*
      CALL DLASQ2( N, WORK, INFO )
*
      IF( INFO.EQ.0 ) THEN
         DO 40 I = 1, N
            D( I ) = SQRT( WORK( I ) )
   40    CONTINUE
         CALL DLASCL( 'G', 0, 0, SCALE, SIGMX, N, 1, D, N, IINFO )
      END IF
*
      RETURN
*
*     End of DLASQ1
*
      END
      SUBROUTINE DLASQ2( N, Z, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     Modified to call DLAZQ3 in place of DLASQ3, 13 Feb 03, SJH.
*
*     .. Scalar Arguments ..
      INTEGER            INFO, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   Z( * )
      DIMENSION  Z( * )
*     ..
*
*  Purpose
*  =======
*
*  DLASQ2 computes all the eigenvalues of the symmetric positive 
*  definite tridiagonal matrix associated with the qd array Z to high
*  relative accuracy are computed to high relative accuracy, in the
*  absence of denormalization, underflow and overflow.
*
*  To see the relation of Z to the tridiagonal matrix, let L be a
*  unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
*  let U be an upper bidiagonal matrix with 1's above and diagonal
*  Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
*  symmetric tridiagonal to which it is similar.
*
*  Note : DLASQ2 defines a logical variable, IEEE, which is true
*  on machines which follow ieee-754 floating-point standard in their
*  handling of infinities and NaNs, and false otherwise. This variable
*  is passed to DLAZQ3.
*
*  Arguments
*  =========
*
*  N     (input) INTEGER
*        The number of rows and columns in the matrix. N >= 0.
*
*  Z     (workspace) DOUBLE PRECISION array, dimension ( 4*N )
*        On entry Z holds the qd array. On exit, entries 1 to N hold
*        the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
*        trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
*        N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
*        holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
*        shifts that failed.
*
*  INFO  (output) INTEGER
*        = 0: successful exit
*        < 0: if the i-th argument is a scalar and had an illegal
*             value, then INFO = -i, if the i-th argument is an
*             array and the j-entry had an illegal value, then
*             INFO = -(i*100+j)
*        > 0: the algorithm failed
*              = 1, a split was marked by a positive value in E
*              = 2, current block of Z not diagonalized after 30*N
*                   iterations (in inner while loop)
*              = 3, termination criterion of outer while loop not met 
*                   (program created more than N unreduced blocks)
*
*  Further Details
*  ===============
*  Local Variables: I0:N0 defines a current unreduced segment of Z.
*  The shifts are accumulated in SIGMA. Iteration count is in ITER.
*  Ping-pong is controlled by PP (alternates between 0 and 1).
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   CBIAS
      PARAMETER          ( CBIAS = 1.50D0 )
CID      DOUBLE PRECISION   ZERO, HALF, ONE, TWO, FOUR, HUNDRD
      PARAMETER          ( ZERO = 0.0D0, HALF = 0.5D0, ONE = 1.0D0,
     $                     TWO = 2.0D0, FOUR = 4.0D0, HUNDRD = 100.0D0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            IEEE
      INTEGER            I0, I4, IINFO, IPN4, ITER, IWHILA, IWHILB, K, 
     $                   N0, NBIG, NDIV, NFAIL, PP, SPLT, TTYPE
CID      DOUBLE PRECISION   D, DESIG, DMIN, DMIN1, DMIN2, DN, DN1, DN2, E,
CID     $                   EMAX, EMIN, EPS, OLDEMN, QMAX, QMIN, S, SAFMIN,
CID     $                   SIGMA, T, TAU, TEMP, TOL, TOL2, TRACE, ZMAX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLAZQ3, DLASRT, XERBLA
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
CID      DOUBLE PRECISION   DLAMCH
      EXTERNAL           DLAMCH, ILAENV
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, DBLE, MAX, MIN, SQRT
*     ..
*     .. Executable Statements ..
*      
*     Test the input arguments.
*     (in case DLASQ2 is not called by DLASQ1)
*
      INFO = 0
      EPS = DLAMCH( 'Precision' )
      SAFMIN = DLAMCH( 'Safe minimum' )
      TOL = EPS*HUNDRD
      TOL2 = TOL**2
*
      IF( N.LT.0 ) THEN
         INFO = -1
         CALL XERBLA( 'DLASQ2', 1 )
         RETURN
      ELSE IF( N.EQ.0 ) THEN
         RETURN
      ELSE IF( N.EQ.1 ) THEN
*
*        1-by-1 case.
*
         IF( Z( 1 ).LT.ZERO ) THEN
            INFO = -201
            CALL XERBLA( 'DLASQ2', 2 )
         END IF
         RETURN
      ELSE IF( N.EQ.2 ) THEN
*
*        2-by-2 case.
*
         IF( Z( 2 ).LT.ZERO .OR. Z( 3 ).LT.ZERO ) THEN
            INFO = -2
            CALL XERBLA( 'DLASQ2', 2 )
            RETURN
         ELSE IF( Z( 3 ).GT.Z( 1 ) ) THEN
            D = Z( 3 )
            Z( 3 ) = Z( 1 )
            Z( 1 ) = D
         END IF
         Z( 5 ) = Z( 1 ) + Z( 2 ) + Z( 3 )
         IF( Z( 2 ).GT.Z( 3 )*TOL2 ) THEN
            T = HALF*( ( Z( 1 )-Z( 3 ) )+Z( 2 ) ) 
            S = Z( 3 )*( Z( 2 ) / T )
            IF( S.LE.T ) THEN
               S = Z( 3 )*( Z( 2 ) / ( T*( ONE+SQRT( ONE+S / T ) ) ) )
            ELSE
               S = Z( 3 )*( Z( 2 ) / ( T+SQRT( T )*SQRT( T+S ) ) )
            END IF
            T = Z( 1 ) + ( S+Z( 2 ) )
            Z( 3 ) = Z( 3 )*( Z( 1 ) / T )
            Z( 1 ) = T
         END IF
         Z( 2 ) = Z( 3 )
         Z( 6 ) = Z( 2 ) + Z( 1 )
         RETURN
      END IF
*
*     Check for negative data and compute sums of q's and e's.
*
      Z( 2*N ) = ZERO
      EMIN = Z( 2 )
      QMAX = ZERO
      ZMAX = ZERO
      D = ZERO
      E = ZERO
*
      DO 10 K = 1, 2*( N-1 ), 2
         IF( Z( K ).LT.ZERO ) THEN
            INFO = -( 200+K )
            CALL XERBLA( 'DLASQ2', 2 )
            RETURN
         ELSE IF( Z( K+1 ).LT.ZERO ) THEN
            INFO = -( 200+K+1 )
            CALL XERBLA( 'DLASQ2', 2 )
            RETURN
         END IF
         D = D + Z( K )
         E = E + Z( K+1 )
         QMAX = MAX( QMAX, Z( K ) )
         EMIN = MIN( EMIN, Z( K+1 ) )
         ZMAX = MAX( QMAX, ZMAX, Z( K+1 ) )
   10 CONTINUE
      IF( Z( 2*N-1 ).LT.ZERO ) THEN
         INFO = -( 200+2*N-1 )
         CALL XERBLA( 'DLASQ2', 2 )
         RETURN
      END IF
      D = D + Z( 2*N-1 )
      QMAX = MAX( QMAX, Z( 2*N-1 ) )
      ZMAX = MAX( QMAX, ZMAX )
*
*     Check for diagonality.
*
      IF( E.EQ.ZERO ) THEN
         DO 20 K = 2, N
            Z( K ) = Z( 2*K-1 )
   20    CONTINUE
         CALL DLASRT( 'D', N, Z, IINFO )
         Z( 2*N-1 ) = D
         RETURN
      END IF
*
      TRACE = D + E
*
*     Check for zero data.
*
      IF( TRACE.EQ.ZERO ) THEN
         Z( 2*N-1 ) = ZERO
         RETURN
      END IF
*         
*     Check whether the machine is IEEE conformable.
*         
      IEEE = ILAENV( 10, 'DLASQ2', 'N', 1, 2, 3, 4 ).EQ.1 .AND.
     $       ILAENV( 11, 'DLASQ2', 'N', 1, 2, 3, 4 ).EQ.1      
*         
*     Rearrange data for locality: Z=(q1,qq1,e1,ee1,q2,qq2,e2,ee2,...).
*
      DO 30 K = 2*N, 2, -2
         Z( 2*K ) = ZERO 
         Z( 2*K-1 ) = Z( K ) 
         Z( 2*K-2 ) = ZERO 
         Z( 2*K-3 ) = Z( K-1 ) 
   30 CONTINUE
*
      I0 = 1
      N0 = N
*
*     Reverse the qd-array, if warranted.
*
      IF( CBIAS*Z( 4*I0-3 ).LT.Z( 4*N0-3 ) ) THEN
         IPN4 = 4*( I0+N0 )
         DO 40 I4 = 4*I0, 2*( I0+N0-1 ), 4
            TEMP = Z( I4-3 )
            Z( I4-3 ) = Z( IPN4-I4-3 )
            Z( IPN4-I4-3 ) = TEMP
            TEMP = Z( I4-1 )
            Z( I4-1 ) = Z( IPN4-I4-5 )
            Z( IPN4-I4-5 ) = TEMP
   40    CONTINUE
      END IF
*
*     Initial split checking via dqd and Li's test.
*
      PP = 0
*
      DO 80 K = 1, 2
*
         D = Z( 4*N0+PP-3 )
         DO 50 I4 = 4*( N0-1 ) + PP, 4*I0 + PP, -4
            IF( Z( I4-1 ).LE.TOL2*D ) THEN
               Z( I4-1 ) = -ZERO
               D = Z( I4-3 )
            ELSE
               D = Z( I4-3 )*( D / ( D+Z( I4-1 ) ) )
            END IF
   50    CONTINUE
*
*        dqd maps Z to ZZ plus Li's test.
*
         EMIN = Z( 4*I0+PP+1 )
         D = Z( 4*I0+PP-3 )
         DO 60 I4 = 4*I0 + PP, 4*( N0-1 ) + PP, 4
            Z( I4-2*PP-2 ) = D + Z( I4-1 )
            IF( Z( I4-1 ).LE.TOL2*D ) THEN
               Z( I4-1 ) = -ZERO
               Z( I4-2*PP-2 ) = D
               Z( I4-2*PP ) = ZERO
               D = Z( I4+1 )
            ELSE IF( SAFMIN*Z( I4+1 ).LT.Z( I4-2*PP-2 ) .AND.
     $               SAFMIN*Z( I4-2*PP-2 ).LT.Z( I4+1 ) ) THEN
               TEMP = Z( I4+1 ) / Z( I4-2*PP-2 )
               Z( I4-2*PP ) = Z( I4-1 )*TEMP
               D = D*TEMP
            ELSE
               Z( I4-2*PP ) = Z( I4+1 )*( Z( I4-1 ) / Z( I4-2*PP-2 ) )
               D = Z( I4+1 )*( D / Z( I4-2*PP-2 ) )
            END IF
            EMIN = MIN( EMIN, Z( I4-2*PP ) )
   60    CONTINUE 
         Z( 4*N0-PP-2 ) = D
*
*        Now find qmax.
*
         QMAX = Z( 4*I0-PP-2 )
         DO 70 I4 = 4*I0 - PP + 2, 4*N0 - PP - 2, 4
            QMAX = MAX( QMAX, Z( I4 ) )
   70    CONTINUE
*
*        Prepare for the next iteration on K.
*
         PP = 1 - PP
   80 CONTINUE
*
*     Initialise variables to pass to DLAZQ3
*
      TTYPE = 0
      DMIN1 = ZERO
      DMIN2 = ZERO
      DN    = ZERO
      DN1   = ZERO
      DN2   = ZERO
      TAU   = ZERO
*
      ITER = 2
      NFAIL = 0
      NDIV = 2*( N0-I0 )
*
      DO 140 IWHILA = 1, N + 1
         IF( N0.LT.1 ) 
     $      GO TO 150
*
*        While array unfinished do 
*
*        E(N0) holds the value of SIGMA when submatrix in I0:N0
*        splits from the rest of the array, but is negated.
*      
         DESIG = ZERO
         IF( N0.EQ.N ) THEN
            SIGMA = ZERO
         ELSE
            SIGMA = -Z( 4*N0-1 )
         END IF
         IF( SIGMA.LT.ZERO ) THEN
            INFO = 1
            RETURN
         END IF
*
*        Find last unreduced submatrix's top index I0, find QMAX and
*        EMIN. Find Gershgorin-type bound if Q's much greater than E's.
*
         EMAX = ZERO 
         IF( N0.GT.I0 ) THEN
            EMIN = ABS( Z( 4*N0-5 ) )
         ELSE
            EMIN = ZERO
         END IF
         QMIN = Z( 4*N0-3 )
         QMAX = QMIN
         DO 90 I4 = 4*N0, 8, -4
            IF( Z( I4-5 ).LE.ZERO )
     $         GO TO 100
            IF( QMIN.GE.FOUR*EMAX ) THEN
               QMIN = MIN( QMIN, Z( I4-3 ) )
               EMAX = MAX( EMAX, Z( I4-5 ) )
            END IF
            QMAX = MAX( QMAX, Z( I4-7 )+Z( I4-5 ) )
            EMIN = MIN( EMIN, Z( I4-5 ) )
   90    CONTINUE
         I4 = 4 
*
  100    CONTINUE
         I0 = I4 / 4
*
*        Store EMIN for passing to DLAZQ3.
*
         Z( 4*N0-1 ) = EMIN
*
*        Put -(initial shift) into DMIN.
*
         DMIN = -MAX( ZERO, QMIN-TWO*SQRT( QMIN )*SQRT( EMAX ) )
*
*        Now I0:N0 is unreduced. PP = 0 for ping, PP = 1 for pong.
*
         PP = 0 
*
         NBIG = 30*( N0-I0+1 )
         DO 120 IWHILB = 1, NBIG
            IF( I0.GT.N0 ) 
     $         GO TO 130
*
*           While submatrix unfinished take a good dqds step.
*
            CALL DLAZQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL,
     $                   ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2, DN, DN1,
     $                   DN2, TAU )
*
            PP = 1 - PP
*
*           When EMIN is very small check for splits.
*
            IF( PP.EQ.0 .AND. N0-I0.GE.3 ) THEN
               IF( Z( 4*N0 ).LE.TOL2*QMAX .OR.
     $             Z( 4*N0-1 ).LE.TOL2*SIGMA ) THEN
                  SPLT = I0 - 1
                  QMAX = Z( 4*I0-3 )
                  EMIN = Z( 4*I0-1 )
                  OLDEMN = Z( 4*I0 )
                  DO 110 I4 = 4*I0, 4*( N0-3 ), 4
                     IF( Z( I4 ).LE.TOL2*Z( I4-3 ) .OR.
     $                   Z( I4-1 ).LE.TOL2*SIGMA ) THEN
                        Z( I4-1 ) = -SIGMA
                        SPLT = I4 / 4
                        QMAX = ZERO
                        EMIN = Z( I4+3 )
                        OLDEMN = Z( I4+4 )
                     ELSE
                        QMAX = MAX( QMAX, Z( I4+1 ) )
                        EMIN = MIN( EMIN, Z( I4-1 ) )
                        OLDEMN = MIN( OLDEMN, Z( I4 ) )
                     END IF
  110             CONTINUE
                  Z( 4*N0-1 ) = EMIN
                  Z( 4*N0 ) = OLDEMN
                  I0 = SPLT + 1
               END IF
            END IF
*
  120    CONTINUE
*
         INFO = 2
         RETURN
*
*        end IWHILB
*
  130    CONTINUE
*
  140 CONTINUE
*
      INFO = 3
      RETURN
*
*     end IWHILA   
*
  150 CONTINUE
*      
*     Move q's to the front.
*      
      DO 160 K = 2, N
         Z( K ) = Z( 4*K-3 )
  160 CONTINUE
*      
*     Sort and compute sum of eigenvalues.
*
      CALL DLASRT( 'D', N, Z, IINFO )
*
      E = ZERO
      DO 170 K = N, 1, -1
         E = E + Z( K )
  170 CONTINUE
*
*     Store trace, sum(eigenvalues) and information on performance.
*
      Z( 2*N+1 ) = TRACE 
      Z( 2*N+2 ) = E
      Z( 2*N+3 ) = DBLE( ITER )
      Z( 2*N+4 ) = DBLE( NDIV ) / DBLE( N**2 )
      Z( 2*N+5 ) = HUNDRD*NFAIL / DBLE( ITER )
      RETURN
*
*     End of DLASQ2
*
      END
      SUBROUTINE DLASQ5( I0, N0, Z, PP, TAU, DMIN, DMIN1, DMIN2, DN,
     $                   DNM1, DNM2, IEEE )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      LOGICAL            IEEE
      INTEGER            I0, N0, PP
CID      DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DNM1, DNM2, TAU
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   Z( * )
      DIMENSION    Z( * )
*     ..
*
*  Purpose
*  =======
*
*  DLASQ5 computes one dqds transform in ping-pong form, one
*  version for IEEE machines another for non IEEE machines.
*
*  Arguments
*  =========
*
*  I0    (input) INTEGER
*        First index.
*
*  N0    (input) INTEGER
*        Last index.
*
*  Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
*        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
*        an extra argument.
*
*  PP    (input) INTEGER
*        PP=0 for ping, PP=1 for pong.
*
*  TAU   (input) DOUBLE PRECISION
*        This is the shift.
*
*  DMIN  (output) DOUBLE PRECISION
*        Minimum value of d.
*
*  DMIN1 (output) DOUBLE PRECISION
*        Minimum value of d, excluding D( N0 ).
*
*  DMIN2 (output) DOUBLE PRECISION
*        Minimum value of d, excluding D( N0 ) and D( N0-1 ).
*
*  DN    (output) DOUBLE PRECISION
*        d(N0), the last value of d.
*
*  DNM1  (output) DOUBLE PRECISION
*        d(N0-1).
*
*  DNM2  (output) DOUBLE PRECISION
*        d(N0-2).
*
*  IEEE  (input) LOGICAL
*        Flag for IEEE or non IEEE arithmetic.
*
*  =====================================================================
*
*     .. Parameter ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D0 )
*     ..
*     .. Local Scalars ..
      INTEGER            J4, J4P2
CID      DOUBLE PRECISION   D, EMIN, TEMP
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MIN
*     ..
*     .. Executable Statements ..
*
      IF( ( N0-I0-1 ).LE.0 )
     $   RETURN
*
      J4 = 4*I0 + PP - 3
      EMIN = Z( J4+4 )
      D = Z( J4 ) - TAU
      DMIN = D
      DMIN1 = -Z( J4 )
*
      IF( IEEE ) THEN
*
*        Code for IEEE arithmetic.
*
         IF( PP.EQ.0 ) THEN
            DO 10 J4 = 4*I0, 4*( N0-3 ), 4
               Z( J4-2 ) = D + Z( J4-1 )
               TEMP = Z( J4+1 ) / Z( J4-2 )
               D = D*TEMP - TAU
               DMIN = MIN( DMIN, D )
               Z( J4 ) = Z( J4-1 )*TEMP
               EMIN = MIN( Z( J4 ), EMIN )
   10       CONTINUE
         ELSE
            DO 20 J4 = 4*I0, 4*( N0-3 ), 4
               Z( J4-3 ) = D + Z( J4 )
               TEMP = Z( J4+2 ) / Z( J4-3 )
               D = D*TEMP - TAU
               DMIN = MIN( DMIN, D )
               Z( J4-1 ) = Z( J4 )*TEMP
               EMIN = MIN( Z( J4-1 ), EMIN )
   20       CONTINUE
         END IF
*
*        Unroll last two steps.
*
         DNM2 = D
         DMIN2 = DMIN
         J4 = 4*( N0-2 ) - PP
         J4P2 = J4 + 2*PP - 1
         Z( J4-2 ) = DNM2 + Z( J4P2 )
         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
         DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU
         DMIN = MIN( DMIN, DNM1 )
*
         DMIN1 = DMIN
         J4 = J4 + 4
         J4P2 = J4 + 2*PP - 1
         Z( J4-2 ) = DNM1 + Z( J4P2 )
         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
         DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU
         DMIN = MIN( DMIN, DN )
*
      ELSE
*
*        Code for non IEEE arithmetic.
*
         IF( PP.EQ.0 ) THEN
            DO 30 J4 = 4*I0, 4*( N0-3 ), 4
               Z( J4-2 ) = D + Z( J4-1 )
               IF( D.LT.ZERO ) THEN
                  RETURN
               ELSE
                  Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) )
                  D = Z( J4+1 )*( D / Z( J4-2 ) ) - TAU
               END IF
               DMIN = MIN( DMIN, D )
               EMIN = MIN( EMIN, Z( J4 ) )
   30       CONTINUE
         ELSE
            DO 40 J4 = 4*I0, 4*( N0-3 ), 4
               Z( J4-3 ) = D + Z( J4 )
               IF( D.LT.ZERO ) THEN
                  RETURN
               ELSE
                  Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) )
                  D = Z( J4+2 )*( D / Z( J4-3 ) ) - TAU
               END IF
               DMIN = MIN( DMIN, D )
               EMIN = MIN( EMIN, Z( J4-1 ) )
   40       CONTINUE
         END IF
*
*        Unroll last two steps.
*
         DNM2 = D
         DMIN2 = DMIN
         J4 = 4*( N0-2 ) - PP
         J4P2 = J4 + 2*PP - 1
         Z( J4-2 ) = DNM2 + Z( J4P2 )
         IF( DNM2.LT.ZERO ) THEN
            RETURN
         ELSE
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
            DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU
         END IF
         DMIN = MIN( DMIN, DNM1 )
*
         DMIN1 = DMIN
         J4 = J4 + 4
         J4P2 = J4 + 2*PP - 1
         Z( J4-2 ) = DNM1 + Z( J4P2 )
         IF( DNM1.LT.ZERO ) THEN
            RETURN
         ELSE
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
            DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU
         END IF
         DMIN = MIN( DMIN, DN )
*
      END IF
*
      Z( J4+2 ) = DN
      Z( 4*N0-PP ) = EMIN
      RETURN
*
*     End of DLASQ5
*
      END
      SUBROUTINE DLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN,
     $                   DNM1, DNM2 )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            I0, N0, PP
CID      DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DNM1, DNM2
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   Z( * )
      DIMENSION    Z( * )
*     ..
*
*  Purpose
*  =======
*
*  DLASQ6 computes one dqd (shift equal to zero) transform in
*  ping-pong form, with protection against underflow and overflow.
*
*  Arguments
*  =========
*
*  I0    (input) INTEGER
*        First index.
*
*  N0    (input) INTEGER
*        Last index.
*
*  Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
*        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
*        an extra argument.
*
*  PP    (input) INTEGER
*        PP=0 for ping, PP=1 for pong.
*
*  DMIN  (output) DOUBLE PRECISION
*        Minimum value of d.
*
*  DMIN1 (output) DOUBLE PRECISION
*        Minimum value of d, excluding D( N0 ).
*
*  DMIN2 (output) DOUBLE PRECISION
*        Minimum value of d, excluding D( N0 ) and D( N0-1 ).
*
*  DN    (output) DOUBLE PRECISION
*        d(N0), the last value of d.
*
*  DNM1  (output) DOUBLE PRECISION
*        d(N0-1).
*
*  DNM2  (output) DOUBLE PRECISION
*        d(N0-2).
*
*  =====================================================================
*
*     .. Parameter ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D0 )
*     ..
*     .. Local Scalars ..
      INTEGER            J4, J4P2
CID      DOUBLE PRECISION   D, EMIN, SAFMIN, TEMP
*     ..
*     .. External Function ..
CID      DOUBLE PRECISION   DLAMCH
      EXTERNAL           DLAMCH
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MIN
*     ..
*     .. Executable Statements ..
*
      IF( ( N0-I0-1 ).LE.0 )
     $   RETURN
*
      SAFMIN = DLAMCH( 'Safe minimum' )
      J4 = 4*I0 + PP - 3
      EMIN = Z( J4+4 ) 
      D = Z( J4 )
      DMIN = D
*
      IF( PP.EQ.0 ) THEN
         DO 10 J4 = 4*I0, 4*( N0-3 ), 4
            Z( J4-2 ) = D + Z( J4-1 ) 
            IF( Z( J4-2 ).EQ.ZERO ) THEN
               Z( J4 ) = ZERO
               D = Z( J4+1 )
               DMIN = D
               EMIN = ZERO
            ELSE IF( SAFMIN*Z( J4+1 ).LT.Z( J4-2 ) .AND.
     $               SAFMIN*Z( J4-2 ).LT.Z( J4+1 ) ) THEN
               TEMP = Z( J4+1 ) / Z( J4-2 )
               Z( J4 ) = Z( J4-1 )*TEMP
               D = D*TEMP
            ELSE 
               Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) )
               D = Z( J4+1 )*( D / Z( J4-2 ) )
            END IF
            DMIN = MIN( DMIN, D )
            EMIN = MIN( EMIN, Z( J4 ) )
   10    CONTINUE
      ELSE
         DO 20 J4 = 4*I0, 4*( N0-3 ), 4
            Z( J4-3 ) = D + Z( J4 ) 
            IF( Z( J4-3 ).EQ.ZERO ) THEN
               Z( J4-1 ) = ZERO
               D = Z( J4+2 )
               DMIN = D
               EMIN = ZERO
            ELSE IF( SAFMIN*Z( J4+2 ).LT.Z( J4-3 ) .AND.
     $               SAFMIN*Z( J4-3 ).LT.Z( J4+2 ) ) THEN
               TEMP = Z( J4+2 ) / Z( J4-3 )
               Z( J4-1 ) = Z( J4 )*TEMP
               D = D*TEMP
            ELSE 
               Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) )
               D = Z( J4+2 )*( D / Z( J4-3 ) )
            END IF
            DMIN = MIN( DMIN, D )
            EMIN = MIN( EMIN, Z( J4-1 ) )
   20    CONTINUE
      END IF
*
*     Unroll last two steps. 
*
      DNM2 = D
      DMIN2 = DMIN
      J4 = 4*( N0-2 ) - PP
      J4P2 = J4 + 2*PP - 1
      Z( J4-2 ) = DNM2 + Z( J4P2 )
      IF( Z( J4-2 ).EQ.ZERO ) THEN
         Z( J4 ) = ZERO
         DNM1 = Z( J4P2+2 )
         DMIN = DNM1
         EMIN = ZERO
      ELSE IF( SAFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) .AND.
     $         SAFMIN*Z( J4-2 ).LT.Z( J4P2+2 ) ) THEN
         TEMP = Z( J4P2+2 ) / Z( J4-2 )
         Z( J4 ) = Z( J4P2 )*TEMP
         DNM1 = DNM2*TEMP
      ELSE
         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
         DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) )
      END IF
      DMIN = MIN( DMIN, DNM1 )
*
      DMIN1 = DMIN
      J4 = J4 + 4
      J4P2 = J4 + 2*PP - 1
      Z( J4-2 ) = DNM1 + Z( J4P2 )
      IF( Z( J4-2 ).EQ.ZERO ) THEN
         Z( J4 ) = ZERO
         DN = Z( J4P2+2 )
         DMIN = DN
         EMIN = ZERO
      ELSE IF( SAFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) .AND.
     $         SAFMIN*Z( J4-2 ).LT.Z( J4P2+2 ) ) THEN
         TEMP = Z( J4P2+2 ) / Z( J4-2 )
         Z( J4 ) = Z( J4P2 )*TEMP
         DN = DNM1*TEMP
      ELSE
         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
         DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) )
      END IF
      DMIN = MIN( DMIN, DN )
*
      Z( J4+2 ) = DN
      Z( 4*N0-PP ) = EMIN
      RETURN
*
*     End of DLASQ6
*
      END
      SUBROUTINE DLASR( SIDE, PIVOT, DIRECT, M, N, C, S, A, LDA )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          DIRECT, PIVOT, SIDE
      INTEGER            LDA, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), C( * ), S( * )
      DIMENSION    A( LDA, * ), C( * ), S( * )
*     ..
*
*  Purpose
*  =======
*
*  DLASR applies a sequence of plane rotations to a real matrix A,
*  from either the left or the right.
*  
*  When SIDE = 'L', the transformation takes the form
*  
*     A := P*A
*  
*  and when SIDE = 'R', the transformation takes the form
*  
*     A := A*P**T
*  
*  where P is an orthogonal matrix consisting of a sequence of z plane
*  rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
*  and P**T is the transpose of P.
*  
*  When DIRECT = 'F' (Forward sequence), then
*  
*     P = P(z-1) * ... * P(2) * P(1)
*  
*  and when DIRECT = 'B' (Backward sequence), then
*  
*     P = P(1) * P(2) * ... * P(z-1)
*  
*  where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
*  
*     R(k) = (  c(k)  s(k) )
*          = ( -s(k)  c(k) ).
*  
*  When PIVOT = 'V' (Variable pivot), the rotation is performed
*  for the plane (k,k+1), i.e., P(k) has the form
*  
*     P(k) = (  1                                            )
*            (       ...                                     )
*            (              1                                )
*            (                   c(k)  s(k)                  )
*            (                  -s(k)  c(k)                  )
*            (                                1              )
*            (                                     ...       )
*            (                                            1  )
*  
*  where R(k) appears as a rank-2 modification to the identity matrix in
*  rows and columns k and k+1.
*  
*  When PIVOT = 'T' (Top pivot), the rotation is performed for the
*  plane (1,k+1), so P(k) has the form
*  
*     P(k) = (  c(k)                    s(k)                 )
*            (         1                                     )
*            (              ...                              )
*            (                     1                         )
*            ( -s(k)                    c(k)                 )
*            (                                 1             )
*            (                                      ...      )
*            (                                             1 )
*  
*  where R(k) appears in rows and columns 1 and k+1.
*  
*  Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
*  performed for the plane (k,z), giving P(k) the form
*  
*     P(k) = ( 1                                             )
*            (      ...                                      )
*            (             1                                 )
*            (                  c(k)                    s(k) )
*            (                         1                     )
*            (                              ...              )
*            (                                     1         )
*            (                 -s(k)                    c(k) )
*  
*  where R(k) appears in rows and columns k and z.  The rotations are
*  performed without ever forming P(k) explicitly.
*
*  Arguments
*  =========
*
*  SIDE    (input) CHARACTER*1
*          Specifies whether the plane rotation matrix P is applied to
*          A on the left or the right.
*          = 'L':  Left, compute A := P*A
*          = 'R':  Right, compute A:= A*P**T
*
*  PIVOT   (input) CHARACTER*1
*          Specifies the plane for which P(k) is a plane rotation
*          matrix.
*          = 'V':  Variable pivot, the plane (k,k+1)
*          = 'T':  Top pivot, the plane (1,k+1)
*          = 'B':  Bottom pivot, the plane (k,z)
*
*  DIRECT  (input) CHARACTER*1
*          Specifies whether P is a forward or backward sequence of
*          plane rotations.
*          = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
*          = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  If m <= 1, an immediate
*          return is effected.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  If n <= 1, an
*          immediate return is effected.
*
*  C       (input) DOUBLE PRECISION array, dimension
*                  (M-1) if SIDE = 'L'
*                  (N-1) if SIDE = 'R'
*          The cosines c(k) of the plane rotations.
*
*  S       (input) DOUBLE PRECISION array, dimension
*                  (M-1) if SIDE = 'L'
*                  (N-1) if SIDE = 'R'
*          The sines s(k) of the plane rotations.  The 2-by-2 plane
*          rotation part of the matrix P(k), R(k), has the form
*          R(k) = (  c(k)  s(k) )
*                 ( -s(k)  c(k) ).
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          The M-by-N matrix A.  On exit, A is overwritten by P*A if
*          SIDE = 'R' or by A*P**T if SIDE = 'L'.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, INFO, J
CID      DOUBLE PRECISION   CTEMP, STEMP, TEMP
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters
*
      INFO = 0
      IF( .NOT.( LSAME( SIDE, 'L' ) .OR. LSAME( SIDE, 'R' ) ) ) THEN
         INFO = 1
      ELSE IF( .NOT.( LSAME( PIVOT, 'V' ) .OR. LSAME( PIVOT,
     $         'T' ) .OR. LSAME( PIVOT, 'B' ) ) ) THEN
         INFO = 2
      ELSE IF( .NOT.( LSAME( DIRECT, 'F' ) .OR. LSAME( DIRECT, 'B' ) ) )
     $          THEN
         INFO = 3
      ELSE IF( M.LT.0 ) THEN
         INFO = 4
      ELSE IF( N.LT.0 ) THEN
         INFO = 5
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = 9
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DLASR ', INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( ( M.EQ.0 ) .OR. ( N.EQ.0 ) )
     $   RETURN
      IF( LSAME( SIDE, 'L' ) ) THEN
*
*        Form  P * A
*
         IF( LSAME( PIVOT, 'V' ) ) THEN
            IF( LSAME( DIRECT, 'F' ) ) THEN
               DO 20 J = 1, M - 1
                  CTEMP = C( J )
                  STEMP = S( J )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 10 I = 1, N
                        TEMP = A( J+1, I )
                        A( J+1, I ) = CTEMP*TEMP - STEMP*A( J, I )
                        A( J, I ) = STEMP*TEMP + CTEMP*A( J, I )
   10                CONTINUE
                  END IF
   20          CONTINUE
            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
               DO 40 J = M - 1, 1, -1
                  CTEMP = C( J )
                  STEMP = S( J )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 30 I = 1, N
                        TEMP = A( J+1, I )
                        A( J+1, I ) = CTEMP*TEMP - STEMP*A( J, I )
                        A( J, I ) = STEMP*TEMP + CTEMP*A( J, I )
   30                CONTINUE
                  END IF
   40          CONTINUE
            END IF
         ELSE IF( LSAME( PIVOT, 'T' ) ) THEN
            IF( LSAME( DIRECT, 'F' ) ) THEN
               DO 60 J = 2, M
                  CTEMP = C( J-1 )
                  STEMP = S( J-1 )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 50 I = 1, N
                        TEMP = A( J, I )
                        A( J, I ) = CTEMP*TEMP - STEMP*A( 1, I )
                        A( 1, I ) = STEMP*TEMP + CTEMP*A( 1, I )
   50                CONTINUE
                  END IF
   60          CONTINUE
            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
               DO 80 J = M, 2, -1
                  CTEMP = C( J-1 )
                  STEMP = S( J-1 )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 70 I = 1, N
                        TEMP = A( J, I )
                        A( J, I ) = CTEMP*TEMP - STEMP*A( 1, I )
                        A( 1, I ) = STEMP*TEMP + CTEMP*A( 1, I )
   70                CONTINUE
                  END IF
   80          CONTINUE
            END IF
         ELSE IF( LSAME( PIVOT, 'B' ) ) THEN
            IF( LSAME( DIRECT, 'F' ) ) THEN
               DO 100 J = 1, M - 1
                  CTEMP = C( J )
                  STEMP = S( J )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 90 I = 1, N
                        TEMP = A( J, I )
                        A( J, I ) = STEMP*A( M, I ) + CTEMP*TEMP
                        A( M, I ) = CTEMP*A( M, I ) - STEMP*TEMP
   90                CONTINUE
                  END IF
  100          CONTINUE
            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
               DO 120 J = M - 1, 1, -1
                  CTEMP = C( J )
                  STEMP = S( J )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 110 I = 1, N
                        TEMP = A( J, I )
                        A( J, I ) = STEMP*A( M, I ) + CTEMP*TEMP
                        A( M, I ) = CTEMP*A( M, I ) - STEMP*TEMP
  110                CONTINUE
                  END IF
  120          CONTINUE
            END IF
         END IF
      ELSE IF( LSAME( SIDE, 'R' ) ) THEN
*
*        Form A * P'
*
         IF( LSAME( PIVOT, 'V' ) ) THEN
            IF( LSAME( DIRECT, 'F' ) ) THEN
               DO 140 J = 1, N - 1
                  CTEMP = C( J )
                  STEMP = S( J )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 130 I = 1, M
                        TEMP = A( I, J+1 )
                        A( I, J+1 ) = CTEMP*TEMP - STEMP*A( I, J )
                        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
  130                CONTINUE
                  END IF
  140          CONTINUE
            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
               DO 160 J = N - 1, 1, -1
                  CTEMP = C( J )
                  STEMP = S( J )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 150 I = 1, M
                        TEMP = A( I, J+1 )
                        A( I, J+1 ) = CTEMP*TEMP - STEMP*A( I, J )
                        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
  150                CONTINUE
                  END IF
  160          CONTINUE
            END IF
         ELSE IF( LSAME( PIVOT, 'T' ) ) THEN
            IF( LSAME( DIRECT, 'F' ) ) THEN
               DO 180 J = 2, N
                  CTEMP = C( J-1 )
                  STEMP = S( J-1 )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 170 I = 1, M
                        TEMP = A( I, J )
                        A( I, J ) = CTEMP*TEMP - STEMP*A( I, 1 )
                        A( I, 1 ) = STEMP*TEMP + CTEMP*A( I, 1 )
  170                CONTINUE
                  END IF
  180          CONTINUE
            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
               DO 200 J = N, 2, -1
                  CTEMP = C( J-1 )
                  STEMP = S( J-1 )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 190 I = 1, M
                        TEMP = A( I, J )
                        A( I, J ) = CTEMP*TEMP - STEMP*A( I, 1 )
                        A( I, 1 ) = STEMP*TEMP + CTEMP*A( I, 1 )
  190                CONTINUE
                  END IF
  200          CONTINUE
            END IF
         ELSE IF( LSAME( PIVOT, 'B' ) ) THEN
            IF( LSAME( DIRECT, 'F' ) ) THEN
               DO 220 J = 1, N - 1
                  CTEMP = C( J )
                  STEMP = S( J )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 210 I = 1, M
                        TEMP = A( I, J )
                        A( I, J ) = STEMP*A( I, N ) + CTEMP*TEMP
                        A( I, N ) = CTEMP*A( I, N ) - STEMP*TEMP
  210                CONTINUE
                  END IF
  220          CONTINUE
            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
               DO 240 J = N - 1, 1, -1
                  CTEMP = C( J )
                  STEMP = S( J )
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
                     DO 230 I = 1, M
                        TEMP = A( I, J )
                        A( I, J ) = STEMP*A( I, N ) + CTEMP*TEMP
                        A( I, N ) = CTEMP*A( I, N ) - STEMP*TEMP
  230                CONTINUE
                  END IF
  240          CONTINUE
            END IF
         END IF
      END IF
*
      RETURN
*
*     End of DLASR
*
      END
      SUBROUTINE DLASRT( ID, N, D, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          ID
      INTEGER            INFO, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   D( * )
      DIMENSION D( * )
*     ..
*
*  Purpose
*  =======
*
*  Sort the numbers in D in increasing order (if ID = 'I') or
*  in decreasing order (if ID = 'D' ).
*
*  Use Quick Sort, reverting to Insertion sort on arrays of
*  size <= 20. Dimension of STACK limits N to about 2**32.
*
*  Arguments
*  =========
*
*  ID      (input) CHARACTER*1
*          = 'I': sort D in increasing order;
*          = 'D': sort D in decreasing order.
*
*  N       (input) INTEGER
*          The length of the array D.
*
*  D       (input/output) DOUBLE PRECISION array, dimension (N)
*          On entry, the array to be sorted.
*          On exit, D has been sorted into increasing order
*          (D(1) <= ... <= D(N) ) or into decreasing order
*          (D(1) >= ... >= D(N) ), depending on ID.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
      INTEGER            SELECT
      PARAMETER          ( SELECT = 20 )
*     ..
*     .. Local Scalars ..
      INTEGER            DIR, ENDD, I, J, START, STKPNT
CID      DOUBLE PRECISION   D1, D2, D3, DMNMX, TMP
*     ..
*     .. Local Arrays ..
      INTEGER            STACK( 2, 32 )
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input paramters.
*
      INFO = 0
      DIR = -1
      IF( LSAME( ID, 'D' ) ) THEN
         DIR = 0
      ELSE IF( LSAME( ID, 'I' ) ) THEN
         DIR = 1
      END IF
      IF( DIR.EQ.-1 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DLASRT', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.LE.1 )
     $   RETURN
*
      STKPNT = 1
      STACK( 1, 1 ) = 1
      STACK( 2, 1 ) = N
   10 CONTINUE
      START = STACK( 1, STKPNT )
      ENDD = STACK( 2, STKPNT )
      STKPNT = STKPNT - 1
      IF( ENDD-START.LE.SELECT .AND. ENDD-START.GT.0 ) THEN
*
*        Do Insertion sort on D( START:ENDD )
*
         IF( DIR.EQ.0 ) THEN
*
*           Sort into decreasing order
*
            DO 30 I = START + 1, ENDD
               DO 20 J = I, START + 1, -1
                  IF( D( J ).GT.D( J-1 ) ) THEN
                     DMNMX = D( J )
                     D( J ) = D( J-1 )
                     D( J-1 ) = DMNMX
                  ELSE
                     GO TO 30
                  END IF
   20          CONTINUE
   30       CONTINUE
*
         ELSE
*
*           Sort into increasing order
*
            DO 50 I = START + 1, ENDD
               DO 40 J = I, START + 1, -1
                  IF( D( J ).LT.D( J-1 ) ) THEN
                     DMNMX = D( J )
                     D( J ) = D( J-1 )
                     D( J-1 ) = DMNMX
                  ELSE
                     GO TO 50
                  END IF
   40          CONTINUE
   50       CONTINUE
*
         END IF
*
      ELSE IF( ENDD-START.GT.SELECT ) THEN
*
*        Partition D( START:ENDD ) and stack parts, largest one first
*
*        Choose partition entry as median of 3
*
         D1 = D( START )
         D2 = D( ENDD )
         I = ( START+ENDD ) / 2
         D3 = D( I )
         IF( D1.LT.D2 ) THEN
            IF( D3.LT.D1 ) THEN
               DMNMX = D1
            ELSE IF( D3.LT.D2 ) THEN
               DMNMX = D3
            ELSE
               DMNMX = D2
            END IF
         ELSE
            IF( D3.LT.D2 ) THEN
               DMNMX = D2
            ELSE IF( D3.LT.D1 ) THEN
               DMNMX = D3
            ELSE
               DMNMX = D1
            END IF
         END IF
*
         IF( DIR.EQ.0 ) THEN
*
*           Sort into decreasing order
*
            I = START - 1
            J = ENDD + 1
   60       CONTINUE
   70       CONTINUE
            J = J - 1
            IF( D( J ).LT.DMNMX )
     $         GO TO 70
   80       CONTINUE
            I = I + 1
            IF( D( I ).GT.DMNMX )
     $         GO TO 80
            IF( I.LT.J ) THEN
               TMP = D( I )
               D( I ) = D( J )
               D( J ) = TMP
               GO TO 60
            END IF
            IF( J-START.GT.ENDD-J-1 ) THEN
               STKPNT = STKPNT + 1
               STACK( 1, STKPNT ) = START
               STACK( 2, STKPNT ) = J
               STKPNT = STKPNT + 1
               STACK( 1, STKPNT ) = J + 1
               STACK( 2, STKPNT ) = ENDD
            ELSE
               STKPNT = STKPNT + 1
               STACK( 1, STKPNT ) = J + 1
               STACK( 2, STKPNT ) = ENDD
               STKPNT = STKPNT + 1
               STACK( 1, STKPNT ) = START
               STACK( 2, STKPNT ) = J
            END IF
         ELSE
*
*           Sort into increasing order
*
            I = START - 1
            J = ENDD + 1
   90       CONTINUE
  100       CONTINUE
            J = J - 1
            IF( D( J ).GT.DMNMX )
     $         GO TO 100
  110       CONTINUE
            I = I + 1
            IF( D( I ).LT.DMNMX )
     $         GO TO 110
            IF( I.LT.J ) THEN
               TMP = D( I )
               D( I ) = D( J )
               D( J ) = TMP
               GO TO 90
            END IF
            IF( J-START.GT.ENDD-J-1 ) THEN
               STKPNT = STKPNT + 1
               STACK( 1, STKPNT ) = START
               STACK( 2, STKPNT ) = J
               STKPNT = STKPNT + 1
               STACK( 1, STKPNT ) = J + 1
               STACK( 2, STKPNT ) = ENDD
            ELSE
               STKPNT = STKPNT + 1
               STACK( 1, STKPNT ) = J + 1
               STACK( 2, STKPNT ) = ENDD
               STKPNT = STKPNT + 1
               STACK( 1, STKPNT ) = START
               STACK( 2, STKPNT ) = J
            END IF
         END IF
      END IF
      IF( STKPNT.GT.0 )
     $   GO TO 10
      RETURN
*
*     End of DLASRT
*
      END
      SUBROUTINE DLASSQ( N, X, INCX, SCALE, SUMSQ )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INCX, N
CID      DOUBLE PRECISION   SCALE, SUMSQ
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   X( * )
      DIMENSION   X( * )
*     ..
*
*  Purpose
*  =======
*
*  DLASSQ  returns the values  scl  and  smsq  such that
*
*     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
*
*  where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
*  assumed to be non-negative and  scl  returns the value
*
*     scl = max( scale, abs( x( i ) ) ).
*
*  scale and sumsq must be supplied in SCALE and SUMSQ and
*  scl and smsq are overwritten on SCALE and SUMSQ respectively.
*
*  The routine makes only one pass through the vector x.
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The number of elements to be used from the vector X.
*
*  X       (input) DOUBLE PRECISION array, dimension (N)
*          The vector for which a scaled sum of squares is computed.
*             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
*
*  INCX    (input) INTEGER
*          The increment between successive values of the vector X.
*          INCX > 0.
*
*  SCALE   (input/output) DOUBLE PRECISION
*          On entry, the value  scale  in the equation above.
*          On exit, SCALE is overwritten with  scl , the scaling factor
*          for the sum of squares.
*
*  SUMSQ   (input/output) DOUBLE PRECISION
*          On entry, the value  sumsq  in the equation above.
*          On exit, SUMSQ is overwritten with  smsq , the basic sum of
*          squares from which  scl  has been factored out.
*
* =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            IX
CID      DOUBLE PRECISION   ABSXI
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS
*     ..
*     .. Executable Statements ..
*
      IF( N.GT.0 ) THEN
         DO 10 IX = 1, 1 + ( N-1 )*INCX, INCX
            IF( X( IX ).NE.ZERO ) THEN
               ABSXI = ABS( X( IX ) )
               IF( SCALE.LT.ABSXI ) THEN
                  SUMSQ = 1 + SUMSQ*( SCALE / ABSXI )**2
                  SCALE = ABSXI
               ELSE
                  SUMSQ = SUMSQ + ( ABSXI / SCALE )**2
               END IF
            END IF
   10    CONTINUE
      END IF
      RETURN
*
*     End of DLASSQ
*
      END
      SUBROUTINE DLASV2( F, G, H, SSMIN, SSMAX, SNR, CSR, SNL, CSL )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION   CSL, CSR, F, G, H, SNL, SNR, SSMAX, SSMIN
*     ..
*
*  Purpose
*  =======
*
*  DLASV2 computes the singular value decomposition of a 2-by-2
*  triangular matrix
*     [  F   G  ]
*     [  0   H  ].
*  On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
*  smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
*  right singular vectors for abs(SSMAX), giving the decomposition
*
*     [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
*     [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
*
*  Arguments
*  =========
*
*  F       (input) DOUBLE PRECISION
*          The (1,1) element of the 2-by-2 matrix.
*
*  G       (input) DOUBLE PRECISION
*          The (1,2) element of the 2-by-2 matrix.
*
*  H       (input) DOUBLE PRECISION
*          The (2,2) element of the 2-by-2 matrix.
*
*  SSMIN   (output) DOUBLE PRECISION
*          abs(SSMIN) is the smaller singular value.
*
*  SSMAX   (output) DOUBLE PRECISION
*          abs(SSMAX) is the larger singular value.
*
*  SNL     (output) DOUBLE PRECISION
*  CSL     (output) DOUBLE PRECISION
*          The vector (CSL, SNL) is a unit left singular vector for the
*          singular value abs(SSMAX).
*
*  SNR     (output) DOUBLE PRECISION
*  CSR     (output) DOUBLE PRECISION
*          The vector (CSR, SNR) is a unit right singular vector for the
*          singular value abs(SSMAX).
*
*  Further Details
*  ===============
*
*  Any input parameter may be aliased with any output parameter.
*
*  Barring over/underflow and assuming a guard digit in subtraction, all
*  output quantities are correct to within a few units in the last
*  place (ulps).
*
*  In IEEE arithmetic, the code works correctly if one matrix element is
*  infinite.
*
*  Overflow will not occur unless the largest singular value itself
*  overflows or is within a few ulps of overflow. (On machines with
*  partial overflow, like the Cray, overflow may occur if the largest
*  singular value is within a factor of 2 of overflow.)
*
*  Underflow is harmless if underflow is gradual. Otherwise, results
*  may correspond to a matrix modified by perturbations of size near
*  the underflow threshold.
*
* =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D0 )
CID      DOUBLE PRECISION   HALF
      PARAMETER          ( HALF = 0.5D0 )
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D0 )
CID      DOUBLE PRECISION   TWO
      PARAMETER          ( TWO = 2.0D0 )
CID      DOUBLE PRECISION   FOUR
      PARAMETER          ( FOUR = 4.0D0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            GASMAL, SWAP
      INTEGER            PMAX
      REAL               L,M,MM
CID      DOUBLE PRECISION   A, CLT, CRT, D, FA, FT, GA, GT, HA, HT, L, M,
CID     $                   MM, R, S, SLT, SRT, T, TEMP, TSIGN, TT
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, SIGN, SQRT
*     ..
*     .. External Functions ..
CID      DOUBLE PRECISION   DLAMCH
      EXTERNAL           DLAMCH
*     ..
*     .. Executable Statements ..
*
      FT = F
      FA = ABS( FT )
      HT = H
      HA = ABS( H )
*
*     PMAX points to the maximum absolute element of matrix
*       PMAX = 1 if F largest in absolute values
*       PMAX = 2 if G largest in absolute values
*       PMAX = 3 if H largest in absolute values
*
      PMAX = 1
      SWAP = ( HA.GT.FA )
      IF( SWAP ) THEN
         PMAX = 3
         TEMP = FT
         FT = HT
         HT = TEMP
         TEMP = FA
         FA = HA
         HA = TEMP
*
*        Now FA .ge. HA
*
      END IF
      GT = G
      GA = ABS( GT )
      IF( GA.EQ.ZERO ) THEN
*
*        Diagonal matrix
*
         SSMIN = HA
         SSMAX = FA
         CLT = ONE
         CRT = ONE
         SLT = ZERO
         SRT = ZERO
      ELSE
         GASMAL = .TRUE.
         IF( GA.GT.FA ) THEN
            PMAX = 2
            IF( ( FA / GA ).LT.DLAMCH( 'EPS' ) ) THEN
*
*              Case of very large GA
*
               GASMAL = .FALSE.
               SSMAX = GA
               IF( HA.GT.ONE ) THEN
                  SSMIN = FA / ( GA / HA )
               ELSE
                  SSMIN = ( FA / GA )*HA
               END IF
               CLT = ONE
               SLT = HT / GT
               SRT = ONE
               CRT = FT / GT
            END IF
         END IF
         IF( GASMAL ) THEN
*
*           Normal case
*
            D = FA - HA
            IF( D.EQ.FA ) THEN
*
*              Copes with infinite F or H
*
               L = ONE
            ELSE
               L = D / FA
            END IF
*
*           Note that 0 .le. L .le. 1
*
            M = GT / FT
*
*           Note that abs(M) .le. 1/macheps
*
            T = TWO - L
*
*           Note that T .ge. 1
*
            MM = M*M
            TT = T*T
            S = SQRT( TT+MM )
*
*           Note that 1 .le. S .le. 1 + 1/macheps
*
            IF( L.EQ.ZERO ) THEN
               R = ABS( M )
            ELSE
               R = SQRT( L*L+MM )
            END IF
*
*           Note that 0 .le. R .le. 1 + 1/macheps
*
            A = HALF*( S+R )
*
*           Note that 1 .le. A .le. 1 + abs(M)
*
            SSMIN = HA / A
            SSMAX = FA*A
            IF( MM.EQ.ZERO ) THEN
*
*              Note that M is very tiny
*
               IF( L.EQ.ZERO ) THEN
                  T = SIGN( TWO, FT )*SIGN( ONE, GT )
               ELSE
                  T = GT / SIGN( D, FT ) + M / T
               END IF
            ELSE
               T = ( M / ( S+T )+M / ( R+L ) )*( ONE+A )
            END IF
            L = SQRT( T*T+FOUR )
            CRT = TWO / L
            SRT = T / L
            CLT = ( CRT+SRT*M ) / A
            SLT = ( HT / FT )*SRT / A
         END IF
      END IF
      IF( SWAP ) THEN
         CSL = SRT
         SNL = CRT
         CSR = SLT
         SNR = CLT
      ELSE
         CSL = CLT
         SNL = SLT
         CSR = CRT
         SNR = SRT
      END IF
*
*     Correct signs of SSMAX and SSMIN
*
      IF( PMAX.EQ.1 )
     $   TSIGN = SIGN( ONE, CSR )*SIGN( ONE, CSL )*SIGN( ONE, F )
      IF( PMAX.EQ.2 )
     $   TSIGN = SIGN( ONE, SNR )*SIGN( ONE, CSL )*SIGN( ONE, G )
      IF( PMAX.EQ.3 )
     $   TSIGN = SIGN( ONE, SNR )*SIGN( ONE, SNL )*SIGN( ONE, H )
      SSMAX = SIGN( SSMAX, TSIGN )
      SSMIN = SIGN( SSMIN, TSIGN*SIGN( ONE, F )*SIGN( ONE, H ) )
      RETURN
*
*     End of DLASV2
*
      END
      SUBROUTINE DLAZQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL,
     $                   ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2, DN, DN1,
     $                   DN2, TAU )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      LOGICAL            IEEE
      INTEGER            I0, ITER, N0, NDIV, NFAIL, PP, TTYPE
CID      DOUBLE PRECISION   DESIG, DMIN, DMIN1, DMIN2, DN, DN1, DN2, QMAX,
CID     $                   SIGMA, TAU
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   Z( * )
      DIMENSION  Z( * )
*     ..
*
*  Purpose
*  =======
*
*  DLAZQ3 checks for deflation, computes a shift (TAU) and calls dqds.
*  In case of failure it changes shifts, and tries again until output
*  is positive.
*
*  Arguments
*  =========
*
*  I0     (input) INTEGER
*         First index.
*
*  N0     (input) INTEGER
*         Last index.
*
*  Z      (input) DOUBLE PRECISION array, dimension ( 4*N )
*         Z holds the qd array.
*
*  PP     (input) INTEGER
*         PP=0 for ping, PP=1 for pong.
*
*  DMIN   (output) DOUBLE PRECISION
*         Minimum value of d.
*
*  SIGMA  (output) DOUBLE PRECISION
*         Sum of shifts used in current segment.
*
*  DESIG  (input/output) DOUBLE PRECISION
*         Lower order part of SIGMA
*
*  QMAX   (input) DOUBLE PRECISION
*         Maximum value of q.
*
*  NFAIL  (output) INTEGER
*         Number of times shift was too big.
*
*  ITER   (output) INTEGER
*         Number of iterations.
*
*  NDIV   (output) INTEGER
*         Number of divisions.
*
*  IEEE   (input) LOGICAL
*         Flag for IEEE or non IEEE arithmetic (passed to DLASQ5).
*
*  TTYPE  (input/output) INTEGER
*         Shift type.  TTYPE is passed as an argument in order to save
*         its value between calls to DLAZQ3
*
*  DMIN1  (input/output) REAL
*  DMIN2  (input/output) REAL
*  DN     (input/output) REAL
*  DN1    (input/output) REAL
*  DN2    (input/output) REAL
*  TAU    (input/output) REAL
*         These are passed as arguments in order to save their values
*         between calls to DLAZQ3
*
*  This is a thread safe version of DLASQ3, which passes TTYPE, DMIN1,
*  DMIN2, DN, DN1. DN2 and TAU through the argument list in place of
*  declaring them in a SAVE statment.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   CBIAS
      PARAMETER          ( CBIAS = 1.50D0 )
CID      DOUBLE PRECISION   ZERO, QURTR, HALF, ONE, TWO, HUNDRD
      PARAMETER          ( ZERO = 0.0D0, QURTR = 0.250D0, HALF = 0.5D0,
     $                     ONE = 1.0D0, TWO = 2.0D0, HUNDRD = 100.0D0 )
*     ..
*     .. Local Scalars ..
      INTEGER            IPN4, J4, N0IN, NN
CID      DOUBLE PRECISION   EPS, G, S, SAFMIN, T, TEMP, TOL, TOL2
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLASQ5, DLASQ6, DLAZQ4
*     ..
*     .. External Function ..
CID      DOUBLE PRECISION   DLAMCH
      EXTERNAL           DLAMCH
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          ABS, MIN, SQRT
*     ..
*     .. Executable Statements ..
*
      N0IN   = N0
      EPS    = DLAMCH( 'Precision' )
      SAFMIN = DLAMCH( 'Safe minimum' )
      TOL    = EPS*HUNDRD
      TOL2   = TOL**2
      G      = ZERO
*
*     Check for deflation.
*
   10 CONTINUE
*
      IF( N0.LT.I0 )
     $   RETURN
      IF( N0.EQ.I0 )
     $   GO TO 20
      NN = 4*N0 + PP
      IF( N0.EQ.( I0+1 ) )
     $   GO TO 40
*
*     Check whether E(N0-1) is negligible, 1 eigenvalue.
*
      IF( Z( NN-5 ).GT.TOL2*( SIGMA+Z( NN-3 ) ) .AND.
     $    Z( NN-2*PP-4 ).GT.TOL2*Z( NN-7 ) )
     $   GO TO 30
*
   20 CONTINUE
*
      Z( 4*N0-3 ) = Z( 4*N0+PP-3 ) + SIGMA
      N0 = N0 - 1
      GO TO 10
*
*     Check  whether E(N0-2) is negligible, 2 eigenvalues.
*
   30 CONTINUE
*
      IF( Z( NN-9 ).GT.TOL2*SIGMA .AND.
     $    Z( NN-2*PP-8 ).GT.TOL2*Z( NN-11 ) )
     $   GO TO 50
*
   40 CONTINUE
*
      IF( Z( NN-3 ).GT.Z( NN-7 ) ) THEN
         S = Z( NN-3 )
         Z( NN-3 ) = Z( NN-7 )
         Z( NN-7 ) = S
      END IF
      IF( Z( NN-5 ).GT.Z( NN-3 )*TOL2 ) THEN
         T = HALF*( ( Z( NN-7 )-Z( NN-3 ) )+Z( NN-5 ) )
         S = Z( NN-3 )*( Z( NN-5 ) / T )
         IF( S.LE.T ) THEN
            S = Z( NN-3 )*( Z( NN-5 ) /
     $          ( T*( ONE+SQRT( ONE+S / T ) ) ) )
         ELSE
            S = Z( NN-3 )*( Z( NN-5 ) / ( T+SQRT( T )*SQRT( T+S ) ) )
         END IF
         T = Z( NN-7 ) + ( S+Z( NN-5 ) )
         Z( NN-3 ) = Z( NN-3 )*( Z( NN-7 ) / T )
         Z( NN-7 ) = T
      END IF
      Z( 4*N0-7 ) = Z( NN-7 ) + SIGMA
      Z( 4*N0-3 ) = Z( NN-3 ) + SIGMA
      N0 = N0 - 2
      GO TO 10
*
   50 CONTINUE
*
*     Reverse the qd-array, if warranted.
*
      IF( DMIN.LE.ZERO .OR. N0.LT.N0IN ) THEN
         IF( CBIAS*Z( 4*I0+PP-3 ).LT.Z( 4*N0+PP-3 ) ) THEN
            IPN4 = 4*( I0+N0 )
            DO 60 J4 = 4*I0, 2*( I0+N0-1 ), 4
               TEMP = Z( J4-3 )
               Z( J4-3 ) = Z( IPN4-J4-3 )
               Z( IPN4-J4-3 ) = TEMP
               TEMP = Z( J4-2 )
               Z( J4-2 ) = Z( IPN4-J4-2 )
               Z( IPN4-J4-2 ) = TEMP
               TEMP = Z( J4-1 )
               Z( J4-1 ) = Z( IPN4-J4-5 )
               Z( IPN4-J4-5 ) = TEMP
               TEMP = Z( J4 )
               Z( J4 ) = Z( IPN4-J4-4 )
               Z( IPN4-J4-4 ) = TEMP
   60       CONTINUE
            IF( N0-I0.LE.4 ) THEN
               Z( 4*N0+PP-1 ) = Z( 4*I0+PP-1 )
               Z( 4*N0-PP ) = Z( 4*I0-PP )
            END IF
            DMIN2 = MIN( DMIN2, Z( 4*N0+PP-1 ) )
            Z( 4*N0+PP-1 ) = MIN( Z( 4*N0+PP-1 ), Z( 4*I0+PP-1 ),
     $                            Z( 4*I0+PP+3 ) )
            Z( 4*N0-PP ) = MIN( Z( 4*N0-PP ), Z( 4*I0-PP ),
     $                          Z( 4*I0-PP+4 ) )
            QMAX = MAX( QMAX, Z( 4*I0+PP-3 ), Z( 4*I0+PP+1 ) )
            DMIN = -ZERO
         END IF
      END IF
*
      IF( DMIN.LT.ZERO .OR. SAFMIN*QMAX.LT.MIN( Z( 4*N0+PP-1 ),
     $    Z( 4*N0+PP-9 ), DMIN2+Z( 4*N0-PP ) ) ) THEN
*
*        Choose a shift.
*
         CALL DLAZQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN, DN1,
     $                DN2, TAU, TTYPE, G )
*
*        Call dqds until DMIN > 0.
*
   80    CONTINUE
*
         CALL DLASQ5( I0, N0, Z, PP, TAU, DMIN, DMIN1, DMIN2, DN,
     $                DN1, DN2, IEEE )
*
         NDIV = NDIV + ( N0-I0+2 )
         ITER = ITER + 1
*
*        Check status.
*
         IF( DMIN.GE.ZERO .AND. DMIN1.GT.ZERO ) THEN
*
*           Success.
*
            GO TO 100
*
         ELSE IF( DMIN.LT.ZERO .AND. DMIN1.GT.ZERO .AND.
     $            Z( 4*( N0-1 )-PP ).LT.TOL*( SIGMA+DN1 ) .AND.
     $            ABS( DN ).LT.TOL*SIGMA ) THEN
*
*           Convergence hidden by negative DN.
*
            Z( 4*( N0-1 )-PP+2 ) = ZERO
            DMIN = ZERO
            GO TO 100
         ELSE IF( DMIN.LT.ZERO ) THEN
*
*           TAU too big. Select new TAU and try again.
*
            NFAIL = NFAIL + 1
            IF( TTYPE.LT.-22 ) THEN
*
*              Failed twice. Play it safe.
*
               TAU = ZERO
            ELSE IF( DMIN1.GT.ZERO ) THEN
*
*              Late failure. Gives excellent shift.
*
               TAU = ( TAU+DMIN )*( ONE-TWO*EPS )
               TTYPE = TTYPE - 11
            ELSE
*
*              Early failure. Divide by 4.
*
               TAU = QURTR*TAU
               TTYPE = TTYPE - 12
            END IF
            GO TO 80
         ELSE IF( DMIN.NE.DMIN ) THEN
*
*           NaN.
*
            TAU = ZERO
            GO TO 80
         ELSE
*
*           Possible underflow. Play it safe.
*
            GO TO 90
         END IF
      END IF
*
*     Risk of underflow.
*
   90 CONTINUE
      CALL DLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN, DN1, DN2 )
      NDIV = NDIV + ( N0-I0+2 )
      ITER = ITER + 1
      TAU = ZERO
*
  100 CONTINUE
      IF( TAU.LT.SIGMA ) THEN
         DESIG = DESIG + TAU
         T = SIGMA + DESIG
         DESIG = DESIG - ( T-SIGMA )
      ELSE
         T = SIGMA + TAU
         DESIG = SIGMA - ( T-TAU ) + DESIG
      END IF
      SIGMA = T
*
      RETURN
*
*     End of DLAZQ3
*
      END
      SUBROUTINE DLAZQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN,
     $                   DN1, DN2, TAU, TTYPE, G )
*
*  -- LAPACK auxiliary routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            I0, N0, N0IN, PP, TTYPE
CID      DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DN1, DN2, G, TAU
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   Z( * )
      DIMENSION Z ( * )
*     ..
*
*  Purpose
*  =======
*
*  DLAZQ4 computes an approximation TAU to the smallest eigenvalue 
*  using values of d from the previous transform.
*
*  I0    (input) INTEGER
*        First index.
*
*  N0    (input) INTEGER
*        Last index.
*
*  Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
*        Z holds the qd array.
*
*  PP    (input) INTEGER
*        PP=0 for ping, PP=1 for pong.
*
*  N0IN  (input) INTEGER
*        The value of N0 at start of EIGTEST.
*
*  DMIN  (input) DOUBLE PRECISION
*        Minimum value of d.
*
*  DMIN1 (input) DOUBLE PRECISION
*        Minimum value of d, excluding D( N0 ).
*
*  DMIN2 (input) DOUBLE PRECISION
*        Minimum value of d, excluding D( N0 ) and D( N0-1 ).
*
*  DN    (input) DOUBLE PRECISION
*        d(N)
*
*  DN1   (input) DOUBLE PRECISION
*        d(N-1)
*
*  DN2   (input) DOUBLE PRECISION
*        d(N-2)
*
*  TAU   (output) DOUBLE PRECISION
*        This is the shift.
*
*  TTYPE (output) INTEGER
*        Shift type.
*
*  G     (input/output) DOUBLE PRECISION
*        G is passed as an argument in order to save its value between
*        calls to DLAZQ4
*
*  Further Details
*  ===============
*  CNST1 = 9/16
*
*  This is a thread safe version of DLASQ4, which passes G through the
*  argument list in place of declaring G in a SAVE statment.
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   CNST1, CNST2, CNST3
      PARAMETER          ( CNST1 = 0.5630D0, CNST2 = 1.010D0,
     $                   CNST3 = 1.050D0 )
CID      DOUBLE PRECISION   QURTR, THIRD, HALF, ZERO, ONE, TWO, HUNDRD
      PARAMETER          ( QURTR = 0.250D0, THIRD = 0.3330D0,
     $                   HALF = 0.50D0, ZERO = 0.0D0, ONE = 1.0D0,
     $                   TWO = 2.0D0, HUNDRD = 100.0D0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I4, NN, NP
CID      DOUBLE PRECISION   A2, B1, B2, GAM, GAP1, GAP2, S
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN, SQRT
*     ..
*     .. Executable Statements ..
*
*     A negative DMIN forces the shift to take that absolute value
*     TTYPE records the type of shift.
*
      IF( DMIN.LE.ZERO ) THEN
         TAU = -DMIN
         TTYPE = -1
         RETURN
      END IF
*       
      NN = 4*N0 + PP
      IF( N0IN.EQ.N0 ) THEN
*
*        No eigenvalues deflated.
*
         IF( DMIN.EQ.DN .OR. DMIN.EQ.DN1 ) THEN
*
            B1 = SQRT( Z( NN-3 ) )*SQRT( Z( NN-5 ) )
            B2 = SQRT( Z( NN-7 ) )*SQRT( Z( NN-9 ) )
            A2 = Z( NN-7 ) + Z( NN-5 )
*
*           Cases 2 and 3.
*
            IF( DMIN.EQ.DN .AND. DMIN1.EQ.DN1 ) THEN
               GAP2 = DMIN2 - A2 - DMIN2*QURTR
               IF( GAP2.GT.ZERO .AND. GAP2.GT.B2 ) THEN
                  GAP1 = A2 - DN - ( B2 / GAP2 )*B2
               ELSE
                  GAP1 = A2 - DN - ( B1+B2 )
               END IF
               IF( GAP1.GT.ZERO .AND. GAP1.GT.B1 ) THEN
                  S = MAX( DN-( B1 / GAP1 )*B1, HALF*DMIN )
                  TTYPE = -2
               ELSE
                  S = ZERO
                  IF( DN.GT.B1 )
     $               S = DN - B1
                  IF( A2.GT.( B1+B2 ) )
     $               S = MIN( S, A2-( B1+B2 ) )
                  S = MAX( S, THIRD*DMIN )
                  TTYPE = -3
               END IF
            ELSE
*
*              Case 4.
*
               TTYPE = -4
               S = QURTR*DMIN
               IF( DMIN.EQ.DN ) THEN
                  GAM = DN
                  A2 = ZERO
                  IF( Z( NN-5 ) .GT. Z( NN-7 ) )
     $               RETURN
                  B2 = Z( NN-5 ) / Z( NN-7 )
                  NP = NN - 9
               ELSE
                  NP = NN - 2*PP
                  B2 = Z( NP-2 )
                  GAM = DN1
                  IF( Z( NP-4 ) .GT. Z( NP-2 ) )
     $               RETURN
                  A2 = Z( NP-4 ) / Z( NP-2 )
                  IF( Z( NN-9 ) .GT. Z( NN-11 ) )
     $               RETURN
                  B2 = Z( NN-9 ) / Z( NN-11 )
                  NP = NN - 13
               END IF
*
*              Approximate contribution to norm squared from I < NN-1.
*
               A2 = A2 + B2
               DO 10 I4 = NP, 4*I0 - 1 + PP, -4
                  IF( B2.EQ.ZERO )
     $               GO TO 20
                  B1 = B2
                  IF( Z( I4 ) .GT. Z( I4-2 ) )
     $               RETURN
                  B2 = B2*( Z( I4 ) / Z( I4-2 ) )
                  A2 = A2 + B2
                  IF( HUNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 ) 
     $               GO TO 20
   10          CONTINUE
   20          CONTINUE
               A2 = CNST3*A2
*
*              Rayleigh quotient residual bound.
*
               IF( A2.LT.CNST1 )
     $            S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )
            END IF
         ELSE IF( DMIN.EQ.DN2 ) THEN
*
*           Case 5.
*
            TTYPE = -5
            S = QURTR*DMIN
*
*           Compute contribution to norm squared from I > NN-2.
*
            NP = NN - 2*PP
            B1 = Z( NP-2 )
            B2 = Z( NP-6 )
            GAM = DN2
            IF( Z( NP-8 ).GT.B2 .OR. Z( NP-4 ).GT.B1 )
     $         RETURN
            A2 = ( Z( NP-8 ) / B2 )*( ONE+Z( NP-4 ) / B1 )
*
*           Approximate contribution to norm squared from I < NN-2.
*
            IF( N0-I0.GT.2 ) THEN
               B2 = Z( NN-13 ) / Z( NN-15 )
               A2 = A2 + B2
               DO 30 I4 = NN - 17, 4*I0 - 1 + PP, -4
                  IF( B2.EQ.ZERO )
     $               GO TO 40
                  B1 = B2
                  IF( Z( I4 ) .GT. Z( I4-2 ) )
     $               RETURN
                  B2 = B2*( Z( I4 ) / Z( I4-2 ) )
                  A2 = A2 + B2
                  IF( HUNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 ) 
     $               GO TO 40
   30          CONTINUE
   40          CONTINUE
               A2 = CNST3*A2
            END IF
*
            IF( A2.LT.CNST1 )
     $         S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )
         ELSE
*
*           Case 6, no information to guide us.
*
            IF( TTYPE.EQ.-6 ) THEN
               G = G + THIRD*( ONE-G )
            ELSE IF( TTYPE.EQ.-18 ) THEN
               G = QURTR*THIRD
            ELSE
               G = QURTR
            END IF
            S = G*DMIN
            TTYPE = -6
         END IF
*
      ELSE IF( N0IN.EQ.( N0+1 ) ) THEN
*
*        One eigenvalue just deflated. Use DMIN1, DN1 for DMIN and DN.
*
         IF( DMIN1.EQ.DN1 .AND. DMIN2.EQ.DN2 ) THEN 
*
*           Cases 7 and 8.
*
            TTYPE = -7
            S = THIRD*DMIN1
            IF( Z( NN-5 ).GT.Z( NN-7 ) )
     $         RETURN
            B1 = Z( NN-5 ) / Z( NN-7 )
            B2 = B1
            IF( B2.EQ.ZERO )
     $         GO TO 60
            DO 50 I4 = 4*N0 - 9 + PP, 4*I0 - 1 + PP, -4
               A2 = B1
               IF( Z( I4 ).GT.Z( I4-2 ) )
     $            RETURN
               B1 = B1*( Z( I4 ) / Z( I4-2 ) )
               B2 = B2 + B1
               IF( HUNDRD*MAX( B1, A2 ).LT.B2 ) 
     $            GO TO 60
   50       CONTINUE
   60       CONTINUE
            B2 = SQRT( CNST3*B2 )
            A2 = DMIN1 / ( ONE+B2**2 )
            GAP2 = HALF*DMIN2 - A2
            IF( GAP2.GT.ZERO .AND. GAP2.GT.B2*A2 ) THEN
               S = MAX( S, A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ) )
            ELSE 
               S = MAX( S, A2*( ONE-CNST2*B2 ) )
               TTYPE = -8
            END IF
         ELSE
*
*           Case 9.
*
            S = QURTR*DMIN1
            IF( DMIN1.EQ.DN1 )
     $         S = HALF*DMIN1
            TTYPE = -9
         END IF
*
      ELSE IF( N0IN.EQ.( N0+2 ) ) THEN
*
*        Two eigenvalues deflated. Use DMIN2, DN2 for DMIN and DN.
*
*        Cases 10 and 11.
*
         IF( DMIN2.EQ.DN2 .AND. TWO*Z( NN-5 ).LT.Z( NN-7 ) ) THEN 
            TTYPE = -10
            S = THIRD*DMIN2
            IF( Z( NN-5 ).GT.Z( NN-7 ) )
     $         RETURN
            B1 = Z( NN-5 ) / Z( NN-7 )
            B2 = B1
            IF( B2.EQ.ZERO )
     $         GO TO 80
            DO 70 I4 = 4*N0 - 9 + PP, 4*I0 - 1 + PP, -4
               IF( Z( I4 ).GT.Z( I4-2 ) )
     $            RETURN
               B1 = B1*( Z( I4 ) / Z( I4-2 ) )
               B2 = B2 + B1
               IF( HUNDRD*B1.LT.B2 )
     $            GO TO 80
   70       CONTINUE
   80       CONTINUE
            B2 = SQRT( CNST3*B2 )
            A2 = DMIN2 / ( ONE+B2**2 )
            GAP2 = Z( NN-7 ) + Z( NN-9 ) -
     $             SQRT( Z( NN-11 ) )*SQRT( Z( NN-9 ) ) - A2
            IF( GAP2.GT.ZERO .AND. GAP2.GT.B2*A2 ) THEN
               S = MAX( S, A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ) )
            ELSE 
               S = MAX( S, A2*( ONE-CNST2*B2 ) )
            END IF
         ELSE
            S = QURTR*DMIN2
            TTYPE = -11
         END IF
      ELSE IF( N0IN.GT.( N0+2 ) ) THEN
*
*        Case 12, more than two eigenvalues deflated. No information.
*
         S = ZERO 
         TTYPE = -12
      END IF
*
      TAU = S
      RETURN
*
*     End of DLAZQ4
*
      END
      SUBROUTINE DORG2R( M, N, K, A, LDA, TAU, WORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, K, LDA, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
      DIMENSION A( LDA, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DORG2R generates an m by n real matrix Q with orthonormal columns,
*  which is defined as the first n columns of a product of k elementary
*  reflectors of order m
*
*        Q  =  H(1) H(2) . . . H(k)
*
*  as returned by DGEQRF.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix Q. M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix Q. M >= N >= 0.
*
*  K       (input) INTEGER
*          The number of elementary reflectors whose product defines the
*          matrix Q. N >= K >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the i-th column must contain the vector which
*          defines the elementary reflector H(i), for i = 1,2,...,k, as
*          returned by DGEQRF in the first k columns of its array
*          argument A.
*          On exit, the m-by-n matrix Q.
*
*  LDA     (input) INTEGER
*          The first dimension of the array A. LDA >= max(1,M).
*
*  TAU     (input) DOUBLE PRECISION array, dimension (K)
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i), as returned by DGEQRF.
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument has an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, J, L
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARF, DSCAL, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 .OR. N.GT.M ) THEN
         INFO = -2
      ELSE IF( K.LT.0 .OR. K.GT.N ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DORG2R', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.LE.0 )
     $   RETURN
*
*     Initialise columns k+1:n to columns of the unit matrix
*
      DO 20 J = K + 1, N
         DO 10 L = 1, M
            A( L, J ) = ZERO
   10    CONTINUE
         A( J, J ) = ONE
   20 CONTINUE
*
      DO 40 I = K, 1, -1
*
*        Apply H(i) to A(i:m,i:n) from the left
*
         IF( I.LT.N ) THEN
            A( I, I ) = ONE
            CALL DLARF( 'Left', M-I+1, N-I, A( I, I ), 1, TAU( I ),
     $                  A( I, I+1 ), LDA, WORK )
         END IF
         IF( I.LT.M )
     $      CALL DSCAL( M-I, -TAU( I ), A( I+1, I ), 1 )
         A( I, I ) = ONE - TAU( I )
*
*        Set A(1:i-1,i) to zero
*
         DO 30 L = 1, I - 1
            A( L, I ) = ZERO
   30    CONTINUE
   40 CONTINUE
      RETURN
*
*     End of DORG2R
*
      END
      SUBROUTINE DORGBR( VECT, M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          VECT
      INTEGER            INFO, K, LDA, LWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
      DIMENSION   A( LDA, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DORGBR generates one of the real orthogonal matrices Q or P**T
*  determined by DGEBRD when reducing a real matrix A to bidiagonal
*  form: A = Q * B * P**T.  Q and P**T are defined as products of
*  elementary reflectors H(i) or G(i) respectively.
*
*  If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
*  is of order M:
*  if m >= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n
*  columns of Q, where m >= n >= k;
*  if m < k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an
*  M-by-M matrix.
*
*  If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
*  is of order N:
*  if k < n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m
*  rows of P**T, where n >= m >= k;
*  if k >= n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as
*  an N-by-N matrix.
*
*  Arguments
*  =========
*
*  VECT    (input) CHARACTER*1
*          Specifies whether the matrix Q or the matrix P**T is
*          required, as defined in the transformation applied by DGEBRD:
*          = 'Q':  generate Q;
*          = 'P':  generate P**T.
*
*  M       (input) INTEGER
*          The number of rows of the matrix Q or P**T to be returned.
*          M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix Q or P**T to be returned.
*          N >= 0.
*          If VECT = 'Q', M >= N >= min(M,K);
*          if VECT = 'P', N >= M >= min(N,K).
*
*  K       (input) INTEGER
*          If VECT = 'Q', the number of columns in the original M-by-K
*          matrix reduced by DGEBRD.
*          If VECT = 'P', the number of rows in the original K-by-N
*          matrix reduced by DGEBRD.
*          K >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the vectors which define the elementary reflectors,
*          as returned by DGEBRD.
*          On exit, the M-by-N matrix Q or P**T.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A. LDA >= max(1,M).
*
*  TAU     (input) DOUBLE PRECISION array, dimension
*                                (min(M,K)) if VECT = 'Q'
*                                (min(N,K)) if VECT = 'P'
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i) or G(i), which determines Q or P**T, as
*          returned by DGEBRD in its array argument TAUQ or TAUP.
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK. LWORK >= max(1,min(M,N)).
*          For optimum performance LWORK >= min(M,N)*NB, where NB
*          is the optimal blocksize.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LQUERY, WANTQ
      INTEGER            I, IINFO, J, LWKOPT, MN, NB
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      INTEGER            ILAENV
      EXTERNAL           LSAME, ILAENV
*     ..
*     .. External Subroutines ..
      EXTERNAL           DORGLQ, DORGQR, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      WANTQ = LSAME( VECT, 'Q' )
      MN = MIN( M, N )
      LQUERY = ( LWORK.EQ.-1 )
      IF( .NOT.WANTQ .AND. .NOT.LSAME( VECT, 'P' ) ) THEN
         INFO = -1
      ELSE IF( M.LT.0 ) THEN
         INFO = -2
      ELSE IF( N.LT.0 .OR. ( WANTQ .AND. ( N.GT.M .OR. N.LT.MIN( M,
     $         K ) ) ) .OR. ( .NOT.WANTQ .AND. ( M.GT.N .OR. M.LT.
     $         MIN( N, K ) ) ) ) THEN
         INFO = -3
      ELSE IF( K.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -6
      ELSE IF( LWORK.LT.MAX( 1, MN ) .AND. .NOT.LQUERY ) THEN
         INFO = -9
      END IF
*
      IF( INFO.EQ.0 ) THEN
         IF( WANTQ ) THEN
            NB = ILAENV( 1, 'DORGQR', ' ', M, N, K, -1 )
         ELSE
            NB = ILAENV( 1, 'DORGLQ', ' ', M, N, K, -1 )
         END IF
         LWKOPT = MAX( 1, MN )*NB
         WORK( 1 ) = LWKOPT
      END IF
*
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DORGBR', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
      IF( WANTQ ) THEN
*
*        Form Q, determined by a call to DGEBRD to reduce an m-by-k
*        matrix
*
         IF( M.GE.K ) THEN
*
*           If m >= k, assume m >= n >= k
*
            CALL DORGQR( M, N, K, A, LDA, TAU, WORK, LWORK, IINFO )
*
         ELSE
*
*           If m < k, assume m = n
*
*           Shift the vectors which define the elementary reflectors one
*           column to the right, and set the first row and column of Q
*           to those of the unit matrix
*
            DO 20 J = M, 2, -1
               A( 1, J ) = ZERO
               DO 10 I = J + 1, M
                  A( I, J ) = A( I, J-1 )
   10          CONTINUE
   20       CONTINUE
            A( 1, 1 ) = ONE
            DO 30 I = 2, M
               A( I, 1 ) = ZERO
   30       CONTINUE
            IF( M.GT.1 ) THEN
*
*              Form Q(2:m,2:m)
*
               CALL DORGQR( M-1, M-1, M-1, A( 2, 2 ), LDA, TAU, WORK,
     $                      LWORK, IINFO )
            END IF
         END IF
      ELSE
*
*        Form P', determined by a call to DGEBRD to reduce a k-by-n
*        matrix
*
         IF( K.LT.N ) THEN
*
*           If k < n, assume k <= m <= n
*
            CALL DORGLQ( M, N, K, A, LDA, TAU, WORK, LWORK, IINFO )
*
         ELSE
*
*           If k >= n, assume m = n
*
*           Shift the vectors which define the elementary reflectors one
*           row downward, and set the first row and column of P' to
*           those of the unit matrix
*
            A( 1, 1 ) = ONE
            DO 40 I = 2, N
               A( I, 1 ) = ZERO
   40       CONTINUE
            DO 60 J = 2, N
               DO 50 I = J - 1, 2, -1
                  A( I, J ) = A( I-1, J )
   50          CONTINUE
               A( 1, J ) = ZERO
   60       CONTINUE
            IF( N.GT.1 ) THEN
*
*              Form P'(2:n,2:n)
*
               CALL DORGLQ( N-1, N-1, N-1, A( 2, 2 ), LDA, TAU, WORK,
     $                      LWORK, IINFO )
            END IF
         END IF
      END IF
      WORK( 1 ) = LWKOPT
      RETURN
*
*     End of DORGBR
*
      END
      SUBROUTINE DORGL2( M, N, K, A, LDA, TAU, WORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, K, LDA, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
      DIMENSION   A( LDA, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DORGL2 generates an m by n real matrix Q with orthonormal rows,
*  which is defined as the first m rows of a product of k elementary
*  reflectors of order n
*
*        Q  =  H(k) . . . H(2) H(1)
*
*  as returned by DGELQF.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix Q. M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix Q. N >= M.
*
*  K       (input) INTEGER
*          The number of elementary reflectors whose product defines the
*          matrix Q. M >= K >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the i-th row must contain the vector which defines
*          the elementary reflector H(i), for i = 1,2,...,k, as returned
*          by DGELQF in the first k rows of its array argument A.
*          On exit, the m-by-n matrix Q.
*
*  LDA     (input) INTEGER
*          The first dimension of the array A. LDA >= max(1,M).
*
*  TAU     (input) DOUBLE PRECISION array, dimension (K)
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i), as returned by DGELQF.
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument has an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, J, L
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARF, DSCAL, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.M ) THEN
         INFO = -2
      ELSE IF( K.LT.0 .OR. K.GT.M ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DORGL2', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.LE.0 )
     $   RETURN
*
      IF( K.LT.M ) THEN
*
*        Initialise rows k+1:m to rows of the unit matrix
*
         DO 20 J = 1, N
            DO 10 L = K + 1, M
               A( L, J ) = ZERO
   10       CONTINUE
            IF( J.GT.K .AND. J.LE.M )
     $         A( J, J ) = ONE
   20    CONTINUE
      END IF
*
      DO 40 I = K, 1, -1
*
*        Apply H(i) to A(i:m,i:n) from the right
*
         IF( I.LT.N ) THEN
            IF( I.LT.M ) THEN
               A( I, I ) = ONE
               CALL DLARF( 'Right', M-I, N-I+1, A( I, I ), LDA,
     $                     TAU( I ), A( I+1, I ), LDA, WORK )
            END IF
            CALL DSCAL( N-I, -TAU( I ), A( I, I+1 ), LDA )
         END IF
         A( I, I ) = ONE - TAU( I )
*
*        Set A(i,1:i-1) to zero
*
         DO 30 L = 1, I - 1
            A( I, L ) = ZERO
   30    CONTINUE
   40 CONTINUE
      RETURN
*
*     End of DORGL2
*
      END
      SUBROUTINE DORGLQ( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, K, LDA, LWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
      DIMENSION A( LDA, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DORGLQ generates an M-by-N real matrix Q with orthonormal rows,
*  which is defined as the first M rows of a product of K elementary
*  reflectors of order N
*
*        Q  =  H(k) . . . H(2) H(1)
*
*  as returned by DGELQF.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix Q. M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix Q. N >= M.
*
*  K       (input) INTEGER
*          The number of elementary reflectors whose product defines the
*          matrix Q. M >= K >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the i-th row must contain the vector which defines
*          the elementary reflector H(i), for i = 1,2,...,k, as returned
*          by DGELQF in the first k rows of its array argument A.
*          On exit, the M-by-N matrix Q.
*
*  LDA     (input) INTEGER
*          The first dimension of the array A. LDA >= max(1,M).
*
*  TAU     (input) DOUBLE PRECISION array, dimension (K)
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i), as returned by DGELQF.
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK. LWORK >= max(1,M).
*          For optimum performance LWORK >= M*NB, where NB is
*          the optimal blocksize.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument has an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LQUERY
      INTEGER            I, IB, IINFO, IWS, J, KI, KK, L, LDWORK,
     $                   LWKOPT, NB, NBMIN, NX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARFB, DLARFT, DORGL2, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
      EXTERNAL           ILAENV
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      NB = ILAENV( 1, 'DORGLQ', ' ', M, N, K, -1 )
      LWKOPT = MAX( 1, M )*NB
      WORK( 1 ) = LWKOPT
      LQUERY = ( LWORK.EQ.-1 )
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.M ) THEN
         INFO = -2
      ELSE IF( K.LT.0 .OR. K.GT.M ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      ELSE IF( LWORK.LT.MAX( 1, M ) .AND. .NOT.LQUERY ) THEN
         INFO = -8
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DORGLQ', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.LE.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
      NBMIN = 2
      NX = 0
      IWS = M
      IF( NB.GT.1 .AND. NB.LT.K ) THEN
*
*        Determine when to cross over from blocked to unblocked code.
*
         NX = MAX( 0, ILAENV( 3, 'DORGLQ', ' ', M, N, K, -1 ) )
         IF( NX.LT.K ) THEN
*
*           Determine if workspace is large enough for blocked code.
*
            LDWORK = M
            IWS = LDWORK*NB
            IF( LWORK.LT.IWS ) THEN
*
*              Not enough workspace to use optimal NB:  reduce NB and
*              determine the minimum value of NB.
*
               NB = LWORK / LDWORK
               NBMIN = MAX( 2, ILAENV( 2, 'DORGLQ', ' ', M, N, K, -1 ) )
            END IF
         END IF
      END IF
*
      IF( NB.GE.NBMIN .AND. NB.LT.K .AND. NX.LT.K ) THEN
*
*        Use blocked code after the last block.
*        The first kk rows are handled by the block method.
*
         KI = ( ( K-NX-1 ) / NB )*NB
         KK = MIN( K, KI+NB )
*
*        Set A(kk+1:m,1:kk) to zero.
*
         DO 20 J = 1, KK
            DO 10 I = KK + 1, M
               A( I, J ) = ZERO
   10       CONTINUE
   20    CONTINUE
      ELSE
         KK = 0
      END IF
*
*     Use unblocked code for the last or only block.
*
      IF( KK.LT.M )
     $   CALL DORGL2( M-KK, N-KK, K-KK, A( KK+1, KK+1 ), LDA,
     $                TAU( KK+1 ), WORK, IINFO )
*
      IF( KK.GT.0 ) THEN
*
*        Use blocked code
*
         DO 50 I = KI + 1, 1, -NB
            IB = MIN( NB, K-I+1 )
            IF( I+IB.LE.M ) THEN
*
*              Form the triangular factor of the block reflector
*              H = H(i) H(i+1) . . . H(i+ib-1)
*
               CALL DLARFT( 'Forward', 'Rowwise', N-I+1, IB, A( I, I ),
     $                      LDA, TAU( I ), WORK, LDWORK )
*
*              Apply H' to A(i+ib:m,i:n) from the right
*
               CALL DLARFB( 'Right', 'Transpose', 'Forward', 'Rowwise',
     $                      M-I-IB+1, N-I+1, IB, A( I, I ), LDA, WORK,
     $                      LDWORK, A( I+IB, I ), LDA, WORK( IB+1 ),
     $                      LDWORK )
            END IF
*
*           Apply H' to columns i:n of current block
*
            CALL DORGL2( IB, N-I+1, IB, A( I, I ), LDA, TAU( I ), WORK,
     $                   IINFO )
*
*           Set columns 1:i-1 of current block to zero
*
            DO 40 J = 1, I - 1
               DO 30 L = I, I + IB - 1
                  A( L, J ) = ZERO
   30          CONTINUE
   40       CONTINUE
   50    CONTINUE
      END IF
*
      WORK( 1 ) = IWS
      RETURN
*
*     End of DORGLQ
*
      END
      SUBROUTINE DORGQR( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      INTEGER            INFO, K, LDA, LWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
      DIMENSION   A( LDA, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DORGQR generates an M-by-N real matrix Q with orthonormal columns,
*  which is defined as the first N columns of a product of K elementary
*  reflectors of order M
*
*        Q  =  H(1) H(2) . . . H(k)
*
*  as returned by DGEQRF.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix Q. M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix Q. M >= N >= 0.
*
*  K       (input) INTEGER
*          The number of elementary reflectors whose product defines the
*          matrix Q. N >= K >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the i-th column must contain the vector which
*          defines the elementary reflector H(i), for i = 1,2,...,k, as
*          returned by DGEQRF in the first k columns of its array
*          argument A.
*          On exit, the M-by-N matrix Q.
*
*  LDA     (input) INTEGER
*          The first dimension of the array A. LDA >= max(1,M).
*
*  TAU     (input) DOUBLE PRECISION array, dimension (K)
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i), as returned by DGEQRF.
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK. LWORK >= max(1,N).
*          For optimum performance LWORK >= N*NB, where NB is the
*          optimal blocksize.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument has an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LQUERY
      INTEGER            I, IB, IINFO, IWS, J, KI, KK, L, LDWORK,
     $                   LWKOPT, NB, NBMIN, NX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARFB, DLARFT, DORG2R, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
      EXTERNAL           ILAENV
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      NB = ILAENV( 1, 'DORGQR', ' ', M, N, K, -1 )
      LWKOPT = MAX( 1, N )*NB
      WORK( 1 ) = LWKOPT
      LQUERY = ( LWORK.EQ.-1 )
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 .OR. N.GT.M ) THEN
         INFO = -2
      ELSE IF( K.LT.0 .OR. K.GT.N ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      ELSE IF( LWORK.LT.MAX( 1, N ) .AND. .NOT.LQUERY ) THEN
         INFO = -8
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DORGQR', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.LE.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
      NBMIN = 2
      NX = 0
      IWS = N
      IF( NB.GT.1 .AND. NB.LT.K ) THEN
*
*        Determine when to cross over from blocked to unblocked code.
*
         NX = MAX( 0, ILAENV( 3, 'DORGQR', ' ', M, N, K, -1 ) )
         IF( NX.LT.K ) THEN
*
*           Determine if workspace is large enough for blocked code.
*
            LDWORK = N
            IWS = LDWORK*NB
            IF( LWORK.LT.IWS ) THEN
*
*              Not enough workspace to use optimal NB:  reduce NB and
*              determine the minimum value of NB.
*
               NB = LWORK / LDWORK
               NBMIN = MAX( 2, ILAENV( 2, 'DORGQR', ' ', M, N, K, -1 ) )
            END IF
         END IF
      END IF
*
      IF( NB.GE.NBMIN .AND. NB.LT.K .AND. NX.LT.K ) THEN
*
*        Use blocked code after the last block.
*        The first kk columns are handled by the block method.
*
         KI = ( ( K-NX-1 ) / NB )*NB
         KK = MIN( K, KI+NB )
*
*        Set A(1:kk,kk+1:n) to zero.
*
         DO 20 J = KK + 1, N
            DO 10 I = 1, KK
               A( I, J ) = ZERO
   10       CONTINUE
   20    CONTINUE
      ELSE
         KK = 0
      END IF
*
*     Use unblocked code for the last or only block.
*
      IF( KK.LT.N )
     $   CALL DORG2R( M-KK, N-KK, K-KK, A( KK+1, KK+1 ), LDA,
     $                TAU( KK+1 ), WORK, IINFO )
*
      IF( KK.GT.0 ) THEN
*
*        Use blocked code
*
         DO 50 I = KI + 1, 1, -NB
            IB = MIN( NB, K-I+1 )
            IF( I+IB.LE.N ) THEN
*
*              Form the triangular factor of the block reflector
*              H = H(i) H(i+1) . . . H(i+ib-1)
*
               CALL DLARFT( 'Forward', 'Columnwise', M-I+1, IB,
     $                      A( I, I ), LDA, TAU( I ), WORK, LDWORK )
*
*              Apply H to A(i:m,i+ib:n) from the left
*
               CALL DLARFB( 'Left', 'No transpose', 'Forward',
     $                      'Columnwise', M-I+1, N-I-IB+1, IB,
     $                      A( I, I ), LDA, WORK, LDWORK, A( I, I+IB ),
     $                      LDA, WORK( IB+1 ), LDWORK )
            END IF
*
*           Apply H to rows i:m of current block
*
            CALL DORG2R( M-I+1, IB, IB, A( I, I ), LDA, TAU( I ), WORK,
     $                   IINFO )
*
*           Set rows 1:i-1 of current block to zero
*
            DO 40 J = I, I + IB - 1
               DO 30 L = 1, I - 1
                  A( L, J ) = ZERO
   30          CONTINUE
   40       CONTINUE
   50    CONTINUE
      END IF
*
      WORK( 1 ) = IWS
      RETURN
*
*     End of DORGQR
*
      END
      SUBROUTINE DORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
     $                   WORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          SIDE, TRANS
      INTEGER            INFO, K, LDA, LDC, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
      DIMENSION  A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DORM2R overwrites the general real m by n matrix C with
*
*        Q * C  if SIDE = 'L' and TRANS = 'N', or
*
*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
*
*        C * Q  if SIDE = 'R' and TRANS = 'N', or
*
*        C * Q' if SIDE = 'R' and TRANS = 'T',
*
*  where Q is a real orthogonal matrix defined as the product of k
*  elementary reflectors
*
*        Q = H(1) H(2) . . . H(k)
*
*  as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n
*  if SIDE = 'R'.
*
*  Arguments
*  =========
*
*  SIDE    (input) CHARACTER*1
*          = 'L': apply Q or Q' from the Left
*          = 'R': apply Q or Q' from the Right
*
*  TRANS   (input) CHARACTER*1
*          = 'N': apply Q  (No transpose)
*          = 'T': apply Q' (Transpose)
*
*  M       (input) INTEGER
*          The number of rows of the matrix C. M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix C. N >= 0.
*
*  K       (input) INTEGER
*          The number of elementary reflectors whose product defines
*          the matrix Q.
*          If SIDE = 'L', M >= K >= 0;
*          if SIDE = 'R', N >= K >= 0.
*
*  A       (input) DOUBLE PRECISION array, dimension (LDA,K)
*          The i-th column must contain the vector which defines the
*          elementary reflector H(i), for i = 1,2,...,k, as returned by
*          DGEQRF in the first k columns of its array argument A.
*          A is modified by the routine but restored on exit.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.
*          If SIDE = 'L', LDA >= max(1,M);
*          if SIDE = 'R', LDA >= max(1,N).
*
*  TAU     (input) DOUBLE PRECISION array, dimension (K)
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i), as returned by DGEQRF.
*
*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
*          On entry, the m by n matrix C.
*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
*
*  LDC     (input) INTEGER
*          The leading dimension of the array C. LDC >= max(1,M).
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension
*                                   (N) if SIDE = 'L',
*                                   (M) if SIDE = 'R'
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LEFT, NOTRAN
      INTEGER            I, I1, I2, I3, IC, JC, MI, NI, NQ
CID      DOUBLE PRECISION   AII
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARF, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      LEFT = LSAME( SIDE, 'L' )
      NOTRAN = LSAME( TRANS, 'N' )
*
*     NQ is the order of Q
*
      IF( LEFT ) THEN
         NQ = M
      ELSE
         NQ = N
      END IF
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN
         INFO = -1
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN
         INFO = -2
      ELSE IF( M.LT.0 ) THEN
         INFO = -3
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN
         INFO = -5
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN
         INFO = -7
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
         INFO = -10
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DORM2R', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 )
     $   RETURN
*
      IF( ( LEFT .AND. .NOT.NOTRAN ) .OR. ( .NOT.LEFT .AND. NOTRAN ) )
     $     THEN
         I1 = 1
         I2 = K
         I3 = 1
      ELSE
         I1 = K
         I2 = 1
         I3 = -1
      END IF
*
      IF( LEFT ) THEN
         NI = N
         JC = 1
      ELSE
         MI = M
         IC = 1
      END IF
*
      DO 10 I = I1, I2, I3
         IF( LEFT ) THEN
*
*           H(i) is applied to C(i:m,1:n)
*
            MI = M - I + 1
            IC = I
         ELSE
*
*           H(i) is applied to C(1:m,i:n)
*
            NI = N - I + 1
            JC = I
         END IF
*
*        Apply H(i)
*
         AII = A( I, I )
         A( I, I ) = ONE
         CALL DLARF( SIDE, MI, NI, A( I, I ), 1, TAU( I ), C( IC, JC ),
     $               LDC, WORK )
         A( I, I ) = AII
   10 CONTINUE
      RETURN
*
*     End of DORM2R
*
      END
      SUBROUTINE DORMBR( VECT, SIDE, TRANS, M, N, K, A, LDA, TAU, C,
     $                   LDC, WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          SIDE, TRANS, VECT
      INTEGER            INFO, K, LDA, LDC, LWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
      DIMENSION  A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C
*  with
*                  SIDE = 'L'     SIDE = 'R'
*  TRANS = 'N':      Q * C          C * Q
*  TRANS = 'T':      Q**T * C       C * Q**T
*
*  If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
*  with
*                  SIDE = 'L'     SIDE = 'R'
*  TRANS = 'N':      P * C          C * P
*  TRANS = 'T':      P**T * C       C * P**T
*
*  Here Q and P**T are the orthogonal matrices determined by DGEBRD when
*  reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
*  P**T are defined as products of elementary reflectors H(i) and G(i)
*  respectively.
*
*  Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
*  order of the orthogonal matrix Q or P**T that is applied.
*
*  If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
*  if nq >= k, Q = H(1) H(2) . . . H(k);
*  if nq < k, Q = H(1) H(2) . . . H(nq-1).
*
*  If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
*  if k < nq, P = G(1) G(2) . . . G(k);
*  if k >= nq, P = G(1) G(2) . . . G(nq-1).
*
*  Arguments
*  =========
*
*  VECT    (input) CHARACTER*1
*          = 'Q': apply Q or Q**T;
*          = 'P': apply P or P**T.
*
*  SIDE    (input) CHARACTER*1
*          = 'L': apply Q, Q**T, P or P**T from the Left;
*          = 'R': apply Q, Q**T, P or P**T from the Right.
*
*  TRANS   (input) CHARACTER*1
*          = 'N':  No transpose, apply Q  or P;
*          = 'T':  Transpose, apply Q**T or P**T.
*
*  M       (input) INTEGER
*          The number of rows of the matrix C. M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix C. N >= 0.
*
*  K       (input) INTEGER
*          If VECT = 'Q', the number of columns in the original
*          matrix reduced by DGEBRD.
*          If VECT = 'P', the number of rows in the original
*          matrix reduced by DGEBRD.
*          K >= 0.
*
*  A       (input) DOUBLE PRECISION array, dimension
*                                (LDA,min(nq,K)) if VECT = 'Q'
*                                (LDA,nq)        if VECT = 'P'
*          The vectors which define the elementary reflectors H(i) and
*          G(i), whose products determine the matrices Q and P, as
*          returned by DGEBRD.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.
*          If VECT = 'Q', LDA >= max(1,nq);
*          if VECT = 'P', LDA >= max(1,min(nq,K)).
*
*  TAU     (input) DOUBLE PRECISION array, dimension (min(nq,K))
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i) or G(i) which determines Q or P, as returned
*          by DGEBRD in the array argument TAUQ or TAUP.
*
*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
*          On entry, the M-by-N matrix C.
*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
*          or P*C or P**T*C or C*P or C*P**T.
*
*  LDC     (input) INTEGER
*          The leading dimension of the array C. LDC >= max(1,M).
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK.
*          If SIDE = 'L', LWORK >= max(1,N);
*          if SIDE = 'R', LWORK >= max(1,M).
*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
*          blocksize.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Local Scalars ..
      LOGICAL            APPLYQ, LEFT, LQUERY, NOTRAN
      CHARACTER          TRANST
      INTEGER            I1, I2, IINFO, LWKOPT, MI, NB, NI, NQ, NW
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      INTEGER            ILAENV
      EXTERNAL           LSAME, ILAENV
*     ..
*     .. External Subroutines ..
      EXTERNAL           DORMLQ, DORMQR, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      APPLYQ = LSAME( VECT, 'Q' )
      LEFT = LSAME( SIDE, 'L' )
      NOTRAN = LSAME( TRANS, 'N' )
      LQUERY = ( LWORK.EQ.-1 )
*
*     NQ is the order of Q or P and NW is the minimum dimension of WORK
*
      IF( LEFT ) THEN
         NQ = M
         NW = N
      ELSE
         NQ = N
         NW = M
      END IF
      IF( .NOT.APPLYQ .AND. .NOT.LSAME( VECT, 'P' ) ) THEN
         INFO = -1
      ELSE IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN
         INFO = -2
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN
         INFO = -3
      ELSE IF( M.LT.0 ) THEN
         INFO = -4
      ELSE IF( N.LT.0 ) THEN
         INFO = -5
      ELSE IF( K.LT.0 ) THEN
         INFO = -6
      ELSE IF( ( APPLYQ .AND. LDA.LT.MAX( 1, NQ ) ) .OR.
     $         ( .NOT.APPLYQ .AND. LDA.LT.MAX( 1, MIN( NQ, K ) ) ) )
     $          THEN
         INFO = -8
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
         INFO = -11
      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN
         INFO = -13
      END IF
*
      IF( INFO.EQ.0 ) THEN
         IF( APPLYQ ) THEN
            IF( LEFT ) THEN
               NB = ILAENV( 1, 'DORMQR', SIDE // TRANS, M-1, N, M-1,
     $              -1 )
            ELSE
               NB = ILAENV( 1, 'DORMQR', SIDE // TRANS, M, N-1, N-1,
     $              -1 )
            END IF
         ELSE
            IF( LEFT ) THEN
               NB = ILAENV( 1, 'DORMLQ', SIDE // TRANS, M-1, N, M-1,
     $              -1 )
            ELSE
               NB = ILAENV( 1, 'DORMLQ', SIDE // TRANS, M, N-1, N-1,
     $              -1 )
            END IF
         END IF
         LWKOPT = MAX( 1, NW )*NB
         WORK( 1 ) = LWKOPT
      END IF
*
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DORMBR', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      WORK( 1 ) = 1
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
      IF( APPLYQ ) THEN
*
*        Apply Q
*
         IF( NQ.GE.K ) THEN
*
*           Q was determined by a call to DGEBRD with nq >= k
*
            CALL DORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
     $                   WORK, LWORK, IINFO )
         ELSE IF( NQ.GT.1 ) THEN
*
*           Q was determined by a call to DGEBRD with nq < k
*
            IF( LEFT ) THEN
               MI = M - 1
               NI = N
               I1 = 2
               I2 = 1
            ELSE
               MI = M
               NI = N - 1
               I1 = 1
               I2 = 2
            END IF
            CALL DORMQR( SIDE, TRANS, MI, NI, NQ-1, A( 2, 1 ), LDA, TAU,
     $                   C( I1, I2 ), LDC, WORK, LWORK, IINFO )
         END IF
      ELSE
*
*        Apply P
*
         IF( NOTRAN ) THEN
            TRANST = 'T'
         ELSE
            TRANST = 'N'
         END IF
         IF( NQ.GT.K ) THEN
*
*           P was determined by a call to DGEBRD with nq > k
*
            CALL DORMLQ( SIDE, TRANST, M, N, K, A, LDA, TAU, C, LDC,
     $                   WORK, LWORK, IINFO )
         ELSE IF( NQ.GT.1 ) THEN
*
*           P was determined by a call to DGEBRD with nq <= k
*
            IF( LEFT ) THEN
               MI = M - 1
               NI = N
               I1 = 2
               I2 = 1
            ELSE
               MI = M
               NI = N - 1
               I1 = 1
               I2 = 2
            END IF
            CALL DORMLQ( SIDE, TRANST, MI, NI, NQ-1, A( 1, 2 ), LDA,
     $                   TAU, C( I1, I2 ), LDC, WORK, LWORK, IINFO )
         END IF
      END IF
      WORK( 1 ) = LWKOPT
      RETURN
*
*     End of DORMBR
*
      END
      SUBROUTINE DORML2( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
     $                   WORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          SIDE, TRANS
      INTEGER            INFO, K, LDA, LDC, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
      DIMENSION  A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DORML2 overwrites the general real m by n matrix C with
*
*        Q * C  if SIDE = 'L' and TRANS = 'N', or
*
*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
*
*        C * Q  if SIDE = 'R' and TRANS = 'N', or
*
*        C * Q' if SIDE = 'R' and TRANS = 'T',
*
*  where Q is a real orthogonal matrix defined as the product of k
*  elementary reflectors
*
*        Q = H(k) . . . H(2) H(1)
*
*  as returned by DGELQF. Q is of order m if SIDE = 'L' and of order n
*  if SIDE = 'R'.
*
*  Arguments
*  =========
*
*  SIDE    (input) CHARACTER*1
*          = 'L': apply Q or Q' from the Left
*          = 'R': apply Q or Q' from the Right
*
*  TRANS   (input) CHARACTER*1
*          = 'N': apply Q  (No transpose)
*          = 'T': apply Q' (Transpose)
*
*  M       (input) INTEGER
*          The number of rows of the matrix C. M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix C. N >= 0.
*
*  K       (input) INTEGER
*          The number of elementary reflectors whose product defines
*          the matrix Q.
*          If SIDE = 'L', M >= K >= 0;
*          if SIDE = 'R', N >= K >= 0.
*
*  A       (input) DOUBLE PRECISION array, dimension
*                               (LDA,M) if SIDE = 'L',
*                               (LDA,N) if SIDE = 'R'
*          The i-th row must contain the vector which defines the
*          elementary reflector H(i), for i = 1,2,...,k, as returned by
*          DGELQF in the first k rows of its array argument A.
*          A is modified by the routine but restored on exit.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A. LDA >= max(1,K).
*
*  TAU     (input) DOUBLE PRECISION array, dimension (K)
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i), as returned by DGELQF.
*
*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
*          On entry, the m by n matrix C.
*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
*
*  LDC     (input) INTEGER
*          The leading dimension of the array C. LDC >= max(1,M).
*
*  WORK    (workspace) DOUBLE PRECISION array, dimension
*                                   (N) if SIDE = 'L',
*                                   (M) if SIDE = 'R'
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
CID      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LEFT, NOTRAN
      INTEGER            I, I1, I2, I3, IC, JC, MI, NI, NQ
CID      DOUBLE PRECISION   AII
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARF, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      LEFT = LSAME( SIDE, 'L' )
      NOTRAN = LSAME( TRANS, 'N' )
*
*     NQ is the order of Q
*
      IF( LEFT ) THEN
         NQ = M
      ELSE
         NQ = N
      END IF
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN
         INFO = -1
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN
         INFO = -2
      ELSE IF( M.LT.0 ) THEN
         INFO = -3
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN
         INFO = -5
      ELSE IF( LDA.LT.MAX( 1, K ) ) THEN
         INFO = -7
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
         INFO = -10
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DORML2', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 )
     $   RETURN
*
      IF( ( LEFT .AND. NOTRAN ) .OR. ( .NOT.LEFT .AND. .NOT.NOTRAN ) )
     $     THEN
         I1 = 1
         I2 = K
         I3 = 1
      ELSE
         I1 = K
         I2 = 1
         I3 = -1
      END IF
*
      IF( LEFT ) THEN
         NI = N
         JC = 1
      ELSE
         MI = M
         IC = 1
      END IF
*
      DO 10 I = I1, I2, I3
         IF( LEFT ) THEN
*
*           H(i) is applied to C(i:m,1:n)
*
            MI = M - I + 1
            IC = I
         ELSE
*
*           H(i) is applied to C(1:m,i:n)
*
            NI = N - I + 1
            JC = I
         END IF
*
*        Apply H(i)
*
         AII = A( I, I )
         A( I, I ) = ONE
         CALL DLARF( SIDE, MI, NI, A( I, I ), LDA, TAU( I ),
     $               C( IC, JC ), LDC, WORK )
         A( I, I ) = AII
   10 CONTINUE
      RETURN
*
*     End of DORML2
*
      END
      SUBROUTINE DORMLQ( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
     $                   WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          SIDE, TRANS
      INTEGER            INFO, K, LDA, LDC, LWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
      DIMENSION A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DORMLQ overwrites the general real M-by-N matrix C with
*
*                  SIDE = 'L'     SIDE = 'R'
*  TRANS = 'N':      Q * C          C * Q
*  TRANS = 'T':      Q**T * C       C * Q**T
*
*  where Q is a real orthogonal matrix defined as the product of k
*  elementary reflectors
*
*        Q = H(k) . . . H(2) H(1)
*
*  as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
*  if SIDE = 'R'.
*
*  Arguments
*  =========
*
*  SIDE    (input) CHARACTER*1
*          = 'L': apply Q or Q**T from the Left;
*          = 'R': apply Q or Q**T from the Right.
*
*  TRANS   (input) CHARACTER*1
*          = 'N':  No transpose, apply Q;
*          = 'T':  Transpose, apply Q**T.
*
*  M       (input) INTEGER
*          The number of rows of the matrix C. M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix C. N >= 0.
*
*  K       (input) INTEGER
*          The number of elementary reflectors whose product defines
*          the matrix Q.
*          If SIDE = 'L', M >= K >= 0;
*          if SIDE = 'R', N >= K >= 0.
*
*  A       (input) DOUBLE PRECISION array, dimension
*                               (LDA,M) if SIDE = 'L',
*                               (LDA,N) if SIDE = 'R'
*          The i-th row must contain the vector which defines the
*          elementary reflector H(i), for i = 1,2,...,k, as returned by
*          DGELQF in the first k rows of its array argument A.
*          A is modified by the routine but restored on exit.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A. LDA >= max(1,K).
*
*  TAU     (input) DOUBLE PRECISION array, dimension (K)
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i), as returned by DGELQF.
*
*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
*          On entry, the M-by-N matrix C.
*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
*
*  LDC     (input) INTEGER
*          The leading dimension of the array C. LDC >= max(1,M).
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK.
*          If SIDE = 'L', LWORK >= max(1,N);
*          if SIDE = 'R', LWORK >= max(1,M).
*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
*          blocksize.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
      INTEGER            NBMAX, LDT
      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LEFT, LQUERY, NOTRAN
      CHARACTER          TRANST
      INTEGER            I, I1, I2, I3, IB, IC, IINFO, IWS, JC, LDWORK,
     $                   LWKOPT, MI, NB, NBMIN, NI, NQ, NW
*     ..
*     .. Local Arrays ..
CID      DOUBLE PRECISION   T( LDT, NBMAX )
      DIMENSION   T( LDT, NBMAX )
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      INTEGER            ILAENV
      EXTERNAL           LSAME, ILAENV
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARFB, DLARFT, DORML2, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      LEFT = LSAME( SIDE, 'L' )
      NOTRAN = LSAME( TRANS, 'N' )
      LQUERY = ( LWORK.EQ.-1 )
*
*     NQ is the order of Q and NW is the minimum dimension of WORK
*
      IF( LEFT ) THEN
         NQ = M
         NW = N
      ELSE
         NQ = N
         NW = M
      END IF
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN
         INFO = -1
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN
         INFO = -2
      ELSE IF( M.LT.0 ) THEN
         INFO = -3
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN
         INFO = -5
      ELSE IF( LDA.LT.MAX( 1, K ) ) THEN
         INFO = -7
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
         INFO = -10
      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN
         INFO = -12
      END IF
*
      IF( INFO.EQ.0 ) THEN
*
*        Determine the block size.  NB may be at most NBMAX, where NBMAX
*        is used to define the local array T.
*
         NB = MIN( NBMAX, ILAENV( 1, 'DORMLQ', SIDE // TRANS, M, N, K,
     $        -1 ) )
         LWKOPT = MAX( 1, NW )*NB
         WORK( 1 ) = LWKOPT
      END IF
*
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DORMLQ', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
      NBMIN = 2
      LDWORK = NW
      IF( NB.GT.1 .AND. NB.LT.K ) THEN
         IWS = NW*NB
         IF( LWORK.LT.IWS ) THEN
            NB = LWORK / LDWORK
            NBMIN = MAX( 2, ILAENV( 2, 'DORMLQ', SIDE // TRANS, M, N, K,
     $              -1 ) )
         END IF
      ELSE
         IWS = NW
      END IF
*
      IF( NB.LT.NBMIN .OR. NB.GE.K ) THEN
*
*        Use unblocked code
*
         CALL DORML2( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK,
     $                IINFO )
      ELSE
*
*        Use blocked code
*
         IF( ( LEFT .AND. NOTRAN ) .OR.
     $       ( .NOT.LEFT .AND. .NOT.NOTRAN ) ) THEN
            I1 = 1
            I2 = K
            I3 = NB
         ELSE
            I1 = ( ( K-1 ) / NB )*NB + 1
            I2 = 1
            I3 = -NB
         END IF
*
         IF( LEFT ) THEN
            NI = N
            JC = 1
         ELSE
            MI = M
            IC = 1
         END IF
*
         IF( NOTRAN ) THEN
            TRANST = 'T'
         ELSE
            TRANST = 'N'
         END IF
*
         DO 10 I = I1, I2, I3
            IB = MIN( NB, K-I+1 )
*
*           Form the triangular factor of the block reflector
*           H = H(i) H(i+1) . . . H(i+ib-1)
*
            CALL DLARFT( 'Forward', 'Rowwise', NQ-I+1, IB, A( I, I ),
     $                   LDA, TAU( I ), T, LDT )
            IF( LEFT ) THEN
*
*              H or H' is applied to C(i:m,1:n)
*
               MI = M - I + 1
               IC = I
            ELSE
*
*              H or H' is applied to C(1:m,i:n)
*
               NI = N - I + 1
               JC = I
            END IF
*
*           Apply H or H'
*
            CALL DLARFB( SIDE, TRANST, 'Forward', 'Rowwise', MI, NI, IB,
     $                   A( I, I ), LDA, T, LDT, C( IC, JC ), LDC, WORK,
     $                   LDWORK )
   10    CONTINUE
      END IF
      WORK( 1 ) = LWKOPT
      RETURN
*
*     End of DORMLQ
*
      END
      SUBROUTINE DORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
     $                   WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.1) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          SIDE, TRANS
      INTEGER            INFO, K, LDA, LDC, LWORK, M, N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
      DIMENSION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DORMQR overwrites the general real M-by-N matrix C with
*
*                  SIDE = 'L'     SIDE = 'R'
*  TRANS = 'N':      Q * C          C * Q
*  TRANS = 'T':      Q**T * C       C * Q**T
*
*  where Q is a real orthogonal matrix defined as the product of k
*  elementary reflectors
*
*        Q = H(1) H(2) . . . H(k)
*
*  as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
*  if SIDE = 'R'.
*
*  Arguments
*  =========
*
*  SIDE    (input) CHARACTER*1
*          = 'L': apply Q or Q**T from the Left;
*          = 'R': apply Q or Q**T from the Right.
*
*  TRANS   (input) CHARACTER*1
*          = 'N':  No transpose, apply Q;
*          = 'T':  Transpose, apply Q**T.
*
*  M       (input) INTEGER
*          The number of rows of the matrix C. M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix C. N >= 0.
*
*  K       (input) INTEGER
*          The number of elementary reflectors whose product defines
*          the matrix Q.
*          If SIDE = 'L', M >= K >= 0;
*          if SIDE = 'R', N >= K >= 0.
*
*  A       (input) DOUBLE PRECISION array, dimension (LDA,K)
*          The i-th column must contain the vector which defines the
*          elementary reflector H(i), for i = 1,2,...,k, as returned by
*          DGEQRF in the first k columns of its array argument A.
*          A is modified by the routine but restored on exit.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.
*          If SIDE = 'L', LDA >= max(1,M);
*          if SIDE = 'R', LDA >= max(1,N).
*
*  TAU     (input) DOUBLE PRECISION array, dimension (K)
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i), as returned by DGEQRF.
*
*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
*          On entry, the M-by-N matrix C.
*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
*
*  LDC     (input) INTEGER
*          The leading dimension of the array C. LDC >= max(1,M).
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK.
*          If SIDE = 'L', LWORK >= max(1,N);
*          if SIDE = 'R', LWORK >= max(1,M).
*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
*          blocksize.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
      INTEGER            NBMAX, LDT
      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LEFT, LQUERY, NOTRAN
      INTEGER            I, I1, I2, I3, IB, IC, IINFO, IWS, JC, LDWORK,
     $                   LWKOPT, MI, NB, NBMIN, NI, NQ, NW
*     ..
*     .. Local Arrays ..
CID      DOUBLE PRECISION   T( LDT, NBMAX )
      DIMENSION   T( LDT, NBMAX )
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      INTEGER            ILAENV
      EXTERNAL           LSAME, ILAENV
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLARFB, DLARFT, DORM2R, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      LEFT = LSAME( SIDE, 'L' )
      NOTRAN = LSAME( TRANS, 'N' )
      LQUERY = ( LWORK.EQ.-1 )
*
*     NQ is the order of Q and NW is the minimum dimension of WORK
*
      IF( LEFT ) THEN
         NQ = M
         NW = N
      ELSE
         NQ = N
         NW = M
      END IF
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN
         INFO = -1
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN
         INFO = -2
      ELSE IF( M.LT.0 ) THEN
         INFO = -3
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN
         INFO = -5
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN
         INFO = -7
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
         INFO = -10
      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN
         INFO = -12
      END IF
*
      IF( INFO.EQ.0 ) THEN
*
*        Determine the block size.  NB may be at most NBMAX, where NBMAX
*        is used to define the local array T.
*
         NB = MIN( NBMAX, ILAENV( 1, 'DORMQR', SIDE // TRANS, M, N, K,
     $        -1 ) )
         LWKOPT = MAX( 1, NW )*NB
         WORK( 1 ) = LWKOPT
      END IF
*
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DORMQR', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
      NBMIN = 2
      LDWORK = NW
      IF( NB.GT.1 .AND. NB.LT.K ) THEN
         IWS = NW*NB
         IF( LWORK.LT.IWS ) THEN
            NB = LWORK / LDWORK
            NBMIN = MAX( 2, ILAENV( 2, 'DORMQR', SIDE // TRANS, M, N, K,
     $              -1 ) )
         END IF
      ELSE
         IWS = NW
      END IF
*
      IF( NB.LT.NBMIN .OR. NB.GE.K ) THEN
*
*        Use unblocked code
*
         CALL DORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK,
     $                IINFO )
      ELSE
*
*        Use blocked code
*
         IF( ( LEFT .AND. .NOT.NOTRAN ) .OR.
     $       ( .NOT.LEFT .AND. NOTRAN ) ) THEN
            I1 = 1
            I2 = K
            I3 = NB
         ELSE
            I1 = ( ( K-1 ) / NB )*NB + 1
            I2 = 1
            I3 = -NB
         END IF
*
         IF( LEFT ) THEN
            NI = N
            JC = 1
         ELSE
            MI = M
            IC = 1
         END IF
*
         DO 10 I = I1, I2, I3
            IB = MIN( NB, K-I+1 )
*
*           Form the triangular factor of the block reflector
*           H = H(i) H(i+1) . . . H(i+ib-1)
*
            CALL DLARFT( 'Forward', 'Columnwise', NQ-I+1, IB, A( I, I ),
     $                   LDA, TAU( I ), T, LDT )
            IF( LEFT ) THEN
*
*              H or H' is applied to C(i:m,1:n)
*
               MI = M - I + 1
               IC = I
            ELSE
*
*              H or H' is applied to C(1:m,i:n)
*
               NI = N - I + 1
               JC = I
            END IF
*
*           Apply H or H'
*
            CALL DLARFB( SIDE, TRANS, 'Forward', 'Columnwise', MI, NI,
     $                   IB, A( I, I ), LDA, T, LDT, C( IC, JC ), LDC,
     $                   WORK, LDWORK )
   10    CONTINUE
      END IF
      WORK( 1 ) = LWKOPT
      RETURN
*
*     End of DORMQR
*
      END

      SUBROUTINE DCOPY(N,DX,INCX,DY,INCY)
*     .. Scalar Arguments ..
      INTEGER INCX,INCY,N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION DX(*),DY(*)
      DIMENSION DX(*),DY(*)
*     ..
*
*  Purpose
*  =======
*
*     copies a vector, x, to a vector, y.
*     uses unrolled loops for increments equal to one.
*     jack dongarra, linpack, 3/11/78.
*     modified 12/3/93, array(1) declarations changed to array(*)
*
*
*     .. Local Scalars ..
      INTEGER I,IX,IY,M,MP1
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC MOD
*     ..
      IF (N.LE.0) RETURN
      IF (INCX.EQ.1 .AND. INCY.EQ.1) GO TO 20
*
*        code for unequal increments or equal increments
*          not equal to 1
*
      IX = 1
      IY = 1
      IF (INCX.LT.0) IX = (-N+1)*INCX + 1
      IF (INCY.LT.0) IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
          DY(IY) = DX(IX)
          IX = IX + INCX
          IY = IY + INCY
   10 CONTINUE
      RETURN
*
*        code for both increments equal to 1
*
*
*        clean-up loop
*
   20 M = MOD(N,7)
      IF (M.EQ.0) GO TO 40
      DO 30 I = 1,M
          DY(I) = DX(I)
   30 CONTINUE
      IF (N.LT.7) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,7
          DY(I) = DX(I)
          DY(I+1) = DX(I+1)
          DY(I+2) = DX(I+2)
          DY(I+3) = DX(I+3)
          DY(I+4) = DX(I+4)
          DY(I+5) = DX(I+5)
          DY(I+6) = DX(I+6)
   50 CONTINUE
      RETURN
      END
      
      
      SUBROUTINE DROT(N,DX,INCX,DY,INCY,C,S)
*     .. Scalar Arguments ..
CID      DOUBLE PRECISION C,S
      INTEGER INCX,INCY,N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION DX(*),DY(*)
      DIMENSION  DX(*),DY(*)
*     ..
*
*  Purpose
*  =======
*
*     applies a plane rotation.
*     jack dongarra, linpack, 3/11/78.
*     modified 12/3/93, array(1) declarations changed to array(*)
*
*
*     .. Local Scalars ..
CID      DOUBLE PRECISION DTEMP
      INTEGER I,IX,IY
*     ..
      IF (N.LE.0) RETURN
      IF (INCX.EQ.1 .AND. INCY.EQ.1) GO TO 20
*
*       code for unequal increments or equal increments not equal
*         to 1
*
      IX = 1
      IY = 1
      IF (INCX.LT.0) IX = (-N+1)*INCX + 1
      IF (INCY.LT.0) IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
          DTEMP = C*DX(IX) + S*DY(IY)
          DY(IY) = C*DY(IY) - S*DX(IX)
          DX(IX) = DTEMP
          IX = IX + INCX
          IY = IY + INCY
   10 CONTINUE
      RETURN
*
*       code for both increments equal to 1
*
   20 DO 30 I = 1,N
          DTEMP = C*DX(I) + S*DY(I)
          DY(I) = C*DY(I) - S*DX(I)
          DX(I) = DTEMP
   30 CONTINUE
      RETURN
      END



CID      DOUBLE PRECISION FUNCTION DNRM2(N,X,INCX)
      FUNCTION DNRM2(N,X,INCX)
*     .. Scalar Arguments ..
      INTEGER INCX,N
*     ..
*     .. Array Arguments ..
CID      DOUBLE PRECISION X(*)
      DIMENSION X(*)
*     ..
*
*  Purpose
*  =======
*
*  DNRM2 returns the euclidean norm of a vector via the function
*  name, so that
*
*     DNRM2 := sqrt( x'*x )
*
*
*  -- This version written on 25-October-1982.
*     Modified on 14-October-1993 to inline the call to DLASSQ.
*     Sven Hammarling, Nag Ltd.
*
*
*     .. Parameters ..
CID      DOUBLE PRECISION ONE,ZERO
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
*     ..
*     .. Local Scalars ..
CID      DOUBLE PRECISION ABSXI,NORM,SCALE,SSQ
      REAL NORM
      INTEGER IX
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC ABS,SQRT
*     ..
      IF (N.LT.1 .OR. INCX.LT.1) THEN
          NORM = ZERO
      ELSE IF (N.EQ.1) THEN
          NORM = ABS(X(1))
      ELSE
          SCALE = ZERO
          SSQ = ONE
*        The following loop is equivalent to this call to the LAPACK
*        auxiliary routine:
*        CALL DLASSQ( N, X, INCX, SCALE, SSQ )
*
          DO 10 IX = 1,1 + (N-1)*INCX,INCX
              IF (X(IX).NE.ZERO) THEN
                  ABSXI = ABS(X(IX))
                  IF (SCALE.LT.ABSXI) THEN
                      SSQ = ONE + SSQ* (SCALE/ABSXI)**2
                      SCALE = ABSXI
                  ELSE
                      SSQ = SSQ + (ABSXI/SCALE)**2
                  END IF
              END IF
   10     CONTINUE
          NORM = SCALE*SQRT(SSQ)
      END IF
*
      DNRM2 = NORM
      RETURN
*
*     End of DNRM2.
*
      END
C
C=======================================================================
C=======================================================================
C                    RANDOM NUMBER GENERATION PACKAGE
C=======================================================================
C=======================================================================
C
C     Note for human users: how to use these subroutines
C     ====================
C
C     First we initialize the "seed" by calling RANDIN(I_SEED), where
C     I_SEED can be set to any value 
C
C     Next generate your random numbers (uniformly distributed within
C     0 and 1) by calling ZUFALL(N,A);  N is the actual number of the
C     random numbers needed and A is the vector that contains them 
C
C     If you want to restore the seed to its original state, you must
C     call ZUFALLSV,   b e f o r e  the last call of ZUFALL  (see the 
C     example below)
C
C     Typical use
C     ===========
C
C     PARAMETER
C    *         (N=500)
C     DIMENSION
C    *          A(1:N),B(1:N),SVBLOK(608)
C
C
C     CALL RANDIN(0)          ! initialize the seed
C 
C     CALL ZUFALLSV(SVBLOK)   ! save the original seed for future
C                             ! restart
C
C     CALL ZUFALL(500,A)      ! generates the random numbers in the
C                             ! vector A
C
C      ....
C
C     CALL ZUFALLRS(SVBLOK)   ! restores the original seed as it was
C                             ! before
C
C     CALL ZUFALL(500,B)      ! B should be identical to A
C
C=======================================================================
C=======================================================================
C
C                 README FOR ZUFALL RANDOM NUMBER PACKAGE
C                 ------ --- ------ ------ ------ -------
C
C     This package contains a portable random number generator set for: 
C
C          a. uniform (u in [0,1)), 
C          b. normal (<g> = 0, <g^2> = 1), and
C          c. Poisson distributions. 
C
C     The basic module, the uniform generator, uses a lagged Fibonacci 
C     series generator:
C     
C                   t    = u(n-273) + u(n-607)
C                   u(n) = t - float(int(t))
C     
C     where each number generated, u(k), is floating point.  Since the 
C     numbers are floating point,  the left-end boundary  of the range 
C     contains zero.  This package  is nearly portable, except for the 
C     following:
C     
C         (1) It is written in lower case, 
C         (2) the test package contains a timer (second), which is not 
C             portable, and 
C         (3) there are cycle times (in seconds) in data statements 
C             for NEC SX-3, Fujitsu VP2200, and Cray Y-MP. 
C
C     Select  your  favorite  and comment-out the others.  Replacement 
C     functions for 'second' are included - comment out the others. 
C     Otherwise the package is portable and returns the same set of 
C     floating point numbers up to word precision on any machine. 
C     There are compiler directives ($cdir for Cray, Cvdir for SX-3, 
C     and VOCL for Fujitsu VP2200) which should be otherwise ignored.
C 
C     To compile this beast, note that all floating point numbers
C     are declared 'double precision'. On Cray X-MP, Y-MP, and C-90
C     machines, use the cft77 (cf77) option -dp to run this in 64
C     bit mode (not 128 bit double).
C 
C     External documentation, 
C
C    "Lagged Fibonacci Random Number Generators for the NEC SX-3", 
C     is to be published in the International Journal of High Speed 
C     Computing (1994). Otherwise, ask the author: 
C 
C          W. P. Petersen 
C          IPS, RZ F-5
C          ETHZ
C          CH 8092, Zurich
C          Switzerland
C 
C          e-mail:  wpp@ips.ethz.ch.
C 
C======================================================================= 
C 
C     THE PACKAGE CONTAINS THE FOLLOWING ROUTINES:
C 
C======================================================================= 
C    
C          UNIFORM generator routines:
C          =======
C
C          subroutine RANDIN(seed)
C          integer seed
C    
C                  initializes common block containing seeds. if seed=0,
C                  the default value is 1802.
C    
C          subroutine zufall(n,u)
C          integer n
C          double precision u(n)
C    
C                  returns set of n uniforms u(1), ..., u(n).
C    
C          subroutine zufallsv(zusave)
C          double precision zusave(608)
C    
C                  saves buffer and pointer in zusave, for later 
C                  restarts
C    
C          subroutine zufallrs(zusave)
C          double precision zusave(608)
C    
C                  restores seed buffer and pointer from zusave
C    
C=======================================================================
C    
C     NORMAL generator routines:
C     ======
C
C          subroutine normalen(n,g)
C          integer n
C          double precision g(n)
C    
C             returns set of n normals g(1), ..., g(n) such that
C             mean <g> = 0, and variance <g**2> = 1.
C    
C          subroutine normalsv(normsv)
C          double precision normsv(1634)
C    
C             saves zufall seed buffer and pointer in normsv
C             buffer/pointer for normalen restart also in normsv
C    
C          subroutine normalrs(normsv)
C          double precision normsv(1634)
C    
C             restores zufall seed buffer/pointer and 
C             buffer/pointer for normalen restart from normsv
C    
C=======================================================================
C    
C    POISSON generator routine:
C    =======
C
C          subroutine fische(n,mu,q)
C          integer n,q(n)
C          double precision mu
C    
C              returns set of n integers q, with poisson
C              distribution, density p(q,mu) = exp(-mu) mu**q/q!
C      
C          USE zufallsv and zufallrs for stop/restart sequence
c
c          this program tests three random number generators:
c------------------------------------------------------------
c          IMPORTANT!!     be sure to compile with -dp option on
c          the Cray cft77 compiler. This disables 128-bit double
c          precision, converting it to 64-bit single.  Likewise,
c          comment out the 'second' function. On other machines,
c          uncomment lines for appropriate version of 'second'.
c------------------------------------------------------------
c      zufallt = a uniform distribution of r.v.'s test
c
c
c=====================================================================
c=====================================================================
c
      subroutine zufall(n,a)
      
C     implicit none

c
c portable lagged Fibonacci series uniform random number
c generator with "lags" -273 und -607:
c
c       t    = u(i-273)+buff(i-607)  (floating pt.)
c       u(i) = t - float(int(t))
c
c W.P. Petersen, IPS, ETH Zuerich, 19 Mar. 92
c
C     double precision a(*)
      DIMENSION a(*)
      
C     double precision buff(607)
      DIMENSION buff(607)
      
C     double precision t

      integer i,k,ptr,VL,k273,k607
      
      integer buffsz,nn,n,left,q,qq
      
      integer aptr,aptr0,bptr
c
      common /klotz0/buff,ptr
      data buffsz/607/
c
      aptr = 0
      nn   = n
c
1     continue
c
      if(nn .le. 0) return
c
c factor nn = q*607 + r
c
      q    = (nn-1)/607
      left = buffsz - ptr
c
      if(q .le. 1) then
c
c only one or fewer full segments
c
         if(nn .lt. left) then
            do 2 i=1,nn
               a(i+aptr) = buff(ptr+i)
2           continue
            ptr  = ptr + nn
            return
         else
            do 3 i=1,left
               a(i+aptr) = buff(ptr+i)
3           continue
            ptr  = 0
            aptr = aptr + left
            nn   = nn - left
c  buff -> buff case
            VL   = 273
            k273 = 334
            k607 = 0
            do 4 k=1,3
cdir$ ivdep
*vdir nodep
*VOCL LOOP, TEMP(t), NOVREC(buff)
               do 5 i=1,VL
                  t            = buff(k273+i) + buff(k607+i)
                  buff(k607+i) = t - float(int(t))
5              continue
               k607 = k607 + VL
               k273 = k273 + VL
               VL   = 167
               if(k.eq.1) k273 = 0
4           continue
c
            goto 1
         endif
      else
c
c more than 1 full segment
c 
          do 6 i=1,left
             a(i+aptr) = buff(ptr+i)
6         continue
          nn   = nn - left
          ptr  = 0
          aptr = aptr+left
c 
c buff -> a(aptr0)
c 
          VL   = 273
          k273 = 334
          k607 = 0
          do 7 k=1,3
             if(k.eq.1)then
*VOCL LOOP, TEMP(t)
                do 8 i=1,VL
                   t         = buff(k273+i) + buff(k607+i)
                   a(aptr+i) = t - float(int(t))
8               continue
                k273 = aptr
                k607 = k607 + VL
                aptr = aptr + VL
                VL   = 167
             else
cdir$ ivdep
*vdir nodep
*VOCL LOOP, TEMP(t)
                do 9 i=1,VL
                   t         = a(k273+i) + buff(k607+i)
                   a(aptr+i) = t - float(int(t))
9               continue
                k607 = k607 + VL
                k273 = k273 + VL
                aptr = aptr + VL
             endif
7         continue
          nn = nn - 607
c
c a(aptr-607) -> a(aptr) for last of the q-1 segments
c
          aptr0 = aptr - 607
          VL    = 607
c
*vdir novector
          do 10 qq=1,q-2
             k273 = 334 + aptr0
cdir$ ivdep
*vdir nodep
*VOCL LOOP, TEMP(t), NOVREC(a)
             do 11 i=1,VL
                t         = a(k273+i) + a(aptr0+i)
                a(aptr+i) = t - float(int(t))
11           continue
             nn    = nn - 607
             aptr  = aptr + VL
             aptr0 = aptr0 + VL
10        continue
c
c a(aptr0) -> buff, last segment before residual
c
          VL   = 273
          k273 = 334 + aptr0
          k607 = aptr0
          bptr = 0
          do 12 k=1,3
             if(k.eq.1) then
*VOCL LOOP, TEMP(t)
                do 13 i=1,VL
                   t            = a(k273+i) + a(k607+i)
                   buff(bptr+i) = t - float(int(t))
13              continue
                k273 = 0
                k607 = k607 + VL
                bptr = bptr + VL
                VL   = 167
             else
cdir$ ivdep
*vdir nodep
*VOCL LOOP, TEMP(t), NOVREC(buff)
                do 14 i=1,VL
                   t            = buff(k273+i) + a(k607+i)
                   buff(bptr+i) = t - float(int(t))
14              continue
                k607 = k607 + VL
                k273 = k273 + VL
                bptr = bptr + VL
             endif
12        continue
          goto 1
      endif
      end
c
c=====================================================================
c=====================================================================
c
      subroutine RANDIN(seed)
      
C     implicit none
c
c  generates initial seed buffer by linear congruential
c  method. Taken from Marsaglia, FSU report FSU-SCRI-87-50
c  variable seed should be 0 < seed <31328
c
      integer seed
      integer ptr
      
C     double precision s,t
      
C     double precision buff(607)
      DIMENSION buff(607)
      
      integer ij,kl,i,ii,j,jj,k,l,m
      common /klotz0/buff,ptr
      data ij/1802/,kl/9373/
c
c=====================================================================
c
      if(seed.ne.0) ij = seed
c
      i = mod(ij/177,177) + 2
      j = mod(ij,177) + 2
      k = mod(kl/169,178) + 1
      l = mod(kl,169)
      do 1 ii=1,607
         s = 0.0
         t = 0.5
         do 2 jj=1,24
            m = mod(mod(i*j,179)*k,179)
            i = j
            j = k
            k = m
            l = mod(53*l+1,169)
            if(mod(l*m,64).ge.32) s = s+t
            t = .5*t
2        continue
         buff(ii) = s
1     continue
c
c=====================================================================
c
      return
      end
c
c=====================================================================
c=====================================================================
c
      subroutine zufallsv(svblk)
      
C     implicit none
c
c  saves common blocks klotz0, containing seeds and 
c  pointer to position in seed block. IMPORTANT: svblk must be
c  dimensioned at least 608 in driver. The entire contents
c  of klotz0 (pointer in buff, and buff) must be saved.
c
C     double precision buff(607)
      DIMENSION buff(607)
      
      integer ptr,i
      
C     double precision svblk(*)
      DIMENSION svblk(*)
c
      common /klotz0/ buff,ptr
c
c=====================================================================
c
      svblk(1) = ptr
      do 1 i=1,607
         svblk(i+1) = buff(i)
1     continue
c
c=====================================================================
c
      return
      end
c
c=====================================================================
c=====================================================================
c
      subroutine zufallrs(svblk)
      
C     implicit none
c
c  restores common block klotz0, containing seeds and pointer
c  to position in seed block. IMPORTANT: svblk must be
c  dimensioned at least 608 in driver. The entire contents
c  of klotz0 must be restored.
c
C     double precision buff(607)
      DIMENSION buff(607)
      
      integer i,ptr
      
C     double precision svblk(*)
      DIMENSION svblk(*)
c
      common /klotz0/ buff,ptr
c
      ptr = svblk(1)
      do 1 i=1,607
         buff(i) = svblk(i+1)
1     continue
c
      return
      end
c
c=====================================================================
c=====================================================================
c
*******************************************************************
********	FILE: randgen.f				***********
********	AUTHORS: Richard Chandler		***********
********		 (richard@stats.ucl.ac.uk)	***********
********		 Paul Northrop 			***********
********		 (northrop@stats.ox.ac.uk)	***********
********	LAST MODIFIED: 26/8/03			***********
********	See file randgen.txt for details	***********
*******************************************************************
*
      BLOCK DATA ZBQLBD01
*
*       Initializes seed array etc. for random number generator.
*       The values below have themselves been generated using the
*       NAG generator.
*
      COMMON /ZBQL0001/ ZBQLIX,B,C
      DOUBLE PRECISION ZBQLIX(43),B,C
      INTEGER I
      DATA (ZBQLIX(I),I=1,43) /8.001441D7,5.5321801D8,
     +1.69570999D8,2.88589940D8,2.91581871D8,1.03842493D8,
     +7.9952507D7,3.81202335D8,3.11575334D8,4.02878631D8,
     +2.49757109D8,1.15192595D8,2.10629619D8,3.99952890D8,
     +4.12280521D8,1.33873288D8,7.1345525D7,2.23467704D8,
     +2.82934796D8,9.9756750D7,1.68564303D8,2.86817366D8,
     +1.14310713D8,3.47045253D8,9.3762426D7 ,1.09670477D8,
     +3.20029657D8,3.26369301D8,9.441177D6,3.53244738D8,
     +2.44771580D8,1.59804337D8,2.07319904D8,3.37342907D8,
     +3.75423178D8,7.0893571D7 ,4.26059785D8,3.95854390D8,
     +2.0081010D7,5.9250059D7,1.62176640D8,3.20429173D8,
     +2.63576576D8/
      DATA B / 4.294967291D9 /
      DATA C / 0.0D0 /
      END
******************************************************************
******************************************************************
******************************************************************
      SUBROUTINE ZBQLINI(SEED)
******************************************************************
*       To initialize the random number generator - either
*       repeatably or nonrepeatably. Need double precision
*       variables because integer storage can't handle the
*       numbers involved
******************************************************************
*	ARGUMENTS
*	=========
*	SEED	(integer, input). User-input number which generates
*		elements of the array ZBQLIX, which is subsequently used 
*		in the random number generation algorithm. If SEED=0,
*		the array is seeded using the system clock if the 
*		FORTRAN implementation allows it.
******************************************************************
*	PARAMETERS
*	==========
*	LFLNO	(integer). Number of lowest file handle to try when
*		opening a temporary file to copy the system clock into.
*		Default is 80 to keep out of the way of any existing
*		open files (although the program keeps searching till
*		it finds an available handle). If this causes problems,
*               (which will only happen if handles 80 through 99 are 
*               already in use), decrease the default value.
******************************************************************
      INTEGER LFLNO
      PARAMETER (LFLNO=80)
******************************************************************
*	VARIABLES
*	=========
*	SEED	See above
*	ZBQLIX	Seed array for the random number generator. Defined
*		in ZBQLBD01
*	B,C	Used in congruential initialisation of ZBQLIX
*	SS,MM,}	System clock secs, mins, hours and days
*	HH,DD }
*	FILNO	File handle used for temporary file
*	INIT	Indicates whether generator has already been initialised
*
      INTEGER SEED,SS,MM,HH,DD,FILNO,I
      INTEGER INIT
      DOUBLE PRECISION ZBQLIX(43),B,C
      DOUBLE PRECISION TMPVAR1,DSS,DMM,DHH,DDD

      COMMON /ZBQL0001/ ZBQLIX,B,C
      COMMON
     *       /JDINFO/ NO_DAY,N_HOUR,MINUTE,NSECND
      SAVE INIT

*
*	Ensure we don't call this more than once in a program
*
      IF (INIT.GE.1) THEN
       IF(INIT.EQ.1) THEN
        WRITE(*,1)
        INIT = 2
       ENDIF
       RETURN
      ELSE
       INIT = 1
      ENDIF
*
*       If SEED = 0, cat the contents of the clock into a file
*       and transform to obtain ZQBLIX(1), then use a congr.
*       algorithm to set remaining elements. Otherwise take
*       specified value of SEED.
*
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*>>>>>>>	NB FOR SYSTEMS WHICH DO NOT SUPPORT THE  >>>>>>>
*>>>>>>>	(NON-STANDARD) 'CALL SYSTEM' COMMAND,    >>>>>>>
*>>>>>>>	THIS WILL NOT WORK, AND THE FIRST CLAUSE >>>>>>>
*>>>>>>>	OF THE FOLLOWING IF BLOCK SHOULD BE	 >>>>>>>
*>>>>>>>	COMMENTED OUT.				 >>>>>>>
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      IF (SEED.EQ.0) THEN
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*>>>>>>>	COMMENT OUT FROM HERE IF YOU DON'T HAVE  >>>>>>>
*>>>>>>>	'CALL SYSTEM' CAPABILITY ...		 >>>>>>>
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
       CALL SYSTEM(' date +%S%M%H%j > zbql1234.tmp')
*
*       Try all file numbers for LFLNO to 999 
*
       FILNO = LFLNO
 10    OPEN(FILNO,FILE='zbql1234.tmp',ERR=11)
       GOTO 12
 11    FILNO = FILNO + 1
       IF (FILNO.GT.999) THEN
        WRITE(*,2)
        RETURN
       ENDIF
       GOTO 10
 12    READ(FILNO,'(3(I2),I3)') SS,MM,HH,DD
C
       NO_DAY=DD
       N_HOUR=HH
       MINUTE=MM
       NSECND=SS
C       
       CLOSE(FILNO)
       CALL SYSTEM('rm zbql1234.tmp')
       DSS = DINT((DBLE(SS)/6.0D1) * B)
       DMM = DINT((DBLE(MM)/6.0D1) * B)
       DHH = DINT((DBLE(HH)/2.4D1) * B)
       DDD = DINT((DBLE(DD)/3.65D2) * B)
       TMPVAR1 = DMOD(DSS+DMM+DHH+DDD,B)
*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
*<<<<<<<<	... TO HERE (END OF COMMENTING OUT FOR 	  <<<<<<<
*<<<<<<<<	USERS WITHOUT 'CALL SYSTEM' CAPABILITY	  <<<<<<<
*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      ELSE
       TMPVAR1 = DMOD(DBLE(SEED),B)
      ENDIF
      ZBQLIX(1) = TMPVAR1
      DO 100 I = 2,43
       TMPVAR1 = ZBQLIX(I-1)*3.0269D4
       TMPVAR1 = DMOD(TMPVAR1,B)       
       ZBQLIX(I) = TMPVAR1
 100  CONTINUE

 1    FORMAT(//5X,'****WARNING**** You have called routine ZBQLINI ',
     +'more than',/5X,'once. I''m ignoring any subsequent calls.',//)
 2    FORMAT(//5X,'**** ERROR **** In routine ZBQLINI, I couldn''t',
     +' find an',/5X,
     +'available file number. To rectify the problem, decrease the ',
     +'value of',/5X,
     +'the parameter LFLNO at the start of this routine (in file ',
     +'randgen.f)',/5X,
     +'and recompile. Any number less than 100 should work.')
      END
******************************************************************
      FUNCTION ZBQLU01(DUMMY)
*
*       Returns a uniform random number between 0 & 1, using
*       a Marsaglia-Zaman type subtract-with-borrow generator.
*       Uses double precision, rather than integer, arithmetic 
*       throughout because MZ's integer constants overflow
*       32-bit integer storage (which goes from -2^31 to 2^31).
*       Ideally, we would explicitly truncate all integer 
*       quantities at each stage to ensure that the double
*       precision representations do not accumulate approximation
*       error; however, on some machines the use of DNINT to
*       accomplish this is *seriously* slow (run-time increased
*       by a factor of about 3). This double precision version 
*       has been tested against an integer implementation that
*       uses long integers (non-standard and, again, slow) -
*       the output was identical up to the 16th decimal place
*       after 10^10 calls, so we're probably OK ...
*
      DOUBLE PRECISION ZBQLU01,DUMMY,B,C,ZBQLIX(43),X,B2,BINV
      INTEGER CURPOS,ID22,ID43

      COMMON /ZBQL0001/ ZBQLIX,B,C
      SAVE /ZBQL0001/
      SAVE CURPOS,ID22,ID43
      DATA CURPOS,ID22,ID43 /1,22,43/

      B2 = B
      BINV = 1.0D0/B
 5    X = ZBQLIX(ID22) - ZBQLIX(ID43) - C
      IF (X.LT.0.0D0) THEN
       X = X + B
       C = 1.0D0
      ELSE
       C = 0.0D0
      ENDIF
      ZBQLIX(ID43) = X
*
*     Update array pointers. Do explicit check for bounds of each to
*     avoid expense of modular arithmetic. If one of them is 0 the others
*     won't be
*
      CURPOS = CURPOS - 1
      ID22 = ID22 - 1
      ID43 = ID43 - 1
      IF (CURPOS.EQ.0) THEN
       CURPOS=43
      ELSEIF (ID22.EQ.0) THEN
       ID22 = 43
      ELSEIF (ID43.EQ.0) THEN
       ID43 = 43
      ENDIF
*
*     The integer arithmetic there can yield X=0, which can cause 
*     problems in subsequent routines (e.g. ZBQLEXP). The problem
*     is simply that X is discrete whereas U is supposed to 
*     be continuous - hence if X is 0, go back and generate another
*     X and return X/B^2 (etc.), which will be uniform on (0,1/B). 
*
      IF (X.LT.BINV) THEN
       B2 = B2*B
       GOTO 5
      ENDIF

      ZBQLU01 = X/B2

      END
******************************************************************
******************************************************************
******************************************************************
      FUNCTION ZBQLNOR(MU,SIGMA)
*
*       Returns a random number Normally distributed with mean
*       MU and standard deviation |SIGMA|, using the Box-Muller
*       algorithm
*
      DOUBLE PRECISION THETA,R,ZBQLNOR,ZBQLU01,PI,MU,SIGMA
      DOUBLE PRECISION SPARE
      INTEGER STATUS
      SAVE STATUS,SPARE,PI
      DATA STATUS /-1/
     
      IF (STATUS.EQ.-1) PI = 4.0D0*DATAN(1.0D0)

      IF (STATUS.LE.0) THEN
       THETA = 2.0D0*PI*ZBQLU01(0.0D0)
       R = DSQRT( -2.0D0*DLOG(ZBQLU01(0.0D0)) )
       ZBQLNOR = (R*DCOS(THETA))
       SPARE = (R*DSIN(THETA))
       STATUS = 1
      ELSE
       ZBQLNOR = SPARE
       STATUS = 0
      ENDIF
      
      ZBQLNOR = MU + (SIGMA*ZBQLNOR)

      END
C
C=======================================================================
C=======================================================================
C
